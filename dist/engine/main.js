var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var requestVideoFrame = {};

var hasRequiredRequestVideoFrame;

function requireRequestVideoFrame () {
	if (hasRequiredRequestVideoFrame) return requestVideoFrame;
	hasRequiredRequestVideoFrame = 1;
	if (typeof HTMLVideoElement !== 'undefined' && !('requestVideoFrameCallback' in HTMLVideoElement.prototype) && 'getVideoPlaybackQuality' in HTMLVideoElement.prototype)
	{
	    HTMLVideoElement.prototype._rvfcpolyfillmap = {};
	    HTMLVideoElement.prototype.requestVideoFrameCallback = function (callback) {
	      const handle = performance.now();
	      const quality = this.getVideoPlaybackQuality();
	      const baseline = this.mozPresentedFrames || this.mozPaintedFrames || quality.totalVideoFrames - quality.droppedVideoFrames;

	      const check = (old, now) => {
	        const newquality = this.getVideoPlaybackQuality();
	        const presentedFrames = this.mozPresentedFrames || this.mozPaintedFrames || newquality.totalVideoFrames - newquality.droppedVideoFrames;
	        if (presentedFrames > baseline) {
	          const processingDuration = this.mozFrameDelay || (newquality.totalFrameDelay - quality.totalFrameDelay) || 0;
	          const timediff = now - old; 
	          callback(now, {
	            presentationTime: now + processingDuration * 1000,
	            expectedDisplayTime: now + timediff,
	            width: this.videoWidth,
	            height: this.videoHeight,
	            mediaTime: Math.max(0, this.currentTime || 0) + timediff / 1000,
	            presentedFrames,
	            processingDuration
	          });
	          delete this._rvfcpolyfillmap[handle];
	        } else {
	          this._rvfcpolyfillmap[handle] = requestAnimationFrame(newer => check(now, newer));
	        }
	      };
	      this._rvfcpolyfillmap[handle] = requestAnimationFrame(newer => check(handle, newer));
	      return handle
	    };

	    HTMLVideoElement.prototype.cancelVideoFrameCallback = function (handle) {
	      cancelAnimationFrame(this._rvfcpolyfillmap[handle]);
	      delete this._rvfcpolyfillmap[handle];
	    };
	}
	return requestVideoFrame;
}

var BlendModes;
var hasRequiredBlendModes;

function requireBlendModes () {
	if (hasRequiredBlendModes) return BlendModes;
	hasRequiredBlendModes = 1;
	BlendModes = {

	    SKIP_CHECK: -1,

	    NORMAL: 0,

	    ADD: 1,

	    MULTIPLY: 2,

	    SCREEN: 3,

	    OVERLAY: 4,

	    DARKEN: 5,

	    LIGHTEN: 6,

	    COLOR_DODGE: 7,

	    COLOR_BURN: 8,

	    HARD_LIGHT: 9,

	    SOFT_LIGHT: 10,

	    DIFFERENCE: 11,

	    EXCLUSION: 12,

	    HUE: 13,

	    SATURATION: 14,

	    COLOR: 15,

	    LUMINOSITY: 16,

	    ERASE: 17,

	    SOURCE_IN: 18,

	    SOURCE_OUT: 19,

	    SOURCE_ATOP: 20,

	    DESTINATION_OVER: 21,

	    DESTINATION_IN: 22,

	    DESTINATION_OUT: 23,

	    DESTINATION_ATOP: 24,

	    LIGHTER: 25,

	    COPY: 26,

	    XOR: 27

	};
	return BlendModes;
}

var ScaleModes_1;
var hasRequiredScaleModes;

function requireScaleModes () {
	if (hasRequiredScaleModes) return ScaleModes_1;
	hasRequiredScaleModes = 1;
	var ScaleModes = {

	    DEFAULT: 0,

	    LINEAR: 0,

	    NEAREST: 1

	};

	ScaleModes_1 = ScaleModes;
	return ScaleModes_1;
}

var _const$f;
var hasRequired_const$f;

function require_const$f () {
	if (hasRequired_const$f) return _const$f;
	hasRequired_const$f = 1;
	var CONST = {

	    VERSION: '3.90.0',

	    LOG_VERSION: 'v390',

	    BlendModes: requireBlendModes(),

	    ScaleModes: requireScaleModes(),

	    AUTO: 0,

	    CANVAS: 1,

	    WEBGL: 2,

	    HEADLESS: 3,

	    FOREVER: -1,

	    NONE: 4,

	    UP: 5,

	    DOWN: 6,

	    LEFT: 7,

	    RIGHT: 8

	};

	_const$f = CONST;
	return _const$f;
}

var IsPlainObject_1;
var hasRequiredIsPlainObject;

function requireIsPlainObject () {
	if (hasRequiredIsPlainObject) return IsPlainObject_1;
	hasRequiredIsPlainObject = 1;
	var IsPlainObject = function (obj)
	{

	    if (!obj || typeof(obj) !== 'object' || obj.nodeType || obj === obj.window)
	    {
	        return false;
	    }

	    try
	    {
	        if (obj.constructor && !({}).hasOwnProperty.call(obj.constructor.prototype, 'isPrototypeOf'))
	        {
	            return false;
	        }
	    }
	    catch (e)
	    {
	        return false;
	    }

	    return true;
	};

	IsPlainObject_1 = IsPlainObject;
	return IsPlainObject_1;
}

var Extend_1$1;
var hasRequiredExtend$1;

function requireExtend$1 () {
	if (hasRequiredExtend$1) return Extend_1$1;
	hasRequiredExtend$1 = 1;
	var IsPlainObject = requireIsPlainObject();

	var Extend = function ()
	{
	    var options, name, src, copy, copyIsArray, clone,
	        target = arguments[0] || {},
	        i = 1,
	        length = arguments.length,
	        deep = false;

	    if (typeof target === 'boolean')
	    {
	        deep = target;
	        target = arguments[1] || {};

	        i = 2;
	    }

	    if (length === i)
	    {
	        target = this;
	        --i;
	    }

	    for (; i < length; i++)
	    {

	        if ((options = arguments[i]) != null)
	        {

	            for (name in options)
	            {
	                src = target[name];
	                copy = options[name];

	                if (target === copy)
	                {
	                    continue;
	                }

	                if (deep && copy && (IsPlainObject(copy) || (copyIsArray = Array.isArray(copy))))
	                {
	                    if (copyIsArray)
	                    {
	                        copyIsArray = false;
	                        clone = src && Array.isArray(src) ? src : [];
	                    }
	                    else
	                    {
	                        clone = src && IsPlainObject(src) ? src : {};
	                    }

	                    target[name] = Extend(deep, clone, copy);

	                }
	                else if (copy !== undefined)
	                {
	                    target[name] = copy;
	                }
	            }
	        }
	    }

	    return target;
	};

	Extend_1$1 = Extend;
	return Extend_1$1;
}

var _const$e;
var hasRequired_const$e;

function require_const$e () {
	if (hasRequired_const$e) return _const$e;
	hasRequired_const$e = 1;
	var ALIGN_CONST = {

	    TOP_LEFT: 0,

	    TOP_CENTER: 1,

	    TOP_RIGHT: 2,

	    LEFT_TOP: 3,

	    LEFT_CENTER: 4,

	    LEFT_BOTTOM: 5,

	    CENTER: 6,

	    RIGHT_TOP: 7,

	    RIGHT_CENTER: 8,

	    RIGHT_BOTTOM: 9,

	    BOTTOM_LEFT: 10,

	    BOTTOM_CENTER: 11,

	    BOTTOM_RIGHT: 12

	};

	_const$e = ALIGN_CONST;
	return _const$e;
}

var GetBottom_1;
var hasRequiredGetBottom;

function requireGetBottom () {
	if (hasRequiredGetBottom) return GetBottom_1;
	hasRequiredGetBottom = 1;
	var GetBottom = function (gameObject)
	{
	    return (gameObject.y + gameObject.height) - (gameObject.height * gameObject.originY);
	};

	GetBottom_1 = GetBottom;
	return GetBottom_1;
}

var GetCenterX_1;
var hasRequiredGetCenterX;

function requireGetCenterX () {
	if (hasRequiredGetCenterX) return GetCenterX_1;
	hasRequiredGetCenterX = 1;
	var GetCenterX = function (gameObject)
	{
	    return gameObject.x - (gameObject.width * gameObject.originX) + (gameObject.width * 0.5);
	};

	GetCenterX_1 = GetCenterX;
	return GetCenterX_1;
}

var SetCenterX_1;
var hasRequiredSetCenterX;

function requireSetCenterX () {
	if (hasRequiredSetCenterX) return SetCenterX_1;
	hasRequiredSetCenterX = 1;
	var SetCenterX = function (gameObject, x)
	{
	    var offsetX = gameObject.width * gameObject.originX;

	    gameObject.x = (x + offsetX) - (gameObject.width * 0.5);

	    return gameObject;
	};

	SetCenterX_1 = SetCenterX;
	return SetCenterX_1;
}

var SetTop_1;
var hasRequiredSetTop;

function requireSetTop () {
	if (hasRequiredSetTop) return SetTop_1;
	hasRequiredSetTop = 1;
	var SetTop = function (gameObject, value)
	{
	    gameObject.y = value + (gameObject.height * gameObject.originY);

	    return gameObject;
	};

	SetTop_1 = SetTop;
	return SetTop_1;
}

var BottomCenter_1$1;
var hasRequiredBottomCenter$1;

function requireBottomCenter$1 () {
	if (hasRequiredBottomCenter$1) return BottomCenter_1$1;
	hasRequiredBottomCenter$1 = 1;
	var GetBottom = requireGetBottom();
	var GetCenterX = requireGetCenterX();
	var SetCenterX = requireSetCenterX();
	var SetTop = requireSetTop();

	var BottomCenter = function (gameObject, alignTo, offsetX, offsetY)
	{
	    if (offsetX === undefined) { offsetX = 0; }
	    if (offsetY === undefined) { offsetY = 0; }

	    SetCenterX(gameObject, GetCenterX(alignTo) + offsetX);
	    SetTop(gameObject, GetBottom(alignTo) + offsetY);

	    return gameObject;
	};

	BottomCenter_1$1 = BottomCenter;
	return BottomCenter_1$1;
}

var GetLeft_1;
var hasRequiredGetLeft;

function requireGetLeft () {
	if (hasRequiredGetLeft) return GetLeft_1;
	hasRequiredGetLeft = 1;
	var GetLeft = function (gameObject)
	{
	    return gameObject.x - (gameObject.width * gameObject.originX);
	};

	GetLeft_1 = GetLeft;
	return GetLeft_1;
}

var SetLeft_1;
var hasRequiredSetLeft;

function requireSetLeft () {
	if (hasRequiredSetLeft) return SetLeft_1;
	hasRequiredSetLeft = 1;
	var SetLeft = function (gameObject, value)
	{
	    gameObject.x = value + (gameObject.width * gameObject.originX);

	    return gameObject;
	};

	SetLeft_1 = SetLeft;
	return SetLeft_1;
}

var BottomLeft_1$1;
var hasRequiredBottomLeft$1;

function requireBottomLeft$1 () {
	if (hasRequiredBottomLeft$1) return BottomLeft_1$1;
	hasRequiredBottomLeft$1 = 1;
	var GetBottom = requireGetBottom();
	var GetLeft = requireGetLeft();
	var SetLeft = requireSetLeft();
	var SetTop = requireSetTop();

	var BottomLeft = function (gameObject, alignTo, offsetX, offsetY)
	{
	    if (offsetX === undefined) { offsetX = 0; }
	    if (offsetY === undefined) { offsetY = 0; }

	    SetLeft(gameObject, GetLeft(alignTo) - offsetX);
	    SetTop(gameObject, GetBottom(alignTo) + offsetY);

	    return gameObject;
	};

	BottomLeft_1$1 = BottomLeft;
	return BottomLeft_1$1;
}

var GetRight_1;
var hasRequiredGetRight;

function requireGetRight () {
	if (hasRequiredGetRight) return GetRight_1;
	hasRequiredGetRight = 1;
	var GetRight = function (gameObject)
	{
	    return (gameObject.x + gameObject.width) - (gameObject.width * gameObject.originX);
	};

	GetRight_1 = GetRight;
	return GetRight_1;
}

var SetRight_1;
var hasRequiredSetRight;

function requireSetRight () {
	if (hasRequiredSetRight) return SetRight_1;
	hasRequiredSetRight = 1;
	var SetRight = function (gameObject, value)
	{
	    gameObject.x = (value - gameObject.width) + (gameObject.width * gameObject.originX);

	    return gameObject;
	};

	SetRight_1 = SetRight;
	return SetRight_1;
}

var BottomRight_1$1;
var hasRequiredBottomRight$1;

function requireBottomRight$1 () {
	if (hasRequiredBottomRight$1) return BottomRight_1$1;
	hasRequiredBottomRight$1 = 1;
	var GetBottom = requireGetBottom();
	var GetRight = requireGetRight();
	var SetRight = requireSetRight();
	var SetTop = requireSetTop();

	var BottomRight = function (gameObject, alignTo, offsetX, offsetY)
	{
	    if (offsetX === undefined) { offsetX = 0; }
	    if (offsetY === undefined) { offsetY = 0; }

	    SetRight(gameObject, GetRight(alignTo) + offsetX);
	    SetTop(gameObject, GetBottom(alignTo) + offsetY);

	    return gameObject;
	};

	BottomRight_1$1 = BottomRight;
	return BottomRight_1$1;
}

var SetBottom_1;
var hasRequiredSetBottom;

function requireSetBottom () {
	if (hasRequiredSetBottom) return SetBottom_1;
	hasRequiredSetBottom = 1;
	var SetBottom = function (gameObject, value)
	{
	    gameObject.y = (value - gameObject.height) + (gameObject.height * gameObject.originY);

	    return gameObject;
	};

	SetBottom_1 = SetBottom;
	return SetBottom_1;
}

var LeftBottom_1;
var hasRequiredLeftBottom;

function requireLeftBottom () {
	if (hasRequiredLeftBottom) return LeftBottom_1;
	hasRequiredLeftBottom = 1;
	var GetBottom = requireGetBottom();
	var GetLeft = requireGetLeft();
	var SetBottom = requireSetBottom();
	var SetRight = requireSetRight();

	var LeftBottom = function (gameObject, alignTo, offsetX, offsetY)
	{
	    if (offsetX === undefined) { offsetX = 0; }
	    if (offsetY === undefined) { offsetY = 0; }

	    SetRight(gameObject, GetLeft(alignTo) - offsetX);
	    SetBottom(gameObject, GetBottom(alignTo) + offsetY);

	    return gameObject;
	};

	LeftBottom_1 = LeftBottom;
	return LeftBottom_1;
}

var GetCenterY_1;
var hasRequiredGetCenterY;

function requireGetCenterY () {
	if (hasRequiredGetCenterY) return GetCenterY_1;
	hasRequiredGetCenterY = 1;
	var GetCenterY = function (gameObject)
	{
	    return gameObject.y - (gameObject.height * gameObject.originY) + (gameObject.height * 0.5);
	};

	GetCenterY_1 = GetCenterY;
	return GetCenterY_1;
}

var SetCenterY_1;
var hasRequiredSetCenterY;

function requireSetCenterY () {
	if (hasRequiredSetCenterY) return SetCenterY_1;
	hasRequiredSetCenterY = 1;
	var SetCenterY = function (gameObject, y)
	{
	    var offsetY = gameObject.height * gameObject.originY;

	    gameObject.y = (y + offsetY) - (gameObject.height * 0.5);

	    return gameObject;
	};

	SetCenterY_1 = SetCenterY;
	return SetCenterY_1;
}

var LeftCenter_1$1;
var hasRequiredLeftCenter$1;

function requireLeftCenter$1 () {
	if (hasRequiredLeftCenter$1) return LeftCenter_1$1;
	hasRequiredLeftCenter$1 = 1;
	var GetCenterY = requireGetCenterY();
	var GetLeft = requireGetLeft();
	var SetCenterY = requireSetCenterY();
	var SetRight = requireSetRight();

	var LeftCenter = function (gameObject, alignTo, offsetX, offsetY)
	{
	    if (offsetX === undefined) { offsetX = 0; }
	    if (offsetY === undefined) { offsetY = 0; }

	    SetRight(gameObject, GetLeft(alignTo) - offsetX);
	    SetCenterY(gameObject, GetCenterY(alignTo) + offsetY);

	    return gameObject;
	};

	LeftCenter_1$1 = LeftCenter;
	return LeftCenter_1$1;
}

var GetTop_1;
var hasRequiredGetTop;

function requireGetTop () {
	if (hasRequiredGetTop) return GetTop_1;
	hasRequiredGetTop = 1;
	var GetTop = function (gameObject)
	{
	    return gameObject.y - (gameObject.height * gameObject.originY);
	};

	GetTop_1 = GetTop;
	return GetTop_1;
}

var LeftTop_1;
var hasRequiredLeftTop;

function requireLeftTop () {
	if (hasRequiredLeftTop) return LeftTop_1;
	hasRequiredLeftTop = 1;
	var GetLeft = requireGetLeft();
	var GetTop = requireGetTop();
	var SetRight = requireSetRight();
	var SetTop = requireSetTop();

	var LeftTop = function (gameObject, alignTo, offsetX, offsetY)
	{
	    if (offsetX === undefined) { offsetX = 0; }
	    if (offsetY === undefined) { offsetY = 0; }

	    SetRight(gameObject, GetLeft(alignTo) - offsetX);
	    SetTop(gameObject, GetTop(alignTo) - offsetY);

	    return gameObject;
	};

	LeftTop_1 = LeftTop;
	return LeftTop_1;
}

var RightBottom_1;
var hasRequiredRightBottom;

function requireRightBottom () {
	if (hasRequiredRightBottom) return RightBottom_1;
	hasRequiredRightBottom = 1;
	var GetBottom = requireGetBottom();
	var GetRight = requireGetRight();
	var SetBottom = requireSetBottom();
	var SetLeft = requireSetLeft();

	var RightBottom = function (gameObject, alignTo, offsetX, offsetY)
	{
	    if (offsetX === undefined) { offsetX = 0; }
	    if (offsetY === undefined) { offsetY = 0; }

	    SetLeft(gameObject, GetRight(alignTo) + offsetX);
	    SetBottom(gameObject, GetBottom(alignTo) + offsetY);

	    return gameObject;
	};

	RightBottom_1 = RightBottom;
	return RightBottom_1;
}

var RightCenter_1$1;
var hasRequiredRightCenter$1;

function requireRightCenter$1 () {
	if (hasRequiredRightCenter$1) return RightCenter_1$1;
	hasRequiredRightCenter$1 = 1;
	var GetCenterY = requireGetCenterY();
	var GetRight = requireGetRight();
	var SetCenterY = requireSetCenterY();
	var SetLeft = requireSetLeft();

	var RightCenter = function (gameObject, alignTo, offsetX, offsetY)
	{
	    if (offsetX === undefined) { offsetX = 0; }
	    if (offsetY === undefined) { offsetY = 0; }

	    SetLeft(gameObject, GetRight(alignTo) + offsetX);
	    SetCenterY(gameObject, GetCenterY(alignTo) + offsetY);

	    return gameObject;
	};

	RightCenter_1$1 = RightCenter;
	return RightCenter_1$1;
}

var RightTop_1;
var hasRequiredRightTop;

function requireRightTop () {
	if (hasRequiredRightTop) return RightTop_1;
	hasRequiredRightTop = 1;
	var GetRight = requireGetRight();
	var GetTop = requireGetTop();
	var SetLeft = requireSetLeft();
	var SetTop = requireSetTop();

	var RightTop = function (gameObject, alignTo, offsetX, offsetY)
	{
	    if (offsetX === undefined) { offsetX = 0; }
	    if (offsetY === undefined) { offsetY = 0; }

	    SetLeft(gameObject, GetRight(alignTo) + offsetX);
	    SetTop(gameObject, GetTop(alignTo) - offsetY);

	    return gameObject;
	};

	RightTop_1 = RightTop;
	return RightTop_1;
}

var TopCenter_1$1;
var hasRequiredTopCenter$1;

function requireTopCenter$1 () {
	if (hasRequiredTopCenter$1) return TopCenter_1$1;
	hasRequiredTopCenter$1 = 1;
	var GetCenterX = requireGetCenterX();
	var GetTop = requireGetTop();
	var SetBottom = requireSetBottom();
	var SetCenterX = requireSetCenterX();

	var TopCenter = function (gameObject, alignTo, offsetX, offsetY)
	{
	    if (offsetX === undefined) { offsetX = 0; }
	    if (offsetY === undefined) { offsetY = 0; }

	    SetCenterX(gameObject, GetCenterX(alignTo) + offsetX);
	    SetBottom(gameObject, GetTop(alignTo) - offsetY);

	    return gameObject;
	};

	TopCenter_1$1 = TopCenter;
	return TopCenter_1$1;
}

var TopLeft_1$1;
var hasRequiredTopLeft$1;

function requireTopLeft$1 () {
	if (hasRequiredTopLeft$1) return TopLeft_1$1;
	hasRequiredTopLeft$1 = 1;
	var GetLeft = requireGetLeft();
	var GetTop = requireGetTop();
	var SetBottom = requireSetBottom();
	var SetLeft = requireSetLeft();

	var TopLeft = function (gameObject, alignTo, offsetX, offsetY)
	{
	    if (offsetX === undefined) { offsetX = 0; }
	    if (offsetY === undefined) { offsetY = 0; }

	    SetLeft(gameObject, GetLeft(alignTo) - offsetX);
	    SetBottom(gameObject, GetTop(alignTo) - offsetY);

	    return gameObject;
	};

	TopLeft_1$1 = TopLeft;
	return TopLeft_1$1;
}

var TopRight_1$1;
var hasRequiredTopRight$1;

function requireTopRight$1 () {
	if (hasRequiredTopRight$1) return TopRight_1$1;
	hasRequiredTopRight$1 = 1;
	var GetRight = requireGetRight();
	var GetTop = requireGetTop();
	var SetBottom = requireSetBottom();
	var SetRight = requireSetRight();

	var TopRight = function (gameObject, alignTo, offsetX, offsetY)
	{
	    if (offsetX === undefined) { offsetX = 0; }
	    if (offsetY === undefined) { offsetY = 0; }

	    SetRight(gameObject, GetRight(alignTo) + offsetX);
	    SetBottom(gameObject, GetTop(alignTo) - offsetY);

	    return gameObject;
	};

	TopRight_1$1 = TopRight;
	return TopRight_1$1;
}

var QuickSet_1$1;
var hasRequiredQuickSet$1;

function requireQuickSet$1 () {
	if (hasRequiredQuickSet$1) return QuickSet_1$1;
	hasRequiredQuickSet$1 = 1;
	var ALIGN_CONST = require_const$e();

	var AlignToMap = [];

	AlignToMap[ALIGN_CONST.BOTTOM_CENTER] = requireBottomCenter$1();
	AlignToMap[ALIGN_CONST.BOTTOM_LEFT] = requireBottomLeft$1();
	AlignToMap[ALIGN_CONST.BOTTOM_RIGHT] = requireBottomRight$1();
	AlignToMap[ALIGN_CONST.LEFT_BOTTOM] = requireLeftBottom();
	AlignToMap[ALIGN_CONST.LEFT_CENTER] = requireLeftCenter$1();
	AlignToMap[ALIGN_CONST.LEFT_TOP] = requireLeftTop();
	AlignToMap[ALIGN_CONST.RIGHT_BOTTOM] = requireRightBottom();
	AlignToMap[ALIGN_CONST.RIGHT_CENTER] = requireRightCenter$1();
	AlignToMap[ALIGN_CONST.RIGHT_TOP] = requireRightTop();
	AlignToMap[ALIGN_CONST.TOP_CENTER] = requireTopCenter$1();
	AlignToMap[ALIGN_CONST.TOP_LEFT] = requireTopLeft$1();
	AlignToMap[ALIGN_CONST.TOP_RIGHT] = requireTopRight$1();

	var QuickSet = function (child, alignTo, position, offsetX, offsetY)
	{
	    return AlignToMap[position](child, alignTo, offsetX, offsetY);
	};

	QuickSet_1$1 = QuickSet;
	return QuickSet_1$1;
}

var AlignTo_1;
var hasRequiredAlignTo;

function requireAlignTo () {
	if (hasRequiredAlignTo) return AlignTo_1;
	hasRequiredAlignTo = 1;
	var QuickSet = requireQuickSet$1();

	var AlignTo = function (items, position, offsetX, offsetY)
	{
	    var target = items[0];

	    for (var i = 1; i < items.length; i++)
	    {
	        var item = items[i];

	        QuickSet(item, target, position, offsetX, offsetY);

	        target = item;
	    }

	    return items;
	};

	AlignTo_1 = AlignTo;
	return AlignTo_1;
}

var PropertyValueInc_1;
var hasRequiredPropertyValueInc;

function requirePropertyValueInc () {
	if (hasRequiredPropertyValueInc) return PropertyValueInc_1;
	hasRequiredPropertyValueInc = 1;
	var PropertyValueInc = function (items, key, value, step, index, direction)
	{
	    if (step === undefined) { step = 0; }
	    if (index === undefined) { index = 0; }
	    if (direction === undefined) { direction = 1; }

	    var i;
	    var t = 0;
	    var end = items.length;

	    if (direction === 1)
	    {

	        for (i = index; i < end; i++)
	        {
	            items[i][key] += value + (t * step);
	            t++;
	        }
	    }
	    else
	    {

	        for (i = index; i >= 0; i--)
	        {
	            items[i][key] += value + (t * step);
	            t++;
	        }
	    }

	    return items;
	};

	PropertyValueInc_1 = PropertyValueInc;
	return PropertyValueInc_1;
}

var Angle_1$1;
var hasRequiredAngle$2;

function requireAngle$2 () {
	if (hasRequiredAngle$2) return Angle_1$1;
	hasRequiredAngle$2 = 1;
	var PropertyValueInc = requirePropertyValueInc();

	var Angle = function (items, value, step, index, direction)
	{
	    return PropertyValueInc(items, 'angle', value, step, index, direction);
	};

	Angle_1$1 = Angle;
	return Angle_1$1;
}

var Call_1;
var hasRequiredCall;

function requireCall () {
	if (hasRequiredCall) return Call_1;
	hasRequiredCall = 1;
	var Call = function (items, callback, context)
	{
	    for (var i = 0; i < items.length; i++)
	    {
	        var item = items[i];

	        callback.call(context, item);
	    }

	    return items;
	};

	Call_1 = Call;
	return Call_1;
}

var GetFirst_1$1;
var hasRequiredGetFirst$1;

function requireGetFirst$1 () {
	if (hasRequiredGetFirst$1) return GetFirst_1$1;
	hasRequiredGetFirst$1 = 1;
	var GetFirst = function (items, compare, index)
	{
	    if (index === undefined) { index = 0; }

	    for (var i = index; i < items.length; i++)
	    {
	        var item = items[i];

	        var match = true;

	        for (var property in compare)
	        {
	            if (item[property] !== compare[property])
	            {
	                match = false;
	            }
	        }

	        if (match)
	        {
	            return item;
	        }
	    }

	    return null;
	};

	GetFirst_1$1 = GetFirst;
	return GetFirst_1$1;
}

var GetLast_1;
var hasRequiredGetLast;

function requireGetLast () {
	if (hasRequiredGetLast) return GetLast_1;
	hasRequiredGetLast = 1;
	var GetLast = function (items, compare, index)
	{
	    if (index === undefined) { index = 0; }

	    for (var i = items.length - 1; i >= index; i--)
	    {
	        var item = items[i];

	        var match = true;

	        for (var property in compare)
	        {
	            if (item[property] !== compare[property])
	            {
	                match = false;
	            }
	        }

	        if (match)
	        {
	            return item;
	        }
	    }

	    return null;
	};

	GetLast_1 = GetLast;
	return GetLast_1;
}

var BottomCenter_1;
var hasRequiredBottomCenter;

function requireBottomCenter () {
	if (hasRequiredBottomCenter) return BottomCenter_1;
	hasRequiredBottomCenter = 1;
	var GetBottom = requireGetBottom();
	var GetCenterX = requireGetCenterX();
	var SetBottom = requireSetBottom();
	var SetCenterX = requireSetCenterX();

	var BottomCenter = function (gameObject, alignIn, offsetX, offsetY)
	{
	    if (offsetX === undefined) { offsetX = 0; }
	    if (offsetY === undefined) { offsetY = 0; }

	    SetCenterX(gameObject, GetCenterX(alignIn) + offsetX);
	    SetBottom(gameObject, GetBottom(alignIn) + offsetY);

	    return gameObject;
	};

	BottomCenter_1 = BottomCenter;
	return BottomCenter_1;
}

var BottomLeft_1;
var hasRequiredBottomLeft;

function requireBottomLeft () {
	if (hasRequiredBottomLeft) return BottomLeft_1;
	hasRequiredBottomLeft = 1;
	var GetBottom = requireGetBottom();
	var GetLeft = requireGetLeft();
	var SetBottom = requireSetBottom();
	var SetLeft = requireSetLeft();

	var BottomLeft = function (gameObject, alignIn, offsetX, offsetY)
	{
	    if (offsetX === undefined) { offsetX = 0; }
	    if (offsetY === undefined) { offsetY = 0; }

	    SetLeft(gameObject, GetLeft(alignIn) - offsetX);
	    SetBottom(gameObject, GetBottom(alignIn) + offsetY);

	    return gameObject;
	};

	BottomLeft_1 = BottomLeft;
	return BottomLeft_1;
}

var BottomRight_1;
var hasRequiredBottomRight;

function requireBottomRight () {
	if (hasRequiredBottomRight) return BottomRight_1;
	hasRequiredBottomRight = 1;
	var GetBottom = requireGetBottom();
	var GetRight = requireGetRight();
	var SetBottom = requireSetBottom();
	var SetRight = requireSetRight();

	var BottomRight = function (gameObject, alignIn, offsetX, offsetY)
	{
	    if (offsetX === undefined) { offsetX = 0; }
	    if (offsetY === undefined) { offsetY = 0; }

	    SetRight(gameObject, GetRight(alignIn) + offsetX);
	    SetBottom(gameObject, GetBottom(alignIn) + offsetY);

	    return gameObject;
	};

	BottomRight_1 = BottomRight;
	return BottomRight_1;
}

var CenterOn_1$3;
var hasRequiredCenterOn$3;

function requireCenterOn$3 () {
	if (hasRequiredCenterOn$3) return CenterOn_1$3;
	hasRequiredCenterOn$3 = 1;
	var SetCenterX = requireSetCenterX();
	var SetCenterY = requireSetCenterY();

	var CenterOn = function (gameObject, x, y)
	{
	    SetCenterX(gameObject, x);

	    return SetCenterY(gameObject, y);
	};

	CenterOn_1$3 = CenterOn;
	return CenterOn_1$3;
}

var Center_1;
var hasRequiredCenter;

function requireCenter () {
	if (hasRequiredCenter) return Center_1;
	hasRequiredCenter = 1;
	var CenterOn = requireCenterOn$3();
	var GetCenterX = requireGetCenterX();
	var GetCenterY = requireGetCenterY();

	var Center = function (gameObject, alignIn, offsetX, offsetY)
	{
	    if (offsetX === undefined) { offsetX = 0; }
	    if (offsetY === undefined) { offsetY = 0; }

	    CenterOn(gameObject, GetCenterX(alignIn) + offsetX, GetCenterY(alignIn) + offsetY);

	    return gameObject;
	};

	Center_1 = Center;
	return Center_1;
}

var LeftCenter_1;
var hasRequiredLeftCenter;

function requireLeftCenter () {
	if (hasRequiredLeftCenter) return LeftCenter_1;
	hasRequiredLeftCenter = 1;
	var GetCenterY = requireGetCenterY();
	var GetLeft = requireGetLeft();
	var SetCenterY = requireSetCenterY();
	var SetLeft = requireSetLeft();

	var LeftCenter = function (gameObject, alignIn, offsetX, offsetY)
	{
	    if (offsetX === undefined) { offsetX = 0; }
	    if (offsetY === undefined) { offsetY = 0; }

	    SetLeft(gameObject, GetLeft(alignIn) - offsetX);
	    SetCenterY(gameObject, GetCenterY(alignIn) + offsetY);

	    return gameObject;
	};

	LeftCenter_1 = LeftCenter;
	return LeftCenter_1;
}

var RightCenter_1;
var hasRequiredRightCenter;

function requireRightCenter () {
	if (hasRequiredRightCenter) return RightCenter_1;
	hasRequiredRightCenter = 1;
	var GetCenterY = requireGetCenterY();
	var GetRight = requireGetRight();
	var SetCenterY = requireSetCenterY();
	var SetRight = requireSetRight();

	var RightCenter = function (gameObject, alignIn, offsetX, offsetY)
	{
	    if (offsetX === undefined) { offsetX = 0; }
	    if (offsetY === undefined) { offsetY = 0; }

	    SetRight(gameObject, GetRight(alignIn) + offsetX);
	    SetCenterY(gameObject, GetCenterY(alignIn) + offsetY);

	    return gameObject;
	};

	RightCenter_1 = RightCenter;
	return RightCenter_1;
}

var TopCenter_1;
var hasRequiredTopCenter;

function requireTopCenter () {
	if (hasRequiredTopCenter) return TopCenter_1;
	hasRequiredTopCenter = 1;
	var GetCenterX = requireGetCenterX();
	var GetTop = requireGetTop();
	var SetCenterX = requireSetCenterX();
	var SetTop = requireSetTop();

	var TopCenter = function (gameObject, alignIn, offsetX, offsetY)
	{
	    if (offsetX === undefined) { offsetX = 0; }
	    if (offsetY === undefined) { offsetY = 0; }

	    SetCenterX(gameObject, GetCenterX(alignIn) + offsetX);
	    SetTop(gameObject, GetTop(alignIn) - offsetY);

	    return gameObject;
	};

	TopCenter_1 = TopCenter;
	return TopCenter_1;
}

var TopLeft_1;
var hasRequiredTopLeft;

function requireTopLeft () {
	if (hasRequiredTopLeft) return TopLeft_1;
	hasRequiredTopLeft = 1;
	var GetLeft = requireGetLeft();
	var GetTop = requireGetTop();
	var SetLeft = requireSetLeft();
	var SetTop = requireSetTop();

	var TopLeft = function (gameObject, alignIn, offsetX, offsetY)
	{
	    if (offsetX === undefined) { offsetX = 0; }
	    if (offsetY === undefined) { offsetY = 0; }

	    SetLeft(gameObject, GetLeft(alignIn) - offsetX);
	    SetTop(gameObject, GetTop(alignIn) - offsetY);

	    return gameObject;
	};

	TopLeft_1 = TopLeft;
	return TopLeft_1;
}

var TopRight_1;
var hasRequiredTopRight;

function requireTopRight () {
	if (hasRequiredTopRight) return TopRight_1;
	hasRequiredTopRight = 1;
	var GetRight = requireGetRight();
	var GetTop = requireGetTop();
	var SetRight = requireSetRight();
	var SetTop = requireSetTop();

	var TopRight = function (gameObject, alignIn, offsetX, offsetY)
	{
	    if (offsetX === undefined) { offsetX = 0; }
	    if (offsetY === undefined) { offsetY = 0; }

	    SetRight(gameObject, GetRight(alignIn) + offsetX);
	    SetTop(gameObject, GetTop(alignIn) - offsetY);

	    return gameObject;
	};

	TopRight_1 = TopRight;
	return TopRight_1;
}

var QuickSet_1;
var hasRequiredQuickSet;

function requireQuickSet () {
	if (hasRequiredQuickSet) return QuickSet_1;
	hasRequiredQuickSet = 1;
	var ALIGN_CONST = require_const$e();

	var AlignInMap = [];

	AlignInMap[ALIGN_CONST.BOTTOM_CENTER] = requireBottomCenter();
	AlignInMap[ALIGN_CONST.BOTTOM_LEFT] = requireBottomLeft();
	AlignInMap[ALIGN_CONST.BOTTOM_RIGHT] = requireBottomRight();
	AlignInMap[ALIGN_CONST.CENTER] = requireCenter();
	AlignInMap[ALIGN_CONST.LEFT_CENTER] = requireLeftCenter();
	AlignInMap[ALIGN_CONST.RIGHT_CENTER] = requireRightCenter();
	AlignInMap[ALIGN_CONST.TOP_CENTER] = requireTopCenter();
	AlignInMap[ALIGN_CONST.TOP_LEFT] = requireTopLeft();
	AlignInMap[ALIGN_CONST.TOP_RIGHT] = requireTopRight();
	AlignInMap[ALIGN_CONST.LEFT_BOTTOM] = AlignInMap[ALIGN_CONST.BOTTOM_LEFT];
	AlignInMap[ALIGN_CONST.LEFT_TOP] = AlignInMap[ALIGN_CONST.TOP_LEFT];
	AlignInMap[ALIGN_CONST.RIGHT_BOTTOM] = AlignInMap[ALIGN_CONST.BOTTOM_RIGHT];
	AlignInMap[ALIGN_CONST.RIGHT_TOP] = AlignInMap[ALIGN_CONST.TOP_RIGHT];

	var QuickSet = function (child, alignIn, position, offsetX, offsetY)
	{
	    return AlignInMap[position](child, alignIn, offsetX, offsetY);
	};

	QuickSet_1 = QuickSet;
	return QuickSet_1;
}

var GetFastValue_1;
var hasRequiredGetFastValue;

function requireGetFastValue () {
	if (hasRequiredGetFastValue) return GetFastValue_1;
	hasRequiredGetFastValue = 1;
	var GetFastValue = function (source, key, defaultValue)
	{
	    var t = typeof(source);

	    if (!source || t === 'number' || t === 'string')
	    {
	        return defaultValue;
	    }
	    else if (source.hasOwnProperty(key) && source[key] !== undefined)
	    {
	        return source[key];
	    }
	    else
	    {
	        return defaultValue;
	    }
	};

	GetFastValue_1 = GetFastValue;
	return GetFastValue_1;
}

var NOOP_1;
var hasRequiredNOOP;

function requireNOOP () {
	if (hasRequiredNOOP) return NOOP_1;
	hasRequiredNOOP = 1;
	var NOOP = function ()
	{

	};

	NOOP_1 = NOOP;
	return NOOP_1;
}

var Class_1;
var hasRequiredClass;

function requireClass () {
	if (hasRequiredClass) return Class_1;
	hasRequiredClass = 1;
	function hasGetterOrSetter (def)
	{
	    return (!!def.get && typeof def.get === 'function') || (!!def.set && typeof def.set === 'function');
	}

	function getProperty (definition, k, isClassDescriptor)
	{

	    var def = (isClassDescriptor) ? definition[k] : Object.getOwnPropertyDescriptor(definition, k);

	    if (!isClassDescriptor && def.value && typeof def.value === 'object')
	    {
	        def = def.value;
	    }

	    if (def && hasGetterOrSetter(def))
	    {
	        if (typeof def.enumerable === 'undefined')
	        {
	            def.enumerable = true;
	        }

	        if (typeof def.configurable === 'undefined')
	        {
	            def.configurable = true;
	        }

	        return def;
	    }
	    else
	    {
	        return false;
	    }
	}

	function hasNonConfigurable (obj, k)
	{
	    var prop = Object.getOwnPropertyDescriptor(obj, k);

	    if (!prop)
	    {
	        return false;
	    }

	    if (prop.value && typeof prop.value === 'object')
	    {
	        prop = prop.value;
	    }

	    if (prop.configurable === false)
	    {
	        return true;
	    }

	    return false;
	}

	function extend (ctor, definition, isClassDescriptor, extend)
	{
	    for (var k in definition)
	    {
	        if (!definition.hasOwnProperty(k))
	        {
	            continue;
	        }

	        var def = getProperty(definition, k, isClassDescriptor);

	        if (def !== false)
	        {

	            var parent = extend || ctor;

	            if (hasNonConfigurable(parent.prototype, k))
	            {

	                if (Class.ignoreFinals)
	                {
	                    continue;
	                }

	                throw new Error('cannot override final property \'' + k + '\', set Class.ignoreFinals = true to skip');
	            }

	            Object.defineProperty(ctor.prototype, k, def);
	        }
	        else
	        {
	            ctor.prototype[k] = definition[k];
	        }
	    }
	}

	function mixin (myClass, mixins)
	{
	    if (!mixins)
	    {
	        return;
	    }

	    if (!Array.isArray(mixins))
	    {
	        mixins = [ mixins ];
	    }

	    for (var i = 0; i < mixins.length; i++)
	    {
	        extend(myClass, mixins[i].prototype || mixins[i]);
	    }
	}

	function Class (definition)
	{
	    if (!definition)
	    {
	        definition = {};
	    }

	    var initialize;
	    var Extends;

	    if (definition.initialize)
	    {
	        if (typeof definition.initialize !== 'function')
	        {
	            throw new Error('initialize must be a function');
	        }

	        initialize = definition.initialize;

	        delete definition.initialize;
	    }
	    else if (definition.Extends)
	    {
	        var base = definition.Extends;

	        initialize = function ()
	        {
	            base.apply(this, arguments);
	        };
	    }
	    else
	    {
	        initialize = function () {};
	    }

	    if (definition.Extends)
	    {
	        initialize.prototype = Object.create(definition.Extends.prototype);
	        initialize.prototype.constructor = initialize;

	        Extends = definition.Extends;

	        delete definition.Extends;
	    }
	    else
	    {
	        initialize.prototype.constructor = initialize;
	    }

	    var mixins = null;

	    if (definition.Mixins)
	    {
	        mixins = definition.Mixins;
	        delete definition.Mixins;
	    }

	    mixin(initialize, mixins);

	    extend(initialize, definition, true, Extends);

	    return initialize;
	}

	Class.extend = extend;
	Class.mixin = mixin;
	Class.ignoreFinals = false;

	Class_1 = Class;
	return Class_1;
}

var Contains_1$4;
var hasRequiredContains$4;

function requireContains$4 () {
	if (hasRequiredContains$4) return Contains_1$4;
	hasRequiredContains$4 = 1;
	var Contains = function (circle, x, y)
	{

	    if (circle.radius > 0 && x >= circle.left && x <= circle.right && y >= circle.top && y <= circle.bottom)
	    {
	        var dx = (circle.x - x) * (circle.x - x);
	        var dy = (circle.y - y) * (circle.y - y);

	        return (dx + dy) <= (circle.radius * circle.radius);
	    }
	    else
	    {
	        return false;
	    }
	};

	Contains_1$4 = Contains;
	return Contains_1$4;
}

var _const$d;
var hasRequired_const$d;

function require_const$d () {
	if (hasRequired_const$d) return _const$d;
	hasRequired_const$d = 1;
	var GEOM_CONST = {

	    CIRCLE: 0,

	    ELLIPSE: 1,

	    LINE: 2,

	    POINT: 3,

	    POLYGON: 4,

	    RECTANGLE: 5,

	    TRIANGLE: 6

	};

	_const$d = GEOM_CONST;
	return _const$d;
}

var Point_1;
var hasRequiredPoint$1;

function requirePoint$1 () {
	if (hasRequiredPoint$1) return Point_1;
	hasRequiredPoint$1 = 1;
	var Class = requireClass();
	var GEOM_CONST = require_const$d();

	var Point = new Class({

	    initialize:

	    function Point (x, y)
	    {
	        if (x === undefined) { x = 0; }
	        if (y === undefined) { y = x; }

	        this.type = GEOM_CONST.POINT;

	        this.x = x;

	        this.y = y;
	    },

	    setTo: function (x, y)
	    {
	        if (x === undefined) { x = 0; }
	        if (y === undefined) { y = x; }

	        this.x = x;
	        this.y = y;

	        return this;
	    }

	});

	Point_1 = Point;
	return Point_1;
}

var CircumferencePoint_1$1;
var hasRequiredCircumferencePoint$1;

function requireCircumferencePoint$1 () {
	if (hasRequiredCircumferencePoint$1) return CircumferencePoint_1$1;
	hasRequiredCircumferencePoint$1 = 1;
	var Point = requirePoint$1();

	var CircumferencePoint = function (circle, angle, out)
	{
	    if (out === undefined) { out = new Point(); }

	    out.x = circle.x + (circle.radius * Math.cos(angle));
	    out.y = circle.y + (circle.radius * Math.sin(angle));

	    return out;
	};

	CircumferencePoint_1$1 = CircumferencePoint;
	return CircumferencePoint_1$1;
}

var Clamp_1;
var hasRequiredClamp;

function requireClamp () {
	if (hasRequiredClamp) return Clamp_1;
	hasRequiredClamp = 1;
	var Clamp = function (value, min, max)
	{
	    return Math.max(min, Math.min(max, value));
	};

	Clamp_1 = Clamp;
	return Clamp_1;
}

var FromPercent_1;
var hasRequiredFromPercent;

function requireFromPercent () {
	if (hasRequiredFromPercent) return FromPercent_1;
	hasRequiredFromPercent = 1;
	var Clamp = requireClamp();

	var FromPercent = function (percent, min, max)
	{
	    percent = Clamp(percent, 0, 1);

	    return (max - min) * percent + min;
	};

	FromPercent_1 = FromPercent;
	return FromPercent_1;
}

var _const$c;
var hasRequired_const$c;

function require_const$c () {
	if (hasRequired_const$c) return _const$c;
	hasRequired_const$c = 1;
	var MATH_CONST = {

	    PI2: Math.PI * 2,

	    TAU: Math.PI * 0.5,

	    EPSILON: 1.0e-6,

	    DEG_TO_RAD: Math.PI / 180,

	    RAD_TO_DEG: 180 / Math.PI,

	    RND: null,

	    MIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER || -9007199254740991,

	    MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991

	};

	_const$c = MATH_CONST;
	return _const$c;
}

var GetPoint_1$4;
var hasRequiredGetPoint$4;

function requireGetPoint$4 () {
	if (hasRequiredGetPoint$4) return GetPoint_1$4;
	hasRequiredGetPoint$4 = 1;
	var CircumferencePoint = requireCircumferencePoint$1();
	var FromPercent = requireFromPercent();
	var MATH_CONST = require_const$c();
	var Point = requirePoint$1();

	var GetPoint = function (circle, position, out)
	{
	    if (out === undefined) { out = new Point(); }

	    var angle = FromPercent(position, 0, MATH_CONST.PI2);

	    return CircumferencePoint(circle, angle, out);
	};

	GetPoint_1$4 = GetPoint;
	return GetPoint_1$4;
}

var Circumference_1$1;
var hasRequiredCircumference$1;

function requireCircumference$1 () {
	if (hasRequiredCircumference$1) return Circumference_1$1;
	hasRequiredCircumference$1 = 1;
	var Circumference = function (circle)
	{
	    return 2 * (Math.PI * circle.radius);
	};

	Circumference_1$1 = Circumference;
	return Circumference_1$1;
}

var GetPoints_1$5;
var hasRequiredGetPoints$5;

function requireGetPoints$5 () {
	if (hasRequiredGetPoints$5) return GetPoints_1$5;
	hasRequiredGetPoints$5 = 1;
	var Circumference = requireCircumference$1();
	var CircumferencePoint = requireCircumferencePoint$1();
	var FromPercent = requireFromPercent();
	var MATH_CONST = require_const$c();

	var GetPoints = function (circle, quantity, stepRate, out)
	{
	    if (out === undefined) { out = []; }

	    if (!quantity && stepRate > 0)
	    {
	        quantity = Circumference(circle) / stepRate;
	    }

	    for (var i = 0; i < quantity; i++)
	    {
	        var angle = FromPercent(i / quantity, 0, MATH_CONST.PI2);

	        out.push(CircumferencePoint(circle, angle));
	    }

	    return out;
	};

	GetPoints_1$5 = GetPoints;
	return GetPoints_1$5;
}

var Random_1$5;
var hasRequiredRandom$5;

function requireRandom$5 () {
	if (hasRequiredRandom$5) return Random_1$5;
	hasRequiredRandom$5 = 1;
	var Point = requirePoint$1();

	var Random = function (circle, out)
	{
	    if (out === undefined) { out = new Point(); }

	    var t = 2 * Math.PI * Math.random();
	    var u = Math.random() + Math.random();
	    var r = (u > 1) ? 2 - u : u;
	    var x = r * Math.cos(t);
	    var y = r * Math.sin(t);

	    out.x = circle.x + (x * circle.radius);
	    out.y = circle.y + (y * circle.radius);

	    return out;
	};

	Random_1$5 = Random;
	return Random_1$5;
}

var Circle_1$1;
var hasRequiredCircle$2;

function requireCircle$2 () {
	if (hasRequiredCircle$2) return Circle_1$1;
	hasRequiredCircle$2 = 1;
	var Class = requireClass();
	var Contains = requireContains$4();
	var GetPoint = requireGetPoint$4();
	var GetPoints = requireGetPoints$5();
	var GEOM_CONST = require_const$d();
	var Random = requireRandom$5();

	var Circle = new Class({

	    initialize:

	    function Circle (x, y, radius)
	    {
	        if (x === undefined) { x = 0; }
	        if (y === undefined) { y = 0; }
	        if (radius === undefined) { radius = 0; }

	        this.type = GEOM_CONST.CIRCLE;

	        this.x = x;

	        this.y = y;

	        this._radius = radius;

	        this._diameter = radius * 2;
	    },

	    contains: function (x, y)
	    {
	        return Contains(this, x, y);
	    },

	    getPoint: function (position, point)
	    {
	        return GetPoint(this, position, point);
	    },

	    getPoints: function (quantity, stepRate, output)
	    {
	        return GetPoints(this, quantity, stepRate, output);
	    },

	    getRandomPoint: function (point)
	    {
	        return Random(this, point);
	    },

	    setTo: function (x, y, radius)
	    {
	        this.x = x;
	        this.y = y;
	        this._radius = radius;
	        this._diameter = radius * 2;

	        return this;
	    },

	    setEmpty: function ()
	    {
	        this._radius = 0;
	        this._diameter = 0;

	        return this;
	    },

	    setPosition: function (x, y)
	    {
	        if (y === undefined) { y = x; }

	        this.x = x;
	        this.y = y;

	        return this;
	    },

	    isEmpty: function ()
	    {
	        return (this._radius <= 0);
	    },

	    radius: {

	        get: function ()
	        {
	            return this._radius;
	        },

	        set: function (value)
	        {
	            this._radius = value;
	            this._diameter = value * 2;
	        }

	    },

	    diameter: {

	        get: function ()
	        {
	            return this._diameter;
	        },

	        set: function (value)
	        {
	            this._diameter = value;
	            this._radius = value * 0.5;
	        }

	    },

	    left: {

	        get: function ()
	        {
	            return this.x - this._radius;
	        },

	        set: function (value)
	        {
	            this.x = value + this._radius;
	        }

	    },

	    right: {

	        get: function ()
	        {
	            return this.x + this._radius;
	        },

	        set: function (value)
	        {
	            this.x = value - this._radius;
	        }

	    },

	    top: {

	        get: function ()
	        {
	            return this.y - this._radius;
	        },

	        set: function (value)
	        {
	            this.y = value + this._radius;
	        }

	    },

	    bottom: {

	        get: function ()
	        {
	            return this.y + this._radius;
	        },

	        set: function (value)
	        {
	            this.y = value - this._radius;
	        }

	    }

	});

	Circle_1$1 = Circle;
	return Circle_1$1;
}

var Alpha_1;
var hasRequiredAlpha;

function requireAlpha () {
	if (hasRequiredAlpha) return Alpha_1;
	hasRequiredAlpha = 1;
	var Clamp = requireClamp();

	var _FLAG = 2; 

	var Alpha = {

	    _alpha: 1,

	    _alphaTL: 1,

	    _alphaTR: 1,

	    _alphaBL: 1,

	    _alphaBR: 1,

	    clearAlpha: function ()
	    {
	        return this.setAlpha(1);
	    },

	    setAlpha: function (topLeft, topRight, bottomLeft, bottomRight)
	    {
	        if (topLeft === undefined) { topLeft = 1; }

	        if (topRight === undefined)
	        {
	            this.alpha = topLeft;
	        }
	        else
	        {
	            this._alphaTL = Clamp(topLeft, 0, 1);
	            this._alphaTR = Clamp(topRight, 0, 1);
	            this._alphaBL = Clamp(bottomLeft, 0, 1);
	            this._alphaBR = Clamp(bottomRight, 0, 1);
	        }

	        return this;
	    },

	    alpha: {

	        get: function ()
	        {
	            return this._alpha;
	        },

	        set: function (value)
	        {
	            var v = Clamp(value, 0, 1);

	            this._alpha = v;
	            this._alphaTL = v;
	            this._alphaTR = v;
	            this._alphaBL = v;
	            this._alphaBR = v;

	            if (v === 0)
	            {
	                this.renderFlags &= ~_FLAG;
	            }
	            else
	            {
	                this.renderFlags |= _FLAG;
	            }
	        }

	    },

	    alphaTopLeft: {

	        get: function ()
	        {
	            return this._alphaTL;
	        },

	        set: function (value)
	        {
	            var v = Clamp(value, 0, 1);

	            this._alphaTL = v;

	            if (v !== 0)
	            {
	                this.renderFlags |= _FLAG;
	            }
	        }

	    },

	    alphaTopRight: {

	        get: function ()
	        {
	            return this._alphaTR;
	        },

	        set: function (value)
	        {
	            var v = Clamp(value, 0, 1);

	            this._alphaTR = v;

	            if (v !== 0)
	            {
	                this.renderFlags |= _FLAG;
	            }
	        }

	    },

	    alphaBottomLeft: {

	        get: function ()
	        {
	            return this._alphaBL;
	        },

	        set: function (value)
	        {
	            var v = Clamp(value, 0, 1);

	            this._alphaBL = v;

	            if (v !== 0)
	            {
	                this.renderFlags |= _FLAG;
	            }
	        }

	    },

	    alphaBottomRight: {

	        get: function ()
	        {
	            return this._alphaBR;
	        },

	        set: function (value)
	        {
	            var v = Clamp(value, 0, 1);

	            this._alphaBR = v;

	            if (v !== 0)
	            {
	                this.renderFlags |= _FLAG;
	            }
	        }

	    }

	};

	Alpha_1 = Alpha;
	return Alpha_1;
}

var AlphaSingle_1;
var hasRequiredAlphaSingle;

function requireAlphaSingle () {
	if (hasRequiredAlphaSingle) return AlphaSingle_1;
	hasRequiredAlphaSingle = 1;
	var Clamp = requireClamp();

	var _FLAG = 2; 

	var AlphaSingle = {

	    _alpha: 1,

	    clearAlpha: function ()
	    {
	        return this.setAlpha(1);
	    },

	    setAlpha: function (value)
	    {
	        if (value === undefined) { value = 1; }

	        this.alpha = value;

	        return this;
	    },

	    alpha: {

	        get: function ()
	        {
	            return this._alpha;
	        },

	        set: function (value)
	        {
	            var v = Clamp(value, 0, 1);

	            this._alpha = v;

	            if (v === 0)
	            {
	                this.renderFlags &= ~_FLAG;
	            }
	            else
	            {
	                this.renderFlags |= _FLAG;
	            }
	        }

	    }

	};

	AlphaSingle_1 = AlphaSingle;
	return AlphaSingle_1;
}

var BlendMode_1;
var hasRequiredBlendMode;

function requireBlendMode () {
	if (hasRequiredBlendMode) return BlendMode_1;
	hasRequiredBlendMode = 1;
	var BlendModes = requireBlendModes();

	var BlendMode = {

	    _blendMode: BlendModes.NORMAL,

	    blendMode: {

	        get: function ()
	        {
	            return this._blendMode;
	        },

	        set: function (value)
	        {
	            if (typeof value === 'string')
	            {
	                value = BlendModes[value];
	            }

	            value |= 0;

	            if (value >= -1)
	            {
	                this._blendMode = value;
	            }
	        }

	    },

	    setBlendMode: function (value)
	    {
	        this.blendMode = value;

	        return this;
	    }

	};

	BlendMode_1 = BlendMode;
	return BlendMode_1;
}

var ComputedSize_1;
var hasRequiredComputedSize;

function requireComputedSize () {
	if (hasRequiredComputedSize) return ComputedSize_1;
	hasRequiredComputedSize = 1;
	var ComputedSize = {

	    width: 0,

	    height: 0,

	    displayWidth: {

	        get: function ()
	        {
	            return this.scaleX * this.width;
	        },

	        set: function (value)
	        {
	            this.scaleX = value / this.width;
	        }

	    },

	    displayHeight: {

	        get: function ()
	        {
	            return this.scaleY * this.height;
	        },

	        set: function (value)
	        {
	            this.scaleY = value / this.height;
	        }

	    },

	    setSize: function (width, height)
	    {
	        this.width = width;
	        this.height = height;

	        return this;
	    },

	    setDisplaySize: function (width, height)
	    {
	        this.displayWidth = width;
	        this.displayHeight = height;

	        return this;
	    }

	};

	ComputedSize_1 = ComputedSize;
	return ComputedSize_1;
}

var Crop_1;
var hasRequiredCrop;

function requireCrop () {
	if (hasRequiredCrop) return Crop_1;
	hasRequiredCrop = 1;
	var Crop = {

	    texture: null,

	    frame: null,

	    isCropped: false,

	    setCrop: function (x, y, width, height)
	    {
	        if (x === undefined)
	        {
	            this.isCropped = false;
	        }
	        else if (this.frame)
	        {
	            if (typeof x === 'number')
	            {
	                this.frame.setCropUVs(this._crop, x, y, width, height, this.flipX, this.flipY);
	            }
	            else
	            {
	                var rect = x;

	                this.frame.setCropUVs(this._crop, rect.x, rect.y, rect.width, rect.height, this.flipX, this.flipY);
	            }

	            this.isCropped = true;
	        }

	        return this;
	    },

	    resetCropObject: function ()
	    {
	        return { u0: 0, v0: 0, u1: 0, v1: 0, width: 0, height: 0, x: 0, y: 0, flipX: false, flipY: false, cx: 0, cy: 0, cw: 0, ch: 0 };
	    }

	};

	Crop_1 = Crop;
	return Crop_1;
}

var CheckMatrix_1;
var hasRequiredCheckMatrix;

function requireCheckMatrix () {
	if (hasRequiredCheckMatrix) return CheckMatrix_1;
	hasRequiredCheckMatrix = 1;
	var CheckMatrix = function (matrix)
	{
	    if (!Array.isArray(matrix) || !Array.isArray(matrix[0]))
	    {
	        return false;
	    }

	    var size = matrix[0].length;

	    for (var i = 1; i < matrix.length; i++)
	    {
	        if (matrix[i].length !== size)
	        {
	            return false;
	        }
	    }

	    return true;
	};

	CheckMatrix_1 = CheckMatrix;
	return CheckMatrix_1;
}

var Pad_1;
var hasRequiredPad;

function requirePad () {
	if (hasRequiredPad) return Pad_1;
	hasRequiredPad = 1;
	var Pad = function (str, len, pad, dir)
	{
	    if (len === undefined) { len = 0; }
	    if (pad === undefined) { pad = ' '; }
	    if (dir === undefined) { dir = 3; }

	    str = str.toString();

	    var padlen = 0;

	    if (len + 1 >= str.length)
	    {
	        switch (dir)
	        {
	            case 1:
	                str = new Array(len + 1 - str.length).join(pad) + str;
	                break;

	            case 3:
	                var right = Math.ceil((padlen = len - str.length) / 2);
	                var left = padlen - right;
	                str = new Array(left + 1).join(pad) + str + new Array(right + 1).join(pad);
	                break;

	            default:
	                str = str + new Array(len + 1 - str.length).join(pad);
	                break;
	        }
	    }

	    return str;
	};

	Pad_1 = Pad;
	return Pad_1;
}

var MatrixToString_1;
var hasRequiredMatrixToString;

function requireMatrixToString () {
	if (hasRequiredMatrixToString) return MatrixToString_1;
	hasRequiredMatrixToString = 1;
	var Pad = requirePad();
	var CheckMatrix = requireCheckMatrix();

	var MatrixToString = function (matrix)
	{
	    var str = '';

	    if (!CheckMatrix(matrix))
	    {
	        return str;
	    }

	    for (var r = 0; r < matrix.length; r++)
	    {
	        for (var c = 0; c < matrix[r].length; c++)
	        {
	            var cell = matrix[r][c].toString();

	            if (cell !== 'undefined')
	            {
	                str += Pad(cell, 2);
	            }
	            else
	            {
	                str += '?';
	            }

	            if (c < matrix[r].length - 1)
	            {
	                str += ' |';
	            }
	        }

	        if (r < matrix.length - 1)
	        {
	            str += '\n';

	            for (var i = 0; i < matrix[r].length; i++)
	            {
	                str += '---';

	                if (i < matrix[r].length - 1)
	                {
	                    str += '+';
	                }
	            }

	            str += '\n';
	        }

	    }

	    return str;
	};

	MatrixToString_1 = MatrixToString;
	return MatrixToString_1;
}

var ReverseColumns_1;
var hasRequiredReverseColumns;

function requireReverseColumns () {
	if (hasRequiredReverseColumns) return ReverseColumns_1;
	hasRequiredReverseColumns = 1;
	var ReverseColumns = function (matrix)
	{
	    return matrix.reverse();
	};

	ReverseColumns_1 = ReverseColumns;
	return ReverseColumns_1;
}

var ReverseRows_1;
var hasRequiredReverseRows;

function requireReverseRows () {
	if (hasRequiredReverseRows) return ReverseRows_1;
	hasRequiredReverseRows = 1;
	var ReverseRows = function (matrix)
	{
	    for (var i = 0; i < matrix.length; i++)
	    {
	        matrix[i].reverse();
	    }

	    return matrix;
	};

	ReverseRows_1 = ReverseRows;
	return ReverseRows_1;
}

var TransposeMatrix_1;
var hasRequiredTransposeMatrix;

function requireTransposeMatrix () {
	if (hasRequiredTransposeMatrix) return TransposeMatrix_1;
	hasRequiredTransposeMatrix = 1;
	var TransposeMatrix = function (array)
	{
	    var sourceRowCount = array.length;
	    var sourceColCount = array[0].length;

	    var result = new Array(sourceColCount);

	    for (var i = 0; i < sourceColCount; i++)
	    {
	        result[i] = new Array(sourceRowCount);

	        for (var j = sourceRowCount - 1; j > -1; j--)
	        {
	            result[i][j] = array[j][i];
	        }
	    }

	    return result;
	};

	TransposeMatrix_1 = TransposeMatrix;
	return TransposeMatrix_1;
}

var RotateMatrix_1;
var hasRequiredRotateMatrix;

function requireRotateMatrix () {
	if (hasRequiredRotateMatrix) return RotateMatrix_1;
	hasRequiredRotateMatrix = 1;
	var CheckMatrix = requireCheckMatrix();
	var TransposeMatrix = requireTransposeMatrix();

	var RotateMatrix = function (matrix, direction)
	{
	    if (direction === undefined) { direction = 90; }

	    if (!CheckMatrix(matrix))
	    {
	        return null;
	    }

	    if (typeof direction !== 'string')
	    {
	        direction = ((direction % 360) + 360) % 360;
	    }

	    if (direction === 90 || direction === -270 || direction === 'rotateLeft')
	    {
	        matrix = TransposeMatrix(matrix);
	        matrix.reverse();
	    }
	    else if (direction === -90 || direction === 270 || direction === 'rotateRight')
	    {
	        matrix.reverse();
	        matrix = TransposeMatrix(matrix);
	    }
	    else if (Math.abs(direction) === 180 || direction === 'rotate180')
	    {
	        for (var i = 0; i < matrix.length; i++)
	        {
	            matrix[i].reverse();
	        }

	        matrix.reverse();
	    }

	    return matrix;
	};

	RotateMatrix_1 = RotateMatrix;
	return RotateMatrix_1;
}

var Rotate180_1;
var hasRequiredRotate180;

function requireRotate180 () {
	if (hasRequiredRotate180) return Rotate180_1;
	hasRequiredRotate180 = 1;
	var RotateMatrix = requireRotateMatrix();

	var Rotate180 = function (matrix)
	{
	    return RotateMatrix(matrix, 180);
	};

	Rotate180_1 = Rotate180;
	return Rotate180_1;
}

var RotateLeft_1$1;
var hasRequiredRotateLeft$1;

function requireRotateLeft$1 () {
	if (hasRequiredRotateLeft$1) return RotateLeft_1$1;
	hasRequiredRotateLeft$1 = 1;
	var RotateMatrix = requireRotateMatrix();

	var RotateLeft = function (matrix, amount)
	{
	    if (amount === undefined) { amount = 1; }

	    for (var i = 0; i < amount; i++)
	    {
	        matrix = RotateMatrix(matrix, 90);
	    }

	    return matrix;
	};

	RotateLeft_1$1 = RotateLeft;
	return RotateLeft_1$1;
}

var RotateRight_1$1;
var hasRequiredRotateRight$1;

function requireRotateRight$1 () {
	if (hasRequiredRotateRight$1) return RotateRight_1$1;
	hasRequiredRotateRight$1 = 1;
	var RotateMatrix = requireRotateMatrix();

	var RotateRight = function (matrix, amount)
	{
	    if (amount === undefined) { amount = 1; }

	    for (var i = 0; i < amount; i++)
	    {
	        matrix = RotateMatrix(matrix, -90);
	    }

	    return matrix;
	};

	RotateRight_1$1 = RotateRight;
	return RotateRight_1$1;
}

var RotateLeft_1;
var hasRequiredRotateLeft;

function requireRotateLeft () {
	if (hasRequiredRotateLeft) return RotateLeft_1;
	hasRequiredRotateLeft = 1;
	var RotateLeft = function (array, total)
	{
	    if (total === undefined) { total = 1; }

	    var element = null;

	    for (var i = 0; i < total; i++)
	    {
	        element = array.shift();
	        array.push(element);
	    }

	    return element;
	};

	RotateLeft_1 = RotateLeft;
	return RotateLeft_1;
}

var RotateRight_1;
var hasRequiredRotateRight;

function requireRotateRight () {
	if (hasRequiredRotateRight) return RotateRight_1;
	hasRequiredRotateRight = 1;
	var RotateRight = function (array, total)
	{
	    if (total === undefined) { total = 1; }

	    var element = null;

	    for (var i = 0; i < total; i++)
	    {
	        element = array.pop();
	        array.unshift(element);
	    }

	    return element;
	};

	RotateRight_1 = RotateRight;
	return RotateRight_1;
}

var TranslateMatrix_1;
var hasRequiredTranslateMatrix;

function requireTranslateMatrix () {
	if (hasRequiredTranslateMatrix) return TranslateMatrix_1;
	hasRequiredTranslateMatrix = 1;
	var RotateLeft = requireRotateLeft();
	var RotateRight = requireRotateRight();

	var TranslateMatrix = function (matrix, x, y)
	{
	    if (x === undefined) { x = 0; }
	    if (y === undefined) { y = 0; }

	    if (y !== 0)
	    {
	        if (y < 0)
	        {

	            RotateLeft(matrix, Math.abs(y));
	        }
	        else
	        {

	            RotateRight(matrix, y);
	        }
	    }

	    if (x !== 0)
	    {
	        for (var i = 0; i < matrix.length; i++)
	        {
	            var row = matrix[i];

	            if (x < 0)
	            {
	                RotateLeft(row, Math.abs(x));
	            }
	            else
	            {
	                RotateRight(row, x);
	            }
	        }
	    }

	    return matrix;
	};

	TranslateMatrix_1 = TranslateMatrix;
	return TranslateMatrix_1;
}

var matrix;
var hasRequiredMatrix;

function requireMatrix () {
	if (hasRequiredMatrix) return matrix;
	hasRequiredMatrix = 1;
	matrix = {

	    CheckMatrix: requireCheckMatrix(),
	    MatrixToString: requireMatrixToString(),
	    ReverseColumns: requireReverseColumns(),
	    ReverseRows: requireReverseRows(),
	    Rotate180: requireRotate180(),
	    RotateLeft: requireRotateLeft$1(),
	    RotateMatrix: requireRotateMatrix(),
	    RotateRight: requireRotateRight$1(),
	    Translate: requireTranslateMatrix(),
	    TransposeMatrix: requireTransposeMatrix()

	};
	return matrix;
}

var Add_1;
var hasRequiredAdd;

function requireAdd () {
	if (hasRequiredAdd) return Add_1;
	hasRequiredAdd = 1;
	var Add = function (array, item, limit, callback, context)
	{
	    if (context === undefined) { context = array; }

	    if (limit > 0)
	    {
	        var remaining = limit - array.length;

	        if (remaining <= 0)
	        {
	            return null;
	        }
	    }

	    if (!Array.isArray(item))
	    {
	        if (array.indexOf(item) === -1)
	        {
	            array.push(item);

	            if (callback)
	            {
	                callback.call(context, item);
	            }

	            return item;
	        }
	        else
	        {
	            return null;
	        }
	    }

	    var itemLength = item.length - 1;

	    while (itemLength >= 0)
	    {
	        if (array.indexOf(item[itemLength]) !== -1)
	        {

	            item.splice(itemLength, 1);
	        }

	        itemLength--;
	    }

	    itemLength = item.length;

	    if (itemLength === 0)
	    {
	        return null;
	    }

	    if (limit > 0 && itemLength > remaining)
	    {
	        item.splice(remaining);

	        itemLength = remaining;
	    }

	    for (var i = 0; i < itemLength; i++)
	    {
	        var entry = item[i];

	        array.push(entry);

	        if (callback)
	        {
	            callback.call(context, entry);
	        }
	    }

	    return item;
	};

	Add_1 = Add;
	return Add_1;
}

var AddAt_1;
var hasRequiredAddAt;

function requireAddAt () {
	if (hasRequiredAddAt) return AddAt_1;
	hasRequiredAddAt = 1;
	var AddAt = function (array, item, index, limit, callback, context)
	{
	    if (index === undefined) { index = 0; }
	    if (context === undefined) { context = array; }

	    if (limit > 0)
	    {
	        var remaining = limit - array.length;

	        if (remaining <= 0)
	        {
	            return null;
	        }
	    }

	    if (!Array.isArray(item))
	    {
	        if (array.indexOf(item) === -1)
	        {
	            array.splice(index, 0, item);

	            if (callback)
	            {
	                callback.call(context, item);
	            }

	            return item;
	        }
	        else
	        {
	            return null;
	        }
	    }

	    var itemLength = item.length - 1;

	    while (itemLength >= 0)
	    {
	        if (array.indexOf(item[itemLength]) !== -1)
	        {

	            item.pop();
	        }

	        itemLength--;
	    }

	    itemLength = item.length;

	    if (itemLength === 0)
	    {
	        return null;
	    }

	    if (limit > 0 && itemLength > remaining)
	    {
	        item.splice(remaining);

	        itemLength = remaining;
	    }

	    for (var i = itemLength - 1; i >= 0; i--)
	    {
	        var entry = item[i];

	        array.splice(index, 0, entry);

	        if (callback)
	        {
	            callback.call(context, entry);
	        }
	    }

	    return item;
	};

	AddAt_1 = AddAt;
	return AddAt_1;
}

var BringToTop_1;
var hasRequiredBringToTop;

function requireBringToTop () {
	if (hasRequiredBringToTop) return BringToTop_1;
	hasRequiredBringToTop = 1;
	var BringToTop = function (array, item)
	{
	    var currentIndex = array.indexOf(item);

	    if (currentIndex !== -1 && currentIndex < array.length)
	    {
	        array.splice(currentIndex, 1);
	        array.push(item);
	    }

	    return item;
	};

	BringToTop_1 = BringToTop;
	return BringToTop_1;
}

var SafeRange_1;
var hasRequiredSafeRange;

function requireSafeRange () {
	if (hasRequiredSafeRange) return SafeRange_1;
	hasRequiredSafeRange = 1;
	var SafeRange = function (array, startIndex, endIndex, throwError)
	{
	    var len = array.length;

	    if (startIndex < 0 ||
	        startIndex >= len ||
	        startIndex >= endIndex ||
	        endIndex > len)
	    {
	        if (throwError)
	        {
	            throw new Error('Range Error: Values outside acceptable range');
	        }

	        return false;
	    }
	    else
	    {
	        return true;
	    }
	};

	SafeRange_1 = SafeRange;
	return SafeRange_1;
}

var CountAllMatching_1;
var hasRequiredCountAllMatching;

function requireCountAllMatching () {
	if (hasRequiredCountAllMatching) return CountAllMatching_1;
	hasRequiredCountAllMatching = 1;
	var SafeRange = requireSafeRange();

	var CountAllMatching = function (array, property, value, startIndex, endIndex)
	{
	    if (startIndex === undefined) { startIndex = 0; }
	    if (endIndex === undefined) { endIndex = array.length; }

	    var total = 0;

	    if (SafeRange(array, startIndex, endIndex))
	    {
	        for (var i = startIndex; i < endIndex; i++)
	        {
	            var child = array[i];

	            if (child[property] === value)
	            {
	                total++;
	            }
	        }
	    }

	    return total;
	};

	CountAllMatching_1 = CountAllMatching;
	return CountAllMatching_1;
}

var Each_1;
var hasRequiredEach;

function requireEach () {
	if (hasRequiredEach) return Each_1;
	hasRequiredEach = 1;
	var Each = function (array, callback, context)
	{
	    var i;
	    var args = [ null ];

	    for (i = 3; i < arguments.length; i++)
	    {
	        args.push(arguments[i]);
	    }

	    for (i = 0; i < array.length; i++)
	    {
	        args[0] = array[i];

	        callback.apply(context, args);
	    }

	    return array;
	};

	Each_1 = Each;
	return Each_1;
}

var EachInRange_1;
var hasRequiredEachInRange;

function requireEachInRange () {
	if (hasRequiredEachInRange) return EachInRange_1;
	hasRequiredEachInRange = 1;
	var SafeRange = requireSafeRange();

	var EachInRange = function (array, callback, context, startIndex, endIndex)
	{
	    if (startIndex === undefined) { startIndex = 0; }
	    if (endIndex === undefined) { endIndex = array.length; }

	    if (SafeRange(array, startIndex, endIndex))
	    {
	        var i;
	        var args = [ null ];

	        for (i = 5; i < arguments.length; i++)
	        {
	            args.push(arguments[i]);
	        }

	        for (i = startIndex; i < endIndex; i++)
	        {
	            args[0] = array[i];

	            callback.apply(context, args);
	        }
	    }

	    return array;
	};

	EachInRange_1 = EachInRange;
	return EachInRange_1;
}

var FindClosestInSorted_1;
var hasRequiredFindClosestInSorted;

function requireFindClosestInSorted () {
	if (hasRequiredFindClosestInSorted) return FindClosestInSorted_1;
	hasRequiredFindClosestInSorted = 1;
	var FindClosestInSorted = function (value, array, key)
	{
	    if (!array.length)
	    {
	        return NaN;
	    }
	    else if (array.length === 1)
	    {
	        return array[0];
	    }

	    var i = 1;
	    var low;
	    var high;

	    if (key)
	    {
	        if (value < array[0][key])
	        {
	            return array[0];
	        }

	        while (array[i][key] < value)
	        {
	            i++;
	        }
	    }
	    else
	    {
	        while (array[i] < value)
	        {
	            i++;
	        }
	    }

	    if (i > array.length)
	    {
	        i = array.length;
	    }

	    if (key)
	    {
	        low = array[i - 1][key];
	        high = array[i][key];

	        return ((high - value) <= (value - low)) ? array[i] : array[i - 1];
	    }
	    else
	    {
	        low = array[i - 1];
	        high = array[i];

	        return ((high - value) <= (value - low)) ? high : low;
	    }
	};

	FindClosestInSorted_1 = FindClosestInSorted;
	return FindClosestInSorted_1;
}

var Flatten_1;
var hasRequiredFlatten;

function requireFlatten () {
	if (hasRequiredFlatten) return Flatten_1;
	hasRequiredFlatten = 1;
	var Flatten = function (array, output)
	{
	    if (output === undefined) { output = []; }

	    for (var i = 0; i < array.length; i++)
	    {
	        if (Array.isArray(array[i]))
	        {
	            Flatten(array[i], output);
	        }
	        else
	        {
	            output.push(array[i]);
	        }
	    }

	    return output;
	};

	Flatten_1 = Flatten;
	return Flatten_1;
}

var GetAll_1;
var hasRequiredGetAll;

function requireGetAll () {
	if (hasRequiredGetAll) return GetAll_1;
	hasRequiredGetAll = 1;
	var SafeRange = requireSafeRange();

	var GetAll = function (array, property, value, startIndex, endIndex)
	{
	    if (startIndex === undefined) { startIndex = 0; }
	    if (endIndex === undefined) { endIndex = array.length; }

	    var output = [];

	    if (SafeRange(array, startIndex, endIndex))
	    {
	        for (var i = startIndex; i < endIndex; i++)
	        {
	            var child = array[i];

	            if (!property ||
	                (property && value === undefined && child.hasOwnProperty(property)) ||
	                (property && value !== undefined && child[property] === value))
	            {
	                output.push(child);
	            }
	        }
	    }

	    return output;
	};

	GetAll_1 = GetAll;
	return GetAll_1;
}

var GetFirst_1;
var hasRequiredGetFirst;

function requireGetFirst () {
	if (hasRequiredGetFirst) return GetFirst_1;
	hasRequiredGetFirst = 1;
	var SafeRange = requireSafeRange();

	var GetFirst = function (array, property, value, startIndex, endIndex)
	{
	    if (startIndex === undefined) { startIndex = 0; }
	    if (endIndex === undefined) { endIndex = array.length; }

	    if (startIndex !== -1)
	    {
	        if (SafeRange(array, startIndex, endIndex))
	        {
	            for (var i = startIndex; i < endIndex; i++)
	            {
	                var child = array[i];

	                if (!property ||
	                    (property && value === undefined && child.hasOwnProperty(property)) ||
	                    (property && value !== undefined && child[property] === value))
	                {
	                    return child;
	                }
	            }
	        }
	    }
	    else
	    {
	        if (SafeRange(array, 0, endIndex))
	        {
	            for (var i = endIndex; i >= 0; i--)
	            {
	                var child = array[i];

	                if (!property ||
	                    (property && value === undefined && child.hasOwnProperty(property)) ||
	                    (property && value !== undefined && child[property] === value))
	                {
	                    return child;
	                }
	            }
	        }
	    }

	    return null;
	};

	GetFirst_1 = GetFirst;
	return GetFirst_1;
}

var GetRandom_1;
var hasRequiredGetRandom;

function requireGetRandom () {
	if (hasRequiredGetRandom) return GetRandom_1;
	hasRequiredGetRandom = 1;
	var GetRandom = function (array, startIndex, length)
	{
	    if (startIndex === undefined) { startIndex = 0; }
	    if (length === undefined) { length = array.length; }

	    var randomIndex = startIndex + Math.floor(Math.random() * length);

	    return (array[randomIndex] === undefined) ? null : array[randomIndex];
	};

	GetRandom_1 = GetRandom;
	return GetRandom_1;
}

var MoveDown_1;
var hasRequiredMoveDown;

function requireMoveDown () {
	if (hasRequiredMoveDown) return MoveDown_1;
	hasRequiredMoveDown = 1;
	var MoveDown = function (array, item)
	{
	    var currentIndex = array.indexOf(item);

	    if (currentIndex > 0)
	    {
	        var item2 = array[currentIndex - 1];

	        var index2 = array.indexOf(item2);

	        array[currentIndex] = item2;
	        array[index2] = item;
	    }

	    return array;
	};

	MoveDown_1 = MoveDown;
	return MoveDown_1;
}

var MoveTo_1$1;
var hasRequiredMoveTo$1;

function requireMoveTo$1 () {
	if (hasRequiredMoveTo$1) return MoveTo_1$1;
	hasRequiredMoveTo$1 = 1;
	var MoveTo = function (array, item, index)
	{
	    var currentIndex = array.indexOf(item);

	    if (currentIndex === -1 || index < 0 || index >= array.length)
	    {
	        throw new Error('Supplied index out of bounds');
	    }

	    if (currentIndex !== index)
	    {

	        array.splice(currentIndex, 1);

	        array.splice(index, 0, item);
	    }

	    return item;
	};

	MoveTo_1$1 = MoveTo;
	return MoveTo_1$1;
}

var MoveUp_1;
var hasRequiredMoveUp;

function requireMoveUp () {
	if (hasRequiredMoveUp) return MoveUp_1;
	hasRequiredMoveUp = 1;
	var MoveUp = function (array, item)
	{
	    var currentIndex = array.indexOf(item);

	    if (currentIndex !== -1 && currentIndex < array.length - 1)
	    {

	        var item2 = array[currentIndex + 1];
	        var index2 = array.indexOf(item2);

	        array[currentIndex] = item2;
	        array[index2] = item;
	    }

	    return array;
	};

	MoveUp_1 = MoveUp;
	return MoveUp_1;
}

var MoveAbove_1;
var hasRequiredMoveAbove;

function requireMoveAbove () {
	if (hasRequiredMoveAbove) return MoveAbove_1;
	hasRequiredMoveAbove = 1;
	var MoveAbove = function (array, item1, item2)
	{
	    if (item1 === item2)
	    {
	        return array;
	    }

	    var currentIndex = array.indexOf(item1);
	    var baseIndex = array.indexOf(item2);

	    if (currentIndex < 0 || baseIndex < 0)
	    {
	        throw new Error('Supplied items must be elements of the same array');
	    }

	    if (currentIndex > baseIndex)
	    {

	        return array;
	    }

	    array.splice(currentIndex, 1);

	    baseIndex = array.indexOf(item2);

	    array.splice(baseIndex + 1, 0, item1);

	    return array;
	};

	MoveAbove_1 = MoveAbove;
	return MoveAbove_1;
}

var MoveBelow_1;
var hasRequiredMoveBelow;

function requireMoveBelow () {
	if (hasRequiredMoveBelow) return MoveBelow_1;
	hasRequiredMoveBelow = 1;
	var MoveBelow = function (array, item1, item2)
	{
	    if (item1 === item2)
	    {
	        return array;
	    }

	    var currentIndex = array.indexOf(item1);
	    var baseIndex = array.indexOf(item2);

	    if (currentIndex < 0 || baseIndex < 0)
	    {
	        throw new Error('Supplied items must be elements of the same array');
	    }

	    if (currentIndex < baseIndex)
	    {

	        return array;
	    }

	    array.splice(currentIndex, 1);

	    if (baseIndex === 0)
	    {
	        array.unshift(item1);
	    }
	    else
	    {
	        array.splice(baseIndex, 0, item1);
	    }

	    return array;
	};

	MoveBelow_1 = MoveBelow;
	return MoveBelow_1;
}

var NumberArray_1;
var hasRequiredNumberArray;

function requireNumberArray () {
	if (hasRequiredNumberArray) return NumberArray_1;
	hasRequiredNumberArray = 1;
	var NumberArray = function (start, end, prefix, suffix)
	{
	    var result = [];

	    var i;
	    var asString = false;

	    if (prefix || suffix)
	    {
	        asString = true;

	        if (!prefix)
	        {
	            prefix = '';
	        }

	        if (!suffix)
	        {
	            suffix = '';
	        }
	    }

	    if (end < start)
	    {
	        for (i = start; i >= end; i--)
	        {
	            if (asString)
	            {
	                result.push(prefix + i.toString() + suffix);
	            }
	            else
	            {
	                result.push(i);
	            }
	        }
	    }
	    else
	    {
	        for (i = start; i <= end; i++)
	        {
	            if (asString)
	            {
	                result.push(prefix + i.toString() + suffix);
	            }
	            else
	            {
	                result.push(i);
	            }
	        }
	    }

	    return result;
	};

	NumberArray_1 = NumberArray;
	return NumberArray_1;
}

var RoundAwayFromZero_1;
var hasRequiredRoundAwayFromZero;

function requireRoundAwayFromZero () {
	if (hasRequiredRoundAwayFromZero) return RoundAwayFromZero_1;
	hasRequiredRoundAwayFromZero = 1;
	var RoundAwayFromZero = function (value)
	{

	    return (value > 0) ? Math.ceil(value) : Math.floor(value);
	};

	RoundAwayFromZero_1 = RoundAwayFromZero;
	return RoundAwayFromZero_1;
}

var NumberArrayStep_1;
var hasRequiredNumberArrayStep;

function requireNumberArrayStep () {
	if (hasRequiredNumberArrayStep) return NumberArrayStep_1;
	hasRequiredNumberArrayStep = 1;
	var RoundAwayFromZero = requireRoundAwayFromZero();

	var NumberArrayStep = function (start, end, step)
	{
	    if (start === undefined) { start = 0; }
	    if (end === undefined) { end = null; }
	    if (step === undefined) { step = 1; }

	    if (end === null)
	    {
	        end = start;
	        start = 0;
	    }

	    var result = [];

	    var total = Math.max(RoundAwayFromZero((end - start) / (step || 1)), 0);

	    for (var i = 0; i < total; i++)
	    {
	        result.push(start);
	        start += step;
	    }

	    return result;
	};

	NumberArrayStep_1 = NumberArrayStep;
	return NumberArrayStep_1;
}

var QuickSelect_1;
var hasRequiredQuickSelect;

function requireQuickSelect () {
	if (hasRequiredQuickSelect) return QuickSelect_1;
	hasRequiredQuickSelect = 1;
	function swap (arr, i, j)
	{
	    var tmp = arr[i];
	    arr[i] = arr[j];
	    arr[j] = tmp;
	}

	function defaultCompare (a, b)
	{
	    return a < b ? -1 : a > b ? 1 : 0;
	}

	var QuickSelect = function (arr, k, left, right, compare)
	{
	    if (left === undefined) { left = 0; }
	    if (right === undefined) { right = arr.length - 1; }
	    if (compare === undefined) { compare = defaultCompare; }

	    while (right > left)
	    {
	        if (right - left > 600)
	        {
	            var n = right - left + 1;
	            var m = k - left + 1;
	            var z = Math.log(n);
	            var s = 0.5 * Math.exp(2 * z / 3);
	            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
	            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
	            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));

	            QuickSelect(arr, k, newLeft, newRight, compare);
	        }

	        var t = arr[k];
	        var i = left;
	        var j = right;

	        swap(arr, left, k);

	        if (compare(arr[right], t) > 0)
	        {
	            swap(arr, left, right);
	        }

	        while (i < j)
	        {
	            swap(arr, i, j);

	            i++;
	            j--;

	            while (compare(arr[i], t) < 0)
	            {
	                i++;
	            }

	            while (compare(arr[j], t) > 0)
	            {
	                j--;
	            }
	        }

	        if (compare(arr[left], t) === 0)
	        {
	            swap(arr, left, j);
	        }
	        else
	        {
	            j++;
	            swap(arr, j, right);
	        }

	        if (j <= k)
	        {
	            left = j + 1;
	        }

	        if (k <= j)
	        {
	            right = j - 1;
	        }
	    }
	};

	QuickSelect_1 = QuickSelect;
	return QuickSelect_1;
}

var GetValue_1;
var hasRequiredGetValue;

function requireGetValue () {
	if (hasRequiredGetValue) return GetValue_1;
	hasRequiredGetValue = 1;
	var GetValue = function (source, key, defaultValue, altSource)
	{
	    if ((!source && !altSource) || typeof source === 'number')
	    {
	        return defaultValue;
	    }
	    else if (source && source.hasOwnProperty(key))
	    {
	        return source[key];
	    }
	    else if (altSource && altSource.hasOwnProperty(key))
	    {
	        return altSource[key];
	    }
	    else if (key.indexOf('.') !== -1)
	    {
	        var keys = key.split('.');
	        var parentA = source;
	        var parentB = altSource;
	        var valueA = defaultValue;
	        var valueB = defaultValue;
	        var valueAFound = true;
	        var valueBFound = true;

	        for (var i = 0; i < keys.length; i++)
	        {
	            if (parentA && parentA.hasOwnProperty(keys[i]))
	            {

	                valueA = parentA[keys[i]];
	                parentA = parentA[keys[i]];
	            }
	            else
	            {
	                valueAFound = false;
	            }

	            if (parentB && parentB.hasOwnProperty(keys[i]))
	            {

	                valueB = parentB[keys[i]];
	                parentB = parentB[keys[i]];
	            }
	            else
	            {
	                valueBFound = false;
	            }
	        }

	        if (valueAFound)
	        {
	            return valueA;
	        }
	        else if (valueBFound)
	        {
	            return valueB;
	        }
	        else
	        {
	            return defaultValue;
	        }
	    }
	    else
	    {
	        return defaultValue;
	    }
	};

	GetValue_1 = GetValue;
	return GetValue_1;
}

var Shuffle_1$2;
var hasRequiredShuffle$2;

function requireShuffle$2 () {
	if (hasRequiredShuffle$2) return Shuffle_1$2;
	hasRequiredShuffle$2 = 1;
	var Shuffle = function (array)
	{
	    for (var i = array.length - 1; i > 0; i--)
	    {
	        var j = Math.floor(Math.random() * (i + 1));
	        var temp = array[i];
	        array[i] = array[j];
	        array[j] = temp;
	    }

	    return array;
	};

	Shuffle_1$2 = Shuffle;
	return Shuffle_1$2;
}

var Range_1;
var hasRequiredRange;

function requireRange () {
	if (hasRequiredRange) return Range_1;
	hasRequiredRange = 1;
	var GetValue = requireGetValue();
	var Shuffle = requireShuffle$2();

	var BuildChunk = function (a, b, qty)
	{
	    var out = [];

	    for (var aIndex = 0; aIndex < a.length; aIndex++)
	    {
	        for (var bIndex = 0; bIndex < b.length; bIndex++)
	        {
	            for (var i = 0; i < qty; i++)
	            {
	                out.push({ a: a[aIndex], b: b[bIndex] });
	            }
	        }
	    }

	    return out;
	};

	var Range = function (a, b, options)
	{
	    var max = GetValue(options, 'max', 0);
	    var qty = GetValue(options, 'qty', 1);
	    var random = GetValue(options, 'random', false);
	    var randomB = GetValue(options, 'randomB', false);
	    var repeat = GetValue(options, 'repeat', 0);
	    var yoyo = GetValue(options, 'yoyo', false);

	    var out = [];

	    if (randomB)
	    {
	        Shuffle(b);
	    }

	    if (repeat === -1)
	    {
	        if (max === 0)
	        {
	            repeat = 0;
	        }
	        else
	        {

	            var total = (a.length * b.length) * qty;

	            if (yoyo)
	            {
	                total *= 2;
	            }

	            repeat = Math.ceil(max / total);
	        }
	    }

	    for (var i = 0; i <= repeat; i++)
	    {
	        var chunk = BuildChunk(a, b, qty);

	        if (random)
	        {
	            Shuffle(chunk);
	        }

	        out = out.concat(chunk);

	        if (yoyo)
	        {
	            chunk.reverse();

	            out = out.concat(chunk);
	        }
	    }

	    if (max)
	    {
	        out.splice(max);
	    }

	    return out;
	};

	Range_1 = Range;
	return Range_1;
}

var SpliceOne_1;
var hasRequiredSpliceOne;

function requireSpliceOne () {
	if (hasRequiredSpliceOne) return SpliceOne_1;
	hasRequiredSpliceOne = 1;
	var SpliceOne = function (array, index)
	{
	    if (index >= array.length)
	    {
	        return;
	    }

	    var len = array.length - 1;

	    var item = array[index];

	    for (var i = index; i < len; i++)
	    {
	        array[i] = array[i + 1];
	    }

	    array.length = len;

	    return item;
	};

	SpliceOne_1 = SpliceOne;
	return SpliceOne_1;
}

var Remove_1;
var hasRequiredRemove;

function requireRemove () {
	if (hasRequiredRemove) return Remove_1;
	hasRequiredRemove = 1;
	var SpliceOne = requireSpliceOne();

	var Remove = function (array, item, callback, context)
	{
	    if (context === undefined) { context = array; }

	    var index;

	    if (!Array.isArray(item))
	    {
	        index = array.indexOf(item);

	        if (index !== -1)
	        {
	            SpliceOne(array, index);

	            if (callback)
	            {
	                callback.call(context, item);
	            }

	            return item;
	        }
	        else
	        {
	            return null;
	        }
	    }

	    var itemLength = item.length - 1;
	    var removed = [];

	    while (itemLength >= 0)
	    {
	        var entry = item[itemLength];

	        index = array.indexOf(entry);

	        if (index !== -1)
	        {
	            SpliceOne(array, index);

	            removed.push(entry);

	            if (callback)
	            {
	                callback.call(context, entry);
	            }
	        }

	        itemLength--;
	    }

	    return removed;
	};

	Remove_1 = Remove;
	return Remove_1;
}

var RemoveAt_1$1;
var hasRequiredRemoveAt$1;

function requireRemoveAt$1 () {
	if (hasRequiredRemoveAt$1) return RemoveAt_1$1;
	hasRequiredRemoveAt$1 = 1;
	var SpliceOne = requireSpliceOne();

	var RemoveAt = function (array, index, callback, context)
	{
	    if (context === undefined) { context = array; }

	    if (index < 0 || index > array.length - 1)
	    {
	        throw new Error('Index out of bounds');
	    }

	    var item = SpliceOne(array, index);

	    if (callback)
	    {
	        callback.call(context, item);
	    }

	    return item;
	};

	RemoveAt_1$1 = RemoveAt;
	return RemoveAt_1$1;
}

var RemoveBetween_1;
var hasRequiredRemoveBetween;

function requireRemoveBetween () {
	if (hasRequiredRemoveBetween) return RemoveBetween_1;
	hasRequiredRemoveBetween = 1;
	var SafeRange = requireSafeRange();

	var RemoveBetween = function (array, startIndex, endIndex, callback, context)
	{
	    if (startIndex === undefined) { startIndex = 0; }
	    if (endIndex === undefined) { endIndex = array.length; }
	    if (context === undefined) { context = array; }

	    if (SafeRange(array, startIndex, endIndex))
	    {
	        var size = endIndex - startIndex;

	        var removed = array.splice(startIndex, size);

	        if (callback)
	        {
	            for (var i = 0; i < removed.length; i++)
	            {
	                var entry = removed[i];

	                callback.call(context, entry);
	            }
	        }

	        return removed;
	    }
	    else
	    {
	        return [];
	    }
	};

	RemoveBetween_1 = RemoveBetween;
	return RemoveBetween_1;
}

var RemoveRandomElement_1;
var hasRequiredRemoveRandomElement;

function requireRemoveRandomElement () {
	if (hasRequiredRemoveRandomElement) return RemoveRandomElement_1;
	hasRequiredRemoveRandomElement = 1;
	var SpliceOne = requireSpliceOne();

	var RemoveRandomElement = function (array, start, length)
	{
	    if (start === undefined) { start = 0; }
	    if (length === undefined) { length = array.length; }

	    var randomIndex = start + Math.floor(Math.random() * length);

	    return SpliceOne(array, randomIndex);
	};

	RemoveRandomElement_1 = RemoveRandomElement;
	return RemoveRandomElement_1;
}

var Replace_1;
var hasRequiredReplace;

function requireReplace () {
	if (hasRequiredReplace) return Replace_1;
	hasRequiredReplace = 1;
	var Replace = function (array, oldChild, newChild)
	{
	    var index1 = array.indexOf(oldChild);
	    var index2 = array.indexOf(newChild);

	    if (index1 !== -1 && index2 === -1)
	    {
	        array[index1] = newChild;

	        return true;
	    }
	    else
	    {
	        return false;
	    }
	};

	Replace_1 = Replace;
	return Replace_1;
}

var SendToBack_1;
var hasRequiredSendToBack;

function requireSendToBack () {
	if (hasRequiredSendToBack) return SendToBack_1;
	hasRequiredSendToBack = 1;
	var SendToBack = function (array, item)
	{
	    var currentIndex = array.indexOf(item);

	    if (currentIndex !== -1 && currentIndex > 0)
	    {
	        array.splice(currentIndex, 1);
	        array.unshift(item);
	    }

	    return item;
	};

	SendToBack_1 = SendToBack;
	return SendToBack_1;
}

var SetAll_1;
var hasRequiredSetAll;

function requireSetAll () {
	if (hasRequiredSetAll) return SetAll_1;
	hasRequiredSetAll = 1;
	var SafeRange = requireSafeRange();

	var SetAll = function (array, property, value, startIndex, endIndex)
	{
	    if (startIndex === undefined) { startIndex = 0; }
	    if (endIndex === undefined) { endIndex = array.length; }

	    if (SafeRange(array, startIndex, endIndex))
	    {
	        for (var i = startIndex; i < endIndex; i++)
	        {
	            var entry = array[i];

	            if (entry.hasOwnProperty(property))
	            {
	                entry[property] = value;
	            }
	        }
	    }

	    return array;
	};

	SetAll_1 = SetAll;
	return SetAll_1;
}

var SortByDigits_1;
var hasRequiredSortByDigits;

function requireSortByDigits () {
	if (hasRequiredSortByDigits) return SortByDigits_1;
	hasRequiredSortByDigits = 1;
	var SortByDigits = function (array)
	{
	    var re = /\D/g;

	    array.sort(function (a, b)
	    {
	        return (parseInt(a.replace(re, ''), 10) - parseInt(b.replace(re, ''), 10));
	    });

	    return array;
	};

	SortByDigits_1 = SortByDigits;
	return SortByDigits_1;
}

var OS_1;
var hasRequiredOS;

function requireOS () {
	if (hasRequiredOS) return OS_1;
	hasRequiredOS = 1;
	var OS = {

	    android: false,
	    chromeOS: false,
	    cordova: false,
	    crosswalk: false,
	    desktop: false,
	    ejecta: false,
	    electron: false,
	    iOS: false,
	    iOSVersion: 0,
	    iPad: false,
	    iPhone: false,
	    kindle: false,
	    linux: false,
	    macOS: false,
	    node: false,
	    nodeWebkit: false,
	    pixelRatio: 1,
	    webApp: false,
	    windows: false,
	    windowsPhone: false

	};

	function init ()
	{
	    if (typeof importScripts === 'function')
	    {
	        return OS;
	    }

	    var ua = navigator.userAgent;

	    if ((/Windows/).test(ua))
	    {
	        OS.windows = true;
	    }
	    else if ((/Mac OS/).test(ua) && !((/like Mac OS/).test(ua)))
	    {
	        //  Because iOS 13 identifies as Mac OS:
	        if (navigator.maxTouchPoints && navigator.maxTouchPoints > 2)
	        {
	            OS.iOS = true;
	            OS.iPad = true;

	            (navigator.appVersion).match(/Version\/(\d+)/);

	            OS.iOSVersion = parseInt(RegExp.$1, 10);
	        }
	        else
	        {
	            OS.macOS = true;
	        }
	    }
	    else if ((/Android/).test(ua))
	    {
	        OS.android = true;
	    }
	    else if ((/Linux/).test(ua))
	    {
	        OS.linux = true;
	    }
	    else if ((/iP[ao]d|iPhone/i).test(ua))
	    {
	        OS.iOS = true;

	        (navigator.appVersion).match(/OS (\d+)/);

	        OS.iOSVersion = parseInt(RegExp.$1, 10);

	        OS.iPhone = ua.toLowerCase().indexOf('iphone') !== -1;
	        OS.iPad = ua.toLowerCase().indexOf('ipad') !== -1;
	    }
	    else if ((/Kindle/).test(ua) || (/\bKF[A-Z][A-Z]+/).test(ua) || (/Silk.*Mobile Safari/).test(ua))
	    {
	        OS.kindle = true;

	        // This will NOT detect early generations of Kindle Fire, I think there is no reliable way...
	        // E.g. "Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_3; en-us; Silk/1.1.0-80) AppleWebKit/533.16 (KHTML, like Gecko) Version/5.0 Safari/533.16 Silk-Accelerated=true"
	    }
	    else if ((/CrOS/).test(ua))
	    {
	        OS.chromeOS = true;
	    }

	    if ((/Windows Phone/i).test(ua) || (/IEMobile/i).test(ua))
	    {
	        OS.android = false;
	        OS.iOS = false;
	        OS.macOS = false;
	        OS.windows = true;
	        OS.windowsPhone = true;
	    }

	    var silk = (/Silk/).test(ua);

	    if (OS.windows || OS.macOS || (OS.linux && !silk) || OS.chromeOS)
	    {
	        OS.desktop = true;
	    }

	    //  Windows Phone / Table reset
	    if (OS.windowsPhone || (((/Windows NT/i).test(ua)) && ((/Touch/i).test(ua))))
	    {
	        OS.desktop = false;
	    }

	    //  WebApp mode in iOS
	    if (navigator.standalone)
	    {
	        OS.webApp = true;
	    }

	    if (typeof importScripts !== 'function')
	    {
	        if (window.cordova !== undefined)
	        {
	            OS.cordova = true;
	        }

	        if (window.ejecta !== undefined)
	        {
	            OS.ejecta = true;
	        }
	    }

	    if (typeof process !== 'undefined' && process.versions && process.versions.node)
	    {
	        OS.node = true;
	    }

	    if (OS.node && typeof process.versions === 'object')
	    {
	        OS.nodeWebkit = !!process.versions['node-webkit'];

	        OS.electron = !!process.versions.electron;
	    }

	    if ((/Crosswalk/).test(ua))
	    {
	        OS.crosswalk = true;
	    }

	    OS.pixelRatio = window['devicePixelRatio'] || 1;

	    return OS;
	}

	OS_1 = init();
	return OS_1;
}

var Browser_1;
var hasRequiredBrowser;

function requireBrowser () {
	if (hasRequiredBrowser) return Browser_1;
	hasRequiredBrowser = 1;
	var OS = requireOS();


	var Browser = {

	    chrome: false,
	    chromeVersion: 0,
	    edge: false,
	    firefox: false,
	    firefoxVersion: 0,
	    ie: false,
	    ieVersion: 0,
	    mobileSafari: false,
	    opera: false,
	    safari: false,
	    safariVersion: 0,
	    silk: false,
	    trident: false,
	    tridentVersion: 0,
	    es2019: false

	};

	function init ()
	{
	    var ua = navigator.userAgent;

	    if ((/Edg\/\d+/).test(ua))
	    {
	        Browser.edge = true;
	        Browser.es2019 = true;
	    }
	    else if ((/OPR/).test(ua))
	    {
	        Browser.opera = true;
	        Browser.es2019 = true;
	    }
	    else if ((/Chrome\/(\d+)/).test(ua) && !OS.windowsPhone)
	    {
	        Browser.chrome = true;
	        Browser.chromeVersion = parseInt(RegExp.$1, 10);
	        Browser.es2019 = (Browser.chromeVersion > 69);
	    }
	    else if ((/Firefox\D+(\d+)/).test(ua))
	    {
	        Browser.firefox = true;
	        Browser.firefoxVersion = parseInt(RegExp.$1, 10);
	        Browser.es2019 = (Browser.firefoxVersion > 10);
	    }
	    else if ((/AppleWebKit\/(?!.*CriOS)/).test(ua) && OS.iOS)
	    {
	        Browser.mobileSafari = true;
	        Browser.es2019 = true;
	    }
	    else if ((/MSIE (\d+\.\d+);/).test(ua))
	    {
	        Browser.ie = true;
	        Browser.ieVersion = parseInt(RegExp.$1, 10);
	    }
	    else if ((/Version\/(\d+\.\d+(\.\d+)?) Safari/).test(ua) && !OS.windowsPhone)
	    {
	        Browser.safari = true;
	        Browser.safariVersion = parseInt(RegExp.$1, 10);
	        Browser.es2019 = (Browser.safariVersion > 10);
	    }
	    else if ((/Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/).test(ua))
	    {
	        Browser.ie = true;
	        Browser.trident = true;
	        Browser.tridentVersion = parseInt(RegExp.$1, 10);
	        Browser.ieVersion = parseInt(RegExp.$3, 10);
	    }

	    //  Silk gets its own if clause because its ua also contains 'Safari'
	    if ((/Silk/).test(ua))
	    {
	        Browser.silk = true;
	    }

	    return Browser;
	}

	Browser_1 = init();
	return Browser_1;
}

var Smoothing_1;
var hasRequiredSmoothing;

function requireSmoothing () {
	if (hasRequiredSmoothing) return Smoothing_1;
	hasRequiredSmoothing = 1;
	var prefix = '';

	var Smoothing = function ()
	{

	    var getPrefix = function (context)
	    {
	        var vendors = [ 'i', 'webkitI', 'msI', 'mozI', 'oI' ];

	        for (var i = 0; i < vendors.length; i++)
	        {
	            var s = vendors[i] + 'mageSmoothingEnabled';

	            if (s in context)
	            {
	                return s;
	            }
	        }

	        return null;
	    };

	    var enable = function (context)
	    {
	        if (prefix === '')
	        {
	            prefix = getPrefix(context);
	        }

	        if (prefix)
	        {
	            context[prefix] = true;
	        }

	        return context;
	    };

	    var disable = function (context)
	    {
	        if (prefix === '')
	        {
	            prefix = getPrefix(context);
	        }

	        if (prefix)
	        {
	            context[prefix] = false;
	        }

	        return context;
	    };

	    var isEnabled = function (context)
	    {
	        return (prefix !== null) ? context[prefix] : null;
	    };

	    return {
	        disable: disable,
	        enable: enable,
	        getPrefix: getPrefix,
	        isEnabled: isEnabled
	    };

	};

	Smoothing_1 = Smoothing();
	return Smoothing_1;
}

var CanvasPool_1;
var hasRequiredCanvasPool;

function requireCanvasPool () {
	if (hasRequiredCanvasPool) return CanvasPool_1;
	hasRequiredCanvasPool = 1;
	var CONST = require_const$f();
	var Smoothing = requireSmoothing();

	var pool = [];

	var _disableContextSmoothing = false;

	var CanvasPool = function ()
	{

	    var create = function (parent, width, height, canvasType, selfParent)
	    {
	        if (width === undefined) { width = 1; }
	        if (height === undefined) { height = 1; }
	        if (canvasType === undefined) { canvasType = CONST.CANVAS; }
	        if (selfParent === undefined) { selfParent = false; }

	        var canvas;
	        var container = first(canvasType);

	        if (container === null)
	        {
	            container = {
	                parent: parent,
	                canvas: document.createElement('canvas'),
	                type: canvasType
	            };

	            if (canvasType === CONST.CANVAS)
	            {
	                pool.push(container);
	            }

	            canvas = container.canvas;
	        }
	        else
	        {
	            container.parent = parent;

	            canvas = container.canvas;
	        }

	        if (selfParent)
	        {
	            container.parent = canvas;
	        }

	        canvas.width = width;
	        canvas.height = height;

	        if (_disableContextSmoothing && canvasType === CONST.CANVAS)
	        {
	            Smoothing.disable(canvas.getContext('2d', { willReadFrequently: false }));
	        }

	        return canvas;
	    };

	    var create2D = function (parent, width, height)
	    {
	        return create(parent, width, height, CONST.CANVAS);
	    };

	    var createWebGL = function (parent, width, height)
	    {
	        return create(parent, width, height, CONST.WEBGL);
	    };

	    var first = function (canvasType)
	    {
	        if (canvasType === undefined) { canvasType = CONST.CANVAS; }

	        if (canvasType === CONST.WEBGL)
	        {
	            return null;
	        }

	        for (var i = 0; i < pool.length; i++)
	        {
	            var container = pool[i];

	            if (!container.parent && container.type === canvasType)
	            {
	                return container;
	            }
	        }

	        return null;
	    };

	    var remove = function (parent)
	    {

	        var isCanvas = parent instanceof HTMLCanvasElement;

	        pool.forEach(function (container)
	        {
	            if ((isCanvas && container.canvas === parent) || (!isCanvas && container.parent === parent))
	            {
	                container.parent = null;
	                container.canvas.width = 1;
	                container.canvas.height = 1;
	            }
	        });
	    };

	    var total = function ()
	    {
	        var c = 0;

	        pool.forEach(function (container)
	        {
	            if (container.parent)
	            {
	                c++;
	            }
	        });

	        return c;
	    };

	    var free = function ()
	    {
	        return pool.length - total();
	    };

	    var disableSmoothing = function ()
	    {
	        _disableContextSmoothing = true;
	    };

	    var enableSmoothing = function ()
	    {
	        _disableContextSmoothing = false;
	    };

	    return {
	        create2D: create2D,
	        create: create,
	        createWebGL: createWebGL,
	        disableSmoothing: disableSmoothing,
	        enableSmoothing: enableSmoothing,
	        first: first,
	        free: free,
	        pool: pool,
	        remove: remove,
	        total: total
	    };
	};

	CanvasPool_1 = CanvasPool();
	return CanvasPool_1;
}

var Features_1;
var hasRequiredFeatures;

function requireFeatures () {
	if (hasRequiredFeatures) return Features_1;
	hasRequiredFeatures = 1;
	var OS = requireOS();
	var Browser = requireBrowser();
	var CanvasPool = requireCanvasPool();


	var Features = {

	    canvas: false,
	    canvasBitBltShift: null,
	    file: false,
	    fileSystem: false,
	    getUserMedia: true,
	    littleEndian: false,
	    localStorage: false,
	    pointerLock: false,
	    stableSort: false,
	    support32bit: false,
	    vibration: false,
	    webGL: false,
	    worker: false

	};

	// Check Little or Big Endian system.
	// @author Matt DesLauriers (@mattdesl)
	function checkIsLittleEndian ()
	{
	    var a = new ArrayBuffer(4);
	    var b = new Uint8Array(a);
	    var c = new Uint32Array(a);

	    b[0] = 0xa1;
	    b[1] = 0xb2;
	    b[2] = 0xc3;
	    b[3] = 0xd4;

	    if (c[0] === 0xd4c3b2a1)
	    {
	        return true;
	    }

	    if (c[0] === 0xa1b2c3d4)
	    {
	        return false;
	    }
	    else
	    {
	        //  Could not determine endianness
	        return null;
	    }
	}

	function init ()
	{
	    if (typeof importScripts === 'function')
	    {
	        return Features;
	    }

	    Features.canvas = !!window['CanvasRenderingContext2D'];

	    try
	    {
	        Features.localStorage = !!localStorage.getItem;
	    }
	    catch (error)
	    {
	        Features.localStorage = false;
	    }

	    Features.file = !!window['File'] && !!window['FileReader'] && !!window['FileList'] && !!window['Blob'];
	    Features.fileSystem = !!window['requestFileSystem'];

	    var isUint8 = false;

	    var testWebGL = function ()
	    {
	        if (window['WebGLRenderingContext'])
	        {
	            try
	            {
	                var canvas = CanvasPool.createWebGL(this);

	                var ctx = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

	                var canvas2D = CanvasPool.create2D(this);

	                var ctx2D = canvas2D.getContext('2d', { willReadFrequently: true });

	                //  Can't be done on a webgl context
	                var image = ctx2D.createImageData(1, 1);

	                //  Test to see if ImageData uses CanvasPixelArray or Uint8ClampedArray.
	                //  @author Matt DesLauriers (@mattdesl)
	                isUint8 = image.data instanceof Uint8ClampedArray;

	                CanvasPool.remove(canvas);
	                CanvasPool.remove(canvas2D);

	                return !!ctx;
	            }
	            catch (e)
	            {
	                return false;
	            }
	        }

	        return false;
	    };

	    Features.webGL = testWebGL();

	    Features.worker = !!window['Worker'];

	    Features.pointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;

	    navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia;

	    window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL;

	    Features.getUserMedia = Features.getUserMedia && !!navigator.getUserMedia && !!window.URL;

	    // Older versions of firefox (< 21) apparently claim support but user media does not actually work
	    if (Browser.firefox && Browser.firefoxVersion < 21)
	    {
	        Features.getUserMedia = false;
	    }

	    // Excludes iOS versions as they generally wrap UIWebView (eg. Safari WebKit) and it
	    // is safer to not try and use the fast copy-over method.
	    if (!OS.iOS && (Browser.ie || Browser.firefox || Browser.chrome))
	    {
	        Features.canvasBitBltShift = true;
	    }

	    // Known not to work
	    if (Browser.safari || Browser.mobileSafari)
	    {
	        Features.canvasBitBltShift = false;
	    }

	    navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate;

	    if (navigator.vibrate)
	    {
	        Features.vibration = true;
	    }

	    if (typeof ArrayBuffer !== 'undefined' && typeof Uint8Array !== 'undefined' && typeof Uint32Array !== 'undefined')
	    {
	        Features.littleEndian = checkIsLittleEndian();
	    }

	    Features.support32bit = (
	        typeof ArrayBuffer !== 'undefined' &&
	        typeof Uint8ClampedArray !== 'undefined' &&
	        typeof Int32Array !== 'undefined' &&
	        Features.littleEndian !== null &&
	        isUint8
	    );

	    return Features;
	}

	Features_1 = init();
	return Features_1;
}

var Input_1;
var hasRequiredInput$1;

function requireInput$1 () {
	if (hasRequiredInput$1) return Input_1;
	hasRequiredInput$1 = 1;
	var Browser = requireBrowser();


	var Input = {

	    gamepads: false,
	    mspointer: false,
	    touch: false,
	    wheelEvent: null

	};

	function init ()
	{
	    if (typeof importScripts === 'function')
	    {
	        return Input;
	    }

	    if ('ontouchstart' in document.documentElement || (navigator.maxTouchPoints && navigator.maxTouchPoints >= 1))
	    {
	        Input.touch = true;
	    }

	    if (navigator.msPointerEnabled || navigator.pointerEnabled)
	    {
	        Input.mspointer = true;
	    }

	    if (navigator.getGamepads)
	    {
	        Input.gamepads = true;
	    }

	    // See https://developer.mozilla.org/en-US/docs/Web/Events/wheel
	    if ('onwheel' in window || (Browser.ie && 'WheelEvent' in window))
	    {
	        // DOM3 Wheel Event: FF 17+, IE 9+, Chrome 31+, Safari 7+
	        Input.wheelEvent = 'wheel';
	    }
	    else if ('onmousewheel' in window)
	    {
	        // Non-FF legacy: IE 6-9, Chrome 1-31, Safari 5-7.
	        Input.wheelEvent = 'mousewheel';
	    }
	    else if (Browser.firefox && 'MouseScrollEvent' in window)
	    {
	        // FF prior to 17. This should probably be scrubbed.
	        Input.wheelEvent = 'DOMMouseScroll';
	    }

	    return Input;
	}

	Input_1 = init();
	return Input_1;
}

var Audio_1;
var hasRequiredAudio;

function requireAudio () {
	if (hasRequiredAudio) return Audio_1;
	hasRequiredAudio = 1;
	var Browser = requireBrowser();


	var Audio = {

	    flac: false,
	    aac: false,
	    audioData: false,
	    dolby: false,
	    m4a: false,
	    mp3: false,
	    ogg: false,
	    opus: false,
	    wav: false,
	    webAudio: false,
	    webm: false

	};

	function init ()
	{
	    if (typeof importScripts === 'function')
	    {
	        return Audio;
	    }

	    Audio.audioData = !!(window['Audio']);

	    Audio.webAudio = !!(window['AudioContext'] || window['webkitAudioContext']);

	    var audioElement = document.createElement('audio');
	    var result = !!audioElement.canPlayType;

	    try
	    {
	        if (result)
	        {
	            var CanPlay = function (type1, type2)
	            {
	                var canPlayType1 = audioElement.canPlayType('audio/' + type1).replace(/^no$/, '');

	                if (type2)
	                {
	                    return Boolean(canPlayType1 || audioElement.canPlayType('audio/' + type2).replace(/^no$/, ''));
	                }
	                else
	                {
	                    return Boolean(canPlayType1);
	                }
	            };

	            //  wav Mimetypes accepted:
	            //  developer.mozilla.org/En/Media_formats_supported_by_the_audio_and_video_elements

	            Audio.ogg = CanPlay('ogg; codecs="vorbis"');
	            Audio.opus = CanPlay('ogg; codecs="opus"', 'opus');
	            Audio.mp3 = CanPlay('mpeg');
	            Audio.wav = CanPlay('wav');
	            Audio.m4a = CanPlay('x-m4a');
	            Audio.aac = CanPlay('aac');
	            Audio.flac = CanPlay('flac', 'x-flac');
	            Audio.webm = CanPlay('webm; codecs="vorbis"');

	            if (audioElement.canPlayType('audio/mp4; codecs="ec-3"') !== '')
	            {
	                if (Browser.edge)
	                {
	                    Audio.dolby = true;
	                }
	                else if (Browser.safari && Browser.safariVersion >= 9)
	                {
	                    if ((/Mac OS X (\d+)_(\d+)/).test(navigator.userAgent))
	                    {
	                        var major = parseInt(RegExp.$1, 10);
	                        var minor = parseInt(RegExp.$2, 10);

	                        if ((major === 10 && minor >= 11) || major > 10)
	                        {
	                            Audio.dolby = true;
	                        }
	                    }
	                }
	            }
	        }
	    }
	    catch (e)
	    {
	        //  Nothing to do here
	    }

	    return Audio;
	}

	Audio_1 = init();
	return Audio_1;
}

var Video_1$1;
var hasRequiredVideo$1;

function requireVideo$1 () {
	if (hasRequiredVideo$1) return Video_1$1;
	hasRequiredVideo$1 = 1;
	var GetFastValue = requireGetFastValue();


	var Video = {

	    h264: false,
	    hls: false,
	    mp4: false,
	    m4v: false,
	    ogg: false,
	    vp9: false,
	    webm: false,
	    hasRequestVideoFrame: false

	};

	function init ()
	{
	    if (typeof importScripts === 'function')
	    {
	        return Video;
	    }

	    var videoElement = document.createElement('video');
	    var result = !!videoElement.canPlayType;
	    var no = /^no$/;

	    try
	    {
	        if (result)
	        {
	            if (videoElement.canPlayType('video/ogg; codecs="theora"').replace(no, ''))
	            {
	                Video.ogg = true;
	            }

	            if (videoElement.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(no, ''))
	            {
	                // Without QuickTime, this value will be `undefined`. github.com/Modernizr/Modernizr/issues/546
	                Video.h264 = true;
	                Video.mp4 = true;
	            }

	            if (videoElement.canPlayType('video/x-m4v').replace(no, ''))
	            {
	                Video.m4v = true;
	            }

	            if (videoElement.canPlayType('video/webm; codecs="vp8, vorbis"').replace(no, ''))
	            {
	                Video.webm = true;
	            }

	            if (videoElement.canPlayType('video/webm; codecs="vp9"').replace(no, ''))
	            {
	                Video.vp9 = true;
	            }

	            if (videoElement.canPlayType('application/x-mpegURL; codecs="avc1.42E01E"').replace(no, ''))
	            {
	                Video.hls = true;
	            }
	        }
	    }
	    catch (e)
	    {
	        //  Nothing to do
	    }

	    if (videoElement.parentNode)
	    {
	        videoElement.parentNode.removeChild(videoElement);
	    }

	    Video.getVideoURL = function (urls)
	    {
	        if (!Array.isArray(urls))
	        {
	            urls = [ urls ];
	        }

	        for (var i = 0; i < urls.length; i++)
	        {
	            var url = GetFastValue(urls[i], 'url', urls[i]);

	            if (url.indexOf('blob:') === 0)
	            {
	                return {
	                    url: url,
	                    type: ''
	                };
	            }

	            var videoType;

	            if (url.indexOf('data:') === 0)
	            {
	                videoType = url.split(',')[0].match(/\/(.*?);/);
	            }
	            else
	            {
	                videoType = url.match(/\.([a-zA-Z0-9]+)($|\?)/);
	            }

	            videoType = GetFastValue(urls[i], 'type', (videoType) ? videoType[1] : '').toLowerCase();

	            if (Video[videoType])
	            {
	                return {
	                    url: url,
	                    type: videoType
	                };
	            }
	        }

	        return null;
	    };

	    return Video;
	}

	Video_1$1 = init();
	return Video_1$1;
}

var Fullscreen_1;
var hasRequiredFullscreen;

function requireFullscreen () {
	if (hasRequiredFullscreen) return Fullscreen_1;
	hasRequiredFullscreen = 1;
	var Fullscreen = {

	    available: false,
	    cancel: '',
	    keyboard: false,
	    request: ''

	};


	function init ()
	{
	    if (typeof importScripts === 'function')
	    {
	        return Fullscreen;
	    }

	    var i;

	    var suffix1 = 'Fullscreen';
	    var suffix2 = 'FullScreen';

	    var fs = [
	        'request' + suffix1,
	        'request' + suffix2,
	        'webkitRequest' + suffix1,
	        'webkitRequest' + suffix2,
	        'msRequest' + suffix1,
	        'msRequest' + suffix2,
	        'mozRequest' + suffix2,
	        'mozRequest' + suffix1
	    ];

	    for (i = 0; i < fs.length; i++)
	    {
	        if (document.documentElement[fs[i]])
	        {
	            Fullscreen.available = true;
	            Fullscreen.request = fs[i];
	            break;
	        }
	    }

	    var cfs = [
	        'cancel' + suffix2,
	        'exit' + suffix1,
	        'webkitCancel' + suffix2,
	        'webkitExit' + suffix1,
	        'msCancel' + suffix2,
	        'msExit' + suffix1,
	        'mozCancel' + suffix2,
	        'mozExit' + suffix1
	    ];

	    if (Fullscreen.available)
	    {
	        for (i = 0; i < cfs.length; i++)
	        {
	            if (document[cfs[i]])
	            {
	                Fullscreen.cancel = cfs[i];
	                break;
	            }
	        }
	    }

	    //  Keyboard Input?
	    //  Safari 5.1 says it supports fullscreen keyboard, but is lying.
	    if (window['Element'] && Element['ALLOW_KEYBOARD_INPUT'] && !(/ Version\/5\.1(?:\.\d+)? Safari\//).test(navigator.userAgent))
	    {
	        Fullscreen.keyboard = true;
	    }

	    Object.defineProperty(Fullscreen, 'active', { get: function () { return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement); } });

	    return Fullscreen;
	}

	Fullscreen_1 = init();
	return Fullscreen_1;
}

var CanvasFeatures_1;
var hasRequiredCanvasFeatures;

function requireCanvasFeatures () {
	if (hasRequiredCanvasFeatures) return CanvasFeatures_1;
	hasRequiredCanvasFeatures = 1;
	var CanvasPool = requireCanvasPool();


	var CanvasFeatures = {

	    supportInverseAlpha: false,
	    supportNewBlendModes: false

	};

	function checkBlendMode ()
	{
	    var pngHead = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX/';
	    var pngEnd = 'AAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==';

	    var magenta = new Image();

	    magenta.onload = function ()
	    {
	        var yellow = new Image();

	        yellow.onload = function ()
	        {
	            var canvas = CanvasPool.create2D(yellow, 6);
	            var context = canvas.getContext('2d', { willReadFrequently: true });

	            context.globalCompositeOperation = 'multiply';

	            context.drawImage(magenta, 0, 0);
	            context.drawImage(yellow, 2, 0);

	            if (!context.getImageData(2, 0, 1, 1))
	            {
	                return false;
	            }

	            var data = context.getImageData(2, 0, 1, 1).data;

	            CanvasPool.remove(yellow);

	            CanvasFeatures.supportNewBlendModes = (data[0] === 255 && data[1] === 0 && data[2] === 0);
	        };

	        yellow.src = pngHead + '/wCKxvRF' + pngEnd;
	    };

	    magenta.src = pngHead + 'AP804Oa6' + pngEnd;

	    return false;
	}

	function checkInverseAlpha ()
	{
	    var canvas = CanvasPool.create2D(this, 2);
	    var context = canvas.getContext('2d', { willReadFrequently: true });

	    context.fillStyle = 'rgba(10, 20, 30, 0.5)';

	    //  Draw a single pixel
	    context.fillRect(0, 0, 1, 1);

	    //  Get the color values
	    var s1 = context.getImageData(0, 0, 1, 1);

	    if (s1 === null)
	    {
	        return false;
	    }

	    //  Plot them to x2
	    context.putImageData(s1, 1, 0);

	    //  Get those values
	    var s2 = context.getImageData(1, 0, 1, 1);

	    var result = (s2.data[0] === s1.data[0] && s2.data[1] === s1.data[1] && s2.data[2] === s1.data[2] && s2.data[3] === s1.data[3]);

	    CanvasPool.remove(this);

	    //  Compare and return
	    return result;
	}

	function init ()
	{
	    if (typeof importScripts !== 'function' && document !== undefined)
	    {
	        CanvasFeatures.supportNewBlendModes = checkBlendMode();
	        CanvasFeatures.supportInverseAlpha = checkInverseAlpha();
	    }

	    return CanvasFeatures;
	}

	CanvasFeatures_1 = init();
	return CanvasFeatures_1;
}

var device;
var hasRequiredDevice;

function requireDevice () {
	if (hasRequiredDevice) return device;
	hasRequiredDevice = 1;
	device = {

	    os: requireOS(),
	    browser: requireBrowser(),
	    features: requireFeatures(),
	    input: requireInput$1(),
	    audio: requireAudio(),
	    video: requireVideo$1(),
	    fullscreen: requireFullscreen(),
	    canvasFeatures: requireCanvasFeatures()

	};
	return device;
}

var StableSort_1;
var hasRequiredStableSort;

function requireStableSort () {
	if (hasRequiredStableSort) return StableSort_1;
	hasRequiredStableSort = 1;
	var Device = requireDevice();

	function Compare (a, b)
	{
	    return String(a).localeCompare(b);
	}

	function Process (array, compare)
	{

	    var len = array.length;

	    if (len <= 1)
	    {
	        return array;
	    }

	    var buffer = new Array(len);

	    for (var chk = 1; chk < len; chk *= 2)
	    {
	        RunPass(array, compare, chk, buffer);

	        var tmp = array;

	        array = buffer;

	        buffer = tmp;
	    }

	    return array;
	}

	function RunPass (arr, comp, chk, result)
	{
	    var len = arr.length;
	    var i = 0;

	    var dbl = chk * 2;

	    var l, r, e;

	    var li, ri;

	    for (l = 0; l < len; l += dbl)
	    {
	        r = l + chk;
	        e = r + chk;

	        if (r > len)
	        {
	            r = len;
	        }

	        if (e > len)
	        {
	            e = len;
	        }

	        li = l;
	        ri = r;

	        while (true)
	        {

	            if (li < r && ri < e)
	            {

	                if (comp(arr[li], arr[ri]) <= 0)
	                {
	                    result[i++] = arr[li++];
	                }
	                else
	                {
	                    result[i++] = arr[ri++];
	                }
	            }
	            else if (li < r)
	            {

	                result[i++] = arr[li++];
	            }
	            else if (ri < e)
	            {
	                result[i++] = arr[ri++];
	            }
	            else
	            {

	                break;
	            }
	        }
	    }
	}

	var StableSort = function (array, compare)
	{
	    if (compare === undefined) { compare = Compare; }

	    if (!array || array.length < 2)
	    {
	        return array;
	    }

	    if (Device.features.stableSort)
	    {
	        return array.sort(compare);
	    }

	    var result = Process(array, compare);

	    if (result !== array)
	    {
	        RunPass(result, null, array.length, array);
	    }

	    return array;
	};

	StableSort_1 = StableSort;
	return StableSort_1;
}

var Swap_1;
var hasRequiredSwap;

function requireSwap () {
	if (hasRequiredSwap) return Swap_1;
	hasRequiredSwap = 1;
	var Swap = function (array, item1, item2)
	{
	    if (item1 === item2)
	    {
	        return array;
	    }

	    var index1 = array.indexOf(item1);
	    var index2 = array.indexOf(item2);

	    if (index1 < 0 || index2 < 0)
	    {
	        throw new Error('Supplied items must be elements of the same array');
	    }

	    array[index1] = item2;
	    array[index2] = item1;

	    return array;
	};

	Swap_1 = Swap;
	return Swap_1;
}

var array;
var hasRequiredArray;

function requireArray () {
	if (hasRequiredArray) return array;
	hasRequiredArray = 1;
	array = {

	    Matrix: requireMatrix(),

	    Add: requireAdd(),
	    AddAt: requireAddAt(),
	    BringToTop: requireBringToTop(),
	    CountAllMatching: requireCountAllMatching(),
	    Each: requireEach(),
	    EachInRange: requireEachInRange(),
	    FindClosestInSorted: requireFindClosestInSorted(),
	    Flatten: requireFlatten(),
	    GetAll: requireGetAll(),
	    GetFirst: requireGetFirst(),
	    GetRandom: requireGetRandom(),
	    MoveDown: requireMoveDown(),
	    MoveTo: requireMoveTo$1(),
	    MoveUp: requireMoveUp(),
	    MoveAbove: requireMoveAbove(),
	    MoveBelow: requireMoveBelow(),
	    NumberArray: requireNumberArray(),
	    NumberArrayStep: requireNumberArrayStep(),
	    QuickSelect: requireQuickSelect(),
	    Range: requireRange(),
	    Remove: requireRemove(),
	    RemoveAt: requireRemoveAt$1(),
	    RemoveBetween: requireRemoveBetween(),
	    RemoveRandomElement: requireRemoveRandomElement(),
	    Replace: requireReplace(),
	    RotateLeft: requireRotateLeft(),
	    RotateRight: requireRotateRight(),
	    SafeRange: requireSafeRange(),
	    SendToBack: requireSendToBack(),
	    SetAll: requireSetAll(),
	    Shuffle: requireShuffle$2(),
	    SortByDigits: requireSortByDigits(),
	    SpliceOne: requireSpliceOne(),
	    StableSort: requireStableSort(),
	    Swap: requireSwap()

	};
	return array;
}

var Depth_1;
var hasRequiredDepth;

function requireDepth () {
	if (hasRequiredDepth) return Depth_1;
	hasRequiredDepth = 1;
	var ArrayUtils = requireArray();

	var Depth = {

	    _depth: 0,

	    depth: {

	        get: function ()
	        {
	            return this._depth;
	        },

	        set: function (value)
	        {
	            if (this.displayList)
	            {
	                this.displayList.queueDepthSort();
	            }

	            this._depth = value;
	        }

	    },

	    setDepth: function (value)
	    {
	        if (value === undefined) { value = 0; }

	        this.depth = value;

	        return this;
	    },

	    setToTop: function ()
	    {
	        var list = this.getDisplayList();

	        if (list)
	        {
	            ArrayUtils.BringToTop(list, this);
	        }

	        return this;
	    },

	    setToBack: function ()
	    {
	        var list = this.getDisplayList();

	        if (list)
	        {
	            ArrayUtils.SendToBack(list, this);
	        }

	        return this;
	    },

	    setAbove: function (gameObject)
	    {
	        var list = this.getDisplayList();

	        if (list && gameObject)
	        {
	            ArrayUtils.MoveAbove(list, this, gameObject);
	        }

	        return this;
	    },

	    setBelow: function (gameObject)
	    {
	        var list = this.getDisplayList();

	        if (list && gameObject)
	        {
	            ArrayUtils.MoveBelow(list, this, gameObject);
	        }

	        return this;
	    }

	};

	Depth_1 = Depth;
	return Depth_1;
}

var Flip_1;
var hasRequiredFlip;

function requireFlip () {
	if (hasRequiredFlip) return Flip_1;
	hasRequiredFlip = 1;
	var Flip = {

	    flipX: false,

	    flipY: false,

	    toggleFlipX: function ()
	    {
	        this.flipX = !this.flipX;

	        return this;
	    },

	    toggleFlipY: function ()
	    {
	        this.flipY = !this.flipY;

	        return this;
	    },

	    setFlipX: function (value)
	    {
	        this.flipX = value;

	        return this;
	    },

	    setFlipY: function (value)
	    {
	        this.flipY = value;

	        return this;
	    },

	    setFlip: function (x, y)
	    {
	        this.flipX = x;
	        this.flipY = y;

	        return this;
	    },

	    resetFlip: function ()
	    {
	        this.flipX = false;
	        this.flipY = false;

	        return this;
	    }

	};

	Flip_1 = Flip;
	return Flip_1;
}

var _const$b;
var hasRequired_const$b;

function require_const$b () {
	if (hasRequired_const$b) return _const$b;
	hasRequired_const$b = 1;
	var FX_CONST = {

	    GLOW: 4,

	    SHADOW: 5,

	    PIXELATE: 6,

	    VIGNETTE: 7,

	    SHINE: 8,

	    BLUR: 9, 

	    GRADIENT: 12,

	    BLOOM: 13,

	    COLOR_MATRIX: 14,

	    CIRCLE: 15,

	    BARREL: 16,

	    DISPLACEMENT: 17,

	    WIPE: 18,

	    BOKEH: 19

	};

	_const$b = FX_CONST;
	return _const$b;
}

var Controller_1;
var hasRequiredController;

function requireController () {
	if (hasRequiredController) return Controller_1;
	hasRequiredController = 1;
	var Class = requireClass();

	var Controller = new Class({

	    initialize:

	    function Controller (type, gameObject)
	    {

	        this.type = type;

	        this.gameObject = gameObject;

	        this.active = true;
	    },

	    setActive: function (value)
	    {
	        this.active = value;

	        return this;
	    },

	    destroy: function ()
	    {
	        this.gameObject = null;
	        this.active = false;
	    }

	});

	Controller_1 = Controller;
	return Controller_1;
}

var Barrel_1;
var hasRequiredBarrel;

function requireBarrel () {
	if (hasRequiredBarrel) return Barrel_1;
	hasRequiredBarrel = 1;
	var Class = requireClass();
	var Controller = requireController();
	var FX_CONST = require_const$b();

	var Barrel = new Class({

	    Extends: Controller,

	    initialize:

	    function Barrel (gameObject, amount)
	    {
	        if (amount === undefined) { amount = 1; }

	        Controller.call(this, FX_CONST.BARREL, gameObject);

	        this.amount = amount;
	    }

	});

	Barrel_1 = Barrel;
	return Barrel_1;
}

var Bloom_1;
var hasRequiredBloom;

function requireBloom () {
	if (hasRequiredBloom) return Bloom_1;
	hasRequiredBloom = 1;
	var Class = requireClass();
	var Controller = requireController();
	var FX_CONST = require_const$b();

	var Bloom = new Class({

	    Extends: Controller,

	    initialize:

	    function Bloom (gameObject, color, offsetX, offsetY, blurStrength, strength, steps)
	    {
	        if (offsetX === undefined) { offsetX = 1; }
	        if (offsetY === undefined) { offsetY = 1; }
	        if (blurStrength === undefined) { blurStrength = 1; }
	        if (strength === undefined) { strength = 1; }
	        if (steps === undefined) { steps = 4; }

	        Controller.call(this, FX_CONST.BLOOM, gameObject);

	        this.steps = steps;

	        this.offsetX = offsetX;

	        this.offsetY = offsetY;

	        this.blurStrength = blurStrength;

	        this.strength = strength;

	        this.glcolor = [ 1, 1, 1 ];

	        if (color !== undefined && color !== null)
	        {
	            this.color = color;
	        }
	    },

	    color: {

	        get: function ()
	        {
	            var color = this.glcolor;

	            return (((color[0] * 255) << 16) + ((color[1] * 255) << 8) + (color[2] * 255 | 0));
	        },

	        set: function (value)
	        {
	            var color = this.glcolor;

	            color[0] = ((value >> 16) & 0xFF) / 255;
	            color[1] = ((value >> 8) & 0xFF) / 255;
	            color[2] = (value & 0xFF) / 255;
	        }

	    }

	});

	Bloom_1 = Bloom;
	return Bloom_1;
}

var Blur_1;
var hasRequiredBlur;

function requireBlur () {
	if (hasRequiredBlur) return Blur_1;
	hasRequiredBlur = 1;
	var Class = requireClass();
	var Controller = requireController();
	var FX_CONST = require_const$b();

	var Blur = new Class({

	    Extends: Controller,

	    initialize:

	    function Blur (gameObject, quality, x, y, strength, color, steps)
	    {
	        if (quality === undefined) { quality = 0; }
	        if (x === undefined) { x = 2; }
	        if (y === undefined) { y = 2; }
	        if (strength === undefined) { strength = 1; }
	        if (steps === undefined) { steps = 4; }

	        Controller.call(this, FX_CONST.BLUR, gameObject);

	        this.quality = quality;

	        this.x = x;

	        this.y = y;

	        this.steps = steps;

	        this.strength = strength;

	        this.glcolor = [ 1, 1, 1 ];

	        if (color !== undefined && color !== null)
	        {
	            this.color = color;
	        }
	    },

	    color: {

	        get: function ()
	        {
	            var color = this.glcolor;

	            return (((color[0] * 255) << 16) + ((color[1] * 255) << 8) + (color[2] * 255 | 0));
	        },

	        set: function (value)
	        {
	            var color = this.glcolor;

	            color[0] = ((value >> 16) & 0xFF) / 255;
	            color[1] = ((value >> 8) & 0xFF) / 255;
	            color[2] = (value & 0xFF) / 255;
	        }

	    }

	});

	Blur_1 = Blur;
	return Blur_1;
}

var Bokeh_1;
var hasRequiredBokeh;

function requireBokeh () {
	if (hasRequiredBokeh) return Bokeh_1;
	hasRequiredBokeh = 1;
	var Class = requireClass();
	var Controller = requireController();
	var FX_CONST = require_const$b();

	var Bokeh = new Class({

	    Extends: Controller,

	    initialize:

	    function Bokeh (gameObject, radius, amount, contrast, isTiltShift, blurX, blurY, strength)
	    {
	        if (radius === undefined) { radius = 0.5; }
	        if (amount === undefined) { amount = 1; }
	        if (contrast === undefined) { contrast = 0.2; }
	        if (isTiltShift === undefined) { isTiltShift = false; }
	        if (blurX === undefined) { blurX = 1; }
	        if (blurY === undefined) { blurY = 1; }
	        if (strength === undefined) { strength = 1; }

	        Controller.call(this, FX_CONST.BOKEH, gameObject);

	        this.radius = radius;

	        this.amount = amount;

	        this.contrast = contrast;

	        this.isTiltShift = isTiltShift;

	        this.strength = strength;

	        this.blurX = blurX;

	        this.blurY = blurY;
	    }

	});

	Bokeh_1 = Bokeh;
	return Bokeh_1;
}

var Circle_1;
var hasRequiredCircle$1;

function requireCircle$1 () {
	if (hasRequiredCircle$1) return Circle_1;
	hasRequiredCircle$1 = 1;
	var Class = requireClass();
	var Controller = requireController();
	var FX_CONST = require_const$b();

	var Circle = new Class({

	    Extends: Controller,

	    initialize:

	    function Circle (gameObject, thickness, color, backgroundColor, scale, feather)
	    {
	        if (thickness === undefined) { thickness = 8; }
	        if (scale === undefined) { scale = 1; }
	        if (feather === undefined) { feather = 0.005; }

	        Controller.call(this, FX_CONST.CIRCLE, gameObject);

	        this.scale = scale;

	        this.feather = feather;

	        this.thickness = thickness;

	        this.glcolor = [ 1, 0.2, 0.7 ];

	        this.glcolor2 = [ 1, 0, 0, 0.4 ];

	        if (color !== undefined && color !== null)
	        {
	            this.color = color;
	        }

	        if (backgroundColor !== undefined && backgroundColor !== null)
	        {
	            this.backgroundColor = backgroundColor;
	        }
	    },

	    color: {

	        get: function ()
	        {
	            var color = this.glcolor;

	            return (((color[0] * 255) << 16) + ((color[1] * 255) << 8) + (color[2] * 255 | 0));
	        },

	        set: function (value)
	        {
	            var color = this.glcolor;

	            color[0] = ((value >> 16) & 0xFF) / 255;
	            color[1] = ((value >> 8) & 0xFF) / 255;
	            color[2] = (value & 0xFF) / 255;
	        }

	    },

	    backgroundColor: {

	        get: function ()
	        {
	            var color = this.glcolor2;

	            return (((color[0] * 255) << 16) + ((color[1] * 255) << 8) + (color[2] * 255 | 0));
	        },

	        set: function (value)
	        {
	            var color = this.glcolor2;

	            color[0] = ((value >> 16) & 0xFF) / 255;
	            color[1] = ((value >> 8) & 0xFF) / 255;
	            color[2] = (value & 0xFF) / 255;
	        }

	    },

	    backgroundAlpha: {

	        get: function ()
	        {
	            return this.glcolor2[3];
	        },

	        set: function (value)
	        {
	            this.glcolor2[3] = value;
	        }

	    }
	});

	Circle_1 = Circle;
	return Circle_1;
}

var ColorMatrix_1$1;
var hasRequiredColorMatrix$1;

function requireColorMatrix$1 () {
	if (hasRequiredColorMatrix$1) return ColorMatrix_1$1;
	hasRequiredColorMatrix$1 = 1;
	var Class = requireClass();

	var tempMatrix = new Float32Array(20);

	var ColorMatrix = new Class({

	    initialize:

	    function ColorMatrix ()
	    {

	        this._matrix = new Float32Array(20);

	        this.alpha = 1;

	        this._dirty = true;

	        this._data = new Float32Array(20);

	        this.reset();
	    },

	    set: function (value)
	    {
	        this._matrix.set(value);

	        this._dirty = true;

	        return this;
	    },

	    reset: function ()
	    {
	        var m = this._matrix;

	        m.fill(0);

	        m[0] = 1;
	        m[6] = 1;
	        m[12] = 1;
	        m[18] = 1;

	        this.alpha = 1;

	        this._dirty = true;

	        return this;
	    },

	    getData: function ()
	    {
	        var data = this._data;

	        if (this._dirty)
	        {
	            data.set(this._matrix);

	            data[4] /= 255;
	            data[9] /= 255;
	            data[14] /= 255;
	            data[19] /= 255;

	            this._dirty = false;
	        }

	        return data;
	    },

	    brightness: function (value, multiply)
	    {
	        if (value === undefined) { value = 0; }
	        if (multiply === undefined) { multiply = false; }

	        var b = value;

	        return this.multiply([
	            b, 0, 0, 0, 0,
	            0, b, 0, 0, 0,
	            0, 0, b, 0, 0,
	            0, 0, 0, 1, 0
	        ], multiply);
	    },

	    saturate: function (value, multiply)
	    {
	        if (value === undefined) { value = 0; }
	        if (multiply === undefined) { multiply = false; }

	        var x = (value * 2 / 3) + 1;
	        var y = ((x - 1) * -0.5);

	        return this.multiply([
	            x, y, y, 0, 0,
	            y, x, y, 0, 0,
	            y, y, x, 0, 0,
	            0, 0, 0, 1, 0
	        ], multiply);
	    },

	    desaturate: function (multiply)
	    {
	        if (multiply === undefined) { multiply = false; }

	        return this.saturate(-1, multiply);
	    },

	    hue: function (rotation, multiply)
	    {
	        if (rotation === undefined) { rotation = 0; }
	        if (multiply === undefined) { multiply = false; }

	        rotation = rotation / 180 * Math.PI;

	        var cos = Math.cos(rotation);
	        var sin = Math.sin(rotation);
	        var lumR = 0.213;
	        var lumG = 0.715;
	        var lumB = 0.072;

	        return this.multiply([
	            lumR + cos * (1 - lumR) + sin * (-lumR),lumG + cos * (-lumG) + sin * (-lumG),lumB + cos * (-lumB) + sin * (1 - lumB), 0, 0,
	            lumR + cos * (-lumR) + sin * (0.143),lumG + cos * (1 - lumG) + sin * (0.140),lumB + cos * (-lumB) + sin * (-0.283), 0, 0,
	            lumR + cos * (-lumR) + sin * (-(1 - lumR)),lumG + cos * (-lumG) + sin * (lumG),lumB + cos * (1 - lumB) + sin * (lumB), 0, 0,
	            0, 0, 0, 1, 0
	        ], multiply);
	    },

	    grayscale: function (value, multiply)
	    {
	        if (value === undefined) { value = 1; }
	        if (multiply === undefined) { multiply = false; }

	        return this.saturate(-value, multiply);
	    },

	    blackWhite: function (multiply)
	    {
	        if (multiply === undefined) { multiply = false; }

	        return this.multiply(ColorMatrix.BLACK_WHITE, multiply);
	    },

	    contrast: function (value, multiply)
	    {
	        if (value === undefined) { value = 0; }
	        if (multiply === undefined) { multiply = false; }

	        var v = value + 1;
	        var o = -0.5 * (v - 1);

	        return this.multiply([
	            v, 0, 0, 0, o,
	            0, v, 0, 0, o,
	            0, 0, v, 0, o,
	            0, 0, 0, 1, 0
	        ], multiply);
	    },

	    negative: function (multiply)
	    {
	        if (multiply === undefined) { multiply = false; }

	        return this.multiply(ColorMatrix.NEGATIVE, multiply);
	    },

	    desaturateLuminance: function (multiply)
	    {
	        if (multiply === undefined) { multiply = false; }

	        return this.multiply(ColorMatrix.DESATURATE_LUMINANCE, multiply);
	    },

	    sepia: function (multiply)
	    {
	        if (multiply === undefined) { multiply = false; }

	        return this.multiply(ColorMatrix.SEPIA, multiply);
	    },

	    night: function (intensity, multiply)
	    {
	        if (intensity === undefined) { intensity = 0.1; }
	        if (multiply === undefined) { multiply = false; }

	        return this.multiply([
	            intensity * (-2.0), -intensity, 0, 0, 0,
	            -intensity, 0, intensity, 0, 0,
	            0, intensity, intensity * 2.0, 0, 0,
	            0, 0, 0, 1, 0
	        ], multiply);
	    },

	    lsd: function (multiply)
	    {
	        if (multiply === undefined) { multiply = false; }

	        return this.multiply(ColorMatrix.LSD, multiply);
	    },

	    brown: function (multiply)
	    {
	        if (multiply === undefined) { multiply = false; }

	        return this.multiply(ColorMatrix.BROWN, multiply);
	    },

	    vintagePinhole: function (multiply)
	    {
	        if (multiply === undefined) { multiply = false; }

	        return this.multiply(ColorMatrix.VINTAGE, multiply);
	    },

	    kodachrome: function (multiply)
	    {
	        if (multiply === undefined) { multiply = false; }

	        return this.multiply(ColorMatrix.KODACHROME, multiply);
	    },

	    technicolor: function (multiply)
	    {
	        if (multiply === undefined) { multiply = false; }

	        return this.multiply(ColorMatrix.TECHNICOLOR, multiply);
	    },

	    polaroid: function (multiply)
	    {
	        if (multiply === undefined) { multiply = false; }

	        return this.multiply(ColorMatrix.POLAROID, multiply);
	    },

	    shiftToBGR: function (multiply)
	    {
	        if (multiply === undefined) { multiply = false; }

	        return this.multiply(ColorMatrix.SHIFT_BGR, multiply);
	    },

	    multiply: function (a, multiply)
	    {
	        if (multiply === undefined) { multiply = false; }

	        if (!multiply)
	        {
	            this.reset();
	        }

	        var m = this._matrix;
	        var c = tempMatrix;

	        c.set(m);

	        m.set([

	            (c[0] * a[0]) + (c[1] * a[5]) + (c[2] * a[10]) + (c[3] * a[15]),
	            (c[0] * a[1]) + (c[1] * a[6]) + (c[2] * a[11]) + (c[3] * a[16]),
	            (c[0] * a[2]) + (c[1] * a[7]) + (c[2] * a[12]) + (c[3] * a[17]),
	            (c[0] * a[3]) + (c[1] * a[8]) + (c[2] * a[13]) + (c[3] * a[18]),
	            (c[0] * a[4]) + (c[1] * a[9]) + (c[2] * a[14]) + (c[3] * a[19]) + c[4],

	            (c[5] * a[0]) + (c[6] * a[5]) + (c[7] * a[10]) + (c[8] * a[15]),
	            (c[5] * a[1]) + (c[6] * a[6]) + (c[7] * a[11]) + (c[8] * a[16]),
	            (c[5] * a[2]) + (c[6] * a[7]) + (c[7] * a[12]) + (c[8] * a[17]),
	            (c[5] * a[3]) + (c[6] * a[8]) + (c[7] * a[13]) + (c[8] * a[18]),
	            (c[5] * a[4]) + (c[6] * a[9]) + (c[7] * a[14]) + (c[8] * a[19]) + c[9],

	            (c[10] * a[0]) + (c[11] * a[5]) + (c[12] * a[10]) + (c[13] * a[15]),
	            (c[10] * a[1]) + (c[11] * a[6]) + (c[12] * a[11]) + (c[13] * a[16]),
	            (c[10] * a[2]) + (c[11] * a[7]) + (c[12] * a[12]) + (c[13] * a[17]),
	            (c[10] * a[3]) + (c[11] * a[8]) + (c[12] * a[13]) + (c[13] * a[18]),
	            (c[10] * a[4]) + (c[11] * a[9]) + (c[12] * a[14]) + (c[13] * a[19]) + c[14],

	            (c[15] * a[0]) + (c[16] * a[5]) + (c[17] * a[10]) + (c[18] * a[15]),
	            (c[15] * a[1]) + (c[16] * a[6]) + (c[17] * a[11]) + (c[18] * a[16]),
	            (c[15] * a[2]) + (c[16] * a[7]) + (c[17] * a[12]) + (c[18] * a[17]),
	            (c[15] * a[3]) + (c[16] * a[8]) + (c[17] * a[13]) + (c[18] * a[18]),
	            (c[15] * a[4]) + (c[16] * a[9]) + (c[17] * a[14]) + (c[18] * a[19]) + c[19]

	        ]);

	        this._dirty = true;

	        return this;
	    }

	});

	ColorMatrix.BLACK_WHITE = [ 0.3, 0.6, 0.1, 0, 0, 0.3, 0.6, 0.1, 0, 0, 0.3, 0.6, 0.1, 0, 0, 0, 0, 0, 1, 0 ];

	ColorMatrix.NEGATIVE = [ -1, 0, 0, 1, 0, 0, -1, 0, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0 ];

	ColorMatrix.DESATURATE_LUMINANCE = [ 0.2764723, 0.9297080, 0.0938197, 0, -37.1, 0.2764723, 0.9297080, 0.0938197, 0, -37.1, 0.2764723, 0.9297080, 0.0938197, 0, -37.1, 0, 0, 0, 1, 0 ];

	ColorMatrix.SEPIA = [ 0.393, 0.7689999, 0.18899999, 0, 0, 0.349, 0.6859999, 0.16799999, 0, 0, 0.272, 0.5339999, 0.13099999, 0, 0, 0, 0, 0, 1, 0 ];

	ColorMatrix.LSD = [ 2, -0.4, 0.5, 0, 0, -0.5, 2, -0.4, 0, 0, -0.4, -0.5, 3, 0, 0, 0, 0, 0, 1, 0 ];

	ColorMatrix.BROWN = [ 0.5997023498159715, 0.34553243048391263, -0.2708298674538042, 0, 47.43192855600873, -0.037703249837783157, 0.8609577587992641, 0.15059552388459913, 0, -36.96841498319127, 0.24113635128153335, -0.07441037908422492, 0.44972182064877153, 0, -7.562075277591283, 0, 0, 0, 1, 0 ];

	ColorMatrix.VINTAGE = [ 0.6279345635605994, 0.3202183420819367, -0.03965408211312453, 0, 9.651285835294123, 0.02578397704808868, 0.6441188644374771, 0.03259127616149294, 0, 7.462829176470591, 0.0466055556782719, -0.0851232987247891, 0.5241648018700465, 0, 5.159190588235296, 0, 0, 0, 1, 0 ];

	ColorMatrix.KODACHROME = [ 1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0, 63.72958762196502, -0.16404339962244616, 1.0835251566291304, -0.05498805115633132, 0, 24.732407896706203, -0.16786010706155763, -0.5603416277695248, 1.6014850761964943, 0, 35.62982807460946, 0, 0, 0, 1, 0 ];

	ColorMatrix.TECHNICOLOR = [ 1.9125277891456083, -0.8545344976951645, -0.09155508482755585, 0, 11.793603434377337, -0.3087833385928097, 1.7658908555458428, -0.10601743074722245, 0, -70.35205161461398, -0.231103377548616, -0.7501899197440212, 1.847597816108189, 0, 30.950940869491138, 0, 0, 0, 1, 0 ];

	ColorMatrix.POLAROID = [ 1.438, -0.062, -0.062, 0, 0, -0.122, 1.378, -0.122, 0, 0, -0.016, -0.016, 1.483, 0, 0, 0, 0, 0, 1, 0 ];

	ColorMatrix.SHIFT_BGR = [ 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0 ];

	ColorMatrix_1$1 = ColorMatrix;
	return ColorMatrix_1$1;
}

var ColorMatrix_1;
var hasRequiredColorMatrix;

function requireColorMatrix () {
	if (hasRequiredColorMatrix) return ColorMatrix_1;
	hasRequiredColorMatrix = 1;
	var Class = requireClass();
	var BaseColorMatrix = requireColorMatrix$1();
	var FX_CONST = require_const$b();

	var ColorMatrix = new Class({

	    Extends: BaseColorMatrix,

	    initialize:

	    function ColorMatrix (gameObject)
	    {
	        BaseColorMatrix.call(this);

	        this.type = FX_CONST.COLOR_MATRIX;

	        this.gameObject = gameObject;

	        this.active = true;
	    },

	    destroy: function ()
	    {
	        this.gameObject = null;
	        this._matrix = null;
	        this._data = null;
	    }

	});

	ColorMatrix_1 = ColorMatrix;
	return ColorMatrix_1;
}

var Displacement_1;
var hasRequiredDisplacement;

function requireDisplacement () {
	if (hasRequiredDisplacement) return Displacement_1;
	hasRequiredDisplacement = 1;
	var Class = requireClass();
	var Controller = requireController();
	var FX_CONST = require_const$b();

	var Displacement = new Class({

	    Extends: Controller,

	    initialize:

	    function Displacement (gameObject, texture, x, y)
	    {
	        if (texture === undefined) { texture = '__WHITE'; }
	        if (x === undefined) { x = 0.005; }
	        if (y === undefined) { y = 0.005; }

	        Controller.call(this, FX_CONST.DISPLACEMENT, gameObject);

	        this.x = x;

	        this.y = y;

	        this.glTexture;

	        this.setTexture(texture);
	    },

	    setTexture: function (texture)
	    {
	        var hawkTexture = this.gameObject.scene.sys.textures.getFrame(texture);

	        if (hawkTexture)
	        {
	            this.glTexture = hawkTexture.glTexture;
	        }

	        return this;
	    }

	});

	Displacement_1 = Displacement;
	return Displacement_1;
}

var Glow_1;
var hasRequiredGlow;

function requireGlow () {
	if (hasRequiredGlow) return Glow_1;
	hasRequiredGlow = 1;
	var Class = requireClass();
	var Controller = requireController();
	var FX_CONST = require_const$b();

	var Glow = new Class({

	    Extends: Controller,

	    initialize:

	    function Glow (gameObject, color, outerStrength, innerStrength, knockout)
	    {
	        if (outerStrength === undefined) { outerStrength = 4; }
	        if (innerStrength === undefined) { innerStrength = 0; }
	        if (knockout === undefined) { knockout = false; }

	        Controller.call(this, FX_CONST.GLOW, gameObject);

	        this.outerStrength = outerStrength;

	        this.innerStrength = innerStrength;

	        this.knockout = knockout;

	        this.glcolor = [ 1, 1, 1, 1 ];

	        if (color !== undefined)
	        {
	            this.color = color;
	        }
	    },

	    color: {

	        get: function ()
	        {
	            var color = this.glcolor;

	            return (((color[0] * 255) << 16) + ((color[1] * 255) << 8) + (color[2] * 255 | 0));
	        },

	        set: function (value)
	        {
	            var color = this.glcolor;

	            color[0] = ((value >> 16) & 0xFF) / 255;
	            color[1] = ((value >> 8) & 0xFF) / 255;
	            color[2] = (value & 0xFF) / 255;
	        }

	    }

	});

	Glow_1 = Glow;
	return Glow_1;
}

var Gradient_1;
var hasRequiredGradient;

function requireGradient () {
	if (hasRequiredGradient) return Gradient_1;
	hasRequiredGradient = 1;
	var Class = requireClass();
	var Controller = requireController();
	var FX_CONST = require_const$b();

	var Gradient = new Class({

	    Extends: Controller,

	    initialize:

	    function Gradient (gameObject, color1, color2, alpha, fromX, fromY, toX, toY, size)
	    {
	        if (alpha === undefined) { alpha = 0.2; }
	        if (fromX === undefined) { fromX = 0; }
	        if (fromY === undefined) { fromY = 0; }
	        if (toX === undefined) { toX = 0; }
	        if (toY === undefined) { toY = 1; }
	        if (size === undefined) { size = 0; }

	        Controller.call(this, FX_CONST.GRADIENT, gameObject);

	        this.alpha = alpha;

	        this.size = size;

	        this.fromX = fromX;

	        this.fromY = fromY;

	        this.toX = toX;

	        this.toY = toY;

	        this.glcolor1 = [ 255, 0, 0 ];

	        this.glcolor2 = [ 0, 255, 0 ];

	        if (color1 !== undefined && color1 !== null)
	        {
	            this.color1 = color1;
	        }

	        if (color2 !== undefined && color2 !== null)
	        {
	            this.color2 = color2;
	        }
	    },

	    color1: {

	        get: function ()
	        {
	            var color = this.glcolor1;

	            return (((color[0]) << 16) + ((color[1]) << 8) + (color[2] | 0));
	        },

	        set: function (value)
	        {
	            var color = this.glcolor1;

	            color[0] = ((value >> 16) & 0xFF);
	            color[1] = ((value >> 8) & 0xFF);
	            color[2] = (value & 0xFF);
	        }

	    },

	    color2: {

	        get: function ()
	        {
	            var color = this.glcolor2;

	            return (((color[0]) << 16) + ((color[1]) << 8) + (color[2] | 0));
	        },

	        set: function (value)
	        {
	            var color = this.glcolor2;

	            color[0] = ((value >> 16) & 0xFF);
	            color[1] = ((value >> 8) & 0xFF);
	            color[2] = (value & 0xFF);
	        }

	    }

	});

	Gradient_1 = Gradient;
	return Gradient_1;
}

var Pixelate_1;
var hasRequiredPixelate;

function requirePixelate () {
	if (hasRequiredPixelate) return Pixelate_1;
	hasRequiredPixelate = 1;
	var Class = requireClass();
	var Controller = requireController();
	var FX_CONST = require_const$b();

	var Pixelate = new Class({

	    Extends: Controller,

	    initialize:

	    function Pixelate (gameObject, amount)
	    {
	        if (amount === undefined) { amount = 1; }

	        Controller.call(this, FX_CONST.PIXELATE, gameObject);

	        this.amount = amount;
	    }

	});

	Pixelate_1 = Pixelate;
	return Pixelate_1;
}

var Shadow_1;
var hasRequiredShadow;

function requireShadow () {
	if (hasRequiredShadow) return Shadow_1;
	hasRequiredShadow = 1;
	var Class = requireClass();
	var Controller = requireController();
	var FX_CONST = require_const$b();

	var Shadow = new Class({

	    Extends: Controller,

	    initialize:

	    function Shadow (gameObject, x, y, decay, power, color, samples, intensity)
	    {
	        if (x === undefined) { x = 0; }
	        if (y === undefined) { y = 0; }
	        if (decay === undefined) { decay = 0.1; }
	        if (power === undefined) { power = 1; }
	        if (samples === undefined) { samples = 6; }
	        if (intensity === undefined) { intensity = 1; }

	        Controller.call(this, FX_CONST.SHADOW, gameObject);

	        this.x = x;

	        this.y = y;

	        this.decay = decay;

	        this.power = power;

	        this.glcolor = [ 0, 0, 0, 1 ];

	        this.samples = samples;

	        this.intensity = intensity;

	        if (color !== undefined)
	        {
	            this.color = color;
	        }
	    },

	    color: {

	        get: function ()
	        {
	            var color = this.glcolor;

	            return (((color[0] * 255) << 16) + ((color[1] * 255) << 8) + (color[2] * 255 | 0));
	        },

	        set: function (value)
	        {
	            var color = this.glcolor;

	            color[0] = ((value >> 16) & 0xFF) / 255;
	            color[1] = ((value >> 8) & 0xFF) / 255;
	            color[2] = (value & 0xFF) / 255;
	        }

	    }

	});

	Shadow_1 = Shadow;
	return Shadow_1;
}

var Shine_1;
var hasRequiredShine;

function requireShine () {
	if (hasRequiredShine) return Shine_1;
	hasRequiredShine = 1;
	var Class = requireClass();
	var Controller = requireController();
	var FX_CONST = require_const$b();

	var Shine = new Class({

	    Extends: Controller,

	    initialize:

	    function Shine (gameObject, speed, lineWidth, gradient, reveal)
	    {
	        if (speed === undefined) { speed = 0.5; }
	        if (lineWidth === undefined) { lineWidth = 0.5; }
	        if (gradient === undefined) { gradient = 3; }
	        if (reveal === undefined) { reveal = false; }

	        Controller.call(this, FX_CONST.SHINE, gameObject);

	        this.speed = speed;

	        this.lineWidth = lineWidth;

	        this.gradient = gradient;

	        this.reveal = reveal;
	    }

	});

	Shine_1 = Shine;
	return Shine_1;
}

var Vignette_1;
var hasRequiredVignette;

function requireVignette () {
	if (hasRequiredVignette) return Vignette_1;
	hasRequiredVignette = 1;
	var Class = requireClass();
	var Controller = requireController();
	var FX_CONST = require_const$b();

	var Vignette = new Class({

	    Extends: Controller,

	    initialize:

	    function Vignette (gameObject, x, y, radius, strength)
	    {
	        if (x === undefined) { x = 0.5; }
	        if (y === undefined) { y = 0.5; }
	        if (radius === undefined) { radius = 0.5; }
	        if (strength === undefined) { strength = 0.5; }

	        Controller.call(this, FX_CONST.VIGNETTE, gameObject);

	        this.x = x;

	        this.y = y;

	        this.radius = radius;

	        this.strength = strength;
	    }

	});

	Vignette_1 = Vignette;
	return Vignette_1;
}

var Wipe_1;
var hasRequiredWipe;

function requireWipe () {
	if (hasRequiredWipe) return Wipe_1;
	hasRequiredWipe = 1;
	var Class = requireClass();
	var Controller = requireController();
	var FX_CONST = require_const$b();

	var Wipe = new Class({

	    Extends: Controller,

	    initialize:

	    function Wipe (gameObject, wipeWidth, direction, axis, reveal)
	    {
	        if (wipeWidth === undefined) { wipeWidth = 0.1; }
	        if (direction === undefined) { direction = 0; }
	        if (axis === undefined) { axis = 0; }
	        if (reveal === undefined) { reveal = false; }

	        Controller.call(this, FX_CONST.WIPE, gameObject);

	        this.progress = 0;

	        this.wipeWidth = wipeWidth;

	        this.direction = direction;

	        this.axis = axis;

	        this.reveal = reveal;
	    }

	});

	Wipe_1 = Wipe;
	return Wipe_1;
}

var fx$1;
var hasRequiredFx$1;

function requireFx$1 () {
	if (hasRequiredFx$1) return fx$1;
	hasRequiredFx$1 = 1;
	var Extend = requireExtend$1();
	var FX_CONST = require_const$b();

	var FX = {

	    Barrel: requireBarrel(),
	    Controller: requireController(),
	    Bloom: requireBloom(),
	    Blur: requireBlur(),
	    Bokeh: requireBokeh(),
	    Circle: requireCircle$1(),
	    ColorMatrix: requireColorMatrix(),
	    Displacement: requireDisplacement(),
	    Glow: requireGlow(),
	    Gradient: requireGradient(),
	    Pixelate: requirePixelate(),
	    Shadow: requireShadow(),
	    Shine: requireShine(),
	    Vignette: requireVignette(),
	    Wipe: requireWipe()

	};

	FX = Extend(false, FX, FX_CONST);

	fx$1 = FX;
	return fx$1;
}

var FX_1;
var hasRequiredFX;

function requireFX () {
	if (hasRequiredFX) return FX_1;
	hasRequiredFX = 1;
	var Class = requireClass();
	var Effects = requireFx$1();
	var SpliceOne = requireSpliceOne();

	var FX = new Class({

	    initialize:

	    function FX (gameObject, isPost)
	    {

	        this.gameObject = gameObject;

	        this.isPost = isPost;

	        this.enabled = false;

	        this.list = [];

	        this.padding = 0;
	    },

	    setPadding: function (padding)
	    {
	        if (padding === undefined) { padding = 0; }

	        this.padding = padding;

	        return this.gameObject;
	    },

	    onFXCopy: function ()
	    {
	    },

	    onFX: function ()
	    {
	    },

	    enable: function (padding)
	    {
	        if (this.isPost)
	        {
	            return;
	        }

	        var renderer = this.gameObject.scene.sys.renderer;

	        if (renderer && renderer.pipelines)
	        {
	            this.gameObject.pipeline = renderer.pipelines.FX_PIPELINE;

	            if (padding !== undefined)
	            {
	                this.padding = padding;
	            }

	            this.enabled = true;
	        }
	        else
	        {
	            this.enabled = false;
	        }
	    },

	    clear: function ()
	    {
	        if (this.isPost)
	        {
	            this.gameObject.resetPostPipeline(true);
	        }
	        else
	        {
	            var list = this.list;

	            for (var i = 0; i < list.length; i++)
	            {
	                list[i].destroy();
	            }

	            this.list = [];
	        }

	        this.enabled = false;

	        return this.gameObject;
	    },

	    remove: function (fx)
	    {
	        var i;

	        if (this.isPost)
	        {
	            var pipelines = this.gameObject.getPostPipeline(String(fx.type));

	            if (!Array.isArray(pipelines))
	            {
	                pipelines = [ pipelines ];
	            }

	            for (i = 0; i < pipelines.length; i++)
	            {
	                var pipeline = pipelines[i];

	                if (pipeline.controller === fx)
	                {
	                    this.gameObject.removePostPipeline(pipeline);

	                    fx.destroy();

	                    break;
	                }
	            }
	        }
	        else
	        {
	            var list = this.list;

	            for (i = 0; i < list.length; i++)
	            {
	                if (list[i] === fx)
	                {
	                    SpliceOne(list, i);

	                    fx.destroy();
	                }
	            }
	        }

	        return this.gameObject;
	    },

	    disable: function (clear)
	    {
	        if (clear === undefined) { clear = false; }

	        if (!this.isPost)
	        {
	            this.gameObject.resetPipeline();
	        }

	        this.enabled = false;

	        if (clear)
	        {
	            this.clear();
	        }

	        return this.gameObject;
	    },

	    add: function (fx, config)
	    {
	        if (this.isPost)
	        {
	            var type = String(fx.type);

	            this.gameObject.setPostPipeline(type, config);

	            var pipeline = this.gameObject.getPostPipeline(type);

	            if (pipeline)
	            {
	                if (Array.isArray(pipeline))
	                {
	                    pipeline = pipeline.pop();
	                }

	                if (pipeline)
	                {
	                    pipeline.controller = fx;
	                }

	                return fx;
	            }
	        }
	        else
	        {
	            if (!this.enabled)
	            {
	                this.enable();
	            }

	            this.list.push(fx);

	            return fx;
	        }
	    },

	    addGlow: function (color, outerStrength, innerStrength, knockout, quality, distance)
	    {
	        return this.add(new Effects.Glow(this.gameObject, color, outerStrength, innerStrength, knockout), { quality: quality, distance: distance });
	    },

	    addShadow: function (x, y, decay, power, color, samples, intensity)
	    {
	        return this.add(new Effects.Shadow(this.gameObject, x, y, decay, power, color, samples, intensity));
	    },

	    addPixelate: function (amount)
	    {
	        return this.add(new Effects.Pixelate(this.gameObject, amount));
	    },

	    addVignette: function (x, y, radius, strength)
	    {
	        return this.add(new Effects.Vignette(this.gameObject, x, y, radius, strength));
	    },

	    addShine: function (speed, lineWidth, gradient, reveal)
	    {
	        return this.add(new Effects.Shine(this.gameObject, speed, lineWidth, gradient, reveal));
	    },

	    addBlur: function (quality, x, y, strength, color, steps)
	    {
	        return this.add(new Effects.Blur(this.gameObject, quality, x, y, strength, color, steps));
	    },

	    addGradient: function (color1, color2, alpha, fromX, fromY, toX, toY, size)
	    {
	        return this.add(new Effects.Gradient(this.gameObject, color1, color2, alpha, fromX, fromY, toX, toY, size));
	    },

	    addBloom: function (color, offsetX, offsetY, blurStrength, strength, steps)
	    {
	        return this.add(new Effects.Bloom(this.gameObject, color, offsetX, offsetY, blurStrength, strength, steps));
	    },

	    addColorMatrix: function ()
	    {
	        return this.add(new Effects.ColorMatrix(this.gameObject));
	    },

	    addCircle: function (thickness, color, backgroundColor, scale, feather)
	    {
	        return this.add(new Effects.Circle(this.gameObject, thickness, color, backgroundColor, scale, feather));
	    },

	    addBarrel: function (amount)
	    {
	        return this.add(new Effects.Barrel(this.gameObject, amount));
	    },

	    addDisplacement: function (texture, x, y)
	    {
	        return this.add(new Effects.Displacement(this.gameObject, texture, x, y));
	    },

	    addWipe: function (wipeWidth, direction, axis)
	    {
	        return this.add(new Effects.Wipe(this.gameObject, wipeWidth, direction, axis));
	    },

	    addReveal: function (wipeWidth, direction, axis)
	    {
	        return this.add(new Effects.Wipe(this.gameObject, wipeWidth, direction, axis, true));
	    },

	    addBokeh: function (radius, amount, contrast)
	    {
	        return this.add(new Effects.Bokeh(this.gameObject, radius, amount, contrast));
	    },

	    addTiltShift: function (radius, amount, contrast, blurX, blurY, strength)
	    {
	        return this.add(new Effects.Bokeh(this.gameObject, radius, amount, contrast, true, blurX, blurY, strength));
	    },

	    destroy: function ()
	    {
	        this.clear();

	        this.gameObject = null;
	    }

	});

	FX_1 = FX;
	return FX_1;
}

var Contains_1$3;
var hasRequiredContains$3;

function requireContains$3 () {
	if (hasRequiredContains$3) return Contains_1$3;
	hasRequiredContains$3 = 1;
	var Contains = function (rect, x, y)
	{
	    if (rect.width <= 0 || rect.height <= 0)
	    {
	        return false;
	    }

	    return (rect.x <= x && rect.x + rect.width >= x && rect.y <= y && rect.y + rect.height >= y);
	};

	Contains_1$3 = Contains;
	return Contains_1$3;
}

var Perimeter_1$2;
var hasRequiredPerimeter$2;

function requirePerimeter$2 () {
	if (hasRequiredPerimeter$2) return Perimeter_1$2;
	hasRequiredPerimeter$2 = 1;
	var Perimeter = function (rect)
	{
	    return 2 * (rect.width + rect.height);
	};

	Perimeter_1$2 = Perimeter;
	return Perimeter_1$2;
}

var GetPoint_1$3;
var hasRequiredGetPoint$3;

function requireGetPoint$3 () {
	if (hasRequiredGetPoint$3) return GetPoint_1$3;
	hasRequiredGetPoint$3 = 1;
	var Perimeter = requirePerimeter$2();
	var Point = requirePoint$1();

	var GetPoint = function (rectangle, position, out)
	{
	    if (out === undefined) { out = new Point(); }

	    if (position <= 0 || position >= 1)
	    {
	        out.x = rectangle.x;
	        out.y = rectangle.y;

	        return out;
	    }

	    var p = Perimeter(rectangle) * position;

	    if (position > 0.5)
	    {
	        p -= (rectangle.width + rectangle.height);

	        if (p <= rectangle.width)
	        {

	            out.x = rectangle.right - p;
	            out.y = rectangle.bottom;
	        }
	        else
	        {

	            out.x = rectangle.x;
	            out.y = rectangle.bottom - (p - rectangle.width);
	        }
	    }
	    else if (p <= rectangle.width)
	    {

	        out.x = rectangle.x + p;
	        out.y = rectangle.y;
	    }
	    else
	    {

	        out.x = rectangle.right;
	        out.y = rectangle.y + (p - rectangle.width);
	    }

	    return out;
	};

	GetPoint_1$3 = GetPoint;
	return GetPoint_1$3;
}

var GetPoints_1$4;
var hasRequiredGetPoints$4;

function requireGetPoints$4 () {
	if (hasRequiredGetPoints$4) return GetPoints_1$4;
	hasRequiredGetPoints$4 = 1;
	var GetPoint = requireGetPoint$3();
	var Perimeter = requirePerimeter$2();

	var GetPoints = function (rectangle, quantity, stepRate, out)
	{
	    if (out === undefined) { out = []; }

	    if (!quantity && stepRate > 0)
	    {
	        quantity = Perimeter(rectangle) / stepRate;
	    }

	    for (var i = 0; i < quantity; i++)
	    {
	        var position = i / quantity;

	        out.push(GetPoint(rectangle, position));
	    }

	    return out;
	};

	GetPoints_1$4 = GetPoints;
	return GetPoints_1$4;
}

var GetPoint_1$2;
var hasRequiredGetPoint$2;

function requireGetPoint$2 () {
	if (hasRequiredGetPoint$2) return GetPoint_1$2;
	hasRequiredGetPoint$2 = 1;
	var Point = requirePoint$1();

	var GetPoint = function (line, position, out)
	{
	    if (out === undefined) { out = new Point(); }

	    out.x = line.x1 + (line.x2 - line.x1) * position;
	    out.y = line.y1 + (line.y2 - line.y1) * position;

	    return out;
	};

	GetPoint_1$2 = GetPoint;
	return GetPoint_1$2;
}

var Length_1;
var hasRequiredLength;

function requireLength () {
	if (hasRequiredLength) return Length_1;
	hasRequiredLength = 1;
	var Length = function (line)
	{
	    return Math.sqrt((line.x2 - line.x1) * (line.x2 - line.x1) + (line.y2 - line.y1) * (line.y2 - line.y1));
	};

	Length_1 = Length;
	return Length_1;
}

var GetPoints_1$3;
var hasRequiredGetPoints$3;

function requireGetPoints$3 () {
	if (hasRequiredGetPoints$3) return GetPoints_1$3;
	hasRequiredGetPoints$3 = 1;
	var Length = requireLength();
	var Point = requirePoint$1();

	var GetPoints = function (line, quantity, stepRate, out)
	{
	    if (out === undefined) { out = []; }

	    if (!quantity && stepRate > 0)
	    {
	        quantity = Length(line) / stepRate;
	    }

	    var x1 = line.x1;
	    var y1 = line.y1;

	    var x2 = line.x2;
	    var y2 = line.y2;

	    for (var i = 0; i < quantity; i++)
	    {
	        var position = i / quantity;

	        var x = x1 + (x2 - x1) * position;
	        var y = y1 + (y2 - y1) * position;

	        out.push(new Point(x, y));
	    }

	    return out;
	};

	GetPoints_1$3 = GetPoints;
	return GetPoints_1$3;
}

var Random_1$4;
var hasRequiredRandom$4;

function requireRandom$4 () {
	if (hasRequiredRandom$4) return Random_1$4;
	hasRequiredRandom$4 = 1;
	var Point = requirePoint$1();

	var Random = function (line, out)
	{
	    if (out === undefined) { out = new Point(); }

	    var t = Math.random();

	    out.x = line.x1 + t * (line.x2 - line.x1);
	    out.y = line.y1 + t * (line.y2 - line.y1);

	    return out;
	};

	Random_1$4 = Random;
	return Random_1$4;
}

var Equal_1;
var hasRequiredEqual;

function requireEqual () {
	if (hasRequiredEqual) return Equal_1;
	hasRequiredEqual = 1;
	var Equal = function (a, b, epsilon)
	{
	    if (epsilon === undefined) { epsilon = 0.0001; }

	    return Math.abs(a - b) < epsilon;
	};

	Equal_1 = Equal;
	return Equal_1;
}

var Vector2_1;
var hasRequiredVector2;

function requireVector2 () {
	if (hasRequiredVector2) return Vector2_1;
	hasRequiredVector2 = 1;
	var Class = requireClass();
	var FuzzyEqual = requireEqual();

	var Vector2 = new Class({

	    initialize:

	    function Vector2 (x, y)
	    {

	        this.x = 0;

	        this.y = 0;

	        if (typeof x === 'object')
	        {
	            this.x = x.x || 0;
	            this.y = x.y || 0;
	        }
	        else
	        {
	            if (y === undefined) { y = x; }

	            this.x = x || 0;
	            this.y = y || 0;
	        }
	    },

	    clone: function ()
	    {
	        return new Vector2(this.x, this.y);
	    },

	    copy: function (src)
	    {
	        this.x = src.x || 0;
	        this.y = src.y || 0;

	        return this;
	    },

	    setFromObject: function (obj)
	    {
	        this.x = obj.x || 0;
	        this.y = obj.y || 0;

	        return this;
	    },

	    set: function (x, y)
	    {
	        if (y === undefined) { y = x; }

	        this.x = x;
	        this.y = y;

	        return this;
	    },

	    setTo: function (x, y)
	    {
	        return this.set(x, y);
	    },

	    setToPolar: function (azimuth, radius)
	    {
	        if (radius == null) { radius = 1; }

	        this.x = Math.cos(azimuth) * radius;
	        this.y = Math.sin(azimuth) * radius;

	        return this;
	    },

	    equals: function (v)
	    {
	        return ((this.x === v.x) && (this.y === v.y));
	    },

	    fuzzyEquals: function (v, epsilon)
	    {
	        return (FuzzyEqual(this.x, v.x, epsilon) && FuzzyEqual(this.y, v.y, epsilon));
	    },

	    angle: function ()
	    {

	        var angle = Math.atan2(this.y, this.x);

	        if (angle < 0)
	        {
	            angle += 2 * Math.PI;
	        }

	        return angle;
	    },

	    setAngle: function (angle)
	    {
	        return this.setToPolar(angle, this.length());
	    },

	    add: function (src)
	    {
	        this.x += src.x;
	        this.y += src.y;

	        return this;
	    },

	    subtract: function (src)
	    {
	        this.x -= src.x;
	        this.y -= src.y;

	        return this;
	    },

	    multiply: function (src)
	    {
	        this.x *= src.x;
	        this.y *= src.y;

	        return this;
	    },

	    scale: function (value)
	    {
	        if (isFinite(value))
	        {
	            this.x *= value;
	            this.y *= value;
	        }
	        else
	        {
	            this.x = 0;
	            this.y = 0;
	        }

	        return this;
	    },

	    divide: function (src)
	    {
	        this.x /= src.x;
	        this.y /= src.y;

	        return this;
	    },

	    negate: function ()
	    {
	        this.x = -this.x;
	        this.y = -this.y;

	        return this;
	    },

	    distance: function (src)
	    {
	        var dx = src.x - this.x;
	        var dy = src.y - this.y;

	        return Math.sqrt(dx * dx + dy * dy);
	    },

	    distanceSq: function (src)
	    {
	        var dx = src.x - this.x;
	        var dy = src.y - this.y;

	        return dx * dx + dy * dy;
	    },

	    length: function ()
	    {
	        var x = this.x;
	        var y = this.y;

	        return Math.sqrt(x * x + y * y);
	    },

	    setLength: function (length)
	    {
	        return this.normalize().scale(length);
	    },

	    lengthSq: function ()
	    {
	        var x = this.x;
	        var y = this.y;

	        return x * x + y * y;
	    },

	    normalize: function ()
	    {
	        var x = this.x;
	        var y = this.y;
	        var len = x * x + y * y;

	        if (len > 0)
	        {
	            len = 1 / Math.sqrt(len);

	            this.x = x * len;
	            this.y = y * len;
	        }

	        return this;
	    },

	    normalizeRightHand: function ()
	    {
	        var x = this.x;

	        this.x = this.y * -1;
	        this.y = x;

	        return this;
	    },

	    normalizeLeftHand: function ()
	    {
	        var x = this.x;

	        this.x = this.y;
	        this.y = x * -1;

	        return this;
	    },

	    dot: function (src)
	    {
	        return this.x * src.x + this.y * src.y;
	    },

	    cross: function (src)
	    {
	        return this.x * src.y - this.y * src.x;
	    },

	    lerp: function (src, t)
	    {
	        if (t === undefined) { t = 0; }

	        var ax = this.x;
	        var ay = this.y;

	        this.x = ax + t * (src.x - ax);
	        this.y = ay + t * (src.y - ay);

	        return this;
	    },

	    transformMat3: function (mat)
	    {
	        var x = this.x;
	        var y = this.y;
	        var m = mat.val;

	        this.x = m[0] * x + m[3] * y + m[6];
	        this.y = m[1] * x + m[4] * y + m[7];

	        return this;
	    },

	    transformMat4: function (mat)
	    {
	        var x = this.x;
	        var y = this.y;
	        var m = mat.val;

	        this.x = m[0] * x + m[4] * y + m[12];
	        this.y = m[1] * x + m[5] * y + m[13];

	        return this;
	    },

	    reset: function ()
	    {
	        this.x = 0;
	        this.y = 0;

	        return this;
	    },

	    limit: function (max)
	    {
	        var len = this.length();

	        if (len && len > max)
	        {
	            this.scale(max / len);
	        }

	        return this;
	    },

	    reflect: function (normal)
	    {
	        normal = normal.clone().normalize();

	        return this.subtract(normal.scale(2 * this.dot(normal)));
	    },

	    mirror: function (axis)
	    {
	        return this.reflect(axis).negate();
	    },

	    rotate: function (delta)
	    {
	        var cos = Math.cos(delta);
	        var sin = Math.sin(delta);

	        return this.set(cos * this.x - sin * this.y, sin * this.x + cos * this.y);
	    },

	    project: function (src)
	    {
	        var scalar = this.dot(src) / src.dot(src);

	        return this.copy(src).scale(scalar);
	    }

	});

	Vector2.ZERO = new Vector2();

	Vector2.RIGHT = new Vector2(1, 0);

	Vector2.LEFT = new Vector2(-1, 0);

	Vector2.UP = new Vector2(0, -1);

	Vector2.DOWN = new Vector2(0, 1);

	Vector2.ONE = new Vector2(1, 1);

	Vector2_1 = Vector2;
	return Vector2_1;
}

var Line_1$1;
var hasRequiredLine$2;

function requireLine$2 () {
	if (hasRequiredLine$2) return Line_1$1;
	hasRequiredLine$2 = 1;
	var Class = requireClass();
	var GetPoint = requireGetPoint$2();
	var GetPoints = requireGetPoints$3();
	var GEOM_CONST = require_const$d();
	var Random = requireRandom$4();
	var Vector2 = requireVector2();

	var Line = new Class({

	    initialize:

	    function Line (x1, y1, x2, y2)
	    {
	        if (x1 === undefined) { x1 = 0; }
	        if (y1 === undefined) { y1 = 0; }
	        if (x2 === undefined) { x2 = 0; }
	        if (y2 === undefined) { y2 = 0; }

	        this.type = GEOM_CONST.LINE;

	        this.x1 = x1;

	        this.y1 = y1;

	        this.x2 = x2;

	        this.y2 = y2;
	    },

	    getPoint: function (position, output)
	    {
	        return GetPoint(this, position, output);
	    },

	    getPoints: function (quantity, stepRate, output)
	    {
	        return GetPoints(this, quantity, stepRate, output);
	    },

	    getRandomPoint: function (point)
	    {
	        return Random(this, point);
	    },

	    setTo: function (x1, y1, x2, y2)
	    {
	        if (x1 === undefined) { x1 = 0; }
	        if (y1 === undefined) { y1 = 0; }
	        if (x2 === undefined) { x2 = 0; }
	        if (y2 === undefined) { y2 = 0; }

	        this.x1 = x1;
	        this.y1 = y1;

	        this.x2 = x2;
	        this.y2 = y2;

	        return this;
	    },

	    setFromObjects: function (start, end)
	    {
	        this.x1 = start.x;
	        this.y1 = start.y;

	        this.x2 = end.x;
	        this.y2 = end.y;

	        return this;
	    },

	    getPointA: function (vec2)
	    {
	        if (vec2 === undefined) { vec2 = new Vector2(); }

	        vec2.set(this.x1, this.y1);

	        return vec2;
	    },

	    getPointB: function (vec2)
	    {
	        if (vec2 === undefined) { vec2 = new Vector2(); }

	        vec2.set(this.x2, this.y2);

	        return vec2;
	    },

	    left: {

	        get: function ()
	        {
	            return Math.min(this.x1, this.x2);
	        },

	        set: function (value)
	        {
	            if (this.x1 <= this.x2)
	            {
	                this.x1 = value;
	            }
	            else
	            {
	                this.x2 = value;
	            }
	        }

	    },

	    right: {

	        get: function ()
	        {
	            return Math.max(this.x1, this.x2);
	        },

	        set: function (value)
	        {
	            if (this.x1 > this.x2)
	            {
	                this.x1 = value;
	            }
	            else
	            {
	                this.x2 = value;
	            }
	        }

	    },

	    top: {

	        get: function ()
	        {
	            return Math.min(this.y1, this.y2);
	        },

	        set: function (value)
	        {
	            if (this.y1 <= this.y2)
	            {
	                this.y1 = value;
	            }
	            else
	            {
	                this.y2 = value;
	            }
	        }

	    },

	    bottom: {

	        get: function ()
	        {
	            return Math.max(this.y1, this.y2);
	        },

	        set: function (value)
	        {
	            if (this.y1 > this.y2)
	            {
	                this.y1 = value;
	            }
	            else
	            {
	                this.y2 = value;
	            }
	        }

	    }

	});

	Line_1$1 = Line;
	return Line_1$1;
}

var Random_1$3;
var hasRequiredRandom$3;

function requireRandom$3 () {
	if (hasRequiredRandom$3) return Random_1$3;
	hasRequiredRandom$3 = 1;
	var Point = requirePoint$1();

	var Random = function (rect, out)
	{
	    if (out === undefined) { out = new Point(); }

	    out.x = rect.x + (Math.random() * rect.width);
	    out.y = rect.y + (Math.random() * rect.height);

	    return out;
	};

	Random_1$3 = Random;
	return Random_1$3;
}

var Rectangle_1$1;
var hasRequiredRectangle$2;

function requireRectangle$2 () {
	if (hasRequiredRectangle$2) return Rectangle_1$1;
	hasRequiredRectangle$2 = 1;
	var Class = requireClass();
	var Contains = requireContains$3();
	var GetPoint = requireGetPoint$3();
	var GetPoints = requireGetPoints$4();
	var GEOM_CONST = require_const$d();
	var Line = requireLine$2();
	var Random = requireRandom$3();

	var Rectangle = new Class({

	    initialize:

	    function Rectangle (x, y, width, height)
	    {
	        if (x === undefined) { x = 0; }
	        if (y === undefined) { y = 0; }
	        if (width === undefined) { width = 0; }
	        if (height === undefined) { height = 0; }

	        this.type = GEOM_CONST.RECTANGLE;

	        this.x = x;

	        this.y = y;

	        this.width = width;

	        this.height = height;
	    },

	    contains: function (x, y)
	    {
	        return Contains(this, x, y);
	    },

	    getPoint: function (position, output)
	    {
	        return GetPoint(this, position, output);
	    },

	    getPoints: function (quantity, stepRate, output)
	    {
	        return GetPoints(this, quantity, stepRate, output);
	    },

	    getRandomPoint: function (point)
	    {
	        return Random(this, point);
	    },

	    setTo: function (x, y, width, height)
	    {
	        this.x = x;
	        this.y = y;
	        this.width = width;
	        this.height = height;

	        return this;
	    },

	    setEmpty: function ()
	    {
	        return this.setTo(0, 0, 0, 0);
	    },

	    setPosition: function (x, y)
	    {
	        if (y === undefined) { y = x; }

	        this.x = x;
	        this.y = y;

	        return this;
	    },

	    setSize: function (width, height)
	    {
	        if (height === undefined) { height = width; }

	        this.width = width;
	        this.height = height;

	        return this;
	    },

	    isEmpty: function ()
	    {
	        return (this.width <= 0 || this.height <= 0);
	    },

	    getLineA: function (line)
	    {
	        if (line === undefined) { line = new Line(); }

	        line.setTo(this.x, this.y, this.right, this.y);

	        return line;
	    },

	    getLineB: function (line)
	    {
	        if (line === undefined) { line = new Line(); }

	        line.setTo(this.right, this.y, this.right, this.bottom);

	        return line;
	    },

	    getLineC: function (line)
	    {
	        if (line === undefined) { line = new Line(); }

	        line.setTo(this.right, this.bottom, this.x, this.bottom);

	        return line;
	    },

	    getLineD: function (line)
	    {
	        if (line === undefined) { line = new Line(); }

	        line.setTo(this.x, this.bottom, this.x, this.y);

	        return line;
	    },

	    left: {

	        get: function ()
	        {
	            return this.x;
	        },

	        set: function (value)
	        {
	            if (value >= this.right)
	            {
	                this.width = 0;
	            }
	            else
	            {
	                this.width = this.right - value;
	            }

	            this.x = value;
	        }

	    },

	    right: {

	        get: function ()
	        {
	            return this.x + this.width;
	        },

	        set: function (value)
	        {
	            if (value <= this.x)
	            {
	                this.width = 0;
	            }
	            else
	            {
	                this.width = value - this.x;
	            }
	        }

	    },

	    top: {

	        get: function ()
	        {
	            return this.y;
	        },

	        set: function (value)
	        {
	            if (value >= this.bottom)
	            {
	                this.height = 0;
	            }
	            else
	            {
	                this.height = (this.bottom - value);
	            }

	            this.y = value;
	        }

	    },

	    bottom: {

	        get: function ()
	        {
	            return this.y + this.height;
	        },

	        set: function (value)
	        {
	            if (value <= this.y)
	            {
	                this.height = 0;
	            }
	            else
	            {
	                this.height = value - this.y;
	            }
	        }

	    },

	    centerX: {

	        get: function ()
	        {
	            return this.x + (this.width / 2);
	        },

	        set: function (value)
	        {
	            this.x = value - (this.width / 2);
	        }

	    },

	    centerY: {

	        get: function ()
	        {
	            return this.y + (this.height / 2);
	        },

	        set: function (value)
	        {
	            this.y = value - (this.height / 2);
	        }

	    }

	});

	Rectangle_1$1 = Rectangle;
	return Rectangle_1$1;
}

var RotateAround_1$1;
var hasRequiredRotateAround$1;

function requireRotateAround$1 () {
	if (hasRequiredRotateAround$1) return RotateAround_1$1;
	hasRequiredRotateAround$1 = 1;
	var RotateAround = function (point, x, y, angle)
	{
	    var c = Math.cos(angle);
	    var s = Math.sin(angle);

	    var tx = point.x - x;
	    var ty = point.y - y;

	    point.x = tx * c - ty * s + x;
	    point.y = tx * s + ty * c + y;

	    return point;
	};

	RotateAround_1$1 = RotateAround;
	return RotateAround_1$1;
}

var GetBounds_1$3;
var hasRequiredGetBounds$3;

function requireGetBounds$3 () {
	if (hasRequiredGetBounds$3) return GetBounds_1$3;
	hasRequiredGetBounds$3 = 1;
	var Rectangle = requireRectangle$2();
	var RotateAround = requireRotateAround$1();
	var Vector2 = requireVector2();

	var GetBounds = {

	    prepareBoundsOutput: function (output, includeParent)
	    {
	        if (includeParent === undefined) { includeParent = false; }

	        if (this.rotation !== 0)
	        {
	            RotateAround(output, this.x, this.y, this.rotation);
	        }

	        if (includeParent && this.parentContainer)
	        {
	            var parentMatrix = this.parentContainer.getBoundsTransformMatrix();

	            parentMatrix.transformPoint(output.x, output.y, output);
	        }

	        return output;
	    },

	    getCenter: function (output, includeParent)
	    {
	        if (output === undefined) { output = new Vector2(); }

	        output.x = this.x - (this.displayWidth * this.originX) + (this.displayWidth / 2);
	        output.y = this.y - (this.displayHeight * this.originY) + (this.displayHeight / 2);

	        return this.prepareBoundsOutput(output, includeParent);
	    },

	    getTopLeft: function (output, includeParent)
	    {
	        if (!output) { output = new Vector2(); }

	        output.x = this.x - (this.displayWidth * this.originX);
	        output.y = this.y - (this.displayHeight * this.originY);

	        return this.prepareBoundsOutput(output, includeParent);
	    },

	    getTopCenter: function (output, includeParent)
	    {
	        if (!output) { output = new Vector2(); }

	        output.x = (this.x - (this.displayWidth * this.originX)) + (this.displayWidth / 2);
	        output.y = this.y - (this.displayHeight * this.originY);

	        return this.prepareBoundsOutput(output, includeParent);
	    },

	    getTopRight: function (output, includeParent)
	    {
	        if (!output) { output = new Vector2(); }

	        output.x = (this.x - (this.displayWidth * this.originX)) + this.displayWidth;
	        output.y = this.y - (this.displayHeight * this.originY);

	        return this.prepareBoundsOutput(output, includeParent);
	    },

	    getLeftCenter: function (output, includeParent)
	    {
	        if (!output) { output = new Vector2(); }

	        output.x = this.x - (this.displayWidth * this.originX);
	        output.y = (this.y - (this.displayHeight * this.originY)) + (this.displayHeight / 2);

	        return this.prepareBoundsOutput(output, includeParent);
	    },

	    getRightCenter: function (output, includeParent)
	    {
	        if (!output) { output = new Vector2(); }

	        output.x = (this.x - (this.displayWidth * this.originX)) + this.displayWidth;
	        output.y = (this.y - (this.displayHeight * this.originY)) + (this.displayHeight / 2);

	        return this.prepareBoundsOutput(output, includeParent);
	    },

	    getBottomLeft: function (output, includeParent)
	    {
	        if (!output) { output = new Vector2(); }

	        output.x = this.x - (this.displayWidth * this.originX);
	        output.y = (this.y - (this.displayHeight * this.originY)) + this.displayHeight;

	        return this.prepareBoundsOutput(output, includeParent);
	    },

	    getBottomCenter: function (output, includeParent)
	    {
	        if (!output) { output = new Vector2(); }

	        output.x = (this.x - (this.displayWidth * this.originX)) + (this.displayWidth / 2);
	        output.y = (this.y - (this.displayHeight * this.originY)) + this.displayHeight;

	        return this.prepareBoundsOutput(output, includeParent);
	    },

	    getBottomRight: function (output, includeParent)
	    {
	        if (!output) { output = new Vector2(); }

	        output.x = (this.x - (this.displayWidth * this.originX)) + this.displayWidth;
	        output.y = (this.y - (this.displayHeight * this.originY)) + this.displayHeight;

	        return this.prepareBoundsOutput(output, includeParent);
	    },

	    getBounds: function (output)
	    {
	        if (output === undefined) { output = new Rectangle(); }

	        var TLx, TLy, TRx, TRy, BLx, BLy, BRx, BRy;

	        if (this.parentContainer)
	        {
	            var parentMatrix = this.parentContainer.getBoundsTransformMatrix();

	            this.getTopLeft(output);
	            parentMatrix.transformPoint(output.x, output.y, output);

	            TLx = output.x;
	            TLy = output.y;

	            this.getTopRight(output);
	            parentMatrix.transformPoint(output.x, output.y, output);

	            TRx = output.x;
	            TRy = output.y;

	            this.getBottomLeft(output);
	            parentMatrix.transformPoint(output.x, output.y, output);

	            BLx = output.x;
	            BLy = output.y;

	            this.getBottomRight(output);
	            parentMatrix.transformPoint(output.x, output.y, output);

	            BRx = output.x;
	            BRy = output.y;
	        }
	        else
	        {
	            this.getTopLeft(output);

	            TLx = output.x;
	            TLy = output.y;

	            this.getTopRight(output);

	            TRx = output.x;
	            TRy = output.y;

	            this.getBottomLeft(output);

	            BLx = output.x;
	            BLy = output.y;

	            this.getBottomRight(output);

	            BRx = output.x;
	            BRy = output.y;
	        }

	        output.x = Math.min(TLx, TRx, BLx, BRx);
	        output.y = Math.min(TLy, TRy, BLy, BRy);
	        output.width = Math.max(TLx, TRx, BLx, BRx) - output.x;
	        output.height = Math.max(TLy, TRy, BLy, BRy) - output.y;

	        return output;
	    }

	};

	GetBounds_1$3 = GetBounds;
	return GetBounds_1$3;
}

var PluginCache_1;
var hasRequiredPluginCache;

function requirePluginCache () {
	if (hasRequiredPluginCache) return PluginCache_1;
	hasRequiredPluginCache = 1;
	var corePlugins = {};

	var customPlugins = {};

	var PluginCache = {};

	PluginCache.register = function (key, plugin, mapping, custom)
	{
	    if (custom === undefined) { custom = false; }

	    corePlugins[key] = { plugin: plugin, mapping: mapping, custom: custom };
	};

	PluginCache.registerCustom = function (key, plugin, mapping, data)
	{
	    customPlugins[key] = { plugin: plugin, mapping: mapping, data: data };
	};

	PluginCache.hasCore = function (key)
	{
	    return corePlugins.hasOwnProperty(key);
	};

	PluginCache.hasCustom = function (key)
	{
	    return customPlugins.hasOwnProperty(key);
	};

	PluginCache.getCore = function (key)
	{
	    return corePlugins[key];
	};

	PluginCache.getCustom = function (key)
	{
	    return customPlugins[key];
	};

	PluginCache.getCustomClass = function (key)
	{
	    return (customPlugins.hasOwnProperty(key)) ? customPlugins[key].plugin : null;
	};

	PluginCache.remove = function (key)
	{
	    if (corePlugins.hasOwnProperty(key))
	    {
	        delete corePlugins[key];
	    }
	};

	PluginCache.removeCustom = function (key)
	{
	    if (customPlugins.hasOwnProperty(key))
	    {
	        delete customPlugins[key];
	    }
	};

	PluginCache.destroyCorePlugins = function ()
	{
	    for (var key in corePlugins)
	    {
	        if (corePlugins.hasOwnProperty(key))
	        {
	            delete corePlugins[key];
	        }
	    }
	};

	PluginCache.destroyCustomPlugins = function ()
	{
	    for (var key in customPlugins)
	    {
	        if (customPlugins.hasOwnProperty(key))
	        {
	            delete customPlugins[key];
	        }
	    }
	};

	PluginCache_1 = PluginCache;
	return PluginCache_1;
}

var ADDED_TO_SCENE_EVENT$1;
var hasRequiredADDED_TO_SCENE_EVENT$1;

function requireADDED_TO_SCENE_EVENT$1 () {
	if (hasRequiredADDED_TO_SCENE_EVENT$1) return ADDED_TO_SCENE_EVENT$1;
	hasRequiredADDED_TO_SCENE_EVENT$1 = 1;
	ADDED_TO_SCENE_EVENT$1 = 'addedtoscene';
	return ADDED_TO_SCENE_EVENT$1;
}

var BOOT_EVENT$3;
var hasRequiredBOOT_EVENT$3;

function requireBOOT_EVENT$3 () {
	if (hasRequiredBOOT_EVENT$3) return BOOT_EVENT$3;
	hasRequiredBOOT_EVENT$3 = 1;
	BOOT_EVENT$3 = 'boot';
	return BOOT_EVENT$3;
}

var CREATE_EVENT;
var hasRequiredCREATE_EVENT;

function requireCREATE_EVENT () {
	if (hasRequiredCREATE_EVENT) return CREATE_EVENT;
	hasRequiredCREATE_EVENT = 1;
	CREATE_EVENT = 'create';
	return CREATE_EVENT;
}

var DESTROY_EVENT$7;
var hasRequiredDESTROY_EVENT$7;

function requireDESTROY_EVENT$7 () {
	if (hasRequiredDESTROY_EVENT$7) return DESTROY_EVENT$7;
	hasRequiredDESTROY_EVENT$7 = 1;
	DESTROY_EVENT$7 = 'destroy';
	return DESTROY_EVENT$7;
}

var PAUSE_EVENT$3;
var hasRequiredPAUSE_EVENT$3;

function requirePAUSE_EVENT$3 () {
	if (hasRequiredPAUSE_EVENT$3) return PAUSE_EVENT$3;
	hasRequiredPAUSE_EVENT$3 = 1;
	PAUSE_EVENT$3 = 'pause';
	return PAUSE_EVENT$3;
}

var POST_UPDATE_EVENT;
var hasRequiredPOST_UPDATE_EVENT;

function requirePOST_UPDATE_EVENT () {
	if (hasRequiredPOST_UPDATE_EVENT) return POST_UPDATE_EVENT;
	hasRequiredPOST_UPDATE_EVENT = 1;
	POST_UPDATE_EVENT = 'postupdate';
	return POST_UPDATE_EVENT;
}

var PRE_RENDER_EVENT$3;
var hasRequiredPRE_RENDER_EVENT$3;

function requirePRE_RENDER_EVENT$3 () {
	if (hasRequiredPRE_RENDER_EVENT$3) return PRE_RENDER_EVENT$3;
	hasRequiredPRE_RENDER_EVENT$3 = 1;
	PRE_RENDER_EVENT$3 = 'prerender';
	return PRE_RENDER_EVENT$3;
}

var PRE_UPDATE_EVENT$1;
var hasRequiredPRE_UPDATE_EVENT$1;

function requirePRE_UPDATE_EVENT$1 () {
	if (hasRequiredPRE_UPDATE_EVENT$1) return PRE_UPDATE_EVENT$1;
	hasRequiredPRE_UPDATE_EVENT$1 = 1;
	PRE_UPDATE_EVENT$1 = 'preupdate';
	return PRE_UPDATE_EVENT$1;
}

var READY_EVENT$2;
var hasRequiredREADY_EVENT$2;

function requireREADY_EVENT$2 () {
	if (hasRequiredREADY_EVENT$2) return READY_EVENT$2;
	hasRequiredREADY_EVENT$2 = 1;
	READY_EVENT$2 = 'ready';
	return READY_EVENT$2;
}

var REMOVED_FROM_SCENE_EVENT$1;
var hasRequiredREMOVED_FROM_SCENE_EVENT$1;

function requireREMOVED_FROM_SCENE_EVENT$1 () {
	if (hasRequiredREMOVED_FROM_SCENE_EVENT$1) return REMOVED_FROM_SCENE_EVENT$1;
	hasRequiredREMOVED_FROM_SCENE_EVENT$1 = 1;
	REMOVED_FROM_SCENE_EVENT$1 = 'removedfromscene';
	return REMOVED_FROM_SCENE_EVENT$1;
}

var RENDER_EVENT$1;
var hasRequiredRENDER_EVENT$1;

function requireRENDER_EVENT$1 () {
	if (hasRequiredRENDER_EVENT$1) return RENDER_EVENT$1;
	hasRequiredRENDER_EVENT$1 = 1;
	RENDER_EVENT$1 = 'render';
	return RENDER_EVENT$1;
}

var RESUME_EVENT$3;
var hasRequiredRESUME_EVENT$3;

function requireRESUME_EVENT$3 () {
	if (hasRequiredRESUME_EVENT$3) return RESUME_EVENT$3;
	hasRequiredRESUME_EVENT$3 = 1;
	RESUME_EVENT$3 = 'resume';
	return RESUME_EVENT$3;
}

var SHUTDOWN_EVENT$1;
var hasRequiredSHUTDOWN_EVENT$1;

function requireSHUTDOWN_EVENT$1 () {
	if (hasRequiredSHUTDOWN_EVENT$1) return SHUTDOWN_EVENT$1;
	hasRequiredSHUTDOWN_EVENT$1 = 1;
	SHUTDOWN_EVENT$1 = 'shutdown';
	return SHUTDOWN_EVENT$1;
}

var SLEEP_EVENT;
var hasRequiredSLEEP_EVENT;

function requireSLEEP_EVENT () {
	if (hasRequiredSLEEP_EVENT) return SLEEP_EVENT;
	hasRequiredSLEEP_EVENT = 1;
	SLEEP_EVENT = 'sleep';
	return SLEEP_EVENT;
}

var START_EVENT$3;
var hasRequiredSTART_EVENT$3;

function requireSTART_EVENT$3 () {
	if (hasRequiredSTART_EVENT$3) return START_EVENT$3;
	hasRequiredSTART_EVENT$3 = 1;
	START_EVENT$3 = 'start';
	return START_EVENT$3;
}

var TRANSITION_COMPLETE_EVENT;
var hasRequiredTRANSITION_COMPLETE_EVENT;

function requireTRANSITION_COMPLETE_EVENT () {
	if (hasRequiredTRANSITION_COMPLETE_EVENT) return TRANSITION_COMPLETE_EVENT;
	hasRequiredTRANSITION_COMPLETE_EVENT = 1;
	TRANSITION_COMPLETE_EVENT = 'transitioncomplete';
	return TRANSITION_COMPLETE_EVENT;
}

var TRANSITION_INIT_EVENT;
var hasRequiredTRANSITION_INIT_EVENT;

function requireTRANSITION_INIT_EVENT () {
	if (hasRequiredTRANSITION_INIT_EVENT) return TRANSITION_INIT_EVENT;
	hasRequiredTRANSITION_INIT_EVENT = 1;
	TRANSITION_INIT_EVENT = 'transitioninit';
	return TRANSITION_INIT_EVENT;
}

var TRANSITION_OUT_EVENT;
var hasRequiredTRANSITION_OUT_EVENT;

function requireTRANSITION_OUT_EVENT () {
	if (hasRequiredTRANSITION_OUT_EVENT) return TRANSITION_OUT_EVENT;
	hasRequiredTRANSITION_OUT_EVENT = 1;
	TRANSITION_OUT_EVENT = 'transitionout';
	return TRANSITION_OUT_EVENT;
}

var TRANSITION_START_EVENT;
var hasRequiredTRANSITION_START_EVENT;

function requireTRANSITION_START_EVENT () {
	if (hasRequiredTRANSITION_START_EVENT) return TRANSITION_START_EVENT;
	hasRequiredTRANSITION_START_EVENT = 1;
	TRANSITION_START_EVENT = 'transitionstart';
	return TRANSITION_START_EVENT;
}

var TRANSITION_WAKE_EVENT;
var hasRequiredTRANSITION_WAKE_EVENT;

function requireTRANSITION_WAKE_EVENT () {
	if (hasRequiredTRANSITION_WAKE_EVENT) return TRANSITION_WAKE_EVENT;
	hasRequiredTRANSITION_WAKE_EVENT = 1;
	TRANSITION_WAKE_EVENT = 'transitionwake';
	return TRANSITION_WAKE_EVENT;
}

var UPDATE_EVENT$1;
var hasRequiredUPDATE_EVENT$1;

function requireUPDATE_EVENT$1 () {
	if (hasRequiredUPDATE_EVENT$1) return UPDATE_EVENT$1;
	hasRequiredUPDATE_EVENT$1 = 1;
	UPDATE_EVENT$1 = 'update';
	return UPDATE_EVENT$1;
}

var WAKE_EVENT;
var hasRequiredWAKE_EVENT;

function requireWAKE_EVENT () {
	if (hasRequiredWAKE_EVENT) return WAKE_EVENT;
	hasRequiredWAKE_EVENT = 1;
	WAKE_EVENT = 'wake';
	return WAKE_EVENT;
}

var events$l;
var hasRequiredEvents$l;

function requireEvents$l () {
	if (hasRequiredEvents$l) return events$l;
	hasRequiredEvents$l = 1;
	events$l = {

	    ADDED_TO_SCENE: requireADDED_TO_SCENE_EVENT$1(),
	    BOOT: requireBOOT_EVENT$3(),
	    CREATE: requireCREATE_EVENT(),
	    DESTROY: requireDESTROY_EVENT$7(),
	    PAUSE: requirePAUSE_EVENT$3(),
	    POST_UPDATE: requirePOST_UPDATE_EVENT(),
	    PRE_RENDER: requirePRE_RENDER_EVENT$3(),
	    PRE_UPDATE: requirePRE_UPDATE_EVENT$1(),
	    READY: requireREADY_EVENT$2(),
	    REMOVED_FROM_SCENE: requireREMOVED_FROM_SCENE_EVENT$1(),
	    RENDER: requireRENDER_EVENT$1(),
	    RESUME: requireRESUME_EVENT$3(),
	    SHUTDOWN: requireSHUTDOWN_EVENT$1(),
	    SLEEP: requireSLEEP_EVENT(),
	    START: requireSTART_EVENT$3(),
	    TRANSITION_COMPLETE: requireTRANSITION_COMPLETE_EVENT(),
	    TRANSITION_INIT: requireTRANSITION_INIT_EVENT(),
	    TRANSITION_OUT: requireTRANSITION_OUT_EVENT(),
	    TRANSITION_START: requireTRANSITION_START_EVENT(),
	    TRANSITION_WAKE: requireTRANSITION_WAKE_EVENT(),
	    UPDATE: requireUPDATE_EVENT$1(),
	    WAKE: requireWAKE_EVENT()

	};
	return events$l;
}

var GameObjectFactory_1;
var hasRequiredGameObjectFactory;

function requireGameObjectFactory () {
	if (hasRequiredGameObjectFactory) return GameObjectFactory_1;
	hasRequiredGameObjectFactory = 1;
	var Class = requireClass();
	var PluginCache = requirePluginCache();
	var SceneEvents = requireEvents$l();

	var GameObjectFactory = new Class({

	    initialize:

	    function GameObjectFactory (scene)
	    {

	        this.scene = scene;

	        this.systems = scene.sys;

	        this.events = scene.sys.events;

	        this.displayList;

	        this.updateList;

	        this.events.once(SceneEvents.BOOT, this.boot, this);
	        this.events.on(SceneEvents.START, this.start, this);
	    },

	    boot: function ()
	    {
	        this.displayList = this.systems.displayList;
	        this.updateList = this.systems.updateList;

	        this.events.once(SceneEvents.DESTROY, this.destroy, this);
	    },

	    start: function ()
	    {
	        this.events.once(SceneEvents.SHUTDOWN, this.shutdown, this);
	    },

	    existing: function (child)
	    {
	        if (child.renderCanvas || child.renderWebGL)
	        {
	            this.displayList.add(child);
	        }

	        if (child.preUpdate)
	        {
	            this.updateList.add(child);
	        }

	        return child;
	    },

	    shutdown: function ()
	    {
	        this.events.off(SceneEvents.SHUTDOWN, this.shutdown, this);
	    },

	    destroy: function ()
	    {
	        this.shutdown();

	        this.events.off(SceneEvents.START, this.start, this);

	        this.scene = null;
	        this.systems = null;
	        this.events = null;

	        this.displayList = null;
	        this.updateList = null;
	    }

	});

	GameObjectFactory.register = function (factoryType, factoryFunction)
	{
	    if (!GameObjectFactory.prototype.hasOwnProperty(factoryType))
	    {
	        GameObjectFactory.prototype[factoryType] = factoryFunction;
	    }
	};

	GameObjectFactory.remove = function (factoryType)
	{
	    if (GameObjectFactory.prototype.hasOwnProperty(factoryType))
	    {
	        delete GameObjectFactory.prototype[factoryType];
	    }
	};

	PluginCache.register('GameObjectFactory', GameObjectFactory, 'add');

	GameObjectFactory_1 = GameObjectFactory;
	return GameObjectFactory_1;
}

var BitmapMask_1;
var hasRequiredBitmapMask;

function requireBitmapMask () {
	if (hasRequiredBitmapMask) return BitmapMask_1;
	hasRequiredBitmapMask = 1;
	var Class = requireClass();
	var GameObjectFactory = requireGameObjectFactory();

	var BitmapMask = new Class({

	    initialize:

	    function BitmapMask (scene, maskObject, x, y, texture, frame)
	    {
	        if (!maskObject)
	        {
	            maskObject = scene.sys.make.image({ x: x, y: y, key: texture, frame: frame, add: false });
	        }

	        this.bitmapMask = maskObject;

	        this.invertAlpha = false;

	        this.isStencil = false;
	    },

	    setBitmap: function (maskObject)
	    {
	        this.bitmapMask = maskObject;
	    },

	    preRenderWebGL: function (renderer, maskedObject, camera)
	    {
	        renderer.pipelines.BITMAPMASK_PIPELINE.beginMask(this, maskedObject, camera);
	    },

	    postRenderWebGL: function (renderer, camera, renderTarget)
	    {
	        renderer.pipelines.BITMAPMASK_PIPELINE.endMask(this, camera, renderTarget);
	    },

	    preRenderCanvas: function ()
	    {

	    },

	    postRenderCanvas: function ()
	    {

	    },

	    destroy: function ()
	    {
	        this.bitmapMask = null;
	    }

	});

	GameObjectFactory.register('bitmapMask', function (maskObject, x, y, key, frame)
	{
	    return new BitmapMask(this.scene, maskObject, x, y, key, frame);
	});

	BitmapMask_1 = BitmapMask;
	return BitmapMask_1;
}

var GeometryMask_1;
var hasRequiredGeometryMask;

function requireGeometryMask () {
	if (hasRequiredGeometryMask) return GeometryMask_1;
	hasRequiredGeometryMask = 1;
	var Class = requireClass();

	var GeometryMask = new Class({

	    initialize:

	    function GeometryMask (scene, graphicsGeometry)
	    {

	        this.geometryMask = graphicsGeometry;

	        this.invertAlpha = false;

	        this.isStencil = true;

	        this.level = 0;
	    },

	    setShape: function (graphicsGeometry)
	    {
	        this.geometryMask = graphicsGeometry;

	        return this;
	    },

	    setInvertAlpha: function (value)
	    {
	        if (value === undefined) { value = true; }

	        this.invertAlpha = value;

	        return this;
	    },

	    preRenderWebGL: function (renderer, child, camera)
	    {
	        var gl = renderer.gl;

	        renderer.flush();

	        if (renderer.maskStack.length === 0)
	        {
	            gl.enable(gl.STENCIL_TEST);
	            gl.clear(gl.STENCIL_BUFFER_BIT);

	            renderer.maskCount = 0;
	        }

	        if (renderer.currentCameraMask.mask !== this)
	        {
	            renderer.currentMask.mask = this;
	        }

	        renderer.maskStack.push({ mask: this, camera: camera });

	        this.applyStencil(renderer, camera, true);

	        renderer.maskCount++;
	    },

	    applyStencil: function (renderer, camera, inc)
	    {
	        var gl = renderer.gl;
	        var geometryMask = this.geometryMask;
	        var level = renderer.maskCount;
	        var mask = 0xff;

	        gl.colorMask(false, false, false, false);

	        if (inc)
	        {
	            gl.stencilFunc(gl.EQUAL, level, mask);
	            gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);

	            level++;
	        }
	        else
	        {
	            gl.stencilFunc(gl.EQUAL, level + 1, mask);
	            gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
	        }

	        this.level = level;

	        geometryMask.renderWebGL(renderer, geometryMask, camera);

	        renderer.flush();

	        gl.colorMask(true, true, true, true);
	        gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);

	        if (this.invertAlpha)
	        {
	            gl.stencilFunc(gl.NOTEQUAL, level, mask);
	        }
	        else
	        {
	            gl.stencilFunc(gl.EQUAL, level, mask);
	        }
	    },

	    postRenderWebGL: function (renderer)
	    {
	        var gl = renderer.gl;

	        renderer.maskStack.pop();

	        renderer.maskCount--;

	        renderer.flush();

	        var current = renderer.currentMask;

	        if (renderer.maskStack.length === 0)
	        {

	            current.mask = null;

	            gl.disable(gl.STENCIL_TEST);
	        }
	        else
	        {
	            var prev = renderer.maskStack[renderer.maskStack.length - 1];

	            prev.mask.applyStencil(renderer, prev.camera, false);

	            if (renderer.currentCameraMask.mask !== prev.mask)
	            {
	                current.mask = prev.mask;
	                current.camera = prev.camera;
	            }
	            else
	            {
	                current.mask = null;
	            }
	        }
	    },

	    preRenderCanvas: function (renderer, mask, camera)
	    {
	        var geometryMask = this.geometryMask;

	        renderer.currentContext.save();

	        geometryMask.renderCanvas(renderer, geometryMask, camera, null, null, true);

	        renderer.currentContext.clip();
	    },

	    postRenderCanvas: function (renderer)
	    {
	        renderer.currentContext.restore();
	    },

	    destroy: function ()
	    {
	        this.geometryMask = null;
	    }

	});

	GeometryMask_1 = GeometryMask;
	return GeometryMask_1;
}

var Mask_1;
var hasRequiredMask$1;

function requireMask$1 () {
	if (hasRequiredMask$1) return Mask_1;
	hasRequiredMask$1 = 1;
	var BitmapMask = requireBitmapMask();
	var GeometryMask = requireGeometryMask();

	var Mask = {

	    mask: null,

	    setMask: function (mask)
	    {
	        this.mask = mask;

	        return this;
	    },

	    clearMask: function (destroyMask)
	    {
	        if (destroyMask === undefined) { destroyMask = false; }

	        if (destroyMask && this.mask)
	        {
	            this.mask.destroy();
	        }

	        this.mask = null;

	        return this;
	    },

	    createBitmapMask: function (maskObject, x, y, texture, frame)
	    {
	        if (maskObject === undefined && (this.texture || this.shader || this.geom))
	        {

	            maskObject = this;
	        }

	        return new BitmapMask(this.scene, maskObject, x, y, texture, frame);
	    },

	    createGeometryMask: function (graphics)
	    {
	        if (graphics === undefined && (this.type === 'Graphics' || this.geom))
	        {

	            graphics = this;
	        }

	        return new GeometryMask(this.scene, graphics);
	    }

	};

	Mask_1 = Mask;
	return Mask_1;
}

var Origin_1;
var hasRequiredOrigin;

function requireOrigin () {
	if (hasRequiredOrigin) return Origin_1;
	hasRequiredOrigin = 1;
	var Origin = {

	    _originComponent: true,

	    originX: 0.5,

	    originY: 0.5,

	    _displayOriginX: 0,
	    _displayOriginY: 0,

	    displayOriginX: {

	        get: function ()
	        {
	            return this._displayOriginX;
	        },

	        set: function (value)
	        {
	            this._displayOriginX = value;
	            this.originX = value / this.width;
	        }

	    },

	    displayOriginY: {

	        get: function ()
	        {
	            return this._displayOriginY;
	        },

	        set: function (value)
	        {
	            this._displayOriginY = value;
	            this.originY = value / this.height;
	        }

	    },

	    setOrigin: function (x, y)
	    {
	        if (x === undefined) { x = 0.5; }
	        if (y === undefined) { y = x; }

	        this.originX = x;
	        this.originY = y;

	        return this.updateDisplayOrigin();
	    },

	    setOriginFromFrame: function ()
	    {
	        if (!this.frame || !this.frame.customPivot)
	        {
	            return this.setOrigin();
	        }
	        else
	        {
	            this.originX = this.frame.pivotX;
	            this.originY = this.frame.pivotY;
	        }

	        return this.updateDisplayOrigin();
	    },

	    setDisplayOrigin: function (x, y)
	    {
	        if (x === undefined) { x = 0; }
	        if (y === undefined) { y = x; }

	        this.displayOriginX = x;
	        this.displayOriginY = y;

	        return this;
	    },

	    updateDisplayOrigin: function ()
	    {
	        this._displayOriginX = this.originX * this.width;
	        this._displayOriginY = this.originY * this.height;

	        return this;
	    }

	};

	Origin_1 = Origin;
	return Origin_1;
}

var DegToRad_1;
var hasRequiredDegToRad;

function requireDegToRad () {
	if (hasRequiredDegToRad) return DegToRad_1;
	hasRequiredDegToRad = 1;
	var CONST = require_const$c();

	var DegToRad = function (degrees)
	{
	    return degrees * CONST.DEG_TO_RAD;
	};

	DegToRad_1 = DegToRad;
	return DegToRad_1;
}

var GetBoolean_1;
var hasRequiredGetBoolean;

function requireGetBoolean () {
	if (hasRequiredGetBoolean) return GetBoolean_1;
	hasRequiredGetBoolean = 1;
	var GetBoolean = function (source, key, defaultValue)
	{
	    if (!source)
	    {
	        return defaultValue;
	    }
	    else if (source.hasOwnProperty(key))
	    {
	        return source[key];
	    }
	    else
	    {
	        return defaultValue;
	    }
	};

	GetBoolean_1 = GetBoolean;
	return GetBoolean_1;
}

var _const$a;
var hasRequired_const$a;

function require_const$a () {
	if (hasRequired_const$a) return _const$a;
	hasRequired_const$a = 1;
	var TWEEN_CONST = {

	    CREATED: 0,

	    DELAY: 2,

	    PENDING_RENDER: 4,

	    PLAYING_FORWARD: 5,

	    PLAYING_BACKWARD: 6,

	    HOLD_DELAY: 7,

	    REPEAT_DELAY: 8,

	    COMPLETE: 9,

	    PENDING: 20,

	    ACTIVE: 21,

	    LOOP_DELAY: 22,

	    COMPLETE_DELAY: 23,

	    START_DELAY: 24,

	    PENDING_REMOVE: 25,

	    REMOVED: 26,

	    FINISHED: 27,

	    DESTROYED: 28,

	    MAX: 999999999999

	};

	_const$a = TWEEN_CONST;
	return _const$a;
}

var PathFollower_1$1;
var hasRequiredPathFollower$1;

function requirePathFollower$1 () {
	if (hasRequiredPathFollower$1) return PathFollower_1$1;
	hasRequiredPathFollower$1 = 1;
	var DegToRad = requireDegToRad();
	var GetBoolean = requireGetBoolean();
	var GetValue = requireGetValue();
	var TWEEN_CONST = require_const$a();
	var Vector2 = requireVector2();

	var PathFollower = {

	    path: null,

	    rotateToPath: false,

	    pathRotationOffset: 0,

	    pathOffset: null,

	    pathVector: null,

	    pathDelta: null,

	    pathTween: null,

	    pathConfig: null,

	    _prevDirection: TWEEN_CONST.PLAYING_FORWARD,

	    setPath: function (path, config)
	    {
	        if (config === undefined) { config = this.pathConfig; }

	        var tween = this.pathTween;

	        if (tween && tween.isPlaying())
	        {
	            tween.stop();
	        }

	        this.path = path;

	        if (config)
	        {
	            this.startFollow(config);
	        }

	        return this;
	    },

	    setRotateToPath: function (value, offset)
	    {
	        if (offset === undefined) { offset = 0; }

	        this.rotateToPath = value;

	        this.pathRotationOffset = offset;

	        return this;
	    },

	    isFollowing: function ()
	    {
	        var tween = this.pathTween;

	        return (tween && tween.isPlaying());
	    },

	    startFollow: function (config, startAt)
	    {
	        if (config === undefined) { config = {}; }
	        if (startAt === undefined) { startAt = 0; }

	        var tween = this.pathTween;

	        if (tween && tween.isPlaying())
	        {
	            tween.stop();
	        }

	        if (typeof config === 'number')
	        {
	            config = { duration: config };
	        }

	        config.from = GetValue(config, 'from', 0);
	        config.to = GetValue(config, 'to', 1);

	        var positionOnPath = GetBoolean(config, 'positionOnPath', false);

	        this.rotateToPath = GetBoolean(config, 'rotateToPath', false);
	        this.pathRotationOffset = GetValue(config, 'rotationOffset', 0);

	        var seek = GetValue(config, 'startAt', startAt);

	        if (seek)
	        {
	            config.onStart = function (tween)
	            {
	                var tweenData = tween.data[0];
	                tweenData.progress = seek;
	                tweenData.elapsed = tweenData.duration * seek;
	                var v = tweenData.ease(tweenData.progress);
	                tweenData.current = tweenData.start + ((tweenData.end - tweenData.start) * v);
	                tweenData.setTargetValue();
	            };
	        }

	        if (!this.pathOffset)
	        {
	            this.pathOffset = new Vector2(this.x, this.y);
	        }

	        if (!this.pathVector)
	        {
	            this.pathVector = new Vector2();
	        }

	        if (!this.pathDelta)
	        {
	            this.pathDelta = new Vector2();
	        }

	        this.pathDelta.reset();

	        config.persist = true;

	        this.pathTween = this.scene.sys.tweens.addCounter(config);

	        this.path.getStartPoint(this.pathOffset);

	        if (positionOnPath)
	        {
	            this.x = this.pathOffset.x;
	            this.y = this.pathOffset.y;
	        }

	        this.pathOffset.x = this.x - this.pathOffset.x;
	        this.pathOffset.y = this.y - this.pathOffset.y;

	        this._prevDirection = TWEEN_CONST.PLAYING_FORWARD;

	        if (this.rotateToPath)
	        {

	            var nextPoint = this.path.getPoint(0.1);

	            this.rotation = Math.atan2(nextPoint.y - this.y, nextPoint.x - this.x) + DegToRad(this.pathRotationOffset);
	        }

	        this.pathConfig = config;

	        return this;
	    },

	    pauseFollow: function ()
	    {
	        var tween = this.pathTween;

	        if (tween && tween.isPlaying())
	        {
	            tween.pause();
	        }

	        return this;
	    },

	    resumeFollow: function ()
	    {
	        var tween = this.pathTween;

	        if (tween && tween.isPaused())
	        {
	            tween.resume();
	        }

	        return this;
	    },

	    stopFollow: function ()
	    {
	        var tween = this.pathTween;

	        if (tween && tween.isPlaying())
	        {
	            tween.stop();
	        }

	        return this;
	    },

	    pathUpdate: function ()
	    {
	        var tween = this.pathTween;

	        if (tween && tween.data)
	        {
	            var tweenData = tween.data[0];
	            var pathDelta = this.pathDelta;
	            var pathVector = this.pathVector;

	            pathDelta.copy(pathVector).negate();

	            if (tweenData.state === TWEEN_CONST.COMPLETE)
	            {
	                this.path.getPoint(tweenData.end, pathVector);

	                pathDelta.add(pathVector);
	                pathVector.add(this.pathOffset);

	                this.setPosition(pathVector.x, pathVector.y);

	                return;
	            }
	            else if (tweenData.state !== TWEEN_CONST.PLAYING_FORWARD && tweenData.state !== TWEEN_CONST.PLAYING_BACKWARD)
	            {

	                return;
	            }

	            this.path.getPoint(tween.getValue(), pathVector);

	            pathDelta.add(pathVector);
	            pathVector.add(this.pathOffset);

	            var oldX = this.x;
	            var oldY = this.y;

	            this.setPosition(pathVector.x, pathVector.y);

	            var speedX = this.x - oldX;
	            var speedY = this.y - oldY;

	            if (speedX === 0 && speedY === 0)
	            {

	                return;
	            }

	            if (tweenData.state !== this._prevDirection)
	            {

	                this._prevDirection = tweenData.state;

	                return;
	            }

	            if (this.rotateToPath)
	            {
	                this.rotation = Math.atan2(speedY, speedX) + DegToRad(this.pathRotationOffset);
	            }
	        }
	    }

	};

	PathFollower_1$1 = PathFollower;
	return PathFollower_1$1;
}

var DeepCopy_1;
var hasRequiredDeepCopy;

function requireDeepCopy () {
	if (hasRequiredDeepCopy) return DeepCopy_1;
	hasRequiredDeepCopy = 1;
	var DeepCopy = function (inObject)
	{
	    var outObject;
	    var value;
	    var key;

	    if (typeof inObject !== 'object' || inObject === null)
	    {

	        return inObject;
	    }

	    outObject = Array.isArray(inObject) ? [] : {};

	    for (key in inObject)
	    {
	        value = inObject[key];

	        outObject[key] = DeepCopy(value);
	    }

	    return outObject;
	};

	DeepCopy_1 = DeepCopy;
	return DeepCopy_1;
}

var Pipeline_1;
var hasRequiredPipeline;

function requirePipeline () {
	if (hasRequiredPipeline) return Pipeline_1;
	hasRequiredPipeline = 1;
	var DeepCopy = requireDeepCopy();

	var Pipeline = {

	    defaultPipeline: null,

	    pipeline: null,

	    pipelineData: null,

	    initPipeline: function (pipeline)
	    {
	        this.pipelineData = {};

	        var renderer = this.scene.sys.renderer;

	        if (!renderer)
	        {
	            return false;
	        }

	        var pipelines = renderer.pipelines;

	        if (pipelines)
	        {
	            if (pipeline === undefined)
	            {
	                pipeline = pipelines.default;
	            }

	            var instance = pipelines.get(pipeline);

	            if (instance)
	            {
	                this.defaultPipeline = instance;
	                this.pipeline = instance;

	                return true;
	            }
	        }

	        return false;
	    },

	    setPipeline: function (pipeline, pipelineData, copyData)
	    {
	        var renderer = this.scene.sys.renderer;

	        if (!renderer)
	        {
	            return this;
	        }

	        var pipelines = renderer.pipelines;

	        if (pipelines)
	        {
	            var instance = pipelines.get(pipeline);

	            if (instance)
	            {
	                this.pipeline = instance;
	            }

	            if (pipelineData)
	            {
	                this.pipelineData = (copyData) ? DeepCopy(pipelineData) : pipelineData;
	            }
	        }

	        return this;
	    },

	    setPipelineData: function (key, value)
	    {
	        var data = this.pipelineData;

	        if (value === undefined)
	        {
	            delete data[key];
	        }
	        else
	        {
	            data[key] = value;
	        }

	        return this;
	    },

	    resetPipeline: function (resetData)
	    {
	        if (resetData === undefined) { resetData = false; }

	        this.pipeline = this.defaultPipeline;

	        if (resetData)
	        {
	            this.pipelineData = {};
	        }

	        return (this.pipeline !== null);
	    },

	    getPipelineName: function ()
	    {
	        return (this.pipeline === null) ? null : this.pipeline.name;
	    }

	};

	Pipeline_1 = Pipeline;
	return Pipeline_1;
}

var PostPipeline_1;
var hasRequiredPostPipeline;

function requirePostPipeline () {
	if (hasRequiredPostPipeline) return PostPipeline_1;
	hasRequiredPostPipeline = 1;
	var DeepCopy = requireDeepCopy();
	var FX = requireFX();
	var SpliceOne = requireSpliceOne();

	var PostPipeline = {

	    hasPostPipeline: false,

	    postPipelines: null,

	    postPipelineData: null,

	    preFX: null,

	    postFX: null,

	    initPostPipeline: function (preFX)
	    {
	        this.postPipelines = [];
	        this.postPipelineData = {};

	        this.postFX = new FX(this, true);

	        if (preFX)
	        {
	            this.preFX = new FX(this, false);
	        }
	    },

	    setPostPipeline: function (pipelines, pipelineData, copyData)
	    {
	        var renderer = this.scene.sys.renderer;

	        if (!renderer)
	        {
	            return this;
	        }

	        var pipelineManager = renderer.pipelines;

	        if (pipelineManager)
	        {
	            if (!Array.isArray(pipelines))
	            {
	                pipelines = [ pipelines ];
	            }

	            for (var i = 0; i < pipelines.length; i++)
	            {
	                var instance = pipelineManager.getPostPipeline(pipelines[i], this, pipelineData);

	                if (instance)
	                {
	                    this.postPipelines.push(instance);
	                }
	            }

	            if (pipelineData)
	            {
	                this.postPipelineData = (copyData) ? DeepCopy(pipelineData) : pipelineData;
	            }
	        }

	        this.hasPostPipeline = (this.postPipelines.length > 0);

	        return this;
	    },

	    setPostPipelineData: function (key, value)
	    {
	        var data = this.postPipelineData;

	        if (value === undefined)
	        {
	            delete data[key];
	        }
	        else
	        {
	            data[key] = value;
	        }

	        return this;
	    },

	    getPostPipeline: function (pipeline)
	    {
	        var isString = (typeof pipeline === 'string');

	        var pipelines = this.postPipelines;

	        var results = [];

	        for (var i = 0; i < pipelines.length; i++)
	        {
	            var instance = pipelines[i];

	            if ((isString && instance.name === pipeline) || (!isString && instance instanceof pipeline))
	            {
	                results.push(instance);
	            }
	        }

	        return (results.length === 1) ? results[0] : results;
	    },

	    resetPostPipeline: function (resetData)
	    {
	        if (resetData === undefined) { resetData = false; }

	        var pipelines = this.postPipelines;

	        for (var i = 0; i < pipelines.length; i++)
	        {
	            pipelines[i].destroy();
	        }

	        this.postPipelines = [];
	        this.hasPostPipeline = false;

	        if (resetData)
	        {
	            this.postPipelineData = {};
	        }
	    },

	    removePostPipeline: function (pipeline)
	    {
	        var isString = (typeof pipeline === 'string');

	        var pipelines = this.postPipelines;

	        for (var i = pipelines.length - 1; i >= 0; i--)
	        {
	            var instance = pipelines[i];

	            if (
	                (isString && instance.name === pipeline) ||
	                (!isString && instance === pipeline))
	            {
	                instance.destroy();

	                SpliceOne(pipelines, i);
	            }
	        }

	        this.hasPostPipeline = (this.postPipelines.length > 0);

	        return this;
	    },

	    clearFX: function ()
	    {
	        if (this.preFX)
	        {
	            this.preFX.clear();
	        }

	        if (this.postFX)
	        {
	            this.postFX.clear();
	        }

	        return this;
	    }

	};

	PostPipeline_1 = PostPipeline;
	return PostPipeline_1;
}

var ScrollFactor_1;
var hasRequiredScrollFactor;

function requireScrollFactor () {
	if (hasRequiredScrollFactor) return ScrollFactor_1;
	hasRequiredScrollFactor = 1;
	var ScrollFactor = {

	    scrollFactorX: 1,

	    scrollFactorY: 1,

	    setScrollFactor: function (x, y)
	    {
	        if (y === undefined) { y = x; }

	        this.scrollFactorX = x;
	        this.scrollFactorY = y;

	        return this;
	    }

	};

	ScrollFactor_1 = ScrollFactor;
	return ScrollFactor_1;
}

var Size_1$2;
var hasRequiredSize$2;

function requireSize$2 () {
	if (hasRequiredSize$2) return Size_1$2;
	hasRequiredSize$2 = 1;
	var Size = {

	    _sizeComponent: true,

	    width: 0,

	    height: 0,

	    displayWidth: {

	        get: function ()
	        {
	            return Math.abs(this.scaleX * this.frame.realWidth);
	        },

	        set: function (value)
	        {
	            this.scaleX = value / this.frame.realWidth;
	        }

	    },

	    displayHeight: {

	        get: function ()
	        {
	            return Math.abs(this.scaleY * this.frame.realHeight);
	        },

	        set: function (value)
	        {
	            this.scaleY = value / this.frame.realHeight;
	        }

	    },

	    setSizeToFrame: function (frame)
	    {
	        if (!frame) { frame = this.frame; }

	        this.width = frame.realWidth;
	        this.height = frame.realHeight;

	        var input = this.input;

	        if (input && !input.customHitArea)
	        {
	            input.hitArea.width = this.width;
	            input.hitArea.height = this.height;
	        }

	        return this;
	    },

	    setSize: function (width, height)
	    {
	        this.width = width;
	        this.height = height;

	        return this;
	    },

	    setDisplaySize: function (width, height)
	    {
	        this.displayWidth = width;
	        this.displayHeight = height;

	        return this;
	    }

	};

	Size_1$2 = Size;
	return Size_1$2;
}

var Frame_1;
var hasRequiredFrame;

function requireFrame () {
	if (hasRequiredFrame) return Frame_1;
	hasRequiredFrame = 1;
	var Class = requireClass();
	var Clamp = requireClamp();
	var Extend = requireExtend$1();

	var Frame = new Class({

	    initialize:

	    function Frame (texture, name, sourceIndex, x, y, width, height)
	    {

	        this.texture = texture;

	        this.name = name;

	        this.source = texture.source[sourceIndex];

	        this.sourceIndex = sourceIndex;

	        this.cutX;

	        this.cutY;

	        this.cutWidth;

	        this.cutHeight;

	        this.x = 0;

	        this.y = 0;

	        this.width;

	        this.height;

	        this.halfWidth;

	        this.halfHeight;

	        this.centerX;

	        this.centerY;

	        this.pivotX = 0;

	        this.pivotY = 0;

	        this.customPivot = false;

	        this.rotated = false;

	        this.autoRound = -1;

	        this.customData = {};

	        this.u0 = 0;

	        this.v0 = 0;

	        this.u1 = 0;

	        this.v1 = 0;

	        this.data = {
	            cut: {
	                x: 0,
	                y: 0,
	                w: 0,
	                h: 0,
	                r: 0,
	                b: 0
	            },
	            trim: false,
	            sourceSize: {
	                w: 0,
	                h: 0
	            },
	            spriteSourceSize: {
	                x: 0,
	                y: 0,
	                w: 0,
	                h: 0,
	                r: 0,
	                b: 0
	            },
	            radius: 0,
	            drawImage: {
	                x: 0,
	                y: 0,
	                width: 0,
	                height: 0
	            },
	            is3Slice: false,
	            scale9: false,
	            scale9Borders: {
	                x: 0,
	                y: 0,
	                w: 0,
	                h: 0
	            }
	        };

	        this.setSize(width, height, x, y);
	    },

	    setCutPosition: function (x, y)
	    {
	        if (x === undefined) { x = 0; }
	        if (y === undefined) { y = 0; }

	        this.cutX = x;
	        this.cutY = y;

	        return this.updateUVs();
	    },

	    setCutSize: function (width, height)
	    {
	        this.cutWidth = width;
	        this.cutHeight = height;

	        return this.updateUVs();
	    },

	    setSize: function (width, height, x, y)
	    {
	        if (x === undefined) { x = 0; }
	        if (y === undefined) { y = 0; }

	        this.setCutPosition(x, y);
	        this.setCutSize(width, height);

	        this.width = width;
	        this.height = height;

	        this.halfWidth = Math.floor(width * 0.5);
	        this.halfHeight = Math.floor(height * 0.5);

	        this.centerX = Math.floor(width / 2);
	        this.centerY = Math.floor(height / 2);

	        var data = this.data;
	        var cut = data.cut;

	        cut.x = x;
	        cut.y = y;
	        cut.w = width;
	        cut.h = height;
	        cut.r = x + width;
	        cut.b = y + height;

	        data.sourceSize.w = width;
	        data.sourceSize.h = height;

	        data.spriteSourceSize.w = width;
	        data.spriteSourceSize.h = height;

	        data.radius = 0.5 * Math.sqrt(width * width + height * height);

	        var drawImage = data.drawImage;

	        drawImage.x = x;
	        drawImage.y = y;
	        drawImage.width = width;
	        drawImage.height = height;

	        return this.updateUVs();
	    },

	    setTrim: function (actualWidth, actualHeight, destX, destY, destWidth, destHeight)
	    {
	        var data = this.data;
	        var ss = data.spriteSourceSize;

	        data.trim = true;

	        data.sourceSize.w = actualWidth;
	        data.sourceSize.h = actualHeight;

	        ss.x = destX;
	        ss.y = destY;
	        ss.w = destWidth;
	        ss.h = destHeight;
	        ss.r = destX + destWidth;
	        ss.b = destY + destHeight;

	        this.x = destX;
	        this.y = destY;

	        this.width = destWidth;
	        this.height = destHeight;

	        this.halfWidth = destWidth * 0.5;
	        this.halfHeight = destHeight * 0.5;

	        this.centerX = Math.floor(destWidth / 2);
	        this.centerY = Math.floor(destHeight / 2);

	        return this.updateUVs();
	    },

	    setScale9: function (x, y, width, height)
	    {
	        var data = this.data;

	        data.scale9 = true;
	        data.is3Slice = (y === 0 && height === this.height);

	        data.scale9Borders.x = x;
	        data.scale9Borders.y = y;
	        data.scale9Borders.w = width;
	        data.scale9Borders.h = height;

	        return this;
	    },

	    setCropUVs: function (crop, x, y, width, height, flipX, flipY)
	    {

	        var cx = this.cutX;
	        var cy = this.cutY;
	        var cw = this.cutWidth;
	        var ch = this.cutHeight;
	        var rw = this.realWidth;
	        var rh = this.realHeight;

	        x = Clamp(x, 0, rw);
	        y = Clamp(y, 0, rh);

	        width = Clamp(width, 0, rw - x);
	        height = Clamp(height, 0, rh - y);

	        var ox = cx + x;
	        var oy = cy + y;
	        var ow = width;
	        var oh = height;

	        var data = this.data;

	        if (data.trim)
	        {
	            var ss = data.spriteSourceSize;

	            width = Clamp(width, 0, ss.x + cw - x);
	            height = Clamp(height, 0, ss.y + ch - y);

	            var cropRight = x + width;
	            var cropBottom = y + height;

	            var intersects = !(ss.r < x || ss.b < y || ss.x > cropRight || ss.y > cropBottom);

	            if (intersects)
	            {
	                var ix = Math.max(ss.x, x);
	                var iy = Math.max(ss.y, y);
	                var iw = Math.min(ss.r, cropRight) - ix;
	                var ih = Math.min(ss.b, cropBottom) - iy;

	                ow = iw;
	                oh = ih;

	                if (flipX)
	                {
	                    ox = cx + (cw - (ix - ss.x) - iw);
	                }
	                else
	                {
	                    ox = cx + (ix - ss.x);
	                }

	                if (flipY)
	                {
	                    oy = cy + (ch - (iy - ss.y) - ih);
	                }
	                else
	                {
	                    oy = cy + (iy - ss.y);
	                }

	                x = ix;
	                y = iy;

	                width = iw;
	                height = ih;
	            }
	            else
	            {
	                ox = 0;
	                oy = 0;
	                ow = 0;
	                oh = 0;
	            }
	        }
	        else
	        {
	            if (flipX)
	            {
	                ox = cx + (cw - x - width);
	            }

	            if (flipY)
	            {
	                oy = cy + (ch - y - height);
	            }
	        }

	        var tw = this.source.width;
	        var th = this.source.height;

	        crop.u0 = Math.max(0, ox / tw);
	        crop.v0 = Math.max(0, oy / th);
	        crop.u1 = Math.min(1, (ox + ow) / tw);
	        crop.v1 = Math.min(1, (oy + oh) / th);

	        crop.x = x;
	        crop.y = y;

	        crop.cx = ox;
	        crop.cy = oy;
	        crop.cw = ow;
	        crop.ch = oh;

	        crop.width = width;
	        crop.height = height;

	        crop.flipX = flipX;
	        crop.flipY = flipY;

	        return crop;
	    },

	    updateCropUVs: function (crop, flipX, flipY)
	    {
	        return this.setCropUVs(crop, crop.x, crop.y, crop.width, crop.height, flipX, flipY);
	    },

	    setUVs: function (width, height, u0, v0, u1, v1)
	    {

	        var cd = this.data.drawImage;

	        cd.width = width;
	        cd.height = height;

	        this.u0 = u0;
	        this.v0 = v0;

	        this.u1 = u1;
	        this.v1 = v1;

	        return this;
	    },

	    updateUVs: function ()
	    {
	        var cx = this.cutX;
	        var cy = this.cutY;
	        var cw = this.cutWidth;
	        var ch = this.cutHeight;

	        var cd = this.data.drawImage;

	        cd.width = cw;
	        cd.height = ch;

	        var tw = this.source.width;
	        var th = this.source.height;

	        this.u0 = cx / tw;
	        this.v0 = cy / th;

	        this.u1 = (cx + cw) / tw;
	        this.v1 = (cy + ch) / th;

	        return this;
	    },

	    updateUVsInverted: function ()
	    {
	        var tw = this.source.width;
	        var th = this.source.height;

	        this.u0 = (this.cutX + this.cutHeight) / tw;
	        this.v0 = this.cutY / th;

	        this.u1 = this.cutX / tw;
	        this.v1 = (this.cutY + this.cutWidth) / th;

	        return this;
	    },

	    clone: function ()
	    {
	        var clone = new Frame(this.texture, this.name, this.sourceIndex);

	        clone.cutX = this.cutX;
	        clone.cutY = this.cutY;
	        clone.cutWidth = this.cutWidth;
	        clone.cutHeight = this.cutHeight;

	        clone.x = this.x;
	        clone.y = this.y;

	        clone.width = this.width;
	        clone.height = this.height;

	        clone.halfWidth = this.halfWidth;
	        clone.halfHeight = this.halfHeight;

	        clone.centerX = this.centerX;
	        clone.centerY = this.centerY;

	        clone.rotated = this.rotated;

	        clone.data = Extend(true, clone.data, this.data);

	        clone.updateUVs();

	        return clone;
	    },

	    destroy: function ()
	    {
	        this.texture = null;
	        this.source = null;
	        this.customData = null;
	        this.data = null;
	    },

	    glTexture: {

	        get: function ()
	        {
	            return this.source.glTexture;
	        }
	    },

	    realWidth: {

	        get: function ()
	        {
	            return this.data.sourceSize.w;
	        }

	    },

	    realHeight: {

	        get: function ()
	        {
	            return this.data.sourceSize.h;
	        }

	    },

	    radius: {

	        get: function ()
	        {
	            return this.data.radius;
	        }

	    },

	    trimmed: {

	        get: function ()
	        {
	            return this.data.trim;
	        }

	    },

	    scale9: {

	        get: function ()
	        {
	            return this.data.scale9;
	        }

	    },

	    is3Slice: {

	        get: function ()
	        {
	            return this.data.is3Slice;
	        }

	    },

	    canvasData: {

	        get: function ()
	        {
	            return this.data.drawImage;
	        }

	    }

	});

	Frame_1 = Frame;
	return Frame_1;
}

var Texture_1$1;
var hasRequiredTexture$1;

function requireTexture$1 () {
	if (hasRequiredTexture$1) return Texture_1$1;
	hasRequiredTexture$1 = 1;
	var Frame = requireFrame();

	var _FLAG = 8; 

	var Texture = {

	    texture: null,

	    frame: null,

	    isCropped: false,

	    setTexture: function (key, frame, updateSize, updateOrigin)
	    {
	        this.texture = this.scene.sys.textures.get(key);

	        return this.setFrame(frame, updateSize, updateOrigin);
	    },

	    setFrame: function (frame, updateSize, updateOrigin)
	    {
	        if (updateSize === undefined) { updateSize = true; }
	        if (updateOrigin === undefined) { updateOrigin = true; }

	        if (frame instanceof Frame)
	        {
	            this.texture = this.scene.sys.textures.get(frame.texture.key);

	            this.frame = frame;
	        }
	        else
	        {
	            this.frame = this.texture.get(frame);
	        }

	        if (!this.frame.cutWidth || !this.frame.cutHeight)
	        {
	            this.renderFlags &= ~_FLAG;
	        }
	        else
	        {
	            this.renderFlags |= _FLAG;
	        }

	        if (this._sizeComponent && updateSize)
	        {
	            this.setSizeToFrame();
	        }

	        if (this._originComponent && updateOrigin)
	        {
	            if (this.frame.customPivot)
	            {
	                this.setOrigin(this.frame.pivotX, this.frame.pivotY);
	            }
	            else
	            {
	                this.updateDisplayOrigin();
	            }
	        }

	        return this;
	    }

	};

	Texture_1$1 = Texture;
	return Texture_1$1;
}

var TextureCrop_1;
var hasRequiredTextureCrop;

function requireTextureCrop () {
	if (hasRequiredTextureCrop) return TextureCrop_1;
	hasRequiredTextureCrop = 1;
	var Frame = requireFrame();

	var _FLAG = 8; 

	var TextureCrop = {

	    texture: null,

	    frame: null,

	    isCropped: false,

	    setCrop: function (x, y, width, height)
	    {
	        if (x === undefined)
	        {
	            this.isCropped = false;
	        }
	        else if (this.frame)
	        {
	            if (typeof x === 'number')
	            {
	                this.frame.setCropUVs(this._crop, x, y, width, height, this.flipX, this.flipY);
	            }
	            else
	            {
	                var rect = x;

	                this.frame.setCropUVs(this._crop, rect.x, rect.y, rect.width, rect.height, this.flipX, this.flipY);
	            }

	            this.isCropped = true;
	        }

	        return this;
	    },

	    setTexture: function (key, frame)
	    {
	        this.texture = this.scene.sys.textures.get(key);

	        return this.setFrame(frame);
	    },

	    setFrame: function (frame, updateSize, updateOrigin)
	    {
	        if (updateSize === undefined) { updateSize = true; }
	        if (updateOrigin === undefined) { updateOrigin = true; }

	        if (frame instanceof Frame)
	        {
	            this.texture = this.scene.sys.textures.get(frame.texture.key);

	            this.frame = frame;
	        }
	        else
	        {
	            this.frame = this.texture.get(frame);
	        }

	        if (!this.frame.cutWidth || !this.frame.cutHeight)
	        {
	            this.renderFlags &= ~_FLAG;
	        }
	        else
	        {
	            this.renderFlags |= _FLAG;
	        }

	        if (this._sizeComponent && updateSize)
	        {
	            this.setSizeToFrame();
	        }

	        if (this._originComponent && updateOrigin)
	        {
	            if (this.frame.customPivot)
	            {
	                this.setOrigin(this.frame.pivotX, this.frame.pivotY);
	            }
	            else
	            {
	                this.updateDisplayOrigin();
	            }
	        }

	        if (this.isCropped)
	        {
	            this.frame.updateCropUVs(this._crop, this.flipX, this.flipY);
	        }

	        return this;
	    },

	    resetCropObject: function ()
	    {
	        return { u0: 0, v0: 0, u1: 0, v1: 0, width: 0, height: 0, x: 0, y: 0, flipX: false, flipY: false, cx: 0, cy: 0, cw: 0, ch: 0 };
	    }

	};

	TextureCrop_1 = TextureCrop;
	return TextureCrop_1;
}

var Tint_1;
var hasRequiredTint;

function requireTint () {
	if (hasRequiredTint) return Tint_1;
	hasRequiredTint = 1;
	var Tint = {

	    tintTopLeft: 0xffffff,

	    tintTopRight: 0xffffff,

	    tintBottomLeft: 0xffffff,

	    tintBottomRight: 0xffffff,

	    tintFill: false,

	    clearTint: function ()
	    {
	        this.setTint(0xffffff);

	        return this;
	    },

	    setTint: function (topLeft, topRight, bottomLeft, bottomRight)
	    {
	        if (topLeft === undefined) { topLeft = 0xffffff; }

	        if (topRight === undefined)
	        {
	            topRight = topLeft;
	            bottomLeft = topLeft;
	            bottomRight = topLeft;
	        }

	        this.tintTopLeft = topLeft;
	        this.tintTopRight = topRight;
	        this.tintBottomLeft = bottomLeft;
	        this.tintBottomRight = bottomRight;

	        this.tintFill = false;

	        return this;
	    },

	    setTintFill: function (topLeft, topRight, bottomLeft, bottomRight)
	    {
	        this.setTint(topLeft, topRight, bottomLeft, bottomRight);

	        this.tintFill = true;

	        return this;
	    },

	    tint: {

	        get: function ()
	        {
	            return this.tintTopLeft;
	        },

	        set: function (value)
	        {
	            this.setTint(value, value, value, value);
	        }
	    },

	    isTinted: {

	        get: function ()
	        {
	            var white = 0xffffff;

	            return (
	                this.tintFill ||
	                this.tintTopLeft !== white ||
	                this.tintTopRight !== white ||
	                this.tintBottomLeft !== white ||
	                this.tintBottomRight !== white
	            );
	        }

	    }

	};

	Tint_1 = Tint;
	return Tint_1;
}

var ToJSON_1;
var hasRequiredToJSON;

function requireToJSON () {
	if (hasRequiredToJSON) return ToJSON_1;
	hasRequiredToJSON = 1;
	var ToJSON = function (gameObject)
	{
	    var out = {
	        name: gameObject.name,
	        type: gameObject.type,
	        x: gameObject.x,
	        y: gameObject.y,
	        depth: gameObject.depth,
	        scale: {
	            x: gameObject.scaleX,
	            y: gameObject.scaleY
	        },
	        origin: {
	            x: gameObject.originX,
	            y: gameObject.originY
	        },
	        flipX: gameObject.flipX,
	        flipY: gameObject.flipY,
	        rotation: gameObject.rotation,
	        alpha: gameObject.alpha,
	        visible: gameObject.visible,
	        blendMode: gameObject.blendMode,
	        textureKey: '',
	        frameKey: '',
	        data: {}
	    };

	    if (gameObject.texture)
	    {
	        out.textureKey = gameObject.texture.key;
	        out.frameKey = gameObject.frame.name;
	    }

	    return out;
	};

	ToJSON_1 = ToJSON;
	return ToJSON_1;
}

var TransformMatrix_1;
var hasRequiredTransformMatrix;

function requireTransformMatrix () {
	if (hasRequiredTransformMatrix) return TransformMatrix_1;
	hasRequiredTransformMatrix = 1;
	var Class = requireClass();
	var MATH_CONST = require_const$c();
	var Vector2 = requireVector2();

	var TransformMatrix = new Class({

	    initialize:

	    function TransformMatrix (a, b, c, d, tx, ty)
	    {
	        if (a === undefined) { a = 1; }
	        if (b === undefined) { b = 0; }
	        if (c === undefined) { c = 0; }
	        if (d === undefined) { d = 1; }
	        if (tx === undefined) { tx = 0; }
	        if (ty === undefined) { ty = 0; }

	        this.matrix = new Float32Array([ a, b, c, d, tx, ty, 0, 0, 1 ]);

	        this.decomposedMatrix = {
	            translateX: 0,
	            translateY: 0,
	            scaleX: 1,
	            scaleY: 1,
	            rotation: 0
	        };

	        this.quad = new Float32Array(8);
	    },

	    a: {

	        get: function ()
	        {
	            return this.matrix[0];
	        },

	        set: function (value)
	        {
	            this.matrix[0] = value;
	        }

	    },

	    b: {

	        get: function ()
	        {
	            return this.matrix[1];
	        },

	        set: function (value)
	        {
	            this.matrix[1] = value;
	        }

	    },

	    c: {

	        get: function ()
	        {
	            return this.matrix[2];
	        },

	        set: function (value)
	        {
	            this.matrix[2] = value;
	        }

	    },

	    d: {

	        get: function ()
	        {
	            return this.matrix[3];
	        },

	        set: function (value)
	        {
	            this.matrix[3] = value;
	        }

	    },

	    e: {

	        get: function ()
	        {
	            return this.matrix[4];
	        },

	        set: function (value)
	        {
	            this.matrix[4] = value;
	        }

	    },

	    f: {

	        get: function ()
	        {
	            return this.matrix[5];
	        },

	        set: function (value)
	        {
	            this.matrix[5] = value;
	        }

	    },

	    tx: {

	        get: function ()
	        {
	            return this.matrix[4];
	        },

	        set: function (value)
	        {
	            this.matrix[4] = value;
	        }

	    },

	    ty: {

	        get: function ()
	        {
	            return this.matrix[5];
	        },

	        set: function (value)
	        {
	            this.matrix[5] = value;
	        }

	    },

	    rotation: {

	        get: function ()
	        {
	            return Math.acos(this.a / this.scaleX) * ((Math.atan(-this.c / this.a) < 0) ? -1 : 1);
	        }

	    },

	    rotationNormalized: {

	        get: function ()
	        {
	            var matrix = this.matrix;

	            var a = matrix[0];
	            var b = matrix[1];
	            var c = matrix[2];
	            var d = matrix[3];

	            if (a || b)
	            {

	                return (b > 0) ? Math.acos(a / this.scaleX) : -Math.acos(a / this.scaleX);
	            }
	            else if (c || d)
	            {

	                return MATH_CONST.TAU - ((d > 0) ? Math.acos(-c / this.scaleY) : -Math.acos(c / this.scaleY));
	            }
	            else
	            {
	                return 0;
	            }
	        }

	    },

	    scaleX: {

	        get: function ()
	        {
	            return Math.sqrt((this.a * this.a) + (this.b * this.b));
	        }

	    },

	    scaleY: {

	        get: function ()
	        {
	            return Math.sqrt((this.c * this.c) + (this.d * this.d));
	        }

	    },

	    loadIdentity: function ()
	    {
	        var matrix = this.matrix;

	        matrix[0] = 1;
	        matrix[1] = 0;
	        matrix[2] = 0;
	        matrix[3] = 1;
	        matrix[4] = 0;
	        matrix[5] = 0;

	        return this;
	    },

	    translate: function (x, y)
	    {
	        var matrix = this.matrix;

	        matrix[4] = matrix[0] * x + matrix[2] * y + matrix[4];
	        matrix[5] = matrix[1] * x + matrix[3] * y + matrix[5];

	        return this;
	    },

	    scale: function (x, y)
	    {
	        var matrix = this.matrix;

	        matrix[0] *= x;
	        matrix[1] *= x;
	        matrix[2] *= y;
	        matrix[3] *= y;

	        return this;
	    },

	    rotate: function (angle)
	    {
	        var sin = Math.sin(angle);
	        var cos = Math.cos(angle);

	        var matrix = this.matrix;

	        var a = matrix[0];
	        var b = matrix[1];
	        var c = matrix[2];
	        var d = matrix[3];

	        matrix[0] = a * cos + c * sin;
	        matrix[1] = b * cos + d * sin;
	        matrix[2] = a * -sin + c * cos;
	        matrix[3] = b * -sin + d * cos;

	        return this;
	    },

	    multiply: function (rhs, out)
	    {
	        var matrix = this.matrix;
	        var source = rhs.matrix;

	        var localA = matrix[0];
	        var localB = matrix[1];
	        var localC = matrix[2];
	        var localD = matrix[3];
	        var localE = matrix[4];
	        var localF = matrix[5];

	        var sourceA = source[0];
	        var sourceB = source[1];
	        var sourceC = source[2];
	        var sourceD = source[3];
	        var sourceE = source[4];
	        var sourceF = source[5];

	        var destinationMatrix = (out === undefined) ? matrix : out.matrix;

	        destinationMatrix[0] = (sourceA * localA) + (sourceB * localC);
	        destinationMatrix[1] = (sourceA * localB) + (sourceB * localD);
	        destinationMatrix[2] = (sourceC * localA) + (sourceD * localC);
	        destinationMatrix[3] = (sourceC * localB) + (sourceD * localD);
	        destinationMatrix[4] = (sourceE * localA) + (sourceF * localC) + localE;
	        destinationMatrix[5] = (sourceE * localB) + (sourceF * localD) + localF;

	        return destinationMatrix;
	    },

	    multiplyWithOffset: function (src, offsetX, offsetY)
	    {
	        var matrix = this.matrix;
	        var otherMatrix = src.matrix;

	        var a0 = matrix[0];
	        var b0 = matrix[1];
	        var c0 = matrix[2];
	        var d0 = matrix[3];
	        var tx0 = matrix[4];
	        var ty0 = matrix[5];

	        var pse = offsetX * a0 + offsetY * c0 + tx0;
	        var psf = offsetX * b0 + offsetY * d0 + ty0;

	        var a1 = otherMatrix[0];
	        var b1 = otherMatrix[1];
	        var c1 = otherMatrix[2];
	        var d1 = otherMatrix[3];
	        var tx1 = otherMatrix[4];
	        var ty1 = otherMatrix[5];

	        matrix[0] = a1 * a0 + b1 * c0;
	        matrix[1] = a1 * b0 + b1 * d0;
	        matrix[2] = c1 * a0 + d1 * c0;
	        matrix[3] = c1 * b0 + d1 * d0;
	        matrix[4] = tx1 * a0 + ty1 * c0 + pse;
	        matrix[5] = tx1 * b0 + ty1 * d0 + psf;

	        return this;
	    },

	    transform: function (a, b, c, d, tx, ty)
	    {
	        var matrix = this.matrix;

	        var a0 = matrix[0];
	        var b0 = matrix[1];
	        var c0 = matrix[2];
	        var d0 = matrix[3];
	        var tx0 = matrix[4];
	        var ty0 = matrix[5];

	        matrix[0] = a * a0 + b * c0;
	        matrix[1] = a * b0 + b * d0;
	        matrix[2] = c * a0 + d * c0;
	        matrix[3] = c * b0 + d * d0;
	        matrix[4] = tx * a0 + ty * c0 + tx0;
	        matrix[5] = tx * b0 + ty * d0 + ty0;

	        return this;
	    },

	    transformPoint: function (x, y, point)
	    {
	        if (point === undefined) { point = { x: 0, y: 0 }; }

	        var matrix = this.matrix;

	        var a = matrix[0];
	        var b = matrix[1];
	        var c = matrix[2];
	        var d = matrix[3];
	        var tx = matrix[4];
	        var ty = matrix[5];

	        point.x = x * a + y * c + tx;
	        point.y = x * b + y * d + ty;

	        return point;
	    },

	    invert: function ()
	    {
	        var matrix = this.matrix;

	        var a = matrix[0];
	        var b = matrix[1];
	        var c = matrix[2];
	        var d = matrix[3];
	        var tx = matrix[4];
	        var ty = matrix[5];

	        var n = a * d - b * c;

	        matrix[0] = d / n;
	        matrix[1] = -b / n;
	        matrix[2] = -c / n;
	        matrix[3] = a / n;
	        matrix[4] = (c * ty - d * tx) / n;
	        matrix[5] = -(a * ty - b * tx) / n;

	        return this;
	    },

	    copyFrom: function (src)
	    {
	        var matrix = this.matrix;

	        matrix[0] = src.a;
	        matrix[1] = src.b;
	        matrix[2] = src.c;
	        matrix[3] = src.d;
	        matrix[4] = src.e;
	        matrix[5] = src.f;

	        return this;
	    },

	    copyFromArray: function (src)
	    {
	        var matrix = this.matrix;

	        matrix[0] = src[0];
	        matrix[1] = src[1];
	        matrix[2] = src[2];
	        matrix[3] = src[3];
	        matrix[4] = src[4];
	        matrix[5] = src[5];

	        return this;
	    },

	    copyToContext: function (ctx)
	    {
	        var matrix = this.matrix;

	        ctx.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);

	        return ctx;
	    },

	    setToContext: function (ctx)
	    {

	        ctx.setTransform(this.a, this.b, this.c, this.d, this.e, this.f);

	        return ctx;
	    },

	    copyToArray: function (out)
	    {
	        var matrix = this.matrix;

	        if (out === undefined)
	        {
	            out = [ matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5] ];
	        }
	        else
	        {
	            out[0] = matrix[0];
	            out[1] = matrix[1];
	            out[2] = matrix[2];
	            out[3] = matrix[3];
	            out[4] = matrix[4];
	            out[5] = matrix[5];
	        }

	        return out;
	    },

	    setTransform: function (a, b, c, d, tx, ty)
	    {
	        var matrix = this.matrix;

	        matrix[0] = a;
	        matrix[1] = b;
	        matrix[2] = c;
	        matrix[3] = d;
	        matrix[4] = tx;
	        matrix[5] = ty;

	        return this;
	    },

	    decomposeMatrix: function ()
	    {
	        var decomposedMatrix = this.decomposedMatrix;

	        var matrix = this.matrix;

	        var a = matrix[0];
	        var b = matrix[1];
	        var c = matrix[2];
	        var d = matrix[3];

	        var determ = a * d - b * c;

	        decomposedMatrix.translateX = matrix[4];
	        decomposedMatrix.translateY = matrix[5];

	        if (a || b)
	        {
	            var r = Math.sqrt(a * a + b * b);

	            decomposedMatrix.rotation = (b > 0) ? Math.acos(a / r) : -Math.acos(a / r);
	            decomposedMatrix.scaleX = r;
	            decomposedMatrix.scaleY = determ / r;
	        }
	        else if (c || d)
	        {
	            var s = Math.sqrt(c * c + d * d);

	            decomposedMatrix.rotation = Math.PI * 0.5 - (d > 0 ? Math.acos(-c / s) : -Math.acos(c / s));
	            decomposedMatrix.scaleX = determ / s;
	            decomposedMatrix.scaleY = s;
	        }
	        else
	        {
	            decomposedMatrix.rotation = 0;
	            decomposedMatrix.scaleX = 0;
	            decomposedMatrix.scaleY = 0;
	        }

	        return decomposedMatrix;
	    },

	    applyITRS: function (x, y, rotation, scaleX, scaleY)
	    {
	        var matrix = this.matrix;

	        var radianSin = Math.sin(rotation);
	        var radianCos = Math.cos(rotation);

	        matrix[4] = x;
	        matrix[5] = y;

	        matrix[0] = radianCos * scaleX;
	        matrix[1] = radianSin * scaleX;
	        matrix[2] = -radianSin * scaleY;
	        matrix[3] = radianCos * scaleY;

	        return this;
	    },

	    applyInverse: function (x, y, output)
	    {
	        if (output === undefined) { output = new Vector2(); }

	        var matrix = this.matrix;

	        var a = matrix[0];
	        var b = matrix[1];
	        var c = matrix[2];
	        var d = matrix[3];
	        var tx = matrix[4];
	        var ty = matrix[5];

	        var id = 1 / ((a * d) + (c * -b));

	        output.x = (d * id * x) + (-c * id * y) + (((ty * c) - (tx * d)) * id);
	        output.y = (a * id * y) + (-b * id * x) + (((-ty * a) + (tx * b)) * id);

	        return output;
	    },

	    setQuad: function (x, y, xw, yh, roundPixels, quad)
	    {
	        if (roundPixels === undefined) { roundPixels = false; }
	        if (quad === undefined) { quad = this.quad; }

	        var matrix = this.matrix;

	        var a = matrix[0];
	        var b = matrix[1];
	        var c = matrix[2];
	        var d = matrix[3];
	        var e = matrix[4];
	        var f = matrix[5];

	        var x0 = x * a + y * c + e;
	        var y0 = x * b + y * d + f;

	        var x1 = x * a + yh * c + e;
	        var y1 = x * b + yh * d + f;

	        var x2 = xw * a + yh * c + e;
	        var y2 = xw * b + yh * d + f;

	        var x3 = xw * a + y * c + e;
	        var y3 = xw * b + y * d + f;

	        if (roundPixels)
	        {

	            var rx0 = Math.floor(x0 + 0.5);
	            var ry0 = Math.floor(y0 + 0.5);

	            var dx = rx0 - x0;
	            var dy = ry0 - y0;

	            quad[0] = rx0;
	            quad[1] = ry0;

	            quad[2] = x1 + dx;
	            quad[3] = y1 + dy;

	            quad[4] = x2 + dx;
	            quad[5] = y2 + dy;

	            quad[6] = x3 + dx;
	            quad[7] = y3 + dy;
	        }
	        else
	        {
	            quad[0] = x0;
	            quad[1] = y0;

	            quad[2] = x1;
	            quad[3] = y1;

	            quad[4] = x2;
	            quad[5] = y2;

	            quad[6] = x3;
	            quad[7] = y3;
	        }

	        return quad;
	    },

	    getX: function (x, y)
	    {
	        return x * this.a + y * this.c + this.e;
	    },

	    getY: function (x, y)
	    {
	        return x * this.b + y * this.d + this.f;
	    },

	    getXRound: function (x, y, round)
	    {
	        var v = this.getX(x, y);

	        if (round)
	        {
	            v = Math.floor(v + 0.5);
	        }

	        return v;
	    },

	    getYRound: function (x, y, round)
	    {
	        var v = this.getY(x, y);

	        if (round)
	        {
	            v = Math.floor(v + 0.5);
	        }

	        return v;
	    },

	    getCSSMatrix: function ()
	    {
	        var m = this.matrix;

	        return 'matrix(' + m[0] + ',' + m[1] + ',' + m[2] + ',' + m[3] + ',' + m[4] + ',' + m[5] + ')';
	    },

	    destroy: function ()
	    {
	        this.matrix = null;
	        this.quad = null;
	        this.decomposedMatrix = null;
	    }

	});

	TransformMatrix_1 = TransformMatrix;
	return TransformMatrix_1;
}

var TransformXY_1;
var hasRequiredTransformXY;

function requireTransformXY () {
	if (hasRequiredTransformXY) return TransformXY_1;
	hasRequiredTransformXY = 1;
	var Vector2 = requireVector2();

	var TransformXY = function (x, y, positionX, positionY, rotation, scaleX, scaleY, output)
	{
	    if (output === undefined) { output = new Vector2(); }

	    var radianSin = Math.sin(rotation);
	    var radianCos = Math.cos(rotation);

	    var a = radianCos * scaleX;
	    var b = radianSin * scaleX;
	    var c = -radianSin * scaleY;
	    var d = radianCos * scaleY;

	    var id = 1 / ((a * d) + (c * -b));

	    output.x = (d * id * x) + (-c * id * y) + (((positionY * c) - (positionX * d)) * id);
	    output.y = (a * id * y) + (-b * id * x) + (((-positionY * a) + (positionX * b)) * id);

	    return output;
	};

	TransformXY_1 = TransformXY;
	return TransformXY_1;
}

var Wrap_1$1;
var hasRequiredWrap$1;

function requireWrap$1 () {
	if (hasRequiredWrap$1) return Wrap_1$1;
	hasRequiredWrap$1 = 1;
	var Wrap = function (value, min, max)
	{
	    var range = max - min;

	    return (min + ((((value - min) % range) + range) % range));
	};

	Wrap_1$1 = Wrap;
	return Wrap_1$1;
}

var Wrap_1;
var hasRequiredWrap;

function requireWrap () {
	if (hasRequiredWrap) return Wrap_1;
	hasRequiredWrap = 1;
	var MathWrap = requireWrap$1();

	var Wrap = function (angle)
	{
	    return MathWrap(angle, -Math.PI, Math.PI);
	};

	Wrap_1 = Wrap;
	return Wrap_1;
}

var WrapDegrees_1;
var hasRequiredWrapDegrees;

function requireWrapDegrees () {
	if (hasRequiredWrapDegrees) return WrapDegrees_1;
	hasRequiredWrapDegrees = 1;
	var Wrap = requireWrap$1();

	var WrapDegrees = function (angle)
	{
	    return Wrap(angle, -180, 180);
	};

	WrapDegrees_1 = WrapDegrees;
	return WrapDegrees_1;
}

var Transform_1;
var hasRequiredTransform;

function requireTransform () {
	if (hasRequiredTransform) return Transform_1;
	hasRequiredTransform = 1;
	var MATH_CONST = require_const$c();
	var TransformMatrix = requireTransformMatrix();
	var TransformXY = requireTransformXY();
	var WrapAngle = requireWrap();
	var WrapAngleDegrees = requireWrapDegrees();
	var Vector2 = requireVector2();

	var _FLAG = 4; 

	var Transform = {

	    hasTransformComponent: true,

	    _scaleX: 1,

	    _scaleY: 1,

	    _rotation: 0,

	    x: 0,

	    y: 0,

	    z: 0,

	    w: 0,

	    scale: {

	        get: function ()
	        {
	            return (this._scaleX + this._scaleY) / 2;
	        },

	        set: function (value)
	        {
	            this._scaleX = value;
	            this._scaleY = value;

	            if (value === 0)
	            {
	                this.renderFlags &= ~_FLAG;
	            }
	            else
	            {
	                this.renderFlags |= _FLAG;
	            }
	        }

	    },

	    scaleX: {

	        get: function ()
	        {
	            return this._scaleX;
	        },

	        set: function (value)
	        {
	            this._scaleX = value;

	            if (value === 0)
	            {
	                this.renderFlags &= ~_FLAG;
	            }
	            else if (this._scaleY !== 0)
	            {
	                this.renderFlags |= _FLAG;
	            }
	        }

	    },

	    scaleY: {

	        get: function ()
	        {
	            return this._scaleY;
	        },

	        set: function (value)
	        {
	            this._scaleY = value;

	            if (value === 0)
	            {
	                this.renderFlags &= ~_FLAG;
	            }
	            else if (this._scaleX !== 0)
	            {
	                this.renderFlags |= _FLAG;
	            }
	        }

	    },

	    angle: {

	        get: function ()
	        {
	            return WrapAngleDegrees(this._rotation * MATH_CONST.RAD_TO_DEG);
	        },

	        set: function (value)
	        {

	            this.rotation = WrapAngleDegrees(value) * MATH_CONST.DEG_TO_RAD;
	        }
	    },

	    rotation: {

	        get: function ()
	        {
	            return this._rotation;
	        },

	        set: function (value)
	        {

	            this._rotation = WrapAngle(value);
	        }
	    },

	    setPosition: function (x, y, z, w)
	    {
	        if (x === undefined) { x = 0; }
	        if (y === undefined) { y = x; }
	        if (z === undefined) { z = 0; }
	        if (w === undefined) { w = 0; }

	        this.x = x;
	        this.y = y;
	        this.z = z;
	        this.w = w;

	        return this;
	    },

	    copyPosition: function (source)
	    {
	        if (source.x !== undefined) { this.x = source.x; }
	        if (source.y !== undefined) { this.y = source.y; }
	        if (source.z !== undefined) { this.z = source.z; }
	        if (source.w !== undefined) { this.w = source.w; }

	        return this;
	    },

	    setRandomPosition: function (x, y, width, height)
	    {
	        if (x === undefined) { x = 0; }
	        if (y === undefined) { y = 0; }
	        if (width === undefined) { width = this.scene.sys.scale.width; }
	        if (height === undefined) { height = this.scene.sys.scale.height; }

	        this.x = x + (Math.random() * width);
	        this.y = y + (Math.random() * height);

	        return this;
	    },

	    setRotation: function (radians)
	    {
	        if (radians === undefined) { radians = 0; }

	        this.rotation = radians;

	        return this;
	    },

	    setAngle: function (degrees)
	    {
	        if (degrees === undefined) { degrees = 0; }

	        this.angle = degrees;

	        return this;
	    },

	    setScale: function (x, y)
	    {
	        if (x === undefined) { x = 1; }
	        if (y === undefined) { y = x; }

	        this.scaleX = x;
	        this.scaleY = y;

	        return this;
	    },

	    setX: function (value)
	    {
	        if (value === undefined) { value = 0; }

	        this.x = value;

	        return this;
	    },

	    setY: function (value)
	    {
	        if (value === undefined) { value = 0; }

	        this.y = value;

	        return this;
	    },

	    setZ: function (value)
	    {
	        if (value === undefined) { value = 0; }

	        this.z = value;

	        return this;
	    },

	    setW: function (value)
	    {
	        if (value === undefined) { value = 0; }

	        this.w = value;

	        return this;
	    },

	    getLocalTransformMatrix: function (tempMatrix)
	    {
	        if (tempMatrix === undefined) { tempMatrix = new TransformMatrix(); }

	        return tempMatrix.applyITRS(this.x, this.y, this._rotation, this._scaleX, this._scaleY);
	    },

	    getWorldTransformMatrix: function (tempMatrix, parentMatrix)
	    {
	        if (tempMatrix === undefined) { tempMatrix = new TransformMatrix(); }

	        var parent = this.parentContainer;

	        if (!parent)
	        {
	            return this.getLocalTransformMatrix(tempMatrix);
	        }

	        var destroyParentMatrix = false;

	        if (!parentMatrix)
	        {
	            parentMatrix = new TransformMatrix();

	            destroyParentMatrix = true;
	        }

	        tempMatrix.applyITRS(this.x, this.y, this._rotation, this._scaleX, this._scaleY);

	        while (parent)
	        {
	            parentMatrix.applyITRS(parent.x, parent.y, parent._rotation, parent._scaleX, parent._scaleY);

	            parentMatrix.multiply(tempMatrix, tempMatrix);

	            parent = parent.parentContainer;
	        }

	        if (destroyParentMatrix)
	        {
	            parentMatrix.destroy();
	        }

	        return tempMatrix;
	    },

	    getLocalPoint: function (x, y, point, camera)
	    {
	        if (!point) { point = new Vector2(); }
	        if (!camera) { camera = this.scene.sys.cameras.main; }

	        var csx = camera.scrollX;
	        var csy = camera.scrollY;

	        var px = x + (csx * this.scrollFactorX) - csx;
	        var py = y + (csy * this.scrollFactorY) - csy;

	        if (this.parentContainer)
	        {
	            this.getWorldTransformMatrix().applyInverse(px, py, point);
	        }
	        else
	        {
	            TransformXY(px, py, this.x, this.y, this.rotation, this.scaleX, this.scaleY, point);
	        }

	        if (this._originComponent)
	        {
	            point.x += this._displayOriginX;
	            point.y += this._displayOriginY;
	        }

	        return point;
	    },

	    getWorldPoint: function (point, tempMatrix, parentMatrix)
	    {
	        if (point === undefined) { point = new Vector2(); }

	        var parent = this.parentContainer;

	        if (!parent)
	        {
	            point.x = this.x;
	            point.y = this.y;

	            return point;
	        }

	        var worldTransform = this.getWorldTransformMatrix(tempMatrix, parentMatrix);

	        point.x = worldTransform.tx;
	        point.y = worldTransform.ty;

	        return point;
	    },

	    getParentRotation: function ()
	    {
	        var rotation = 0;

	        var parent = this.parentContainer;

	        while (parent)
	        {
	            rotation += parent.rotation;

	            parent = parent.parentContainer;
	        }

	        return rotation;
	    }

	};

	Transform_1 = Transform;
	return Transform_1;
}

var Visible_1;
var hasRequiredVisible;

function requireVisible () {
	if (hasRequiredVisible) return Visible_1;
	hasRequiredVisible = 1;
	var _FLAG = 1; 

	var Visible = {

	    _visible: true,

	    visible: {

	        get: function ()
	        {
	            return this._visible;
	        },

	        set: function (value)
	        {
	            if (value)
	            {
	                this._visible = true;
	                this.renderFlags |= _FLAG;
	            }
	            else
	            {
	                this._visible = false;
	                this.renderFlags &= ~_FLAG;
	            }
	        }

	    },

	    setVisible: function (value)
	    {
	        this.visible = value;

	        return this;
	    }
	};

	Visible_1 = Visible;
	return Visible_1;
}

var components$2;
var hasRequiredComponents$2;

function requireComponents$2 () {
	if (hasRequiredComponents$2) return components$2;
	hasRequiredComponents$2 = 1;
	components$2 = {

	    Alpha: requireAlpha(),
	    AlphaSingle: requireAlphaSingle(),
	    BlendMode: requireBlendMode(),
	    ComputedSize: requireComputedSize(),
	    Crop: requireCrop(),
	    Depth: requireDepth(),
	    Flip: requireFlip(),
	    FX: requireFX(),
	    GetBounds: requireGetBounds$3(),
	    Mask: requireMask$1(),
	    Origin: requireOrigin(),
	    PathFollower: requirePathFollower$1(),
	    Pipeline: requirePipeline(),
	    PostPipeline: requirePostPipeline(),
	    ScrollFactor: requireScrollFactor(),
	    Size: requireSize$2(),
	    Texture: requireTexture$1(),
	    TextureCrop: requireTextureCrop(),
	    Tint: requireTint(),
	    ToJSON: requireToJSON(),
	    Transform: requireTransform(),
	    TransformMatrix: requireTransformMatrix(),
	    Visible: requireVisible()

	};
	return components$2;
}

var CHANGE_DATA_EVENT;
var hasRequiredCHANGE_DATA_EVENT;

function requireCHANGE_DATA_EVENT () {
	if (hasRequiredCHANGE_DATA_EVENT) return CHANGE_DATA_EVENT;
	hasRequiredCHANGE_DATA_EVENT = 1;
	CHANGE_DATA_EVENT = 'changedata';
	return CHANGE_DATA_EVENT;
}

var CHANGE_DATA_KEY_EVENT;
var hasRequiredCHANGE_DATA_KEY_EVENT;

function requireCHANGE_DATA_KEY_EVENT () {
	if (hasRequiredCHANGE_DATA_KEY_EVENT) return CHANGE_DATA_KEY_EVENT;
	hasRequiredCHANGE_DATA_KEY_EVENT = 1;
	CHANGE_DATA_KEY_EVENT = 'changedata-';
	return CHANGE_DATA_KEY_EVENT;
}

var DESTROY_EVENT$6;
var hasRequiredDESTROY_EVENT$6;

function requireDESTROY_EVENT$6 () {
	if (hasRequiredDESTROY_EVENT$6) return DESTROY_EVENT$6;
	hasRequiredDESTROY_EVENT$6 = 1;
	DESTROY_EVENT$6 = 'destroy';
	return DESTROY_EVENT$6;
}

var REMOVE_DATA_EVENT;
var hasRequiredREMOVE_DATA_EVENT;

function requireREMOVE_DATA_EVENT () {
	if (hasRequiredREMOVE_DATA_EVENT) return REMOVE_DATA_EVENT;
	hasRequiredREMOVE_DATA_EVENT = 1;
	REMOVE_DATA_EVENT = 'removedata';
	return REMOVE_DATA_EVENT;
}

var SET_DATA_EVENT;
var hasRequiredSET_DATA_EVENT;

function requireSET_DATA_EVENT () {
	if (hasRequiredSET_DATA_EVENT) return SET_DATA_EVENT;
	hasRequiredSET_DATA_EVENT = 1;
	SET_DATA_EVENT = 'setdata';
	return SET_DATA_EVENT;
}

var events$k;
var hasRequiredEvents$k;

function requireEvents$k () {
	if (hasRequiredEvents$k) return events$k;
	hasRequiredEvents$k = 1;
	events$k = {

	    CHANGE_DATA: requireCHANGE_DATA_EVENT(),
	    CHANGE_DATA_KEY: requireCHANGE_DATA_KEY_EVENT(),
	    DESTROY: requireDESTROY_EVENT$6(),
	    REMOVE_DATA: requireREMOVE_DATA_EVENT(),
	    SET_DATA: requireSET_DATA_EVENT()

	};
	return events$k;
}

var DataManager_1;
var hasRequiredDataManager;

function requireDataManager () {
	if (hasRequiredDataManager) return DataManager_1;
	hasRequiredDataManager = 1;
	var Class = requireClass();
	var Events = requireEvents$k();

	var DataManager = new Class({

	    initialize:

	    function DataManager (parent, eventEmitter)
	    {

	        this.parent = parent;

	        this.events = eventEmitter;

	        if (!eventEmitter)
	        {
	            this.events = (parent.events) ? parent.events : parent;
	        }

	        this.list = {};

	        this.values = {};

	        this._frozen = false;

	        if (!parent.hasOwnProperty('sys') && this.events)
	        {
	            this.events.once(Events.DESTROY, this.destroy, this);
	        }
	    },

	    get: function (key)
	    {
	        var list = this.list;

	        if (Array.isArray(key))
	        {
	            var output = [];

	            for (var i = 0; i < key.length; i++)
	            {
	                output.push(list[key[i]]);
	            }

	            return output;
	        }
	        else
	        {
	            return list[key];
	        }
	    },

	    getAll: function ()
	    {
	        var results = {};

	        for (var key in this.list)
	        {
	            if (this.list.hasOwnProperty(key))
	            {
	                results[key] = this.list[key];
	            }
	        }

	        return results;
	    },

	    query: function (search)
	    {
	        var results = {};

	        for (var key in this.list)
	        {
	            if (this.list.hasOwnProperty(key) && key.match(search))
	            {
	                results[key] = this.list[key];
	            }
	        }

	        return results;
	    },

	    set: function (key, data)
	    {
	        if (this._frozen)
	        {
	            return this;
	        }

	        if (typeof key === 'string')
	        {
	            return this.setValue(key, data);
	        }
	        else
	        {
	            for (var entry in key)
	            {
	                this.setValue(entry, key[entry]);
	            }
	        }

	        return this;
	    },

	    inc: function (key, amount)
	    {
	        if (this._frozen)
	        {
	            return this;
	        }

	        if (amount === undefined)
	        {
	            amount = 1;
	        }

	        var value = this.get(key);

	        if (value === undefined)
	        {
	            value = 0;
	        }

	        this.set(key, (value + amount));

	        return this;
	    },

	    toggle: function (key)
	    {
	        if (this._frozen)
	        {
	            return this;
	        }

	        this.set(key, !this.get(key));

	        return this;
	    },

	    setValue: function (key, data)
	    {
	        if (this._frozen)
	        {
	            return this;
	        }

	        if (this.has(key))
	        {

	            this.values[key] = data;
	        }
	        else
	        {
	            var _this = this;
	            var list = this.list;
	            var events = this.events;
	            var parent = this.parent;

	            Object.defineProperty(this.values, key, {

	                enumerable: true,

	                configurable: true,

	                get: function ()
	                {
	                    return list[key];
	                },

	                set: function (value)
	                {
	                    if (!_this._frozen)
	                    {
	                        var previousValue = list[key];
	                        list[key] = value;

	                        events.emit(Events.CHANGE_DATA, parent, key, value, previousValue);
	                        events.emit(Events.CHANGE_DATA_KEY + key, parent, value, previousValue);
	                    }
	                }

	            });

	            list[key] = data;

	            events.emit(Events.SET_DATA, parent, key, data);
	        }

	        return this;
	    },

	    each: function (callback, context)
	    {
	        var args = [ this.parent, null, undefined ];

	        for (var i = 1; i < arguments.length; i++)
	        {
	            args.push(arguments[i]);
	        }

	        for (var key in this.list)
	        {
	            args[1] = key;
	            args[2] = this.list[key];

	            callback.apply(context, args);
	        }

	        return this;
	    },

	    merge: function (data, overwrite)
	    {
	        if (overwrite === undefined) { overwrite = true; }

	        for (var key in data)
	        {
	            if (data.hasOwnProperty(key) && (overwrite || (!overwrite && !this.has(key))))
	            {
	                this.setValue(key, data[key]);
	            }
	        }

	        return this;
	    },

	    remove: function (key)
	    {
	        if (this._frozen)
	        {
	            return this;
	        }

	        if (Array.isArray(key))
	        {
	            for (var i = 0; i < key.length; i++)
	            {
	                this.removeValue(key[i]);
	            }
	        }
	        else
	        {
	            return this.removeValue(key);
	        }

	        return this;
	    },

	    removeValue: function (key)
	    {
	        if (this.has(key))
	        {
	            var data = this.list[key];

	            delete this.list[key];
	            delete this.values[key];

	            this.events.emit(Events.REMOVE_DATA, this.parent, key, data);
	        }

	        return this;
	    },

	    pop: function (key)
	    {
	        var data = undefined;

	        if (!this._frozen && this.has(key))
	        {
	            data = this.list[key];

	            delete this.list[key];
	            delete this.values[key];

	            this.events.emit(Events.REMOVE_DATA, this.parent, key, data);
	        }

	        return data;
	    },

	    has: function (key)
	    {
	        return this.list.hasOwnProperty(key);
	    },

	    setFreeze: function (value)
	    {
	        this._frozen = value;

	        return this;
	    },

	    reset: function ()
	    {
	        for (var key in this.list)
	        {
	            delete this.list[key];
	            delete this.values[key];
	        }

	        this._frozen = false;

	        return this;
	    },

	    destroy: function ()
	    {
	        this.reset();

	        this.events.off(Events.CHANGE_DATA);
	        this.events.off(Events.SET_DATA);
	        this.events.off(Events.REMOVE_DATA);

	        this.parent = null;
	    },

	    freeze: {

	        get: function ()
	        {
	            return this._frozen;
	        },

	        set: function (value)
	        {
	            this._frozen = (value) ? true : false;
	        }

	    },

	    count: {

	        get: function ()
	        {
	            var i = 0;

	            for (var key in this.list)
	            {
	                if (this.list[key] !== undefined)
	                {
	                    i++;
	                }
	            }

	            return i;
	        }

	    }

	});

	DataManager_1 = DataManager;
	return DataManager_1;
}

var eventemitter3 = {exports: {}};

eventemitter3.exports;

var hasRequiredEventemitter3;

function requireEventemitter3 () {
	if (hasRequiredEventemitter3) return eventemitter3.exports;
	hasRequiredEventemitter3 = 1;
	(function (module) {

		var has = Object.prototype.hasOwnProperty
		  , prefix = '~';

		/**
		 * Constructor to create a storage for our `EE` objects.
		 * An `Events` instance is a plain object whose properties are event names.
		 *
		 * @constructor
		 * @private
		 */
		function Events() {}

		//
		// We try to not inherit from `Object.prototype`. In some engines creating an
		// instance in this way is faster than calling `Object.create(null)` directly.
		// If `Object.create(null)` is not supported we prefix the event names with a
		// character to make sure that the built-in object properties are not
		// overridden or used as an attack vector.
		//
		if (Object.create) {
		  Events.prototype = Object.create(null);

		  //
		  // This hack is needed because the `__proto__` property is still inherited in
		  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
		  //
		  if (!new Events().__proto__) prefix = false;
		}

		/**
		 * Representation of a single event listener.
		 *
		 * @param {Function} fn The listener function.
		 * @param {*} context The context to invoke the listener with.
		 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
		 * @constructor
		 * @private
		 */
		function EE(fn, context, once) {
		  this.fn = fn;
		  this.context = context;
		  this.once = once || false;
		}

		/**
		 * Add a listener for a given event.
		 *
		 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
		 * @param {(String|Symbol)} event The event name.
		 * @param {Function} fn The listener function.
		 * @param {*} context The context to invoke the listener with.
		 * @param {Boolean} once Specify if the listener is a one-time listener.
		 * @returns {EventEmitter}
		 * @private
		 */
		function addListener(emitter, event, fn, context, once) {
		  if (typeof fn !== 'function') {
		    throw new TypeError('The listener must be a function');
		  }

		  var listener = new EE(fn, context || emitter, once)
		    , evt = prefix ? prefix + event : event;

		  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
		  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
		  else emitter._events[evt] = [emitter._events[evt], listener];

		  return emitter;
		}

		/**
		 * Clear event by name.
		 *
		 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
		 * @param {(String|Symbol)} evt The Event name.
		 * @private
		 */
		function clearEvent(emitter, evt) {
		  if (--emitter._eventsCount === 0) emitter._events = new Events();
		  else delete emitter._events[evt];
		}

		/**
		 * Minimal `EventEmitter` interface that is molded against the Node.js
		 * `EventEmitter` interface.
		 *
		 * @constructor
		 * @public
		 */
		function EventEmitter() {
		  this._events = new Events();
		  this._eventsCount = 0;
		}

		/**
		 * Return an array listing the events for which the emitter has registered
		 * listeners.
		 *
		 * @returns {Array}
		 * @public
		 */
		EventEmitter.prototype.eventNames = function eventNames() {
		  var names = []
		    , events
		    , name;

		  if (this._eventsCount === 0) return names;

		  for (name in (events = this._events)) {
		    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
		  }

		  if (Object.getOwnPropertySymbols) {
		    return names.concat(Object.getOwnPropertySymbols(events));
		  }

		  return names;
		};

		/**
		 * Return the listeners registered for a given event.
		 *
		 * @param {(String|Symbol)} event The event name.
		 * @returns {Array} The registered listeners.
		 * @public
		 */
		EventEmitter.prototype.listeners = function listeners(event) {
		  var evt = prefix ? prefix + event : event
		    , handlers = this._events[evt];

		  if (!handlers) return [];
		  if (handlers.fn) return [handlers.fn];

		  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
		    ee[i] = handlers[i].fn;
		  }

		  return ee;
		};

		/**
		 * Return the number of listeners listening to a given event.
		 *
		 * @param {(String|Symbol)} event The event name.
		 * @returns {Number} The number of listeners.
		 * @public
		 */
		EventEmitter.prototype.listenerCount = function listenerCount(event) {
		  var evt = prefix ? prefix + event : event
		    , listeners = this._events[evt];

		  if (!listeners) return 0;
		  if (listeners.fn) return 1;
		  return listeners.length;
		};

		/**
		 * Calls each of the listeners registered for a given event.
		 *
		 * @param {(String|Symbol)} event The event name.
		 * @returns {Boolean} `true` if the event had listeners, else `false`.
		 * @public
		 */
		EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
		  var evt = prefix ? prefix + event : event;

		  if (!this._events[evt]) return false;

		  var listeners = this._events[evt]
		    , len = arguments.length
		    , args
		    , i;

		  if (listeners.fn) {
		    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

		    switch (len) {
		      case 1: return listeners.fn.call(listeners.context), true;
		      case 2: return listeners.fn.call(listeners.context, a1), true;
		      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
		      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
		      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
		      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
		    }

		    for (i = 1, args = new Array(len -1); i < len; i++) {
		      args[i - 1] = arguments[i];
		    }

		    listeners.fn.apply(listeners.context, args);
		  } else {
		    var length = listeners.length
		      , j;

		    for (i = 0; i < length; i++) {
		      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

		      switch (len) {
		        case 1: listeners[i].fn.call(listeners[i].context); break;
		        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
		        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
		        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
		        default:
		          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
		            args[j - 1] = arguments[j];
		          }

		          listeners[i].fn.apply(listeners[i].context, args);
		      }
		    }
		  }

		  return true;
		};

		/**
		 * Add a listener for a given event.
		 *
		 * @param {(String|Symbol)} event The event name.
		 * @param {Function} fn The listener function.
		 * @param {*} [context=this] The context to invoke the listener with.
		 * @returns {EventEmitter} `this`.
		 * @public
		 */
		EventEmitter.prototype.on = function on(event, fn, context) {
		  return addListener(this, event, fn, context, false);
		};

		/**
		 * Add a one-time listener for a given event.
		 *
		 * @param {(String|Symbol)} event The event name.
		 * @param {Function} fn The listener function.
		 * @param {*} [context=this] The context to invoke the listener with.
		 * @returns {EventEmitter} `this`.
		 * @public
		 */
		EventEmitter.prototype.once = function once(event, fn, context) {
		  return addListener(this, event, fn, context, true);
		};

		/**
		 * Remove the listeners of a given event.
		 *
		 * @param {(String|Symbol)} event The event name.
		 * @param {Function} fn Only remove the listeners that match this function.
		 * @param {*} context Only remove the listeners that have this context.
		 * @param {Boolean} once Only remove one-time listeners.
		 * @returns {EventEmitter} `this`.
		 * @public
		 */
		EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
		  var evt = prefix ? prefix + event : event;

		  if (!this._events[evt]) return this;
		  if (!fn) {
		    clearEvent(this, evt);
		    return this;
		  }

		  var listeners = this._events[evt];

		  if (listeners.fn) {
		    if (
		      listeners.fn === fn &&
		      (!once || listeners.once) &&
		      (!context || listeners.context === context)
		    ) {
		      clearEvent(this, evt);
		    }
		  } else {
		    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
		      if (
		        listeners[i].fn !== fn ||
		        (once && !listeners[i].once) ||
		        (context && listeners[i].context !== context)
		      ) {
		        events.push(listeners[i]);
		      }
		    }

		    //
		    // Reset the array, or remove it completely if we have no more listeners.
		    //
		    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
		    else clearEvent(this, evt);
		  }

		  return this;
		};

		/**
		 * Remove all listeners, or those of the specified event.
		 *
		 * @param {(String|Symbol)} [event] The event name.
		 * @returns {EventEmitter} `this`.
		 * @public
		 */
		EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
		  var evt;

		  if (event) {
		    evt = prefix ? prefix + event : event;
		    if (this._events[evt]) clearEvent(this, evt);
		  } else {
		    this._events = new Events();
		    this._eventsCount = 0;
		  }

		  return this;
		};

		//
		// Alias methods names because people roll like that.
		//
		EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
		EventEmitter.prototype.addListener = EventEmitter.prototype.on;

		//
		// Expose the prefix.
		//
		EventEmitter.prefixed = prefix;

		//
		// Allow `EventEmitter` to be imported as module namespace.
		//
		EventEmitter.EventEmitter = EventEmitter;

		//
		// Expose the module.
		//
		{
		  module.exports = EventEmitter;
		} 
	} (eventemitter3));
	return eventemitter3.exports;
}

var ADDED_TO_SCENE_EVENT;
var hasRequiredADDED_TO_SCENE_EVENT;

function requireADDED_TO_SCENE_EVENT () {
	if (hasRequiredADDED_TO_SCENE_EVENT) return ADDED_TO_SCENE_EVENT;
	hasRequiredADDED_TO_SCENE_EVENT = 1;
	ADDED_TO_SCENE_EVENT = 'addedtoscene';
	return ADDED_TO_SCENE_EVENT;
}

var DESTROY_EVENT$5;
var hasRequiredDESTROY_EVENT$5;

function requireDESTROY_EVENT$5 () {
	if (hasRequiredDESTROY_EVENT$5) return DESTROY_EVENT$5;
	hasRequiredDESTROY_EVENT$5 = 1;
	DESTROY_EVENT$5 = 'destroy';
	return DESTROY_EVENT$5;
}

var REMOVED_FROM_SCENE_EVENT;
var hasRequiredREMOVED_FROM_SCENE_EVENT;

function requireREMOVED_FROM_SCENE_EVENT () {
	if (hasRequiredREMOVED_FROM_SCENE_EVENT) return REMOVED_FROM_SCENE_EVENT;
	hasRequiredREMOVED_FROM_SCENE_EVENT = 1;
	REMOVED_FROM_SCENE_EVENT = 'removedfromscene';
	return REMOVED_FROM_SCENE_EVENT;
}

var VIDEO_COMPLETE_EVENT;
var hasRequiredVIDEO_COMPLETE_EVENT;

function requireVIDEO_COMPLETE_EVENT () {
	if (hasRequiredVIDEO_COMPLETE_EVENT) return VIDEO_COMPLETE_EVENT;
	hasRequiredVIDEO_COMPLETE_EVENT = 1;
	VIDEO_COMPLETE_EVENT = 'complete';
	return VIDEO_COMPLETE_EVENT;
}

var VIDEO_CREATED_EVENT;
var hasRequiredVIDEO_CREATED_EVENT;

function requireVIDEO_CREATED_EVENT () {
	if (hasRequiredVIDEO_CREATED_EVENT) return VIDEO_CREATED_EVENT;
	hasRequiredVIDEO_CREATED_EVENT = 1;
	VIDEO_CREATED_EVENT = 'created';
	return VIDEO_CREATED_EVENT;
}

var VIDEO_ERROR_EVENT;
var hasRequiredVIDEO_ERROR_EVENT;

function requireVIDEO_ERROR_EVENT () {
	if (hasRequiredVIDEO_ERROR_EVENT) return VIDEO_ERROR_EVENT;
	hasRequiredVIDEO_ERROR_EVENT = 1;
	VIDEO_ERROR_EVENT = 'error';
	return VIDEO_ERROR_EVENT;
}

var VIDEO_LOCKED_EVENT;
var hasRequiredVIDEO_LOCKED_EVENT;

function requireVIDEO_LOCKED_EVENT () {
	if (hasRequiredVIDEO_LOCKED_EVENT) return VIDEO_LOCKED_EVENT;
	hasRequiredVIDEO_LOCKED_EVENT = 1;
	VIDEO_LOCKED_EVENT = 'locked';
	return VIDEO_LOCKED_EVENT;
}

var VIDEO_LOOP_EVENT;
var hasRequiredVIDEO_LOOP_EVENT;

function requireVIDEO_LOOP_EVENT () {
	if (hasRequiredVIDEO_LOOP_EVENT) return VIDEO_LOOP_EVENT;
	hasRequiredVIDEO_LOOP_EVENT = 1;
	VIDEO_LOOP_EVENT = 'loop';
	return VIDEO_LOOP_EVENT;
}

var VIDEO_METADATA_EVENT;
var hasRequiredVIDEO_METADATA_EVENT;

function requireVIDEO_METADATA_EVENT () {
	if (hasRequiredVIDEO_METADATA_EVENT) return VIDEO_METADATA_EVENT;
	hasRequiredVIDEO_METADATA_EVENT = 1;
	VIDEO_METADATA_EVENT = 'metadata';
	return VIDEO_METADATA_EVENT;
}

var VIDEO_PLAY_EVENT;
var hasRequiredVIDEO_PLAY_EVENT;

function requireVIDEO_PLAY_EVENT () {
	if (hasRequiredVIDEO_PLAY_EVENT) return VIDEO_PLAY_EVENT;
	hasRequiredVIDEO_PLAY_EVENT = 1;
	VIDEO_PLAY_EVENT = 'play';
	return VIDEO_PLAY_EVENT;
}

var VIDEO_PLAYING_EVENT;
var hasRequiredVIDEO_PLAYING_EVENT;

function requireVIDEO_PLAYING_EVENT () {
	if (hasRequiredVIDEO_PLAYING_EVENT) return VIDEO_PLAYING_EVENT;
	hasRequiredVIDEO_PLAYING_EVENT = 1;
	VIDEO_PLAYING_EVENT = 'playing';
	return VIDEO_PLAYING_EVENT;
}

var VIDEO_SEEKED_EVENT;
var hasRequiredVIDEO_SEEKED_EVENT;

function requireVIDEO_SEEKED_EVENT () {
	if (hasRequiredVIDEO_SEEKED_EVENT) return VIDEO_SEEKED_EVENT;
	hasRequiredVIDEO_SEEKED_EVENT = 1;
	VIDEO_SEEKED_EVENT = 'seeked';
	return VIDEO_SEEKED_EVENT;
}

var VIDEO_SEEKING_EVENT;
var hasRequiredVIDEO_SEEKING_EVENT;

function requireVIDEO_SEEKING_EVENT () {
	if (hasRequiredVIDEO_SEEKING_EVENT) return VIDEO_SEEKING_EVENT;
	hasRequiredVIDEO_SEEKING_EVENT = 1;
	VIDEO_SEEKING_EVENT = 'seeking';
	return VIDEO_SEEKING_EVENT;
}

var VIDEO_STALLED_EVENT;
var hasRequiredVIDEO_STALLED_EVENT;

function requireVIDEO_STALLED_EVENT () {
	if (hasRequiredVIDEO_STALLED_EVENT) return VIDEO_STALLED_EVENT;
	hasRequiredVIDEO_STALLED_EVENT = 1;
	VIDEO_STALLED_EVENT = 'stalled';
	return VIDEO_STALLED_EVENT;
}

var VIDEO_STOP_EVENT;
var hasRequiredVIDEO_STOP_EVENT;

function requireVIDEO_STOP_EVENT () {
	if (hasRequiredVIDEO_STOP_EVENT) return VIDEO_STOP_EVENT;
	hasRequiredVIDEO_STOP_EVENT = 1;
	VIDEO_STOP_EVENT = 'stop';
	return VIDEO_STOP_EVENT;
}

var VIDEO_TEXTURE_EVENT;
var hasRequiredVIDEO_TEXTURE_EVENT;

function requireVIDEO_TEXTURE_EVENT () {
	if (hasRequiredVIDEO_TEXTURE_EVENT) return VIDEO_TEXTURE_EVENT;
	hasRequiredVIDEO_TEXTURE_EVENT = 1;
	VIDEO_TEXTURE_EVENT = 'textureready';
	return VIDEO_TEXTURE_EVENT;
}

var VIDEO_UNLOCKED_EVENT;
var hasRequiredVIDEO_UNLOCKED_EVENT;

function requireVIDEO_UNLOCKED_EVENT () {
	if (hasRequiredVIDEO_UNLOCKED_EVENT) return VIDEO_UNLOCKED_EVENT;
	hasRequiredVIDEO_UNLOCKED_EVENT = 1;
	VIDEO_UNLOCKED_EVENT = 'unlocked';
	return VIDEO_UNLOCKED_EVENT;
}

var VIDEO_UNSUPPORTED_EVENT;
var hasRequiredVIDEO_UNSUPPORTED_EVENT;

function requireVIDEO_UNSUPPORTED_EVENT () {
	if (hasRequiredVIDEO_UNSUPPORTED_EVENT) return VIDEO_UNSUPPORTED_EVENT;
	hasRequiredVIDEO_UNSUPPORTED_EVENT = 1;
	VIDEO_UNSUPPORTED_EVENT = 'unsupported';
	return VIDEO_UNSUPPORTED_EVENT;
}

var events$j;
var hasRequiredEvents$j;

function requireEvents$j () {
	if (hasRequiredEvents$j) return events$j;
	hasRequiredEvents$j = 1;
	events$j = {

	    ADDED_TO_SCENE: requireADDED_TO_SCENE_EVENT(),
	    DESTROY: requireDESTROY_EVENT$5(),
	    REMOVED_FROM_SCENE: requireREMOVED_FROM_SCENE_EVENT(),
	    VIDEO_COMPLETE: requireVIDEO_COMPLETE_EVENT(),
	    VIDEO_CREATED: requireVIDEO_CREATED_EVENT(),
	    VIDEO_ERROR: requireVIDEO_ERROR_EVENT(),
	    VIDEO_LOCKED: requireVIDEO_LOCKED_EVENT(),
	    VIDEO_LOOP: requireVIDEO_LOOP_EVENT(),
	    VIDEO_METADATA: requireVIDEO_METADATA_EVENT(),
	    VIDEO_PLAY: requireVIDEO_PLAY_EVENT(),
	    VIDEO_PLAYING: requireVIDEO_PLAYING_EVENT(),
	    VIDEO_SEEKED: requireVIDEO_SEEKED_EVENT(),
	    VIDEO_SEEKING: requireVIDEO_SEEKING_EVENT(),
	    VIDEO_STALLED: requireVIDEO_STALLED_EVENT(),
	    VIDEO_STOP: requireVIDEO_STOP_EVENT(),
	    VIDEO_TEXTURE: requireVIDEO_TEXTURE_EVENT(),
	    VIDEO_UNLOCKED: requireVIDEO_UNLOCKED_EVENT(),
	    VIDEO_UNSUPPORTED: requireVIDEO_UNSUPPORTED_EVENT()

	};
	return events$j;
}

var GameObject_1;
var hasRequiredGameObject;

function requireGameObject () {
	if (hasRequiredGameObject) return GameObject_1;
	hasRequiredGameObject = 1;
	var Class = requireClass();
	var ComponentsToJSON = requireToJSON();
	var DataManager = requireDataManager();
	var EventEmitter = requireEventemitter3();
	var Events = requireEvents$j();
	var SceneEvents = requireEvents$l();

	var GameObject = new Class({

	    Extends: EventEmitter,

	    initialize:

	    function GameObject (scene, type)
	    {
	        EventEmitter.call(this);

	        this.scene = scene;

	        this.displayList = null;

	        this.type = type;

	        this.state = 0;

	        this.parentContainer = null;

	        this.name = '';

	        this.active = true;

	        this.tabIndex = -1;

	        this.data = null;

	        this.renderFlags = 15;

	        this.cameraFilter = 0;

	        this.input = null;

	        this.body = null;

	        this.ignoreDestroy = false;

	        this.on(Events.ADDED_TO_SCENE, this.addedToScene, this);
	        this.on(Events.REMOVED_FROM_SCENE, this.removedFromScene, this);

	        scene.sys.queueDepthSort();
	    },

	    setActive: function (value)
	    {
	        this.active = value;

	        return this;
	    },

	    setName: function (value)
	    {
	        this.name = value;

	        return this;
	    },

	    setState: function (value)
	    {
	        this.state = value;

	        return this;
	    },

	    setDataEnabled: function ()
	    {
	        if (!this.data)
	        {
	            this.data = new DataManager(this);
	        }

	        return this;
	    },

	    setData: function (key, value)
	    {
	        if (!this.data)
	        {
	            this.data = new DataManager(this);
	        }

	        this.data.set(key, value);

	        return this;
	    },

	    incData: function (key, amount)
	    {
	        if (!this.data)
	        {
	            this.data = new DataManager(this);
	        }

	        this.data.inc(key, amount);

	        return this;
	    },

	    toggleData: function (key)
	    {
	        if (!this.data)
	        {
	            this.data = new DataManager(this);
	        }

	        this.data.toggle(key);

	        return this;
	    },

	    getData: function (key)
	    {
	        if (!this.data)
	        {
	            this.data = new DataManager(this);
	        }

	        return this.data.get(key);
	    },

	    setInteractive: function (hitArea, hitAreaCallback, dropZone)
	    {
	        this.scene.sys.input.enable(this, hitArea, hitAreaCallback, dropZone);

	        return this;
	    },

	    disableInteractive: function (resetCursor)
	    {
	        if (resetCursor === undefined) { resetCursor = false; }

	        this.scene.sys.input.disable(this, resetCursor);

	        return this;
	    },

	    removeInteractive: function (resetCursor)
	    {
	        if (resetCursor === undefined) { resetCursor = false; }

	        this.scene.sys.input.clear(this);

	        if (resetCursor)
	        {
	            this.scene.sys.input.resetCursor();
	        }

	        this.input = undefined;

	        return this;
	    },

	    addedToScene: function ()
	    {
	    },

	    removedFromScene: function ()
	    {
	    },

	    update: function ()
	    {
	    },

	    toJSON: function ()
	    {
	        return ComponentsToJSON(this);
	    },

	    willRender: function (camera)
	    {
	        var listWillRender = (this.displayList && this.displayList.active) ? this.displayList.willRender(camera) : true;

	        return !(!listWillRender || GameObject.RENDER_MASK !== this.renderFlags || (this.cameraFilter !== 0 && (this.cameraFilter & camera.id)));
	    },

	    getIndexList: function ()
	    {

	        var child = this;
	        var parent = this.parentContainer;

	        var indexes = [];

	        while (parent)
	        {
	            indexes.unshift(parent.getIndex(child));

	            child = parent;

	            if (!parent.parentContainer)
	            {
	                break;
	            }
	            else
	            {
	                parent = parent.parentContainer;
	            }
	        }

	        if (this.displayList)
	        {
	            indexes.unshift(this.displayList.getIndex(child));
	        }
	        else
	        {
	            indexes.unshift(this.scene.sys.displayList.getIndex(child));
	        }

	        return indexes;
	    },

	    addToDisplayList: function (displayList)
	    {
	        if (displayList === undefined) { displayList = this.scene.sys.displayList; }

	        if (this.displayList && this.displayList !== displayList)
	        {
	            this.removeFromDisplayList();
	        }

	        if (!displayList.exists(this))
	        {
	            this.displayList = displayList;

	            displayList.add(this, true);

	            displayList.queueDepthSort();

	            this.emit(Events.ADDED_TO_SCENE, this, this.scene);

	            displayList.events.emit(SceneEvents.ADDED_TO_SCENE, this, this.scene);
	        }

	        return this;
	    },

	    addToUpdateList: function ()
	    {
	        if (this.scene && this.preUpdate)
	        {
	            this.scene.sys.updateList.add(this);
	        }

	        return this;
	    },

	    removeFromDisplayList: function ()
	    {
	        var displayList = this.displayList || this.scene.sys.displayList;

	        if (displayList && displayList.exists(this))
	        {
	            displayList.remove(this, true);

	            displayList.queueDepthSort();

	            this.displayList = null;

	            this.emit(Events.REMOVED_FROM_SCENE, this, this.scene);

	            displayList.events.emit(SceneEvents.REMOVED_FROM_SCENE, this, this.scene);
	        }

	        return this;
	    },

	    removeFromUpdateList: function ()
	    {
	        if (this.scene && this.preUpdate)
	        {
	            this.scene.sys.updateList.remove(this);
	        }

	        return this;
	    },

	    getDisplayList: function ()
	    {
	        var list = null;

	        if (this.parentContainer)
	        {
	            list = this.parentContainer.list;
	        }
	        else if (this.displayList)
	        {
	            list = this.displayList.list;
	        }

	        return list;
	    },

	    destroy: function (fromScene)
	    {

	        if (!this.scene || this.ignoreDestroy)
	        {
	            return;
	        }

	        if (fromScene === undefined) { fromScene = false; }

	        if (this.preDestroy)
	        {
	            this.preDestroy.call(this);
	        }

	        this.emit(Events.DESTROY, this, fromScene);

	        this.removeAllListeners();

	        if (this.postPipelines)
	        {
	            this.resetPostPipeline(true);
	        }

	        this.removeFromDisplayList();
	        this.removeFromUpdateList();

	        if (this.input)
	        {
	            this.scene.sys.input.clear(this);

	            this.input = undefined;
	        }

	        if (this.data)
	        {
	            this.data.destroy();

	            this.data = undefined;
	        }

	        if (this.body)
	        {
	            this.body.destroy();

	            this.body = undefined;
	        }

	        if (this.preFX)
	        {
	            this.preFX.destroy();

	            this.preFX = undefined;
	        }

	        if (this.postFX)
	        {
	            this.postFX.destroy();

	            this.postFX = undefined;
	        }

	        this.active = false;
	        this.visible = false;

	        this.scene = undefined;
	        this.parentContainer = undefined;
	    }

	});

	GameObject.RENDER_MASK = 15;

	GameObject_1 = GameObject;
	return GameObject_1;
}

var Zone_1;
var hasRequiredZone;

function requireZone () {
	if (hasRequiredZone) return Zone_1;
	hasRequiredZone = 1;
	var BlendModes = requireBlendModes();
	var Circle = requireCircle$2();
	var CircleContains = requireContains$4();
	var Class = requireClass();
	var Components = requireComponents$2();
	var GameObject = requireGameObject();
	var Rectangle = requireRectangle$2();
	var RectangleContains = requireContains$3();

	var Zone = new Class({

	    Extends: GameObject,

	    Mixins: [
	        Components.Depth,
	        Components.GetBounds,
	        Components.Origin,
	        Components.Transform,
	        Components.ScrollFactor,
	        Components.Visible
	    ],

	    initialize:

	    function Zone (scene, x, y, width, height)
	    {
	        if (width === undefined) { width = 1; }
	        if (height === undefined) { height = width; }

	        GameObject.call(this, scene, 'Zone');

	        this.setPosition(x, y);

	        this.width = width;

	        this.height = height;

	        this.blendMode = BlendModes.NORMAL;

	        this.updateDisplayOrigin();
	    },

	    displayWidth: {

	        get: function ()
	        {
	            return this.scaleX * this.width;
	        },

	        set: function (value)
	        {
	            this.scaleX = value / this.width;
	        }

	    },

	    displayHeight: {

	        get: function ()
	        {
	            return this.scaleY * this.height;
	        },

	        set: function (value)
	        {
	            this.scaleY = value / this.height;
	        }

	    },

	    setSize: function (width, height, resizeInput)
	    {
	        if (resizeInput === undefined) { resizeInput = true; }

	        this.width = width;
	        this.height = height;

	        this.updateDisplayOrigin();

	        var input = this.input;

	        if (resizeInput && input && !input.customHitArea)
	        {
	            input.hitArea.width = width;
	            input.hitArea.height = height;
	        }

	        return this;
	    },

	    setDisplaySize: function (width, height)
	    {
	        this.displayWidth = width;
	        this.displayHeight = height;

	        return this;
	    },

	    setCircleDropZone: function (radius)
	    {
	        return this.setDropZone(new Circle(0, 0, radius), CircleContains);
	    },

	    setRectangleDropZone: function (width, height)
	    {
	        return this.setDropZone(new Rectangle(0, 0, width, height), RectangleContains);
	    },

	    setDropZone: function (hitArea, hitAreaCallback)
	    {
	        if (!this.input)
	        {
	            this.setInteractive(hitArea, hitAreaCallback, true);
	        }

	        return this;
	    },

	    setAlpha: function ()
	    {
	    },

	    setBlendMode: function ()
	    {
	    },

	    renderCanvas: function (renderer, src, camera)
	    {
	        camera.addToRenderList(src);
	    },

	    renderWebGL: function (renderer, src, camera)
	    {
	        camera.addToRenderList(src);
	    }

	});

	Zone_1 = Zone;
	return Zone_1;
}

var GridAlign_1;
var hasRequiredGridAlign;

function requireGridAlign () {
	if (hasRequiredGridAlign) return GridAlign_1;
	hasRequiredGridAlign = 1;
	var AlignIn = requireQuickSet();
	var CONST = require_const$e();
	var GetFastValue = requireGetFastValue();
	var NOOP = requireNOOP();
	var Zone = requireZone();

	var tempZone = new Zone({ sys: { queueDepthSort: NOOP, events: { once: NOOP } } }, 0, 0, 1, 1).setOrigin(0, 0);

	var GridAlign = function (items, options)
	{
	    if (options === undefined) { options = {}; }

	    var widthSet = options.hasOwnProperty('width');
	    var heightSet = options.hasOwnProperty('height');

	    var width = GetFastValue(options, 'width', -1);
	    var height = GetFastValue(options, 'height', -1);

	    var cellWidth = GetFastValue(options, 'cellWidth', 1);
	    var cellHeight = GetFastValue(options, 'cellHeight', cellWidth);

	    var position = GetFastValue(options, 'position', CONST.TOP_LEFT);
	    var x = GetFastValue(options, 'x', 0);
	    var y = GetFastValue(options, 'y', 0);

	    var cx = 0;
	    var cy = 0;
	    var w = (width * cellWidth);
	    var h = (height * cellHeight);

	    tempZone.setPosition(x, y);
	    tempZone.setSize(cellWidth, cellHeight);

	    for (var i = 0; i < items.length; i++)
	    {
	        AlignIn(items[i], tempZone, position);

	        if (widthSet && width === -1)
	        {

	            tempZone.x += cellWidth;
	        }
	        else if (heightSet && height === -1)
	        {

	            tempZone.y += cellHeight;
	        }
	        else if (heightSet && !widthSet)
	        {

	            cy += cellHeight;
	            tempZone.y += cellHeight;

	            if (cy === h)
	            {
	                cy = 0;
	                cx += cellWidth;
	                tempZone.y = y;
	                tempZone.x += cellWidth;

	                if (cx === w)
	                {

	                    break;
	                }
	            }
	        }
	        else
	        {

	            cx += cellWidth;
	            tempZone.x += cellWidth;

	            if (cx === w)
	            {
	                cx = 0;
	                cy += cellHeight;
	                tempZone.x = x;
	                tempZone.y += cellHeight;

	                if (cy === h)
	                {

	                    break;
	                }
	            }
	        }
	    }

	    return items;
	};

	GridAlign_1 = GridAlign;
	return GridAlign_1;
}

var IncAlpha_1;
var hasRequiredIncAlpha;

function requireIncAlpha () {
	if (hasRequiredIncAlpha) return IncAlpha_1;
	hasRequiredIncAlpha = 1;
	var PropertyValueInc = requirePropertyValueInc();

	var IncAlpha = function (items, value, step, index, direction)
	{
	    return PropertyValueInc(items, 'alpha', value, step, index, direction);
	};

	IncAlpha_1 = IncAlpha;
	return IncAlpha_1;
}

var IncX_1;
var hasRequiredIncX;

function requireIncX () {
	if (hasRequiredIncX) return IncX_1;
	hasRequiredIncX = 1;
	var PropertyValueInc = requirePropertyValueInc();

	var IncX = function (items, value, step, index, direction)
	{
	    return PropertyValueInc(items, 'x', value, step, index, direction);
	};

	IncX_1 = IncX;
	return IncX_1;
}

var IncXY_1;
var hasRequiredIncXY;

function requireIncXY () {
	if (hasRequiredIncXY) return IncXY_1;
	hasRequiredIncXY = 1;
	var PropertyValueInc = requirePropertyValueInc();

	var IncXY = function (items, x, y, stepX, stepY, index, direction)
	{
	    if (y === undefined || y === null) { y = x; }

	    PropertyValueInc(items, 'x', x, stepX, index, direction);

	    return PropertyValueInc(items, 'y', y, stepY, index, direction);
	};

	IncXY_1 = IncXY;
	return IncXY_1;
}

var IncY_1;
var hasRequiredIncY;

function requireIncY () {
	if (hasRequiredIncY) return IncY_1;
	hasRequiredIncY = 1;
	var PropertyValueInc = requirePropertyValueInc();

	var IncY = function (items, value, step, index, direction)
	{
	    return PropertyValueInc(items, 'y', value, step, index, direction);
	};

	IncY_1 = IncY;
	return IncY_1;
}

var PlaceOnCircle_1;
var hasRequiredPlaceOnCircle;

function requirePlaceOnCircle () {
	if (hasRequiredPlaceOnCircle) return PlaceOnCircle_1;
	hasRequiredPlaceOnCircle = 1;
	var PlaceOnCircle = function (items, circle, startAngle, endAngle)
	{
	    if (startAngle === undefined) { startAngle = 0; }
	    if (endAngle === undefined) { endAngle = 6.28; }

	    var angle = startAngle;
	    var angleStep = (endAngle - startAngle) / items.length;

	    var cx = circle.x;
	    var cy = circle.y;
	    var radius = circle.radius;

	    for (var i = 0; i < items.length; i++)
	    {
	        items[i].x = cx + (radius * Math.cos(angle));
	        items[i].y = cy + (radius * Math.sin(angle));

	        angle += angleStep;
	    }

	    return items;
	};

	PlaceOnCircle_1 = PlaceOnCircle;
	return PlaceOnCircle_1;
}

var PlaceOnEllipse_1;
var hasRequiredPlaceOnEllipse;

function requirePlaceOnEllipse () {
	if (hasRequiredPlaceOnEllipse) return PlaceOnEllipse_1;
	hasRequiredPlaceOnEllipse = 1;
	var PlaceOnEllipse = function (items, ellipse, startAngle, endAngle)
	{
	    if (startAngle === undefined) { startAngle = 0; }
	    if (endAngle === undefined) { endAngle = 6.28; }

	    var angle = startAngle;
	    var angleStep = (endAngle - startAngle) / items.length;

	    var a = ellipse.width / 2;
	    var b = ellipse.height / 2;

	    for (var i = 0; i < items.length; i++)
	    {
	        items[i].x = ellipse.x + a * Math.cos(angle);
	        items[i].y = ellipse.y + b * Math.sin(angle);

	        angle += angleStep;
	    }

	    return items;
	};

	PlaceOnEllipse_1 = PlaceOnEllipse;
	return PlaceOnEllipse_1;
}

var DistanceBetweenPoints_1;
var hasRequiredDistanceBetweenPoints;

function requireDistanceBetweenPoints () {
	if (hasRequiredDistanceBetweenPoints) return DistanceBetweenPoints_1;
	hasRequiredDistanceBetweenPoints = 1;
	var DistanceBetweenPoints = function (a, b)
	{
	    var dx = a.x - b.x;
	    var dy = a.y - b.y;

	    return Math.sqrt(dx * dx + dy * dy);
	};

	DistanceBetweenPoints_1 = DistanceBetweenPoints;
	return DistanceBetweenPoints_1;
}

var In_1$9;
var hasRequiredIn$9;

function requireIn$9 () {
	if (hasRequiredIn$9) return In_1$9;
	hasRequiredIn$9 = 1;
	var In = function (v, overshoot)
	{
	    if (overshoot === undefined) { overshoot = 1.70158; }

	    return v * v * ((overshoot + 1) * v - overshoot);
	};

	In_1$9 = In;
	return In_1$9;
}

var Out_1$9;
var hasRequiredOut$9;

function requireOut$9 () {
	if (hasRequiredOut$9) return Out_1$9;
	hasRequiredOut$9 = 1;
	var Out = function (v, overshoot)
	{
	    if (overshoot === undefined) { overshoot = 1.70158; }

	    return --v * v * ((overshoot + 1) * v + overshoot) + 1;
	};

	Out_1$9 = Out;
	return Out_1$9;
}

var InOut_1$9;
var hasRequiredInOut$9;

function requireInOut$9 () {
	if (hasRequiredInOut$9) return InOut_1$9;
	hasRequiredInOut$9 = 1;
	var InOut = function (v, overshoot)
	{
	    if (overshoot === undefined) { overshoot = 1.70158; }

	    var s = overshoot * 1.525;

	    if ((v *= 2) < 1)
	    {
	        return 0.5 * (v * v * ((s + 1) * v - s));
	    }
	    else
	    {
	        return 0.5 * ((v -= 2) * v * ((s + 1) * v + s) + 2);
	    }
	};

	InOut_1$9 = InOut;
	return InOut_1$9;
}

var back;
var hasRequiredBack;

function requireBack () {
	if (hasRequiredBack) return back;
	hasRequiredBack = 1;
	back = {

	    In: requireIn$9(),
	    Out: requireOut$9(),
	    InOut: requireInOut$9()

	};
	return back;
}

var In_1$8;
var hasRequiredIn$8;

function requireIn$8 () {
	if (hasRequiredIn$8) return In_1$8;
	hasRequiredIn$8 = 1;
	var In = function (v)
	{
	    v = 1 - v;

	    if (v < 1 / 2.75)
	    {
	        return 1 - (7.5625 * v * v);
	    }
	    else if (v < 2 / 2.75)
	    {
	        return 1 - (7.5625 * (v -= 1.5 / 2.75) * v + 0.75);
	    }
	    else if (v < 2.5 / 2.75)
	    {
	        return 1 - (7.5625 * (v -= 2.25 / 2.75) * v + 0.9375);
	    }
	    else
	    {
	        return 1 - (7.5625 * (v -= 2.625 / 2.75) * v + 0.984375);
	    }
	};

	In_1$8 = In;
	return In_1$8;
}

var Out_1$8;
var hasRequiredOut$8;

function requireOut$8 () {
	if (hasRequiredOut$8) return Out_1$8;
	hasRequiredOut$8 = 1;
	var Out = function (v)
	{
	    if (v < 1 / 2.75)
	    {
	        return 7.5625 * v * v;
	    }
	    else if (v < 2 / 2.75)
	    {
	        return 7.5625 * (v -= 1.5 / 2.75) * v + 0.75;
	    }
	    else if (v < 2.5 / 2.75)
	    {
	        return 7.5625 * (v -= 2.25 / 2.75) * v + 0.9375;
	    }
	    else
	    {
	        return 7.5625 * (v -= 2.625 / 2.75) * v + 0.984375;
	    }
	};

	Out_1$8 = Out;
	return Out_1$8;
}

var InOut_1$8;
var hasRequiredInOut$8;

function requireInOut$8 () {
	if (hasRequiredInOut$8) return InOut_1$8;
	hasRequiredInOut$8 = 1;
	var InOut = function (v)
	{
	    var reverse = false;

	    if (v < 0.5)
	    {
	        v = 1 - (v * 2);
	        reverse = true;
	    }
	    else
	    {
	        v = (v * 2) - 1;
	    }

	    if (v < 1 / 2.75)
	    {
	        v = 7.5625 * v * v;
	    }
	    else if (v < 2 / 2.75)
	    {
	        v = 7.5625 * (v -= 1.5 / 2.75) * v + 0.75;
	    }
	    else if (v < 2.5 / 2.75)
	    {
	        v = 7.5625 * (v -= 2.25 / 2.75) * v + 0.9375;
	    }
	    else
	    {
	        v = 7.5625 * (v -= 2.625 / 2.75) * v + 0.984375;
	    }

	    if (reverse)
	    {
	        return (1 - v) * 0.5;
	    }
	    else
	    {
	        return v * 0.5 + 0.5;
	    }
	};

	InOut_1$8 = InOut;
	return InOut_1$8;
}

var bounce;
var hasRequiredBounce$1;

function requireBounce$1 () {
	if (hasRequiredBounce$1) return bounce;
	hasRequiredBounce$1 = 1;
	bounce = {

	    In: requireIn$8(),
	    Out: requireOut$8(),
	    InOut: requireInOut$8()

	};
	return bounce;
}

var In_1$7;
var hasRequiredIn$7;

function requireIn$7 () {
	if (hasRequiredIn$7) return In_1$7;
	hasRequiredIn$7 = 1;
	var In = function (v)
	{
	    return 1 - Math.sqrt(1 - v * v);
	};

	In_1$7 = In;
	return In_1$7;
}

var Out_1$7;
var hasRequiredOut$7;

function requireOut$7 () {
	if (hasRequiredOut$7) return Out_1$7;
	hasRequiredOut$7 = 1;
	var Out = function (v)
	{
	    return Math.sqrt(1 - (--v * v));
	};

	Out_1$7 = Out;
	return Out_1$7;
}

var InOut_1$7;
var hasRequiredInOut$7;

function requireInOut$7 () {
	if (hasRequiredInOut$7) return InOut_1$7;
	hasRequiredInOut$7 = 1;
	var InOut = function (v)
	{
	    if ((v *= 2) < 1)
	    {
	        return -0.5 * (Math.sqrt(1 - v * v) - 1);
	    }
	    else
	    {
	        return 0.5 * (Math.sqrt(1 - (v -= 2) * v) + 1);
	    }
	};

	InOut_1$7 = InOut;
	return InOut_1$7;
}

var circular;
var hasRequiredCircular;

function requireCircular () {
	if (hasRequiredCircular) return circular;
	hasRequiredCircular = 1;
	circular = {

	    In: requireIn$7(),
	    Out: requireOut$7(),
	    InOut: requireInOut$7()

	};
	return circular;
}

var In_1$6;
var hasRequiredIn$6;

function requireIn$6 () {
	if (hasRequiredIn$6) return In_1$6;
	hasRequiredIn$6 = 1;
	var In = function (v)
	{
	    return v * v * v;
	};

	In_1$6 = In;
	return In_1$6;
}

var Out_1$6;
var hasRequiredOut$6;

function requireOut$6 () {
	if (hasRequiredOut$6) return Out_1$6;
	hasRequiredOut$6 = 1;
	var Out = function (v)
	{
	    return --v * v * v + 1;
	};

	Out_1$6 = Out;
	return Out_1$6;
}

var InOut_1$6;
var hasRequiredInOut$6;

function requireInOut$6 () {
	if (hasRequiredInOut$6) return InOut_1$6;
	hasRequiredInOut$6 = 1;
	var InOut = function (v)
	{
	    if ((v *= 2) < 1)
	    {
	        return 0.5 * v * v * v;
	    }
	    else
	    {
	        return 0.5 * ((v -= 2) * v * v + 2);
	    }
	};

	InOut_1$6 = InOut;
	return InOut_1$6;
}

var cubic;
var hasRequiredCubic;

function requireCubic () {
	if (hasRequiredCubic) return cubic;
	hasRequiredCubic = 1;
	cubic = {

	    In: requireIn$6(),
	    Out: requireOut$6(),
	    InOut: requireInOut$6()

	};
	return cubic;
}

var In_1$5;
var hasRequiredIn$5;

function requireIn$5 () {
	if (hasRequiredIn$5) return In_1$5;
	hasRequiredIn$5 = 1;
	var In = function (v, amplitude, period)
	{
	    if (amplitude === undefined) { amplitude = 0.1; }
	    if (period === undefined) { period = 0.1; }

	    if (v === 0)
	    {
	        return 0;
	    }
	    else if (v === 1)
	    {
	        return 1;
	    }
	    else
	    {
	        var s = period / 4;

	        if (amplitude < 1)
	        {
	            amplitude = 1;
	        }
	        else
	        {
	            s = period * Math.asin(1 / amplitude) / (2 * Math.PI);
	        }

	        return -(amplitude * Math.pow(2, 10 * (v -= 1)) * Math.sin((v - s) * (2 * Math.PI) / period));
	    }
	};

	In_1$5 = In;
	return In_1$5;
}

var Out_1$5;
var hasRequiredOut$5;

function requireOut$5 () {
	if (hasRequiredOut$5) return Out_1$5;
	hasRequiredOut$5 = 1;
	var Out = function (v, amplitude, period)
	{
	    if (amplitude === undefined) { amplitude = 0.1; }
	    if (period === undefined) { period = 0.1; }

	    if (v === 0)
	    {
	        return 0;
	    }
	    else if (v === 1)
	    {
	        return 1;
	    }
	    else
	    {
	        var s = period / 4;

	        if (amplitude < 1)
	        {
	            amplitude = 1;
	        }
	        else
	        {
	            s = period * Math.asin(1 / amplitude) / (2 * Math.PI);
	        }

	        return (amplitude * Math.pow(2, -10 * v) * Math.sin((v - s) * (2 * Math.PI) / period) + 1);
	    }
	};

	Out_1$5 = Out;
	return Out_1$5;
}

var InOut_1$5;
var hasRequiredInOut$5;

function requireInOut$5 () {
	if (hasRequiredInOut$5) return InOut_1$5;
	hasRequiredInOut$5 = 1;
	var InOut = function (v, amplitude, period)
	{
	    if (amplitude === undefined) { amplitude = 0.1; }
	    if (period === undefined) { period = 0.1; }

	    if (v === 0)
	    {
	        return 0;
	    }
	    else if (v === 1)
	    {
	        return 1;
	    }
	    else
	    {
	        var s = period / 4;

	        if (amplitude < 1)
	        {
	            amplitude = 1;
	        }
	        else
	        {
	            s = period * Math.asin(1 / amplitude) / (2 * Math.PI);
	        }

	        if ((v *= 2) < 1)
	        {
	            return -0.5 * (amplitude * Math.pow(2, 10 * (v -= 1)) * Math.sin((v - s) * (2 * Math.PI) / period));
	        }
	        else
	        {
	            return amplitude * Math.pow(2, -10 * (v -= 1)) * Math.sin((v - s) * (2 * Math.PI) / period) * 0.5 + 1;
	        }
	    }
	};

	InOut_1$5 = InOut;
	return InOut_1$5;
}

var elastic;
var hasRequiredElastic;

function requireElastic () {
	if (hasRequiredElastic) return elastic;
	hasRequiredElastic = 1;
	elastic = {

	    In: requireIn$5(),
	    Out: requireOut$5(),
	    InOut: requireInOut$5()

	};
	return elastic;
}

var In_1$4;
var hasRequiredIn$4;

function requireIn$4 () {
	if (hasRequiredIn$4) return In_1$4;
	hasRequiredIn$4 = 1;
	var In = function (v)
	{
	    return Math.pow(2, 10 * (v - 1)) - 0.001;
	};

	In_1$4 = In;
	return In_1$4;
}

var Out_1$4;
var hasRequiredOut$4;

function requireOut$4 () {
	if (hasRequiredOut$4) return Out_1$4;
	hasRequiredOut$4 = 1;
	var Out = function (v)
	{
	    return 1 - Math.pow(2, -10 * v);
	};

	Out_1$4 = Out;
	return Out_1$4;
}

var InOut_1$4;
var hasRequiredInOut$4;

function requireInOut$4 () {
	if (hasRequiredInOut$4) return InOut_1$4;
	hasRequiredInOut$4 = 1;
	var InOut = function (v)
	{
	    if ((v *= 2) < 1)
	    {
	        return 0.5 * Math.pow(2, 10 * (v - 1));
	    }
	    else
	    {
	        return 0.5 * (2 - Math.pow(2, -10 * (v - 1)));
	    }
	};

	InOut_1$4 = InOut;
	return InOut_1$4;
}

var expo;
var hasRequiredExpo;

function requireExpo () {
	if (hasRequiredExpo) return expo;
	hasRequiredExpo = 1;
	expo = {

	    In: requireIn$4(),
	    Out: requireOut$4(),
	    InOut: requireInOut$4()

	};
	return expo;
}

var Linear_1$1;
var hasRequiredLinear$2;

function requireLinear$2 () {
	if (hasRequiredLinear$2) return Linear_1$1;
	hasRequiredLinear$2 = 1;
	var Linear = function (v)
	{
	    return v;
	};

	Linear_1$1 = Linear;
	return Linear_1$1;
}

var linear;
var hasRequiredLinear$1;

function requireLinear$1 () {
	if (hasRequiredLinear$1) return linear;
	hasRequiredLinear$1 = 1;
	linear = requireLinear$2();
	return linear;
}

var In_1$3;
var hasRequiredIn$3;

function requireIn$3 () {
	if (hasRequiredIn$3) return In_1$3;
	hasRequiredIn$3 = 1;
	var In = function (v)
	{
	    return v * v;
	};

	In_1$3 = In;
	return In_1$3;
}

var Out_1$3;
var hasRequiredOut$3;

function requireOut$3 () {
	if (hasRequiredOut$3) return Out_1$3;
	hasRequiredOut$3 = 1;
	var Out = function (v)
	{
	    return v * (2 - v);
	};

	Out_1$3 = Out;
	return Out_1$3;
}

var InOut_1$3;
var hasRequiredInOut$3;

function requireInOut$3 () {
	if (hasRequiredInOut$3) return InOut_1$3;
	hasRequiredInOut$3 = 1;
	var InOut = function (v)
	{
	    if ((v *= 2) < 1)
	    {
	        return 0.5 * v * v;
	    }
	    else
	    {
	        return -0.5 * (--v * (v - 2) - 1);
	    }
	};

	InOut_1$3 = InOut;
	return InOut_1$3;
}

var quadratic;
var hasRequiredQuadratic;

function requireQuadratic () {
	if (hasRequiredQuadratic) return quadratic;
	hasRequiredQuadratic = 1;
	quadratic = {

	    In: requireIn$3(),
	    Out: requireOut$3(),
	    InOut: requireInOut$3()

	};
	return quadratic;
}

var In_1$2;
var hasRequiredIn$2;

function requireIn$2 () {
	if (hasRequiredIn$2) return In_1$2;
	hasRequiredIn$2 = 1;
	var In = function (v)
	{
	    return v * v * v * v;
	};

	In_1$2 = In;
	return In_1$2;
}

var Out_1$2;
var hasRequiredOut$2;

function requireOut$2 () {
	if (hasRequiredOut$2) return Out_1$2;
	hasRequiredOut$2 = 1;
	var Out = function (v)
	{
	    return 1 - (--v * v * v * v);
	};

	Out_1$2 = Out;
	return Out_1$2;
}

var InOut_1$2;
var hasRequiredInOut$2;

function requireInOut$2 () {
	if (hasRequiredInOut$2) return InOut_1$2;
	hasRequiredInOut$2 = 1;
	var InOut = function (v)
	{
	    if ((v *= 2) < 1)
	    {
	        return 0.5 * v * v * v * v;
	    }
	    else
	    {
	        return -0.5 * ((v -= 2) * v * v * v - 2);
	    }
	};

	InOut_1$2 = InOut;
	return InOut_1$2;
}

var quartic;
var hasRequiredQuartic;

function requireQuartic () {
	if (hasRequiredQuartic) return quartic;
	hasRequiredQuartic = 1;
	quartic = {

	    In: requireIn$2(),
	    Out: requireOut$2(),
	    InOut: requireInOut$2()

	};
	return quartic;
}

var In_1$1;
var hasRequiredIn$1;

function requireIn$1 () {
	if (hasRequiredIn$1) return In_1$1;
	hasRequiredIn$1 = 1;
	var In = function (v)
	{
	    return v * v * v * v * v;
	};

	In_1$1 = In;
	return In_1$1;
}

var Out_1$1;
var hasRequiredOut$1;

function requireOut$1 () {
	if (hasRequiredOut$1) return Out_1$1;
	hasRequiredOut$1 = 1;
	var Out = function (v)
	{
	    return --v * v * v * v * v + 1;
	};

	Out_1$1 = Out;
	return Out_1$1;
}

var InOut_1$1;
var hasRequiredInOut$1;

function requireInOut$1 () {
	if (hasRequiredInOut$1) return InOut_1$1;
	hasRequiredInOut$1 = 1;
	var InOut = function (v)
	{
	    if ((v *= 2) < 1)
	    {
	        return 0.5 * v * v * v * v * v;
	    }
	    else
	    {
	        return 0.5 * ((v -= 2) * v * v * v * v + 2);
	    }
	};

	InOut_1$1 = InOut;
	return InOut_1$1;
}

var quintic;
var hasRequiredQuintic;

function requireQuintic () {
	if (hasRequiredQuintic) return quintic;
	hasRequiredQuintic = 1;
	quintic = {

	    In: requireIn$1(),
	    Out: requireOut$1(),
	    InOut: requireInOut$1()

	};
	return quintic;
}

var In_1;
var hasRequiredIn;

function requireIn () {
	if (hasRequiredIn) return In_1;
	hasRequiredIn = 1;
	var In = function (v)
	{
	    if (v === 0)
	    {
	        return 0;
	    }
	    else if (v === 1)
	    {
	        return 1;
	    }
	    else
	    {
	        return 1 - Math.cos(v * Math.PI / 2);
	    }
	};

	In_1 = In;
	return In_1;
}

var Out_1;
var hasRequiredOut;

function requireOut () {
	if (hasRequiredOut) return Out_1;
	hasRequiredOut = 1;
	var Out = function (v)
	{
	    if (v === 0)
	    {
	        return 0;
	    }
	    else if (v === 1)
	    {
	        return 1;
	    }
	    else
	    {
	        return Math.sin(v * Math.PI / 2);
	    }
	};

	Out_1 = Out;
	return Out_1;
}

var InOut_1;
var hasRequiredInOut;

function requireInOut () {
	if (hasRequiredInOut) return InOut_1;
	hasRequiredInOut = 1;
	var InOut = function (v)
	{
	    if (v === 0)
	    {
	        return 0;
	    }
	    else if (v === 1)
	    {
	        return 1;
	    }
	    else
	    {
	        return 0.5 * (1 - Math.cos(Math.PI * v));
	    }
	};

	InOut_1 = InOut;
	return InOut_1;
}

var sine;
var hasRequiredSine;

function requireSine () {
	if (hasRequiredSine) return sine;
	hasRequiredSine = 1;
	sine = {

	    In: requireIn(),
	    Out: requireOut(),
	    InOut: requireInOut()

	};
	return sine;
}

var Stepped_1;
var hasRequiredStepped$1;

function requireStepped$1 () {
	if (hasRequiredStepped$1) return Stepped_1;
	hasRequiredStepped$1 = 1;
	var Stepped = function (v, steps)
	{
	    if (steps === undefined) { steps = 1; }

	    if (v <= 0)
	    {
	        return 0;
	    }
	    else if (v >= 1)
	    {
	        return 1;
	    }
	    else
	    {
	        return (((steps * v) | 0) + 1) * (1 / steps);
	    }
	};

	Stepped_1 = Stepped;
	return Stepped_1;
}

var stepped;
var hasRequiredStepped;

function requireStepped () {
	if (hasRequiredStepped) return stepped;
	hasRequiredStepped = 1;
	stepped = requireStepped$1();
	return stepped;
}

var EaseMap;
var hasRequiredEaseMap;

function requireEaseMap () {
	if (hasRequiredEaseMap) return EaseMap;
	hasRequiredEaseMap = 1;
	var Back = requireBack();
	var Bounce = requireBounce$1();
	var Circular = requireCircular();
	var Cubic = requireCubic();
	var Elastic = requireElastic();
	var Expo = requireExpo();
	var Linear = requireLinear$1();
	var Quadratic = requireQuadratic();
	var Quartic = requireQuartic();
	var Quintic = requireQuintic();
	var Sine = requireSine();
	var Stepped = requireStepped();

	EaseMap = {

	    Power0: Linear,
	    Power1: Quadratic.Out,
	    Power2: Cubic.Out,
	    Power3: Quartic.Out,
	    Power4: Quintic.Out,

	    Linear: Linear,
	    Quad: Quadratic.Out,
	    Cubic: Cubic.Out,
	    Quart: Quartic.Out,
	    Quint: Quintic.Out,
	    Sine: Sine.Out,
	    Expo: Expo.Out,
	    Circ: Circular.Out,
	    Elastic: Elastic.Out,
	    Back: Back.Out,
	    Bounce: Bounce.Out,
	    Stepped: Stepped,

	    'Quad.easeIn': Quadratic.In,
	    'Cubic.easeIn': Cubic.In,
	    'Quart.easeIn': Quartic.In,
	    'Quint.easeIn': Quintic.In,
	    'Sine.easeIn': Sine.In,
	    'Expo.easeIn': Expo.In,
	    'Circ.easeIn': Circular.In,
	    'Elastic.easeIn': Elastic.In,
	    'Back.easeIn': Back.In,
	    'Bounce.easeIn': Bounce.In,

	    'Quad.easeOut': Quadratic.Out,
	    'Cubic.easeOut': Cubic.Out,
	    'Quart.easeOut': Quartic.Out,
	    'Quint.easeOut': Quintic.Out,
	    'Sine.easeOut': Sine.Out,
	    'Expo.easeOut': Expo.Out,
	    'Circ.easeOut': Circular.Out,
	    'Elastic.easeOut': Elastic.Out,
	    'Back.easeOut': Back.Out,
	    'Bounce.easeOut': Bounce.Out,

	    'Quad.easeInOut': Quadratic.InOut,
	    'Cubic.easeInOut': Cubic.InOut,
	    'Quart.easeInOut': Quartic.InOut,
	    'Quint.easeInOut': Quintic.InOut,
	    'Sine.easeInOut': Sine.InOut,
	    'Expo.easeInOut': Expo.InOut,
	    'Circ.easeInOut': Circular.InOut,
	    'Elastic.easeInOut': Elastic.InOut,
	    'Back.easeInOut': Back.InOut,
	    'Bounce.easeInOut': Bounce.InOut

	};
	return EaseMap;
}

var UppercaseFirst_1;
var hasRequiredUppercaseFirst;

function requireUppercaseFirst () {
	if (hasRequiredUppercaseFirst) return UppercaseFirst_1;
	hasRequiredUppercaseFirst = 1;
	var UppercaseFirst = function (str)
	{
	    return str && str[0].toUpperCase() + str.slice(1);
	};

	UppercaseFirst_1 = UppercaseFirst;
	return UppercaseFirst_1;
}

var GetEaseFunction_1;
var hasRequiredGetEaseFunction;

function requireGetEaseFunction () {
	if (hasRequiredGetEaseFunction) return GetEaseFunction_1;
	hasRequiredGetEaseFunction = 1;
	var EaseMap = requireEaseMap();
	var UppercaseFirst = requireUppercaseFirst();

	var GetEaseFunction = function (ease, easeParams)
	{

	    var easeFunction = EaseMap.Power0;

	    if (typeof ease === 'string')
	    {

	        if (EaseMap.hasOwnProperty(ease))
	        {
	            easeFunction = EaseMap[ease];
	        }
	        else
	        {

	            var direction = '';

	            if (ease.indexOf('.'))
	            {

	                direction = ease.substring(ease.indexOf('.') + 1);

	                var directionLower = direction.toLowerCase();

	                if (directionLower === 'in')
	                {
	                    direction = 'easeIn';
	                }
	                else if (directionLower === 'out')
	                {
	                    direction = 'easeOut';
	                }
	                else if (directionLower === 'inout')
	                {
	                    direction = 'easeInOut';
	                }
	            }

	            ease = UppercaseFirst(ease.substring(0, ease.indexOf('.') + 1) + direction);

	            if (EaseMap.hasOwnProperty(ease))
	            {
	                easeFunction = EaseMap[ease];
	            }
	        }
	    }
	    else if (typeof ease === 'function')
	    {

	        easeFunction = ease;
	    }

	    if (!easeParams)
	    {

	        return easeFunction;
	    }

	    var cloneParams = easeParams.slice(0);

	    cloneParams.unshift(0);

	    return function (v)
	    {
	        cloneParams[0] = v;

	        return easeFunction.apply(this, cloneParams);
	    };
	};

	GetEaseFunction_1 = GetEaseFunction;
	return GetEaseFunction_1;
}

var GetEasedPoints_1;
var hasRequiredGetEasedPoints;

function requireGetEasedPoints () {
	if (hasRequiredGetEasedPoints) return GetEasedPoints_1;
	hasRequiredGetEasedPoints = 1;
	var DistanceBetweenPoints = requireDistanceBetweenPoints();
	var GetEaseFunction = requireGetEaseFunction();
	var Point = requirePoint$1();

	var GetEasedPoints = function (line, ease, quantity, collinearThreshold, easeParams)
	{
	    if (collinearThreshold === undefined) { collinearThreshold = 0; }
	    if (easeParams === undefined) { easeParams = []; }

	    var results = [];

	    var x1 = line.x1;
	    var y1 = line.y1;

	    var spaceX = line.x2 - x1;
	    var spaceY = line.y2 - y1;

	    var easeFunc = GetEaseFunction(ease, easeParams);

	    var i;
	    var v;
	    var q = quantity - 1;

	    for (i = 0; i < q; i++)
	    {
	        v = easeFunc(i / q);

	        results.push(new Point(x1 + (spaceX * v), y1 + (spaceY * v)));
	    }

	    v = easeFunc(1);

	    results.push(new Point(x1 + (spaceX * v), y1 + (spaceY * v)));

	    if (collinearThreshold > 0)
	    {
	        var prevPoint = results[0];

	        var sortedResults = [ prevPoint ];

	        for (i = 1; i < results.length - 1; i++)
	        {
	            var point = results[i];

	            if (DistanceBetweenPoints(prevPoint, point) >= collinearThreshold)
	            {
	                sortedResults.push(point);
	                prevPoint = point;
	            }
	        }

	        var endPoint = results[results.length - 1];

	        if (DistanceBetweenPoints(prevPoint, endPoint) < collinearThreshold)
	        {
	            sortedResults.pop();
	        }

	        sortedResults.push(endPoint);

	        return sortedResults;
	    }
	    else
	    {
	        return results;
	    }
	};

	GetEasedPoints_1 = GetEasedPoints;
	return GetEasedPoints_1;
}

var PlaceOnLine_1;
var hasRequiredPlaceOnLine;

function requirePlaceOnLine () {
	if (hasRequiredPlaceOnLine) return PlaceOnLine_1;
	hasRequiredPlaceOnLine = 1;
	var GetPoints = requireGetPoints$3();
	var GetEasedPoints = requireGetEasedPoints();

	var PlaceOnLine = function (items, line, ease)
	{
	    var points;

	    if (ease)
	    {
	        points = GetEasedPoints(line, ease, items.length);
	    }
	    else
	    {
	        points = GetPoints(line, items.length);
	    }

	    for (var i = 0; i < items.length; i++)
	    {
	        var item = items[i];
	        var point = points[i];

	        item.x = point.x;
	        item.y = point.y;
	    }

	    return items;
	};

	PlaceOnLine_1 = PlaceOnLine;
	return PlaceOnLine_1;
}

var MarchingAnts_1;
var hasRequiredMarchingAnts;

function requireMarchingAnts () {
	if (hasRequiredMarchingAnts) return MarchingAnts_1;
	hasRequiredMarchingAnts = 1;
	var Perimeter = requirePerimeter$2();
	var Point = requirePoint$1();

	var MarchingAnts = function (rect, step, quantity, out)
	{
	    if (out === undefined) { out = []; }

	    if (!step && !quantity)
	    {

	        return out;
	    }

	    if (!step)
	    {
	        step = Perimeter(rect) / quantity;
	    }
	    else
	    {
	        quantity = Math.round(Perimeter(rect) / step);
	    }

	    var x = rect.x;
	    var y = rect.y;
	    var face = 0;

	    for (var i = 0; i < quantity; i++)
	    {
	        out.push(new Point(x, y));

	        switch (face)
	        {

	            case 0:
	                x += step;

	                if (x >= rect.right)
	                {
	                    face = 1;
	                    y += (x - rect.right);
	                    x = rect.right;
	                }
	                break;

	            case 1:
	                y += step;

	                if (y >= rect.bottom)
	                {
	                    face = 2;
	                    x -= (y - rect.bottom);
	                    y = rect.bottom;
	                }
	                break;

	            case 2:
	                x -= step;

	                if (x <= rect.left)
	                {
	                    face = 3;
	                    y -= (rect.left - x);
	                    x = rect.left;
	                }
	                break;

	            case 3:
	                y -= step;

	                if (y <= rect.top)
	                {
	                    face = 0;
	                    y = rect.top;
	                }
	                break;
	        }
	    }

	    return out;
	};

	MarchingAnts_1 = MarchingAnts;
	return MarchingAnts_1;
}

var PlaceOnRectangle_1;
var hasRequiredPlaceOnRectangle;

function requirePlaceOnRectangle () {
	if (hasRequiredPlaceOnRectangle) return PlaceOnRectangle_1;
	hasRequiredPlaceOnRectangle = 1;
	var MarchingAnts = requireMarchingAnts();
	var RotateLeft = requireRotateLeft();
	var RotateRight = requireRotateRight();

	var PlaceOnRectangle = function (items, rect, shift)
	{
	    if (shift === undefined) { shift = 0; }

	    var points = MarchingAnts(rect, false, items.length);

	    if (shift > 0)
	    {
	        RotateLeft(points, shift);
	    }
	    else if (shift < 0)
	    {
	        RotateRight(points, Math.abs(shift));
	    }

	    for (var i = 0; i < items.length; i++)
	    {
	        items[i].x = points[i].x;
	        items[i].y = points[i].y;
	    }

	    return items;
	};

	PlaceOnRectangle_1 = PlaceOnRectangle;
	return PlaceOnRectangle_1;
}

var BresenhamPoints_1;
var hasRequiredBresenhamPoints;

function requireBresenhamPoints () {
	if (hasRequiredBresenhamPoints) return BresenhamPoints_1;
	hasRequiredBresenhamPoints = 1;
	var BresenhamPoints = function (line, stepRate, results)
	{
	    if (stepRate === undefined) { stepRate = 1; }
	    if (results === undefined) { results = []; }

	    var x1 = Math.round(line.x1);
	    var y1 = Math.round(line.y1);
	    var x2 = Math.round(line.x2);
	    var y2 = Math.round(line.y2);

	    var dx = Math.abs(x2 - x1);
	    var dy = Math.abs(y2 - y1);
	    var sx = (x1 < x2) ? 1 : -1;
	    var sy = (y1 < y2) ? 1 : -1;
	    var err = dx - dy;

	    results.push({ x: x1, y: y1 });

	    var i = 1;

	    while (!((x1 === x2) && (y1 === y2)))
	    {
	        var e2 = err << 1;

	        if (e2 > -dy)
	        {
	            err -= dy;
	            x1 += sx;
	        }

	        if (e2 < dx)
	        {
	            err += dx;
	            y1 += sy;
	        }

	        if (i % stepRate === 0)
	        {
	            results.push({ x: x1, y: y1 });
	        }

	        i++;
	    }

	    return results;
	};

	BresenhamPoints_1 = BresenhamPoints;
	return BresenhamPoints_1;
}

var PlaceOnTriangle_1;
var hasRequiredPlaceOnTriangle;

function requirePlaceOnTriangle () {
	if (hasRequiredPlaceOnTriangle) return PlaceOnTriangle_1;
	hasRequiredPlaceOnTriangle = 1;
	var BresenhamPoints = requireBresenhamPoints();

	var PlaceOnTriangle = function (items, triangle, stepRate)
	{
	    var p1 = BresenhamPoints({ x1: triangle.x1, y1: triangle.y1, x2: triangle.x2, y2: triangle.y2 }, stepRate);
	    var p2 = BresenhamPoints({ x1: triangle.x2, y1: triangle.y2, x2: triangle.x3, y2: triangle.y3 }, stepRate);
	    var p3 = BresenhamPoints({ x1: triangle.x3, y1: triangle.y3, x2: triangle.x1, y2: triangle.y1 }, stepRate);

	    p1.pop();
	    p2.pop();
	    p3.pop();

	    p1 = p1.concat(p2, p3);

	    var step = p1.length / items.length;
	    var p = 0;

	    for (var i = 0; i < items.length; i++)
	    {
	        var item = items[i];
	        var point = p1[Math.floor(p)];

	        item.x = point.x;
	        item.y = point.y;

	        p += step;
	    }

	    return items;
	};

	PlaceOnTriangle_1 = PlaceOnTriangle;
	return PlaceOnTriangle_1;
}

var PlayAnimation_1;
var hasRequiredPlayAnimation;

function requirePlayAnimation () {
	if (hasRequiredPlayAnimation) return PlayAnimation_1;
	hasRequiredPlayAnimation = 1;
	var PlayAnimation = function (items, key, ignoreIfPlaying)
	{
	    for (var i = 0; i < items.length; i++)
	    {
	        var gameObject = items[i];

	        if (gameObject.anims)
	        {
	            gameObject.anims.play(key, ignoreIfPlaying);
	        }
	    }

	    return items;
	};

	PlayAnimation_1 = PlayAnimation;
	return PlayAnimation_1;
}

var PropertyValueSet_1;
var hasRequiredPropertyValueSet;

function requirePropertyValueSet () {
	if (hasRequiredPropertyValueSet) return PropertyValueSet_1;
	hasRequiredPropertyValueSet = 1;
	var PropertyValueSet = function (items, key, value, step, index, direction)
	{
	    if (step === undefined) { step = 0; }
	    if (index === undefined) { index = 0; }
	    if (direction === undefined) { direction = 1; }

	    var i;
	    var t = 0;
	    var end = items.length;

	    if (direction === 1)
	    {

	        for (i = index; i < end; i++)
	        {
	            items[i][key] = value + (t * step);
	            t++;
	        }
	    }
	    else
	    {

	        for (i = index; i >= 0; i--)
	        {
	            items[i][key] = value + (t * step);
	            t++;
	        }
	    }

	    return items;
	};

	PropertyValueSet_1 = PropertyValueSet;
	return PropertyValueSet_1;
}

var RandomCircle_1;
var hasRequiredRandomCircle;

function requireRandomCircle () {
	if (hasRequiredRandomCircle) return RandomCircle_1;
	hasRequiredRandomCircle = 1;
	var Random = requireRandom$5();

	var RandomCircle = function (items, circle)
	{
	    for (var i = 0; i < items.length; i++)
	    {
	        Random(circle, items[i]);
	    }

	    return items;
	};

	RandomCircle_1 = RandomCircle;
	return RandomCircle_1;
}

var Random_1$2;
var hasRequiredRandom$2;

function requireRandom$2 () {
	if (hasRequiredRandom$2) return Random_1$2;
	hasRequiredRandom$2 = 1;
	var Point = requirePoint$1();

	var Random = function (ellipse, out)
	{
	    if (out === undefined) { out = new Point(); }

	    var p = Math.random() * Math.PI * 2;
	    var s = Math.sqrt(Math.random());

	    out.x = ellipse.x + ((s * Math.cos(p)) * ellipse.width / 2);
	    out.y = ellipse.y + ((s * Math.sin(p)) * ellipse.height / 2);

	    return out;
	};

	Random_1$2 = Random;
	return Random_1$2;
}

var RandomEllipse_1;
var hasRequiredRandomEllipse;

function requireRandomEllipse () {
	if (hasRequiredRandomEllipse) return RandomEllipse_1;
	hasRequiredRandomEllipse = 1;
	var Random = requireRandom$2();

	var RandomEllipse = function (items, ellipse)
	{
	    for (var i = 0; i < items.length; i++)
	    {
	        Random(ellipse, items[i]);
	    }

	    return items;
	};

	RandomEllipse_1 = RandomEllipse;
	return RandomEllipse_1;
}

var RandomLine_1;
var hasRequiredRandomLine;

function requireRandomLine () {
	if (hasRequiredRandomLine) return RandomLine_1;
	hasRequiredRandomLine = 1;
	var Random = requireRandom$4();

	var RandomLine = function (items, line)
	{
	    for (var i = 0; i < items.length; i++)
	    {
	        Random(line, items[i]);
	    }

	    return items;
	};

	RandomLine_1 = RandomLine;
	return RandomLine_1;
}

var RandomRectangle_1;
var hasRequiredRandomRectangle;

function requireRandomRectangle () {
	if (hasRequiredRandomRectangle) return RandomRectangle_1;
	hasRequiredRandomRectangle = 1;
	var Random = requireRandom$3();

	var RandomRectangle = function (items, rect)
	{
	    for (var i = 0; i < items.length; i++)
	    {
	        Random(rect, items[i]);
	    }

	    return items;
	};

	RandomRectangle_1 = RandomRectangle;
	return RandomRectangle_1;
}

var Random_1$1;
var hasRequiredRandom$1;

function requireRandom$1 () {
	if (hasRequiredRandom$1) return Random_1$1;
	hasRequiredRandom$1 = 1;
	var Point = requirePoint$1();

	var Random = function (triangle, out)
	{
	    if (out === undefined) { out = new Point(); }

	    var ux = triangle.x2 - triangle.x1;
	    var uy = triangle.y2 - triangle.y1;

	    var vx = triangle.x3 - triangle.x1;
	    var vy = triangle.y3 - triangle.y1;

	    var r = Math.random();
	    var s = Math.random();

	    if (r + s >= 1)
	    {
	        r = 1 - r;
	        s = 1 - s;
	    }

	    out.x = triangle.x1 + ((ux * r) + (vx * s));
	    out.y = triangle.y1 + ((uy * r) + (vy * s));

	    return out;
	};

	Random_1$1 = Random;
	return Random_1$1;
}

var RandomTriangle_1;
var hasRequiredRandomTriangle;

function requireRandomTriangle () {
	if (hasRequiredRandomTriangle) return RandomTriangle_1;
	hasRequiredRandomTriangle = 1;
	var Random = requireRandom$1();

	var RandomTriangle = function (items, triangle)
	{
	    for (var i = 0; i < items.length; i++)
	    {
	        Random(triangle, items[i]);
	    }

	    return items;
	};

	RandomTriangle_1 = RandomTriangle;
	return RandomTriangle_1;
}

var Rotate_1$3;
var hasRequiredRotate$3;

function requireRotate$3 () {
	if (hasRequiredRotate$3) return Rotate_1$3;
	hasRequiredRotate$3 = 1;
	var PropertyValueInc = requirePropertyValueInc();

	var Rotate = function (items, value, step, index, direction)
	{
	    return PropertyValueInc(items, 'rotation', value, step, index, direction);
	};

	Rotate_1$3 = Rotate;
	return Rotate_1$3;
}

var RotateAroundDistance_1$1;
var hasRequiredRotateAroundDistance$1;

function requireRotateAroundDistance$1 () {
	if (hasRequiredRotateAroundDistance$1) return RotateAroundDistance_1$1;
	hasRequiredRotateAroundDistance$1 = 1;
	var RotateAroundDistance = function (point, x, y, angle, distance)
	{
	    var t = angle + Math.atan2(point.y - y, point.x - x);

	    point.x = x + (distance * Math.cos(t));
	    point.y = y + (distance * Math.sin(t));

	    return point;
	};

	RotateAroundDistance_1$1 = RotateAroundDistance;
	return RotateAroundDistance_1$1;
}

var DistanceBetween_1;
var hasRequiredDistanceBetween;

function requireDistanceBetween () {
	if (hasRequiredDistanceBetween) return DistanceBetween_1;
	hasRequiredDistanceBetween = 1;
	var DistanceBetween = function (x1, y1, x2, y2)
	{
	    var dx = x1 - x2;
	    var dy = y1 - y2;

	    return Math.sqrt(dx * dx + dy * dy);
	};

	DistanceBetween_1 = DistanceBetween;
	return DistanceBetween_1;
}

var RotateAround_1;
var hasRequiredRotateAround;

function requireRotateAround () {
	if (hasRequiredRotateAround) return RotateAround_1;
	hasRequiredRotateAround = 1;
	var RotateAroundDistance = requireRotateAroundDistance$1();
	var DistanceBetween = requireDistanceBetween();

	var RotateAround = function (items, point, angle)
	{
	    var x = point.x;
	    var y = point.y;

	    for (var i = 0; i < items.length; i++)
	    {
	        var item = items[i];

	        RotateAroundDistance(item, x, y, angle, Math.max(1, DistanceBetween(item.x, item.y, x, y)));
	    }

	    return items;
	};

	RotateAround_1 = RotateAround;
	return RotateAround_1;
}

var RotateAroundDistance_1;
var hasRequiredRotateAroundDistance;

function requireRotateAroundDistance () {
	if (hasRequiredRotateAroundDistance) return RotateAroundDistance_1;
	hasRequiredRotateAroundDistance = 1;
	var MathRotateAroundDistance = requireRotateAroundDistance$1();

	var RotateAroundDistance = function (items, point, angle, distance)
	{
	    var x = point.x;
	    var y = point.y;

	    if (distance === 0)
	    {
	        return items;
	    }

	    for (var i = 0; i < items.length; i++)
	    {
	        MathRotateAroundDistance(items[i], x, y, angle, distance);
	    }

	    return items;
	};

	RotateAroundDistance_1 = RotateAroundDistance;
	return RotateAroundDistance_1;
}

var ScaleX_1;
var hasRequiredScaleX;

function requireScaleX () {
	if (hasRequiredScaleX) return ScaleX_1;
	hasRequiredScaleX = 1;
	var PropertyValueInc = requirePropertyValueInc();

	var ScaleX = function (items, value, step, index, direction)
	{
	    return PropertyValueInc(items, 'scaleX', value, step, index, direction);
	};

	ScaleX_1 = ScaleX;
	return ScaleX_1;
}

var ScaleXY_1;
var hasRequiredScaleXY;

function requireScaleXY () {
	if (hasRequiredScaleXY) return ScaleXY_1;
	hasRequiredScaleXY = 1;
	var PropertyValueInc = requirePropertyValueInc();

	var ScaleXY = function (items, scaleX, scaleY, stepX, stepY, index, direction)
	{
	    if (scaleY === undefined || scaleY === null) { scaleY = scaleX; }

	    PropertyValueInc(items, 'scaleX', scaleX, stepX, index, direction);

	    return PropertyValueInc(items, 'scaleY', scaleY, stepY, index, direction);
	};

	ScaleXY_1 = ScaleXY;
	return ScaleXY_1;
}

var ScaleY_1;
var hasRequiredScaleY;

function requireScaleY () {
	if (hasRequiredScaleY) return ScaleY_1;
	hasRequiredScaleY = 1;
	var PropertyValueInc = requirePropertyValueInc();

	var ScaleY = function (items, value, step, index, direction)
	{
	    return PropertyValueInc(items, 'scaleY', value, step, index, direction);
	};

	ScaleY_1 = ScaleY;
	return ScaleY_1;
}

var SetAlpha_1;
var hasRequiredSetAlpha;

function requireSetAlpha () {
	if (hasRequiredSetAlpha) return SetAlpha_1;
	hasRequiredSetAlpha = 1;
	var PropertyValueSet = requirePropertyValueSet();

	var SetAlpha = function (items, value, step, index, direction)
	{
	    return PropertyValueSet(items, 'alpha', value, step, index, direction);
	};

	SetAlpha_1 = SetAlpha;
	return SetAlpha_1;
}

var SetBlendMode_1;
var hasRequiredSetBlendMode;

function requireSetBlendMode () {
	if (hasRequiredSetBlendMode) return SetBlendMode_1;
	hasRequiredSetBlendMode = 1;
	var PropertyValueSet = requirePropertyValueSet();

	var SetBlendMode = function (items, value, index, direction)
	{
	    return PropertyValueSet(items, 'blendMode', value, 0, index, direction);
	};

	SetBlendMode_1 = SetBlendMode;
	return SetBlendMode_1;
}

var SetDepth_1;
var hasRequiredSetDepth;

function requireSetDepth () {
	if (hasRequiredSetDepth) return SetDepth_1;
	hasRequiredSetDepth = 1;
	var PropertyValueSet = requirePropertyValueSet();

	var SetDepth = function (items, value, step, index, direction)
	{
	    return PropertyValueSet(items, 'depth', value, step, index, direction);
	};

	SetDepth_1 = SetDepth;
	return SetDepth_1;
}

var SetHitArea_1;
var hasRequiredSetHitArea;

function requireSetHitArea () {
	if (hasRequiredSetHitArea) return SetHitArea_1;
	hasRequiredSetHitArea = 1;
	var SetHitArea = function (items, hitArea, hitAreaCallback)
	{
	    for (var i = 0; i < items.length; i++)
	    {
	        items[i].setInteractive(hitArea, hitAreaCallback);
	    }

	    return items;
	};

	SetHitArea_1 = SetHitArea;
	return SetHitArea_1;
}

var SetOrigin_1;
var hasRequiredSetOrigin;

function requireSetOrigin () {
	if (hasRequiredSetOrigin) return SetOrigin_1;
	hasRequiredSetOrigin = 1;
	var PropertyValueSet = requirePropertyValueSet();

	var SetOrigin = function (items, originX, originY, stepX, stepY, index, direction)
	{
	    if (originY === undefined || originY === null) { originY = originX; }

	    PropertyValueSet(items, 'originX', originX, stepX, index, direction);
	    PropertyValueSet(items, 'originY', originY, stepY, index, direction);

	    items.forEach(function (item)
	    {
	        item.updateDisplayOrigin();
	    });

	    return items;
	};

	SetOrigin_1 = SetOrigin;
	return SetOrigin_1;
}

var SetRotation_1;
var hasRequiredSetRotation;

function requireSetRotation () {
	if (hasRequiredSetRotation) return SetRotation_1;
	hasRequiredSetRotation = 1;
	var PropertyValueSet = requirePropertyValueSet();

	var SetRotation = function (items, value, step, index, direction)
	{
	    return PropertyValueSet(items, 'rotation', value, step, index, direction);
	};

	SetRotation_1 = SetRotation;
	return SetRotation_1;
}

var SetScale_1;
var hasRequiredSetScale;

function requireSetScale () {
	if (hasRequiredSetScale) return SetScale_1;
	hasRequiredSetScale = 1;
	var PropertyValueSet = requirePropertyValueSet();

	var SetScale = function (items, scaleX, scaleY, stepX, stepY, index, direction)
	{
	    if (scaleY === undefined || scaleY === null) { scaleY = scaleX; }

	    PropertyValueSet(items, 'scaleX', scaleX, stepX, index, direction);

	    return PropertyValueSet(items, 'scaleY', scaleY, stepY, index, direction);
	};

	SetScale_1 = SetScale;
	return SetScale_1;
}

var SetScaleX_1;
var hasRequiredSetScaleX;

function requireSetScaleX () {
	if (hasRequiredSetScaleX) return SetScaleX_1;
	hasRequiredSetScaleX = 1;
	var PropertyValueSet = requirePropertyValueSet();

	var SetScaleX = function (items, value, step, index, direction)
	{
	    return PropertyValueSet(items, 'scaleX', value, step, index, direction);
	};

	SetScaleX_1 = SetScaleX;
	return SetScaleX_1;
}

var SetScaleY_1;
var hasRequiredSetScaleY;

function requireSetScaleY () {
	if (hasRequiredSetScaleY) return SetScaleY_1;
	hasRequiredSetScaleY = 1;
	var PropertyValueSet = requirePropertyValueSet();

	var SetScaleY = function (items, value, step, index, direction)
	{
	    return PropertyValueSet(items, 'scaleY', value, step, index, direction);
	};

	SetScaleY_1 = SetScaleY;
	return SetScaleY_1;
}

var SetScrollFactor_1;
var hasRequiredSetScrollFactor;

function requireSetScrollFactor () {
	if (hasRequiredSetScrollFactor) return SetScrollFactor_1;
	hasRequiredSetScrollFactor = 1;
	var PropertyValueSet = requirePropertyValueSet();

	var SetScrollFactor = function (items, scrollFactorX, scrollFactorY, stepX, stepY, index, direction)
	{
	    if (scrollFactorY === undefined || scrollFactorY === null) { scrollFactorY = scrollFactorX; }

	    PropertyValueSet(items, 'scrollFactorX', scrollFactorX, stepX, index, direction);

	    return PropertyValueSet(items, 'scrollFactorY', scrollFactorY, stepY, index, direction);
	};

	SetScrollFactor_1 = SetScrollFactor;
	return SetScrollFactor_1;
}

var SetScrollFactorX_1;
var hasRequiredSetScrollFactorX;

function requireSetScrollFactorX () {
	if (hasRequiredSetScrollFactorX) return SetScrollFactorX_1;
	hasRequiredSetScrollFactorX = 1;
	var PropertyValueSet = requirePropertyValueSet();

	var SetScrollFactorX = function (items, value, step, index, direction)
	{
	    return PropertyValueSet(items, 'scrollFactorX', value, step, index, direction);
	};

	SetScrollFactorX_1 = SetScrollFactorX;
	return SetScrollFactorX_1;
}

var SetScrollFactorY_1;
var hasRequiredSetScrollFactorY;

function requireSetScrollFactorY () {
	if (hasRequiredSetScrollFactorY) return SetScrollFactorY_1;
	hasRequiredSetScrollFactorY = 1;
	var PropertyValueSet = requirePropertyValueSet();

	var SetScrollFactorY = function (items, value, step, index, direction)
	{
	    return PropertyValueSet(items, 'scrollFactorY', value, step, index, direction);
	};

	SetScrollFactorY_1 = SetScrollFactorY;
	return SetScrollFactorY_1;
}

var SetTint_1;
var hasRequiredSetTint;

function requireSetTint () {
	if (hasRequiredSetTint) return SetTint_1;
	hasRequiredSetTint = 1;
	var SetTint = function (items, topLeft, topRight, bottomLeft, bottomRight)
	{
	    for (var i = 0; i < items.length; i++)
	    {
	        items[i].setTint(topLeft, topRight, bottomLeft, bottomRight);
	    }

	    return items;
	};

	SetTint_1 = SetTint;
	return SetTint_1;
}

var SetVisible_1;
var hasRequiredSetVisible;

function requireSetVisible () {
	if (hasRequiredSetVisible) return SetVisible_1;
	hasRequiredSetVisible = 1;
	var PropertyValueSet = requirePropertyValueSet();

	var SetVisible = function (items, value, index, direction)
	{
	    return PropertyValueSet(items, 'visible', value, 0, index, direction);
	};

	SetVisible_1 = SetVisible;
	return SetVisible_1;
}

var SetX_1;
var hasRequiredSetX;

function requireSetX () {
	if (hasRequiredSetX) return SetX_1;
	hasRequiredSetX = 1;
	var PropertyValueSet = requirePropertyValueSet();

	var SetX = function (items, value, step, index, direction)
	{
	    return PropertyValueSet(items, 'x', value, step, index, direction);
	};

	SetX_1 = SetX;
	return SetX_1;
}

var SetXY_1;
var hasRequiredSetXY;

function requireSetXY () {
	if (hasRequiredSetXY) return SetXY_1;
	hasRequiredSetXY = 1;
	var PropertyValueSet = requirePropertyValueSet();

	var SetXY = function (items, x, y, stepX, stepY, index, direction)
	{
	    if (y === undefined || y === null) { y = x; }

	    PropertyValueSet(items, 'x', x, stepX, index, direction);

	    return PropertyValueSet(items, 'y', y, stepY, index, direction);
	};

	SetXY_1 = SetXY;
	return SetXY_1;
}

var SetY_1;
var hasRequiredSetY;

function requireSetY () {
	if (hasRequiredSetY) return SetY_1;
	hasRequiredSetY = 1;
	var PropertyValueSet = requirePropertyValueSet();

	var SetY = function (items, value, step, index, direction)
	{
	    return PropertyValueSet(items, 'y', value, step, index, direction);
	};

	SetY_1 = SetY;
	return SetY_1;
}

var ShiftPosition_1;
var hasRequiredShiftPosition;

function requireShiftPosition () {
	if (hasRequiredShiftPosition) return ShiftPosition_1;
	hasRequiredShiftPosition = 1;
	var Vector2 = requireVector2();

	var ShiftPosition = function (items, x, y, direction, output)
	{
	    if (direction === undefined) { direction = 0; }
	    if (output === undefined) { output = new Vector2(); }

	    var px;
	    var py;
	    var len = items.length;

	    if (len === 1)
	    {
	        px = items[0].x;
	        py = items[0].y;

	        items[0].x = x;
	        items[0].y = y;
	    }
	    else
	    {
	        var i = 1;
	        var pos = 0;

	        if (direction === 0)
	        {
	            pos = len - 1;
	            i = len - 2;
	        }

	        px = items[pos].x;
	        py = items[pos].y;

	        items[pos].x = x;
	        items[pos].y = y;

	        for (var c = 0; c < len; c++)
	        {
	            if (i >= len || i === -1)
	            {
	                continue;
	            }

	            var cur = items[i];

	            var cx = cur.x;
	            var cy = cur.y;

	            cur.x = px;
	            cur.y = py;

	            px = cx;
	            py = cy;

	            if (direction === 0)
	            {
	                i--;
	            }
	            else
	            {
	                i++;
	            }
	        }
	    }

	    output.x = px;
	    output.y = py;

	    return output;
	};

	ShiftPosition_1 = ShiftPosition;
	return ShiftPosition_1;
}

var Shuffle_1$1;
var hasRequiredShuffle$1;

function requireShuffle$1 () {
	if (hasRequiredShuffle$1) return Shuffle_1$1;
	hasRequiredShuffle$1 = 1;
	var ArrayShuffle = requireShuffle$2();

	var Shuffle = function (items)
	{
	    return ArrayShuffle(items);
	};

	Shuffle_1$1 = Shuffle;
	return Shuffle_1$1;
}

var SmootherStep_1$1;
var hasRequiredSmootherStep$1;

function requireSmootherStep$1 () {
	if (hasRequiredSmootherStep$1) return SmootherStep_1$1;
	hasRequiredSmootherStep$1 = 1;
	var SmootherStep = function (x, min, max)
	{
	    x = Math.max(0, Math.min(1, (x - min) / (max - min)));

	    return x * x * x * (x * (x * 6 - 15) + 10);
	};

	SmootherStep_1$1 = SmootherStep;
	return SmootherStep_1$1;
}

var SmootherStep_1;
var hasRequiredSmootherStep;

function requireSmootherStep () {
	if (hasRequiredSmootherStep) return SmootherStep_1;
	hasRequiredSmootherStep = 1;
	var MathSmootherStep = requireSmootherStep$1();

	var SmootherStep = function (items, property, min, max, inc)
	{
	    if (inc === undefined) { inc = false; }

	    var step = Math.abs(max - min) / items.length;
	    var i;

	    if (inc)
	    {
	        for (i = 0; i < items.length; i++)
	        {
	            items[i][property] += MathSmootherStep(i * step, min, max);
	        }
	    }
	    else
	    {
	        for (i = 0; i < items.length; i++)
	        {
	            items[i][property] = MathSmootherStep(i * step, min, max);
	        }
	    }

	    return items;
	};

	SmootherStep_1 = SmootherStep;
	return SmootherStep_1;
}

var SmoothStep_1$1;
var hasRequiredSmoothStep$1;

function requireSmoothStep$1 () {
	if (hasRequiredSmoothStep$1) return SmoothStep_1$1;
	hasRequiredSmoothStep$1 = 1;
	var SmoothStep = function (x, min, max)
	{
	    if (x <= min)
	    {
	        return 0;
	    }

	    if (x >= max)
	    {
	        return 1;
	    }

	    x = (x - min) / (max - min);

	    return x * x * (3 - 2 * x);
	};

	SmoothStep_1$1 = SmoothStep;
	return SmoothStep_1$1;
}

var SmoothStep_1;
var hasRequiredSmoothStep;

function requireSmoothStep () {
	if (hasRequiredSmoothStep) return SmoothStep_1;
	hasRequiredSmoothStep = 1;
	var MathSmoothStep = requireSmoothStep$1();

	var SmoothStep = function (items, property, min, max, inc)
	{
	    if (inc === undefined) { inc = false; }

	    var step = Math.abs(max - min) / items.length;
	    var i;

	    if (inc)
	    {
	        for (i = 0; i < items.length; i++)
	        {
	            items[i][property] += MathSmoothStep(i * step, min, max);
	        }
	    }
	    else
	    {
	        for (i = 0; i < items.length; i++)
	        {
	            items[i][property] = MathSmoothStep(i * step, min, max);
	        }
	    }

	    return items;
	};

	SmoothStep_1 = SmoothStep;
	return SmoothStep_1;
}

var Spread_1;
var hasRequiredSpread;

function requireSpread () {
	if (hasRequiredSpread) return Spread_1;
	hasRequiredSpread = 1;
	var Spread = function (items, property, min, max, inc)
	{
	    if (inc === undefined) { inc = false; }
	    if (items.length === 0) { return items; }
	    if (items.length === 1) 
	    {
	        if (inc)
	        {
	            items[0][property] += (max + min) / 2;
	        }
	        else
	        {
	            items[0][property] = (max + min) / 2;
	        }

	        return items;
	    }

	    var step = Math.abs(max - min) / (items.length - 1);
	    var i;

	    if (inc)
	    {
	        for (i = 0; i < items.length; i++)
	        {
	            items[i][property] += i * step + min;
	        }
	    }
	    else
	    {
	        for (i = 0; i < items.length; i++)
	        {
	            items[i][property] = i * step + min;
	        }
	    }

	    return items;
	};

	Spread_1 = Spread;
	return Spread_1;
}

var ToggleVisible_1;
var hasRequiredToggleVisible;

function requireToggleVisible () {
	if (hasRequiredToggleVisible) return ToggleVisible_1;
	hasRequiredToggleVisible = 1;
	var ToggleVisible = function (items)
	{
	    for (var i = 0; i < items.length; i++)
	    {
	        items[i].visible = !items[i].visible;
	    }

	    return items;
	};

	ToggleVisible_1 = ToggleVisible;
	return ToggleVisible_1;
}

var WrapInRectangle_1;
var hasRequiredWrapInRectangle;

function requireWrapInRectangle () {
	if (hasRequiredWrapInRectangle) return WrapInRectangle_1;
	hasRequiredWrapInRectangle = 1;
	var Wrap = requireWrap$1();

	var WrapInRectangle = function (items, rect, padding)
	{
	    if (padding === undefined)
	    {
	        padding = 0;
	    }

	    for (var i = 0; i < items.length; i++)
	    {
	        var item = items[i];

	        item.x = Wrap(item.x, rect.left - padding, rect.right + padding);
	        item.y = Wrap(item.y, rect.top - padding, rect.bottom + padding);
	    }

	    return items;
	};

	WrapInRectangle_1 = WrapInRectangle;
	return WrapInRectangle_1;
}

var actions;
var hasRequiredActions;

function requireActions () {
	if (hasRequiredActions) return actions;
	hasRequiredActions = 1;
	actions = {

	    AlignTo: requireAlignTo(),
	    Angle: requireAngle$2(),
	    Call: requireCall(),
	    GetFirst: requireGetFirst$1(),
	    GetLast: requireGetLast(),
	    GridAlign: requireGridAlign(),
	    IncAlpha: requireIncAlpha(),
	    IncX: requireIncX(),
	    IncXY: requireIncXY(),
	    IncY: requireIncY(),
	    PlaceOnCircle: requirePlaceOnCircle(),
	    PlaceOnEllipse: requirePlaceOnEllipse(),
	    PlaceOnLine: requirePlaceOnLine(),
	    PlaceOnRectangle: requirePlaceOnRectangle(),
	    PlaceOnTriangle: requirePlaceOnTriangle(),
	    PlayAnimation: requirePlayAnimation(),
	    PropertyValueInc: requirePropertyValueInc(),
	    PropertyValueSet: requirePropertyValueSet(),
	    RandomCircle: requireRandomCircle(),
	    RandomEllipse: requireRandomEllipse(),
	    RandomLine: requireRandomLine(),
	    RandomRectangle: requireRandomRectangle(),
	    RandomTriangle: requireRandomTriangle(),
	    Rotate: requireRotate$3(),
	    RotateAround: requireRotateAround(),
	    RotateAroundDistance: requireRotateAroundDistance(),
	    ScaleX: requireScaleX(),
	    ScaleXY: requireScaleXY(),
	    ScaleY: requireScaleY(),
	    SetAlpha: requireSetAlpha(),
	    SetBlendMode: requireSetBlendMode(),
	    SetDepth: requireSetDepth(),
	    SetHitArea: requireSetHitArea(),
	    SetOrigin: requireSetOrigin(),
	    SetRotation: requireSetRotation(),
	    SetScale: requireSetScale(),
	    SetScaleX: requireSetScaleX(),
	    SetScaleY: requireSetScaleY(),
	    SetScrollFactor: requireSetScrollFactor(),
	    SetScrollFactorX: requireSetScrollFactorX(),
	    SetScrollFactorY: requireSetScrollFactorY(),
	    SetTint: requireSetTint(),
	    SetVisible: requireSetVisible(),
	    SetX: requireSetX(),
	    SetXY: requireSetXY(),
	    SetY: requireSetY(),
	    ShiftPosition: requireShiftPosition(),
	    Shuffle: requireShuffle$1(),
	    SmootherStep: requireSmootherStep(),
	    SmoothStep: requireSmoothStep(),
	    Spread: requireSpread(),
	    ToggleVisible: requireToggleVisible(),
	    WrapInRectangle: requireWrapInRectangle()

	};
	return actions;
}

var ADD_ANIMATION_EVENT;
var hasRequiredADD_ANIMATION_EVENT;

function requireADD_ANIMATION_EVENT () {
	if (hasRequiredADD_ANIMATION_EVENT) return ADD_ANIMATION_EVENT;
	hasRequiredADD_ANIMATION_EVENT = 1;
	ADD_ANIMATION_EVENT = 'add';
	return ADD_ANIMATION_EVENT;
}

var ANIMATION_COMPLETE_EVENT;
var hasRequiredANIMATION_COMPLETE_EVENT;

function requireANIMATION_COMPLETE_EVENT () {
	if (hasRequiredANIMATION_COMPLETE_EVENT) return ANIMATION_COMPLETE_EVENT;
	hasRequiredANIMATION_COMPLETE_EVENT = 1;
	ANIMATION_COMPLETE_EVENT = 'animationcomplete';
	return ANIMATION_COMPLETE_EVENT;
}

var ANIMATION_COMPLETE_KEY_EVENT;
var hasRequiredANIMATION_COMPLETE_KEY_EVENT;

function requireANIMATION_COMPLETE_KEY_EVENT () {
	if (hasRequiredANIMATION_COMPLETE_KEY_EVENT) return ANIMATION_COMPLETE_KEY_EVENT;
	hasRequiredANIMATION_COMPLETE_KEY_EVENT = 1;
	ANIMATION_COMPLETE_KEY_EVENT = 'animationcomplete-';
	return ANIMATION_COMPLETE_KEY_EVENT;
}

var ANIMATION_REPEAT_EVENT;
var hasRequiredANIMATION_REPEAT_EVENT;

function requireANIMATION_REPEAT_EVENT () {
	if (hasRequiredANIMATION_REPEAT_EVENT) return ANIMATION_REPEAT_EVENT;
	hasRequiredANIMATION_REPEAT_EVENT = 1;
	ANIMATION_REPEAT_EVENT = 'animationrepeat';
	return ANIMATION_REPEAT_EVENT;
}

var ANIMATION_RESTART_EVENT;
var hasRequiredANIMATION_RESTART_EVENT;

function requireANIMATION_RESTART_EVENT () {
	if (hasRequiredANIMATION_RESTART_EVENT) return ANIMATION_RESTART_EVENT;
	hasRequiredANIMATION_RESTART_EVENT = 1;
	ANIMATION_RESTART_EVENT = 'animationrestart';
	return ANIMATION_RESTART_EVENT;
}

var ANIMATION_START_EVENT;
var hasRequiredANIMATION_START_EVENT;

function requireANIMATION_START_EVENT () {
	if (hasRequiredANIMATION_START_EVENT) return ANIMATION_START_EVENT;
	hasRequiredANIMATION_START_EVENT = 1;
	ANIMATION_START_EVENT = 'animationstart';
	return ANIMATION_START_EVENT;
}

var ANIMATION_STOP_EVENT;
var hasRequiredANIMATION_STOP_EVENT;

function requireANIMATION_STOP_EVENT () {
	if (hasRequiredANIMATION_STOP_EVENT) return ANIMATION_STOP_EVENT;
	hasRequiredANIMATION_STOP_EVENT = 1;
	ANIMATION_STOP_EVENT = 'animationstop';
	return ANIMATION_STOP_EVENT;
}

var ANIMATION_UPDATE_EVENT;
var hasRequiredANIMATION_UPDATE_EVENT;

function requireANIMATION_UPDATE_EVENT () {
	if (hasRequiredANIMATION_UPDATE_EVENT) return ANIMATION_UPDATE_EVENT;
	hasRequiredANIMATION_UPDATE_EVENT = 1;
	ANIMATION_UPDATE_EVENT = 'animationupdate';
	return ANIMATION_UPDATE_EVENT;
}

var PAUSE_ALL_EVENT$1;
var hasRequiredPAUSE_ALL_EVENT$1;

function requirePAUSE_ALL_EVENT$1 () {
	if (hasRequiredPAUSE_ALL_EVENT$1) return PAUSE_ALL_EVENT$1;
	hasRequiredPAUSE_ALL_EVENT$1 = 1;
	PAUSE_ALL_EVENT$1 = 'pauseall';
	return PAUSE_ALL_EVENT$1;
}

var REMOVE_ANIMATION_EVENT;
var hasRequiredREMOVE_ANIMATION_EVENT;

function requireREMOVE_ANIMATION_EVENT () {
	if (hasRequiredREMOVE_ANIMATION_EVENT) return REMOVE_ANIMATION_EVENT;
	hasRequiredREMOVE_ANIMATION_EVENT = 1;
	REMOVE_ANIMATION_EVENT = 'remove';
	return REMOVE_ANIMATION_EVENT;
}

var RESUME_ALL_EVENT$1;
var hasRequiredRESUME_ALL_EVENT$1;

function requireRESUME_ALL_EVENT$1 () {
	if (hasRequiredRESUME_ALL_EVENT$1) return RESUME_ALL_EVENT$1;
	hasRequiredRESUME_ALL_EVENT$1 = 1;
	RESUME_ALL_EVENT$1 = 'resumeall';
	return RESUME_ALL_EVENT$1;
}

var events$i;
var hasRequiredEvents$i;

function requireEvents$i () {
	if (hasRequiredEvents$i) return events$i;
	hasRequiredEvents$i = 1;
	events$i = {

	    ADD_ANIMATION: requireADD_ANIMATION_EVENT(),
	    ANIMATION_COMPLETE: requireANIMATION_COMPLETE_EVENT(),
	    ANIMATION_COMPLETE_KEY: requireANIMATION_COMPLETE_KEY_EVENT(),
	    ANIMATION_REPEAT: requireANIMATION_REPEAT_EVENT(),
	    ANIMATION_RESTART: requireANIMATION_RESTART_EVENT(),
	    ANIMATION_START: requireANIMATION_START_EVENT(),
	    ANIMATION_STOP: requireANIMATION_STOP_EVENT(),
	    ANIMATION_UPDATE: requireANIMATION_UPDATE_EVENT(),
	    PAUSE_ALL: requirePAUSE_ALL_EVENT$1(),
	    REMOVE_ANIMATION: requireREMOVE_ANIMATION_EVENT(),
	    RESUME_ALL: requireRESUME_ALL_EVENT$1()

	};
	return events$i;
}

var AnimationFrame_1;
var hasRequiredAnimationFrame;

function requireAnimationFrame () {
	if (hasRequiredAnimationFrame) return AnimationFrame_1;
	hasRequiredAnimationFrame = 1;
	var Class = requireClass();

	var AnimationFrame = new Class({

	    initialize:

	    function AnimationFrame (textureKey, textureFrame, index, frame, isKeyFrame)
	    {
	        if (isKeyFrame === undefined) { isKeyFrame = false; }

	        this.textureKey = textureKey;

	        this.textureFrame = textureFrame;

	        this.index = index;

	        this.frame = frame;

	        this.isFirst = false;

	        this.isLast = false;

	        this.prevFrame = null;

	        this.nextFrame = null;

	        this.duration = 0;

	        this.progress = 0;

	        this.isKeyFrame = isKeyFrame;
	    },

	    toJSON: function ()
	    {
	        return {
	            key: this.textureKey,
	            frame: this.textureFrame,
	            duration: this.duration,
	            keyframe: this.isKeyFrame
	        };
	    },

	    destroy: function ()
	    {
	        this.frame = undefined;
	    }

	});

	AnimationFrame_1 = AnimationFrame;
	return AnimationFrame_1;
}

var Animation_1;
var hasRequiredAnimation;

function requireAnimation () {
	if (hasRequiredAnimation) return Animation_1;
	hasRequiredAnimation = 1;
	var Clamp = requireClamp();
	var Class = requireClass();
	var Events = requireEvents$i();
	var FindClosestInSorted = requireFindClosestInSorted();
	var Frame = requireAnimationFrame();
	var GetValue = requireGetValue();
	var SortByDigits = requireSortByDigits();

	var Animation = new Class({

	    initialize:

	    function Animation (manager, key, config)
	    {

	        this.manager = manager;

	        this.key = key;

	        this.type = 'frame';

	        this.frames = this.getFrames(
	            manager.textureManager,
	            GetValue(config, 'frames', []),
	            GetValue(config, 'defaultTextureKey', null),
	            GetValue(config, 'sortFrames', true)
	        );

	        this.frameRate = GetValue(config, 'frameRate', null);

	        this.duration = GetValue(config, 'duration', null);

	        this.msPerFrame;

	        this.skipMissedFrames = GetValue(config, 'skipMissedFrames', true);

	        this.delay = GetValue(config, 'delay', 0);

	        this.repeat = GetValue(config, 'repeat', 0);

	        this.repeatDelay = GetValue(config, 'repeatDelay', 0);

	        this.yoyo = GetValue(config, 'yoyo', false);

	        this.showBeforeDelay = GetValue(config, 'showBeforeDelay', false);

	        this.showOnStart = GetValue(config, 'showOnStart', false);

	        this.hideOnComplete = GetValue(config, 'hideOnComplete', false);

	        this.randomFrame = GetValue(config, 'randomFrame', false);

	        this.paused = false;

	        this.calculateDuration(this, this.getTotalFrames(), this.duration, this.frameRate);

	        if (this.manager.on)
	        {
	            this.manager.on(Events.PAUSE_ALL, this.pause, this);
	            this.manager.on(Events.RESUME_ALL, this.resume, this);
	        }
	    },

	    getTotalFrames: function ()
	    {
	        return this.frames.length;
	    },

	    calculateDuration: function (target, totalFrames, duration, frameRate)
	    {
	        if (duration === null && frameRate === null)
	        {

	            target.frameRate = 24;
	            target.duration = (24 / totalFrames) * 1000;
	        }
	        else if (duration && frameRate === null)
	        {

	            target.duration = duration;
	            target.frameRate = totalFrames / (duration / 1000);
	        }
	        else
	        {

	            target.frameRate = frameRate;
	            target.duration = (totalFrames / frameRate) * 1000;
	        }

	        target.msPerFrame = 1000 / target.frameRate;
	    },

	    addFrame: function (config)
	    {
	        return this.addFrameAt(this.frames.length, config);
	    },

	    addFrameAt: function (index, config)
	    {
	        var newFrames = this.getFrames(this.manager.textureManager, config);

	        if (newFrames.length > 0)
	        {
	            if (index === 0)
	            {
	                this.frames = newFrames.concat(this.frames);
	            }
	            else if (index === this.frames.length)
	            {
	                this.frames = this.frames.concat(newFrames);
	            }
	            else
	            {
	                var pre = this.frames.slice(0, index);
	                var post = this.frames.slice(index);

	                this.frames = pre.concat(newFrames, post);
	            }

	            this.updateFrameSequence();
	        }

	        return this;
	    },

	    checkFrame: function (index)
	    {
	        return (index >= 0 && index < this.frames.length);
	    },

	    getFirstTick: function (state)
	    {

	        state.accumulator = 0;

	        state.nextTick = state.frameRate === state.currentAnim.frameRate ? state.currentFrame.duration || state.msPerFrame : state.msPerFrame;
	    },

	    getFrameAt: function (index)
	    {
	        return this.frames[index];
	    },

	    getFrames: function (textureManager, frames, defaultTextureKey, sortFrames)
	    {
	        if (sortFrames === undefined) { sortFrames = true; }

	        var out = [];
	        var prev;
	        var animationFrame;
	        var index = 1;
	        var i;
	        var textureKey;

	        if (typeof frames === 'string')
	        {
	            textureKey = frames;

	            if (!textureManager.exists(textureKey))
	            {
	                console.warn('Texture "%s" not found', textureKey);

	                return out;
	            }

	            var texture = textureManager.get(textureKey);
	            var frameKeys = texture.getFrameNames();

	            if (sortFrames)
	            {
	                SortByDigits(frameKeys);
	            }

	            frames = [];

	            frameKeys.forEach(function (value)
	            {
	                frames.push({ key: textureKey, frame: value });
	            });
	        }

	        if (!Array.isArray(frames) || frames.length === 0)
	        {
	            return out;
	        }

	        for (i = 0; i < frames.length; i++)
	        {
	            var item = frames[i];

	            var key = GetValue(item, 'key', defaultTextureKey);

	            if (!key)
	            {
	                continue;
	            }

	            var frame = GetValue(item, 'frame', 0);

	            var textureFrame = textureManager.getFrame(key, frame);

	            if (!textureFrame)
	            {
	                console.warn('Texture "%s" not found', key);

	                continue;
	            }

	            animationFrame = new Frame(key, frame, index, textureFrame);

	            animationFrame.duration = GetValue(item, 'duration', 0);

	            animationFrame.isFirst = (!prev);

	            if (prev)
	            {
	                prev.nextFrame = animationFrame;

	                animationFrame.prevFrame = prev;
	            }

	            out.push(animationFrame);

	            prev = animationFrame;

	            index++;
	        }

	        if (out.length > 0)
	        {
	            animationFrame.isLast = true;

	            animationFrame.nextFrame = out[0];

	            out[0].prevFrame = animationFrame;

	            var slice = 1 / (out.length - 1);

	            for (i = 0; i < out.length; i++)
	            {
	                out[i].progress = i * slice;
	            }
	        }

	        return out;
	    },

	    getNextTick: function (state)
	    {
	        state.accumulator -= state.nextTick;

	        state.nextTick = state.frameRate === state.currentAnim.frameRate ? state.currentFrame.duration || state.msPerFrame : state.msPerFrame;
	    },

	    getFrameByProgress: function (value)
	    {
	        value = Clamp(value, 0, 1);

	        return FindClosestInSorted(value, this.frames, 'progress');
	    },

	    nextFrame: function (state)
	    {
	        var frame = state.currentFrame;

	        if (frame.isLast)
	        {

	            if (state.yoyo)
	            {
	                this.handleYoyoFrame(state, false);
	            }
	            else if (state.repeatCounter > 0)
	            {

	                if (state.inReverse && state.forward)
	                {
	                    state.forward = false;
	                }
	                else
	                {
	                    this.repeatAnimation(state);
	                }
	            }
	            else
	            {
	                state.complete();
	            }
	        }
	        else
	        {
	            this.updateAndGetNextTick(state, frame.nextFrame);
	        }
	    },

	    handleYoyoFrame: function (state, isReverse)
	    {
	        if (!isReverse) { isReverse = false; }

	        if (state.inReverse === !isReverse && state.repeatCounter > 0)
	        {
	            if (state.repeatDelay === 0 || state.pendingRepeat)
	            {
	                state.forward = isReverse;
	            }

	            this.repeatAnimation(state);

	            return;
	        }

	        if (state.inReverse !== isReverse && state.repeatCounter === 0)
	        {
	            state.complete();

	            return;
	        }

	        state.forward = isReverse;

	        var frame = (isReverse) ? state.currentFrame.nextFrame : state.currentFrame.prevFrame;

	        this.updateAndGetNextTick(state, frame);
	    },

	    getLastFrame: function ()
	    {
	        return this.frames[this.frames.length - 1];
	    },

	    previousFrame: function (state)
	    {
	        var frame = state.currentFrame;

	        if (frame.isFirst)
	        {

	            if (state.yoyo)
	            {
	                this.handleYoyoFrame(state, true);
	            }
	            else if (state.repeatCounter > 0)
	            {
	                if (state.inReverse && !state.forward)
	                {
	                    this.repeatAnimation(state);
	                }
	                else
	                {

	                    state.forward = true;

	                    this.repeatAnimation(state);
	                }
	            }
	            else
	            {
	                state.complete();
	            }
	        }
	        else
	        {
	            this.updateAndGetNextTick(state, frame.prevFrame);
	        }
	    },

	    updateAndGetNextTick: function (state, frame)
	    {
	        state.setCurrentFrame(frame);

	        this.getNextTick(state);
	    },

	    removeFrame: function (frame)
	    {
	        var index = this.frames.indexOf(frame);

	        if (index !== -1)
	        {
	            this.removeFrameAt(index);
	        }

	        return this;
	    },

	    removeFrameAt: function (index)
	    {
	        this.frames.splice(index, 1);

	        this.updateFrameSequence();

	        return this;
	    },

	    repeatAnimation: function (state)
	    {
	        if (state._pendingStop === 2)
	        {
	            if (state._pendingStopValue === 0)
	            {
	                return state.stop();
	            }
	            else
	            {
	                state._pendingStopValue--;
	            }
	        }

	        if (state.repeatDelay > 0 && !state.pendingRepeat)
	        {
	            state.pendingRepeat = true;
	            state.accumulator -= state.nextTick;
	            state.nextTick += state.repeatDelay;
	        }
	        else
	        {
	            state.repeatCounter--;

	            if (state.forward)
	            {
	                state.setCurrentFrame(state.currentFrame.nextFrame);
	            }
	            else
	            {
	                state.setCurrentFrame(state.currentFrame.prevFrame);
	            }

	            if (state.isPlaying)
	            {
	                this.getNextTick(state);

	                state.handleRepeat();
	            }
	        }
	    },

	    toJSON: function ()
	    {
	        var output = {
	            key: this.key,
	            type: this.type,
	            frames: [],
	            frameRate: this.frameRate,
	            duration: this.duration,
	            skipMissedFrames: this.skipMissedFrames,
	            delay: this.delay,
	            repeat: this.repeat,
	            repeatDelay: this.repeatDelay,
	            yoyo: this.yoyo,
	            showBeforeDelay: this.showBeforeDelay,
	            showOnStart: this.showOnStart,
	            randomFrame: this.randomFrame,
	            hideOnComplete: this.hideOnComplete
	        };

	        this.frames.forEach(function (frame)
	        {
	            output.frames.push(frame.toJSON());
	        });

	        return output;
	    },

	    updateFrameSequence: function ()
	    {
	        var len = this.frames.length;
	        var slice = 1 / (len - 1);

	        var frame;

	        for (var i = 0; i < len; i++)
	        {
	            frame = this.frames[i];

	            frame.index = i + 1;
	            frame.isFirst = false;
	            frame.isLast = false;
	            frame.progress = i * slice;

	            if (i === 0)
	            {
	                frame.isFirst = true;

	                if (len === 1)
	                {
	                    frame.isLast = true;
	                    frame.nextFrame = frame;
	                    frame.prevFrame = frame;
	                }
	                else
	                {
	                    frame.isLast = false;
	                    frame.prevFrame = this.frames[len - 1];
	                    frame.nextFrame = this.frames[i + 1];
	                }
	            }
	            else if (i === len - 1 && len > 1)
	            {
	                frame.isLast = true;
	                frame.prevFrame = this.frames[len - 2];
	                frame.nextFrame = this.frames[0];
	            }
	            else if (len > 1)
	            {
	                frame.prevFrame = this.frames[i - 1];
	                frame.nextFrame = this.frames[i + 1];
	            }
	        }

	        return this;
	    },

	    pause: function ()
	    {
	        this.paused = true;

	        return this;
	    },

	    resume: function ()
	    {
	        this.paused = false;

	        return this;
	    },

	    destroy: function ()
	    {
	        if (this.manager.off)
	        {
	            this.manager.off(Events.PAUSE_ALL, this.pause, this);
	            this.manager.off(Events.RESUME_ALL, this.resume, this);
	        }

	        this.manager.remove(this.key);

	        for (var i = 0; i < this.frames.length; i++)
	        {
	            this.frames[i].destroy();
	        }

	        this.frames = [];

	        this.manager = null;
	    }

	});

	Animation_1 = Animation;
	return Animation_1;
}

var _Map;
var hasRequired_Map;

function require_Map () {
	if (hasRequired_Map) return _Map;
	hasRequired_Map = 1;
	var Class = requireClass();

	var Map = new Class({

	    initialize:

	    function Map (elements)
	    {

	        this.entries = {};

	        this.size = 0;

	        this.setAll(elements);
	    },

	    setAll: function (elements)
	    {
	        if (Array.isArray(elements))
	        {
	            for (var i = 0; i < elements.length; i++)
	            {
	                this.set(elements[i][0], elements[i][1]);
	            }
	        }

	        return this;
	    },

	    set: function (key, value)
	    {
	        if (!this.has(key))
	        {
	            this.size++;
	        }

	        this.entries[key] = value;

	        return this;
	    },

	    get: function (key)
	    {
	        if (this.has(key))
	        {
	            return this.entries[key];
	        }
	    },

	    getArray: function ()
	    {
	        var output = [];
	        var entries = this.entries;

	        for (var key in entries)
	        {
	            output.push(entries[key]);
	        }

	        return output;
	    },

	    has: function (key)
	    {
	        return (this.entries.hasOwnProperty(key));
	    },

	    delete: function (key)
	    {
	        if (this.has(key))
	        {
	            delete this.entries[key];
	            this.size--;
	        }

	        return this;
	    },

	    clear: function ()
	    {
	        Object.keys(this.entries).forEach(function (prop)
	        {
	            delete this.entries[prop];

	        }, this);

	        this.size = 0;

	        return this;
	    },

	    keys: function ()
	    {
	        return Object.keys(this.entries);
	    },

	    values: function ()
	    {
	        var output = [];
	        var entries = this.entries;

	        for (var key in entries)
	        {
	            output.push(entries[key]);
	        }

	        return output;
	    },

	    dump: function ()
	    {
	        var entries = this.entries;

	        console.group('Map');

	        for (var key in entries)
	        {
	            console.log(key, entries[key]);
	        }

	        console.groupEnd();
	    },

	    each: function (callback)
	    {
	        var entries = this.entries;

	        for (var key in entries)
	        {
	            if (callback(key, entries[key]) === false)
	            {
	                break;
	            }
	        }

	        return this;
	    },

	    contains: function (value)
	    {
	        var entries = this.entries;

	        for (var key in entries)
	        {
	            if (entries[key] === value)
	            {
	                return true;
	            }
	        }

	        return false;
	    },

	    merge: function (map, override)
	    {
	        if (override === undefined) { override = false; }

	        var local = this.entries;
	        var source = map.entries;

	        for (var key in source)
	        {
	            if (local.hasOwnProperty(key) && override)
	            {
	                local[key] = source[key];
	            }
	            else
	            {
	                this.set(key, source[key]);
	            }
	        }

	        return this;
	    }

	});

	_Map = Map;
	return _Map;
}

var BLUR_EVENT;
var hasRequiredBLUR_EVENT;

function requireBLUR_EVENT () {
	if (hasRequiredBLUR_EVENT) return BLUR_EVENT;
	hasRequiredBLUR_EVENT = 1;
	BLUR_EVENT = 'blur';
	return BLUR_EVENT;
}

var BOOT_EVENT$2;
var hasRequiredBOOT_EVENT$2;

function requireBOOT_EVENT$2 () {
	if (hasRequiredBOOT_EVENT$2) return BOOT_EVENT$2;
	hasRequiredBOOT_EVENT$2 = 1;
	BOOT_EVENT$2 = 'boot';
	return BOOT_EVENT$2;
}

var CONTEXT_LOST_EVENT;
var hasRequiredCONTEXT_LOST_EVENT;

function requireCONTEXT_LOST_EVENT () {
	if (hasRequiredCONTEXT_LOST_EVENT) return CONTEXT_LOST_EVENT;
	hasRequiredCONTEXT_LOST_EVENT = 1;
	CONTEXT_LOST_EVENT = 'contextlost';
	return CONTEXT_LOST_EVENT;
}

var DESTROY_EVENT$4;
var hasRequiredDESTROY_EVENT$4;

function requireDESTROY_EVENT$4 () {
	if (hasRequiredDESTROY_EVENT$4) return DESTROY_EVENT$4;
	hasRequiredDESTROY_EVENT$4 = 1;
	DESTROY_EVENT$4 = 'destroy';
	return DESTROY_EVENT$4;
}

var FOCUS_EVENT;
var hasRequiredFOCUS_EVENT;

function requireFOCUS_EVENT () {
	if (hasRequiredFOCUS_EVENT) return FOCUS_EVENT;
	hasRequiredFOCUS_EVENT = 1;
	FOCUS_EVENT = 'focus';
	return FOCUS_EVENT;
}

var HIDDEN_EVENT;
var hasRequiredHIDDEN_EVENT;

function requireHIDDEN_EVENT () {
	if (hasRequiredHIDDEN_EVENT) return HIDDEN_EVENT;
	hasRequiredHIDDEN_EVENT = 1;
	HIDDEN_EVENT = 'hidden';
	return HIDDEN_EVENT;
}

var PAUSE_EVENT$2;
var hasRequiredPAUSE_EVENT$2;

function requirePAUSE_EVENT$2 () {
	if (hasRequiredPAUSE_EVENT$2) return PAUSE_EVENT$2;
	hasRequiredPAUSE_EVENT$2 = 1;
	PAUSE_EVENT$2 = 'pause';
	return PAUSE_EVENT$2;
}

var POST_RENDER_EVENT$2;
var hasRequiredPOST_RENDER_EVENT$2;

function requirePOST_RENDER_EVENT$2 () {
	if (hasRequiredPOST_RENDER_EVENT$2) return POST_RENDER_EVENT$2;
	hasRequiredPOST_RENDER_EVENT$2 = 1;
	POST_RENDER_EVENT$2 = 'postrender';
	return POST_RENDER_EVENT$2;
}

var POST_STEP_EVENT;
var hasRequiredPOST_STEP_EVENT;

function requirePOST_STEP_EVENT () {
	if (hasRequiredPOST_STEP_EVENT) return POST_STEP_EVENT;
	hasRequiredPOST_STEP_EVENT = 1;
	POST_STEP_EVENT = 'poststep';
	return POST_STEP_EVENT;
}

var PRE_RENDER_EVENT$2;
var hasRequiredPRE_RENDER_EVENT$2;

function requirePRE_RENDER_EVENT$2 () {
	if (hasRequiredPRE_RENDER_EVENT$2) return PRE_RENDER_EVENT$2;
	hasRequiredPRE_RENDER_EVENT$2 = 1;
	PRE_RENDER_EVENT$2 = 'prerender';
	return PRE_RENDER_EVENT$2;
}

var PRE_STEP_EVENT;
var hasRequiredPRE_STEP_EVENT;

function requirePRE_STEP_EVENT () {
	if (hasRequiredPRE_STEP_EVENT) return PRE_STEP_EVENT;
	hasRequiredPRE_STEP_EVENT = 1;
	PRE_STEP_EVENT = 'prestep';
	return PRE_STEP_EVENT;
}

var READY_EVENT$1;
var hasRequiredREADY_EVENT$1;

function requireREADY_EVENT$1 () {
	if (hasRequiredREADY_EVENT$1) return READY_EVENT$1;
	hasRequiredREADY_EVENT$1 = 1;
	READY_EVENT$1 = 'ready';
	return READY_EVENT$1;
}

var RESUME_EVENT$2;
var hasRequiredRESUME_EVENT$2;

function requireRESUME_EVENT$2 () {
	if (hasRequiredRESUME_EVENT$2) return RESUME_EVENT$2;
	hasRequiredRESUME_EVENT$2 = 1;
	RESUME_EVENT$2 = 'resume';
	return RESUME_EVENT$2;
}

var STEP_EVENT;
var hasRequiredSTEP_EVENT;

function requireSTEP_EVENT () {
	if (hasRequiredSTEP_EVENT) return STEP_EVENT;
	hasRequiredSTEP_EVENT = 1;
	STEP_EVENT = 'step';
	return STEP_EVENT;
}

var SYSTEM_READY_EVENT;
var hasRequiredSYSTEM_READY_EVENT;

function requireSYSTEM_READY_EVENT () {
	if (hasRequiredSYSTEM_READY_EVENT) return SYSTEM_READY_EVENT;
	hasRequiredSYSTEM_READY_EVENT = 1;
	SYSTEM_READY_EVENT = 'systemready';
	return SYSTEM_READY_EVENT;
}

var VISIBLE_EVENT;
var hasRequiredVISIBLE_EVENT;

function requireVISIBLE_EVENT () {
	if (hasRequiredVISIBLE_EVENT) return VISIBLE_EVENT;
	hasRequiredVISIBLE_EVENT = 1;
	VISIBLE_EVENT = 'visible';
	return VISIBLE_EVENT;
}

var events$h;
var hasRequiredEvents$h;

function requireEvents$h () {
	if (hasRequiredEvents$h) return events$h;
	hasRequiredEvents$h = 1;
	events$h = {

	    BLUR: requireBLUR_EVENT(),
	    BOOT: requireBOOT_EVENT$2(),
	    CONTEXT_LOST: requireCONTEXT_LOST_EVENT(),
	    DESTROY: requireDESTROY_EVENT$4(),
	    FOCUS: requireFOCUS_EVENT(),
	    HIDDEN: requireHIDDEN_EVENT(),
	    PAUSE: requirePAUSE_EVENT$2(),
	    POST_RENDER: requirePOST_RENDER_EVENT$2(),
	    POST_STEP: requirePOST_STEP_EVENT(),
	    PRE_RENDER: requirePRE_RENDER_EVENT$2(),
	    PRE_STEP: requirePRE_STEP_EVENT(),
	    READY: requireREADY_EVENT$1(),
	    RESUME: requireRESUME_EVENT$2(),
	    STEP: requireSTEP_EVENT(),
	    SYSTEM_READY: requireSYSTEM_READY_EVENT(),
	    VISIBLE: requireVISIBLE_EVENT()

	};
	return events$h;
}

var AnimationManager_1;
var hasRequiredAnimationManager;

function requireAnimationManager () {
	if (hasRequiredAnimationManager) return AnimationManager_1;
	hasRequiredAnimationManager = 1;
	var Animation = requireAnimation();
	var Class = requireClass();
	var CustomMap = require_Map();
	var EventEmitter = requireEventemitter3();
	var Events = requireEvents$i();
	var GameEvents = requireEvents$h();
	var GetFastValue = requireGetFastValue();
	var GetValue = requireGetValue();
	var MATH_CONST = require_const$c();
	var NumberArray = requireNumberArray();
	var Pad = requirePad();

	var AnimationManager = new Class({

	    Extends: EventEmitter,

	    initialize:

	    function AnimationManager (game)
	    {
	        EventEmitter.call(this);

	        this.game = game;

	        this.textureManager = null;

	        this.globalTimeScale = 1;

	        this.anims = new CustomMap();

	        this.mixes = new CustomMap();

	        this.paused = false;

	        this.name = 'AnimationManager';

	        game.events.once(GameEvents.BOOT, this.boot, this);
	    },

	    boot: function ()
	    {
	        this.textureManager = this.game.textures;

	        this.game.events.once(GameEvents.DESTROY, this.destroy, this);
	    },

	    addMix: function (animA, animB, delay)
	    {
	        var anims = this.anims;
	        var mixes = this.mixes;

	        var keyA = (typeof(animA) === 'string') ? animA : animA.key;
	        var keyB = (typeof(animB) === 'string') ? animB : animB.key;

	        if (anims.has(keyA) && anims.has(keyB))
	        {
	            var mixObj = mixes.get(keyA);

	            if (!mixObj)
	            {
	                mixObj = {};
	            }

	            mixObj[keyB] = delay;

	            mixes.set(keyA, mixObj);
	        }

	        return this;
	    },

	    removeMix: function (animA, animB)
	    {
	        var mixes = this.mixes;

	        var keyA = (typeof(animA) === 'string') ? animA : animA.key;

	        var mixObj = mixes.get(keyA);

	        if (mixObj)
	        {
	            if (animB)
	            {
	                var keyB = (typeof(animB) === 'string') ? animB : animB.key;

	                if (mixObj.hasOwnProperty(keyB))
	                {

	                    delete mixObj[keyB];
	                }
	            }
	            else if (!animB)
	            {

	                mixes.delete(keyA);
	            }
	        }

	        return this;
	    },

	    getMix: function (animA, animB)
	    {
	        var mixes = this.mixes;

	        var keyA = (typeof(animA) === 'string') ? animA : animA.key;
	        var keyB = (typeof(animB) === 'string') ? animB : animB.key;

	        var mixObj = mixes.get(keyA);

	        if (mixObj && mixObj.hasOwnProperty(keyB))
	        {
	            return mixObj[keyB];
	        }
	        else
	        {
	            return 0;
	        }
	    },

	    add: function (key, animation)
	    {
	        if (this.anims.has(key))
	        {
	            console.warn('Animation key exists: ' + key);

	            return this;
	        }

	        animation.key = key;

	        this.anims.set(key, animation);

	        this.emit(Events.ADD_ANIMATION, key, animation);

	        return this;
	    },

	    exists: function (key)
	    {
	        return this.anims.has(key);
	    },

	    createFromAseprite: function (key, tags, target)
	    {
	        var output = [];

	        var data = this.game.cache.json.get(key);

	        if (!data)
	        {
	            console.warn('No Aseprite data found for: ' + key);

	            return output;
	        }

	        var _this = this;

	        var meta = GetValue(data, 'meta', null);
	        var frames = GetValue(data, 'frames', null);

	        if (meta && frames)
	        {
	            var frameTags = GetValue(meta, 'frameTags', []);

	            frameTags.forEach(function (tag)
	            {
	                var animFrames = [];

	                var name = GetFastValue(tag, 'name', null);
	                var from = GetFastValue(tag, 'from', 0);
	                var to = GetFastValue(tag, 'to', 0);
	                var direction = GetFastValue(tag, 'direction', 'forward');

	                if (!name)
	                {

	                    return;
	                }

	                if (!tags || (tags && tags.indexOf(name) > -1))
	                {

	                    var totalDuration = 0;
	                    for (var i = from; i <= to; i++)
	                    {
	                        var frameKey = i.toString();
	                        var frame = frames[frameKey];

	                        if (frame)
	                        {
	                            var frameDuration = GetFastValue(frame, 'duration', MATH_CONST.MAX_SAFE_INTEGER);
	                            animFrames.push({ key: key, frame: frameKey, duration: frameDuration });
	                            totalDuration += frameDuration;
	                        }
	                    }

	                    if (direction === 'reverse')
	                    {
	                        animFrames = animFrames.reverse();
	                    }

	                    var createConfig = {
	                        key: name,
	                        frames: animFrames,
	                        duration: totalDuration,
	                        yoyo: (direction === 'pingpong')
	                    };

	                    var result;

	                    if (target)
	                    {
	                        if (target.anims)
	                        {
	                            result = target.anims.create(createConfig);
	                        }
	                    }
	                    else
	                    {
	                        result = _this.create(createConfig);
	                    }

	                    if (result)
	                    {
	                        output.push(result);
	                    }
	                }
	            });
	        }

	        return output;
	    },

	    create: function (config)
	    {
	        var key = config.key;

	        var anim = false;

	        if (key)
	        {
	            anim = this.get(key);

	            if (!anim)
	            {
	                anim = new Animation(this, key, config);

	                this.anims.set(key, anim);

	                this.emit(Events.ADD_ANIMATION, key, anim);
	            }
	            else
	            {
	                console.warn('AnimationManager key already exists: ' + key);
	            }
	        }

	        return anim;
	    },

	    fromJSON: function (data, clearCurrentAnimations)
	    {
	        if (clearCurrentAnimations === undefined) { clearCurrentAnimations = false; }

	        if (clearCurrentAnimations)
	        {
	            this.anims.clear();
	        }

	        if (typeof data === 'string')
	        {
	            data = JSON.parse(data);
	        }

	        var output = [];

	        if (data.hasOwnProperty('anims') && Array.isArray(data.anims))
	        {
	            for (var i = 0; i < data.anims.length; i++)
	            {
	                output.push(this.create(data.anims[i]));
	            }

	            if (data.hasOwnProperty('globalTimeScale'))
	            {
	                this.globalTimeScale = data.globalTimeScale;
	            }
	        }
	        else if (data.hasOwnProperty('key') && data.type === 'frame')
	        {
	            output.push(this.create(data));
	        }

	        return output;
	    },

	    generateFrameNames: function (key, config)
	    {
	        var prefix = GetValue(config, 'prefix', '');
	        var start = GetValue(config, 'start', 0);
	        var end = GetValue(config, 'end', 0);
	        var suffix = GetValue(config, 'suffix', '');
	        var zeroPad = GetValue(config, 'zeroPad', 0);
	        var out = GetValue(config, 'outputArray', []);
	        var frames = GetValue(config, 'frames', false);

	        if (!this.textureManager.exists(key))
	        {
	            console.warn('Texture "%s" not found', key);

	            return out;
	        }

	        var texture = this.textureManager.get(key);

	        if (!texture)
	        {
	            return out;
	        }

	        var i;

	        if (!config)
	        {

	            frames = texture.getFrameNames();

	            for (i = 0; i < frames.length; i++)
	            {
	                out.push({ key: key, frame: frames[i] });
	            }
	        }
	        else
	        {
	            if (!frames)
	            {
	                frames = NumberArray(start, end);
	            }

	            for (i = 0; i < frames.length; i++)
	            {
	                var frame = prefix + Pad(frames[i], zeroPad, '0', 1) + suffix;

	                if (texture.has(frame))
	                {
	                    out.push({ key: key, frame: frame });
	                }
	                else
	                {
	                    console.warn('Frame "%s" not found in texture "%s"', frame, key);
	                }
	            }
	        }

	        return out;
	    },

	    generateFrameNumbers: function (key, config)
	    {
	        var start = GetValue(config, 'start', 0);
	        var end = GetValue(config, 'end', -1);
	        var first = GetValue(config, 'first', false);
	        var out = GetValue(config, 'outputArray', []);
	        var frames = GetValue(config, 'frames', false);

	        if (!this.textureManager.exists(key))
	        {
	            console.warn('Texture "%s" not found', key);

	            return out;
	        }

	        var texture = this.textureManager.get(key);

	        if (!texture)
	        {
	            return out;
	        }

	        if (first && texture.has(first))
	        {
	            out.push({ key: key, frame: first });
	        }

	        if (!frames)
	        {
	            if (end === -1)
	            {

	                end = texture.frameTotal - 2;
	            }

	            frames = NumberArray(start, end);
	        }

	        for (var i = 0; i < frames.length; i++)
	        {
	            var frameName = frames[i];

	            if (texture.has(frameName))
	            {
	                out.push({ key: key, frame: frameName });
	            }
	            else
	            {
	                console.warn('Frame "%s" not found in texture "%s"', frameName, key);
	            }
	        }

	        return out;
	    },

	    get: function (key)
	    {
	        return this.anims.get(key);
	    },

	    getAnimsFromTexture: function (key)
	    {
	        var texture = this.textureManager.get(key);

	        var match = texture.key;
	        var anims = this.anims.getArray();

	        var out = [];

	        for (var i = 0; i < anims.length; i++)
	        {
	            var anim = anims[i];
	            var frames = anim.frames;

	            for (var c = 0; c < frames.length; c++)
	            {
	                if (frames[c].textureKey === match)
	                {
	                    out.push(anim.key);

	                    break;
	                }
	            }
	        }

	        return out;
	    },

	    pauseAll: function ()
	    {
	        if (!this.paused)
	        {
	            this.paused = true;

	            this.emit(Events.PAUSE_ALL);
	        }

	        return this;
	    },

	    play: function (key, children)
	    {
	        if (!Array.isArray(children))
	        {
	            children = [ children ];
	        }

	        for (var i = 0; i < children.length; i++)
	        {
	            children[i].anims.play(key);
	        }

	        return this;
	    },

	    staggerPlay: function (key, children, stagger, staggerFirst)
	    {
	        if (stagger === undefined) { stagger = 0; }
	        if (staggerFirst === undefined) { staggerFirst = true; }

	        if (!Array.isArray(children))
	        {
	            children = [ children ];
	        }

	        var len = children.length;

	        if (!staggerFirst)
	        {
	            len--;
	        }

	        for (var i = 0; i < children.length; i++)
	        {
	            var time = (stagger < 0) ? Math.abs(stagger) * (len - i) : stagger * i;

	            children[i].anims.playAfterDelay(key, time);
	        }

	        return this;
	    },

	    remove: function (key)
	    {
	        var anim = this.get(key);

	        if (anim)
	        {
	            this.emit(Events.REMOVE_ANIMATION, key, anim);

	            this.anims.delete(key);

	            this.removeMix(key);
	        }

	        return anim;
	    },

	    resumeAll: function ()
	    {
	        if (this.paused)
	        {
	            this.paused = false;

	            this.emit(Events.RESUME_ALL);
	        }

	        return this;
	    },

	    toJSON: function (key)
	    {
	        var output = {
	            anims: [],
	            globalTimeScale: this.globalTimeScale
	        };

	        if (key !== undefined && key !== '')
	        {
	            output.anims.push(this.anims.get(key).toJSON());
	        }
	        else
	        {
	            this.anims.each(function (animationKey, animation)
	            {
	                output.anims.push(animation.toJSON());
	            });
	        }

	        return output;
	    },

	    destroy: function ()
	    {
	        this.anims.clear();
	        this.mixes.clear();

	        this.textureManager = null;

	        this.game = null;
	    }

	});

	AnimationManager_1 = AnimationManager;
	return AnimationManager_1;
}

var Between_1$1;
var hasRequiredBetween$1;

function requireBetween$1 () {
	if (hasRequiredBetween$1) return Between_1$1;
	hasRequiredBetween$1 = 1;
	var Between = function (min, max)
	{
	    return Math.floor(Math.random() * (max - min + 1) + min);
	};

	Between_1$1 = Between;
	return Between_1$1;
}

var AnimationState_1;
var hasRequiredAnimationState;

function requireAnimationState () {
	if (hasRequiredAnimationState) return AnimationState_1;
	hasRequiredAnimationState = 1;
	var Animation = requireAnimation();
	var Between = requireBetween$1();
	var Class = requireClass();
	var CustomMap = require_Map();
	var Events = requireEvents$i();
	var GetFastValue = requireGetFastValue();

	var AnimationState = new Class({

	    initialize:

	    function AnimationState (parent)
	    {

	        this.parent = parent;

	        this.animationManager = parent.scene.sys.anims;

	        this.animationManager.on(Events.REMOVE_ANIMATION, this.globalRemove, this);

	        this.textureManager = this.animationManager.textureManager;

	        this.anims = null;

	        this.isPlaying = false;

	        this.hasStarted = false;

	        this.currentAnim = null;

	        this.currentFrame = null;

	        this.nextAnim = null;

	        this.nextAnimsQueue = [];

	        this.timeScale = 1;

	        this.frameRate = 0;

	        this.duration = 0;

	        this.msPerFrame = 0;

	        this.skipMissedFrames = true;

	        this.randomFrame = false;

	        this.delay = 0;

	        this.repeat = 0;

	        this.repeatDelay = 0;

	        this.yoyo = false;

	        this.showBeforeDelay = false;

	        this.showOnStart = false;

	        this.hideOnComplete = false;

	        this.forward = true;

	        this.inReverse = false;

	        this.accumulator = 0;

	        this.nextTick = 0;

	        this.delayCounter = 0;

	        this.repeatCounter = 0;

	        this.pendingRepeat = false;

	        this._paused = false;

	        this._wasPlaying = false;

	        this._pendingStop = 0;

	        this._pendingStopValue;
	    },

	    chain: function (key)
	    {
	        var parent = this.parent;

	        if (key === undefined)
	        {
	            this.nextAnimsQueue.length = 0;
	            this.nextAnim = null;

	            return parent;
	        }

	        if (!Array.isArray(key))
	        {
	            key = [ key ];
	        }

	        for (var i = 0; i < key.length; i++)
	        {
	            var anim = key[i];

	            if (!this.nextAnim)
	            {
	                this.nextAnim = anim;
	            }
	            else
	            {
	                this.nextAnimsQueue.push(anim);
	            }
	        }

	        return this.parent;
	    },

	    getName: function ()
	    {
	        return (this.currentAnim) ? this.currentAnim.key : '';
	    },

	    getFrameName: function ()
	    {
	        return (this.currentFrame) ? this.currentFrame.textureFrame : '';
	    },

	    load: function (key)
	    {
	        if (this.isPlaying)
	        {
	            this.stop();
	        }

	        var manager = this.animationManager;
	        var animKey = (typeof key === 'string') ? key : GetFastValue(key, 'key', null);

	        var anim = (this.exists(animKey)) ? this.get(animKey) : manager.get(animKey);

	        if (!anim)
	        {
	            console.warn('Missing animation: ' + animKey);
	        }
	        else
	        {
	            this.currentAnim = anim;

	            var totalFrames = anim.getTotalFrames();
	            var frameRate = GetFastValue(key, 'frameRate', anim.frameRate);
	            var duration = GetFastValue(key, 'duration', anim.duration);

	            anim.calculateDuration(this, totalFrames, duration, frameRate);

	            this.delay = GetFastValue(key, 'delay', anim.delay);
	            this.repeat = GetFastValue(key, 'repeat', anim.repeat);
	            this.repeatDelay = GetFastValue(key, 'repeatDelay', anim.repeatDelay);
	            this.yoyo = GetFastValue(key, 'yoyo', anim.yoyo);
	            this.showBeforeDelay = GetFastValue(key, 'showBeforeDelay', anim.showBeforeDelay);
	            this.showOnStart = GetFastValue(key, 'showOnStart', anim.showOnStart);
	            this.hideOnComplete = GetFastValue(key, 'hideOnComplete', anim.hideOnComplete);
	            this.skipMissedFrames = GetFastValue(key, 'skipMissedFrames', anim.skipMissedFrames);
	            this.randomFrame = GetFastValue(key, 'randomFrame', anim.randomFrame);

	            this.timeScale = GetFastValue(key, 'timeScale', this.timeScale);

	            var startFrame = GetFastValue(key, 'startFrame', 0);

	            if (startFrame > totalFrames)
	            {
	                startFrame = 0;
	            }

	            if (this.randomFrame)
	            {
	                startFrame = Between(0, totalFrames - 1);
	            }

	            var frame = anim.frames[startFrame];

	            if (startFrame === 0 && !this.forward)
	            {
	                frame = anim.getLastFrame();
	            }

	            this.currentFrame = frame;
	        }

	        return this.parent;
	    },

	    pause: function (atFrame)
	    {
	        if (!this._paused)
	        {
	            this._paused = true;
	            this._wasPlaying = this.isPlaying;
	            this.isPlaying = false;
	        }

	        if (atFrame !== undefined)
	        {
	            this.setCurrentFrame(atFrame);
	        }

	        return this.parent;
	    },

	    resume: function (fromFrame)
	    {
	        if (this._paused)
	        {
	            this._paused = false;
	            this.isPlaying = this._wasPlaying;
	        }

	        if (fromFrame !== undefined)
	        {
	            this.setCurrentFrame(fromFrame);
	        }

	        return this.parent;
	    },

	    playAfterDelay: function (key, delay)
	    {
	        if (!this.isPlaying)
	        {
	            this.delayCounter = delay;

	            this.play(key, true);
	        }
	        else
	        {

	            var nextAnim = this.nextAnim;
	            var queue = this.nextAnimsQueue;

	            if (nextAnim)
	            {
	                queue.unshift(nextAnim);
	            }

	            this.nextAnim = key;

	            this._pendingStop = 1;
	            this._pendingStopValue = delay;
	        }

	        return this.parent;
	    },

	    playAfterRepeat: function (key, repeatCount)
	    {
	        if (repeatCount === undefined) { repeatCount = 1; }

	        if (!this.isPlaying)
	        {
	            this.play(key);
	        }
	        else
	        {

	            var nextAnim = this.nextAnim;
	            var queue = this.nextAnimsQueue;

	            if (nextAnim)
	            {
	                queue.unshift(nextAnim);
	            }

	            if (this.repeatCounter !== -1 && repeatCount > this.repeatCounter)
	            {
	                repeatCount = this.repeatCounter;
	            }

	            this.nextAnim = key;

	            this._pendingStop = 2;
	            this._pendingStopValue = repeatCount;
	        }

	        return this.parent;
	    },

	    play: function (key, ignoreIfPlaying)
	    {
	        if (ignoreIfPlaying === undefined) { ignoreIfPlaying = false; }

	        var currentAnim = this.currentAnim;
	        var parent = this.parent;

	        var animKey = (typeof key === 'string') ? key : key.key;

	        if (ignoreIfPlaying && this.isPlaying && currentAnim.key === animKey)
	        {
	            return parent;
	        }

	        if (currentAnim && this.isPlaying)
	        {
	            var mix = this.animationManager.getMix(currentAnim.key, key);

	            if (mix > 0)
	            {
	                return this.playAfterDelay(key, mix);
	            }
	        }

	        this.forward = true;
	        this.inReverse = false;

	        this._paused = false;
	        this._wasPlaying = true;

	        return this.startAnimation(key);
	    },

	    playReverse: function (key, ignoreIfPlaying)
	    {
	        if (ignoreIfPlaying === undefined) { ignoreIfPlaying = false; }

	        var animKey = (typeof key === 'string') ? key : key.key;

	        if (ignoreIfPlaying && this.isPlaying && this.currentAnim.key === animKey)
	        {
	            return this.parent;
	        }

	        this.forward = false;
	        this.inReverse = true;

	        this._paused = false;
	        this._wasPlaying = true;

	        return this.startAnimation(key);
	    },

	    startAnimation: function (key)
	    {
	        this.load(key);

	        var anim = this.currentAnim;
	        var gameObject = this.parent;

	        if (!anim)
	        {
	            return gameObject;
	        }

	        this.repeatCounter = (this.repeat === -1) ? Number.MAX_VALUE : this.repeat;

	        anim.getFirstTick(this);

	        this.isPlaying = true;
	        this.pendingRepeat = false;
	        this.hasStarted = false;

	        this._pendingStop = 0;
	        this._pendingStopValue = 0;
	        this._paused = false;

	        this.delayCounter += this.delay;

	        if (this.delayCounter === 0)
	        {
	            this.handleStart();
	        }
	        else if (this.showBeforeDelay)
	        {

	            this.setCurrentFrame(this.currentFrame);
	        }

	        return gameObject;
	    },

	    handleStart: function ()
	    {
	        if (this.showOnStart)
	        {
	            this.parent.setVisible(true);
	        }

	        this.setCurrentFrame(this.currentFrame);

	        this.hasStarted = true;

	        this.emitEvents(Events.ANIMATION_START);
	    },

	    handleRepeat: function ()
	    {
	        this.pendingRepeat = false;

	        this.emitEvents(Events.ANIMATION_REPEAT);
	    },

	    handleStop: function ()
	    {
	        this._pendingStop = 0;

	        this.isPlaying = false;

	        this.emitEvents(Events.ANIMATION_STOP);
	    },

	    handleComplete: function ()
	    {
	        this._pendingStop = 0;

	        this.isPlaying = false;

	        if (this.hideOnComplete)
	        {
	            this.parent.setVisible(false);
	        }

	        this.emitEvents(Events.ANIMATION_COMPLETE, Events.ANIMATION_COMPLETE_KEY);
	    },

	    emitEvents: function (event, keyEvent)
	    {
	        var anim = this.currentAnim;

	        if (anim)
	        {
	            var frame = this.currentFrame;

	            var gameObject = this.parent;

	            var frameKey = frame.textureFrame;

	            gameObject.emit(event, anim, frame, gameObject, frameKey);

	            if (keyEvent)
	            {
	                gameObject.emit(keyEvent + anim.key, anim, frame, gameObject, frameKey);
	            }
	        }
	    },

	    reverse: function ()
	    {
	        if (this.isPlaying)
	        {
	            this.inReverse = !this.inReverse;

	            this.forward = !this.forward;
	        }

	        return this.parent;
	    },

	    getProgress: function ()
	    {
	        var frame = this.currentFrame;

	        if (!frame)
	        {
	            return 0;
	        }

	        var p = frame.progress;

	        if (this.inReverse)
	        {
	            p *= -1;
	        }

	        return p;
	    },

	    setProgress: function (value)
	    {
	        if (!this.forward)
	        {
	            value = 1 - value;
	        }

	        this.setCurrentFrame(this.currentAnim.getFrameByProgress(value));

	        return this.parent;
	    },

	    setRepeat: function (value)
	    {
	        this.repeatCounter = (value === -1) ? Number.MAX_VALUE : value;

	        return this.parent;
	    },

	    globalRemove: function (key, animation)
	    {
	        if (animation === undefined) { animation = this.currentAnim; }

	        if (this.isPlaying && animation.key === this.currentAnim.key)
	        {
	            this.stop();

	            this.setCurrentFrame(this.currentAnim.frames[0]);
	        }
	    },

	    restart: function (includeDelay, resetRepeats)
	    {
	        if (includeDelay === undefined) { includeDelay = false; }
	        if (resetRepeats === undefined) { resetRepeats = false; }

	        var anim = this.currentAnim;
	        var gameObject = this.parent;

	        if (!anim)
	        {
	            return gameObject;
	        }

	        if (resetRepeats)
	        {
	            this.repeatCounter = (this.repeat === -1) ? Number.MAX_VALUE : this.repeat;
	        }

	        anim.getFirstTick(this);

	        this.emitEvents(Events.ANIMATION_RESTART);

	        this.isPlaying = true;
	        this.pendingRepeat = false;

	        this.hasStarted = !includeDelay;

	        this._pendingStop = 0;
	        this._pendingStopValue = 0;
	        this._paused = false;

	        this.setCurrentFrame(anim.frames[0]);

	        return this.parent;
	    },

	    complete: function ()
	    {
	        this._pendingStop = 0;

	        this.isPlaying = false;

	        if (this.currentAnim)
	        {
	            this.handleComplete();
	        }

	        if (this.nextAnim)
	        {
	            var key = this.nextAnim;

	            this.nextAnim = (this.nextAnimsQueue.length > 0) ? this.nextAnimsQueue.shift() : null;

	            this.play(key);
	        }

	        return this.parent;
	    },

	    stop: function ()
	    {
	        this._pendingStop = 0;

	        this.isPlaying = false;

	        this.delayCounter = 0;

	        if (this.currentAnim)
	        {
	            this.handleStop();
	        }

	        if (this.nextAnim)
	        {
	            var key = this.nextAnim;

	            this.nextAnim = this.nextAnimsQueue.shift();

	            this.play(key);
	        }

	        return this.parent;
	    },

	    stopAfterDelay: function (delay)
	    {
	        this._pendingStop = 1;
	        this._pendingStopValue = delay;

	        return this.parent;
	    },

	    stopAfterRepeat: function (repeatCount)
	    {
	        if (repeatCount === undefined) { repeatCount = 1; }

	        if (this.repeatCounter !== -1 && repeatCount > this.repeatCounter)
	        {
	            repeatCount = this.repeatCounter;
	        }

	        this._pendingStop = 2;
	        this._pendingStopValue = repeatCount;

	        return this.parent;
	    },

	    stopOnFrame: function (frame)
	    {
	        this._pendingStop = 3;
	        this._pendingStopValue = frame;

	        return this.parent;
	    },

	    getTotalFrames: function ()
	    {
	        return (this.currentAnim) ? this.currentAnim.getTotalFrames() : 0;
	    },

	    update: function (time, delta)
	    {
	        var anim = this.currentAnim;

	        if (!this.isPlaying || !anim || anim.paused)
	        {
	            return;
	        }

	        this.accumulator += delta * this.timeScale * this.animationManager.globalTimeScale;

	        if (this._pendingStop === 1)
	        {
	            this._pendingStopValue -= delta;

	            if (this._pendingStopValue <= 0)
	            {
	                return this.stop();
	            }
	        }

	        if (!this.hasStarted)
	        {
	            if (this.accumulator >= this.delayCounter)
	            {
	                this.accumulator -= this.delayCounter;

	                this.handleStart();
	            }
	        }
	        else if (this.accumulator >= this.nextTick)
	        {

	            if (this.forward)
	            {
	                anim.nextFrame(this);
	            }
	            else
	            {
	                anim.previousFrame(this);
	            }

	            if (this.isPlaying && this._pendingStop === 0 && this.skipMissedFrames && this.accumulator > this.nextTick)
	            {
	                var safetyNet = 0;

	                do
	                {
	                    if (this.forward)
	                    {
	                        anim.nextFrame(this);
	                    }
	                    else
	                    {
	                        anim.previousFrame(this);
	                    }

	                    safetyNet++;

	                } while (this.isPlaying && this.accumulator > this.nextTick && safetyNet < 60);
	            }
	        }
	    },

	    setCurrentFrame: function (animationFrame)
	    {
	        var gameObject = this.parent;

	        this.currentFrame = animationFrame;

	        gameObject.texture = animationFrame.frame.texture;
	        gameObject.frame = animationFrame.frame;

	        if (gameObject.isCropped)
	        {
	            gameObject.frame.updateCropUVs(gameObject._crop, gameObject.flipX, gameObject.flipY);
	        }

	        if (animationFrame.setAlpha)
	        {
	            gameObject.alpha = animationFrame.alpha;
	        }

	        gameObject.setSizeToFrame();

	        if (gameObject._originComponent)
	        {
	            if (animationFrame.frame.customPivot)
	            {
	                gameObject.setOrigin(animationFrame.frame.pivotX, animationFrame.frame.pivotY);
	            }
	            else
	            {
	                gameObject.updateDisplayOrigin();
	            }
	        }

	        if (this.isPlaying && this.hasStarted)
	        {
	            this.emitEvents(Events.ANIMATION_UPDATE);

	            if (this._pendingStop === 3 && this._pendingStopValue === animationFrame)
	            {
	                this.stop();
	            }
	        }

	        return gameObject;
	    },

	    nextFrame: function ()
	    {
	        if (this.currentAnim)
	        {
	            this.currentAnim.nextFrame(this);
	        }

	        return this.parent;
	    },

	    previousFrame: function ()
	    {
	        if (this.currentAnim)
	        {
	            this.currentAnim.previousFrame(this);
	        }

	        return this.parent;
	    },

	    get: function (key)
	    {
	        return (this.anims) ? this.anims.get(key) : null;
	    },

	    exists: function (key)
	    {
	        return (this.anims) ? this.anims.has(key) : false;
	    },

	    create: function (config)
	    {
	        var key = config.key;

	        var anim = false;

	        if (key)
	        {
	            anim = this.get(key);

	            if (!anim)
	            {
	                anim = new Animation(this, key, config);

	                if (!this.anims)
	                {
	                    this.anims = new CustomMap();
	                }

	                this.anims.set(key, anim);
	            }
	            else
	            {
	                console.warn('Animation key already exists: ' + key);
	            }
	        }

	        return anim;
	    },

	    createFromAseprite: function (key, tags)
	    {
	        return this.animationManager.createFromAseprite(key, tags, this.parent);
	    },

	    generateFrameNames: function (key, config)
	    {
	        return this.animationManager.generateFrameNames(key, config);
	    },

	    generateFrameNumbers: function (key, config)
	    {
	        return this.animationManager.generateFrameNumbers(key, config);
	    },

	    remove: function (key)
	    {
	        var anim = this.get(key);

	        if (anim)
	        {
	            if (this.currentAnim === anim)
	            {
	                this.stop();
	            }

	            this.anims.delete(key);
	        }

	        return anim;
	    },

	    destroy: function ()
	    {
	        this.animationManager.off(Events.REMOVE_ANIMATION, this.globalRemove, this);

	        if (this.anims)
	        {
	            this.anims.clear();
	        }

	        this.animationManager = null;
	        this.parent = null;
	        this.nextAnim = null;
	        this.nextAnimsQueue.length = 0;

	        this.currentAnim = null;
	        this.currentFrame = null;
	    },

	    isPaused: {

	        get: function ()
	        {
	            return this._paused;
	        }

	    }

	});

	AnimationState_1 = AnimationState;
	return AnimationState_1;
}

var animations;
var hasRequiredAnimations;

function requireAnimations () {
	if (hasRequiredAnimations) return animations;
	hasRequiredAnimations = 1;
	animations = {

	    Animation: requireAnimation(),
	    AnimationFrame: requireAnimationFrame(),
	    AnimationManager: requireAnimationManager(),
	    AnimationState: requireAnimationState(),
	    Events: requireEvents$i()

	};
	return animations;
}

var ADD_EVENT$2;
var hasRequiredADD_EVENT$2;

function requireADD_EVENT$2 () {
	if (hasRequiredADD_EVENT$2) return ADD_EVENT$2;
	hasRequiredADD_EVENT$2 = 1;
	ADD_EVENT$2 = 'add';
	return ADD_EVENT$2;
}

var REMOVE_EVENT$1;
var hasRequiredREMOVE_EVENT$1;

function requireREMOVE_EVENT$1 () {
	if (hasRequiredREMOVE_EVENT$1) return REMOVE_EVENT$1;
	hasRequiredREMOVE_EVENT$1 = 1;
	REMOVE_EVENT$1 = 'remove';
	return REMOVE_EVENT$1;
}

var events$g;
var hasRequiredEvents$g;

function requireEvents$g () {
	if (hasRequiredEvents$g) return events$g;
	hasRequiredEvents$g = 1;
	events$g = {

	    ADD: requireADD_EVENT$2(),
	    REMOVE: requireREMOVE_EVENT$1()

	};
	return events$g;
}

var BaseCache_1;
var hasRequiredBaseCache;

function requireBaseCache () {
	if (hasRequiredBaseCache) return BaseCache_1;
	hasRequiredBaseCache = 1;
	var Class = requireClass();
	var CustomMap = require_Map();
	var EventEmitter = requireEventemitter3();
	var Events = requireEvents$g();

	var BaseCache = new Class({

	    initialize:

	    function BaseCache ()
	    {

	        this.entries = new CustomMap();

	        this.events = new EventEmitter();
	    },

	    add: function (key, data)
	    {
	        this.entries.set(key, data);

	        this.events.emit(Events.ADD, this, key, data);

	        return this;
	    },

	    has: function (key)
	    {
	        return this.entries.has(key);
	    },

	    exists: function (key)
	    {
	        return this.entries.has(key);
	    },

	    get: function (key)
	    {
	        return this.entries.get(key);
	    },

	    remove: function (key)
	    {
	        var entry = this.get(key);

	        if (entry)
	        {
	            this.entries.delete(key);

	            this.events.emit(Events.REMOVE, this, key, entry.data);
	        }

	        return this;
	    },

	    getKeys: function ()
	    {
	        return this.entries.keys();
	    },

	    destroy: function ()
	    {
	        this.entries.clear();
	        this.events.removeAllListeners();

	        this.entries = null;
	        this.events = null;
	    }

	});

	BaseCache_1 = BaseCache;
	return BaseCache_1;
}

var CacheManager_1;
var hasRequiredCacheManager;

function requireCacheManager () {
	if (hasRequiredCacheManager) return CacheManager_1;
	hasRequiredCacheManager = 1;
	var BaseCache = requireBaseCache();
	var Class = requireClass();
	var GameEvents = requireEvents$h();

	var CacheManager = new Class({

	    initialize:

	    function CacheManager (game)
	    {

	        this.game = game;

	        this.binary = new BaseCache();

	        this.bitmapFont = new BaseCache();

	        this.json = new BaseCache();

	        this.physics = new BaseCache();

	        this.shader = new BaseCache();

	        this.audio = new BaseCache();

	        this.video = new BaseCache();

	        this.text = new BaseCache();

	        this.html = new BaseCache();

	        this.obj = new BaseCache();

	        this.tilemap = new BaseCache();

	        this.xml = new BaseCache();

	        this.custom = {};

	        this.game.events.once(GameEvents.DESTROY, this.destroy, this);
	    },

	    addCustom: function (key)
	    {
	        if (!this.custom.hasOwnProperty(key))
	        {
	            this.custom[key] = new BaseCache();
	        }

	        return this.custom[key];
	    },

	    destroy: function ()
	    {
	        var keys = [
	            'binary',
	            'bitmapFont',
	            'json',
	            'physics',
	            'shader',
	            'audio',
	            'video',
	            'text',
	            'html',
	            'obj',
	            'tilemap',
	            'xml'
	        ];

	        for (var i = 0; i < keys.length; i++)
	        {
	            this[keys[i]].destroy();
	            this[keys[i]] = null;
	        }

	        for (var key in this.custom)
	        {
	            this.custom[key].destroy();
	        }

	        this.custom = null;

	        this.game = null;
	    }

	});

	CacheManager_1 = CacheManager;
	return CacheManager_1;
}

var cache;
var hasRequiredCache;

function requireCache () {
	if (hasRequiredCache) return cache;
	hasRequiredCache = 1;
	cache = {

	    BaseCache: requireBaseCache(),
	    CacheManager: requireCacheManager(),
	    Events: requireEvents$g()

	};
	return cache;
}

var FixedKeyControl_1;
var hasRequiredFixedKeyControl;

function requireFixedKeyControl () {
	if (hasRequiredFixedKeyControl) return FixedKeyControl_1;
	hasRequiredFixedKeyControl = 1;
	var Class = requireClass();
	var GetValue = requireGetValue();

	var FixedKeyControl = new Class({

	    initialize:

	    function FixedKeyControl (config)
	    {

	        this.camera = GetValue(config, 'camera', null);

	        this.left = GetValue(config, 'left', null);

	        this.right = GetValue(config, 'right', null);

	        this.up = GetValue(config, 'up', null);

	        this.down = GetValue(config, 'down', null);

	        this.zoomIn = GetValue(config, 'zoomIn', null);

	        this.zoomOut = GetValue(config, 'zoomOut', null);

	        this.zoomSpeed = GetValue(config, 'zoomSpeed', 0.01);

	        this.minZoom = GetValue(config, 'minZoom', 0.001);

	        this.maxZoom = GetValue(config, 'maxZoom', 1000);

	        this.speedX = 0;

	        this.speedY = 0;

	        var speed = GetValue(config, 'speed', null);

	        if (typeof speed === 'number')
	        {
	            this.speedX = speed;
	            this.speedY = speed;
	        }
	        else
	        {
	            this.speedX = GetValue(config, 'speed.x', 0);
	            this.speedY = GetValue(config, 'speed.y', 0);
	        }

	        this._zoom = 0;

	        this.active = (this.camera !== null);
	    },

	    start: function ()
	    {
	        this.active = (this.camera !== null);

	        return this;
	    },

	    stop: function ()
	    {
	        this.active = false;

	        return this;
	    },

	    setCamera: function (camera)
	    {
	        this.camera = camera;

	        return this;
	    },

	    update: function (delta)
	    {
	        if (!this.active)
	        {
	            return;
	        }

	        if (delta === undefined) { delta = 1; }

	        var cam = this.camera;

	        if (this.up && this.up.isDown)
	        {
	            cam.scrollY -= ((this.speedY * delta) | 0);
	        }
	        else if (this.down && this.down.isDown)
	        {
	            cam.scrollY += ((this.speedY * delta) | 0);
	        }

	        if (this.left && this.left.isDown)
	        {
	            cam.scrollX -= ((this.speedX * delta) | 0);
	        }
	        else if (this.right && this.right.isDown)
	        {
	            cam.scrollX += ((this.speedX * delta) | 0);
	        }

	        if (this.zoomIn && this.zoomIn.isDown)
	        {
	            cam.zoom -= this.zoomSpeed;

	            if (cam.zoom < this.minZoom)
	            {
	                cam.zoom = this.minZoom;
	            }
	        }
	        else if (this.zoomOut && this.zoomOut.isDown)
	        {
	            cam.zoom += this.zoomSpeed;

	            if (cam.zoom > this.maxZoom)
	            {
	                cam.zoom = this.maxZoom;
	            }
	        }
	    },

	    destroy: function ()
	    {
	        this.camera = null;

	        this.left = null;
	        this.right = null;
	        this.up = null;
	        this.down = null;

	        this.zoomIn = null;
	        this.zoomOut = null;
	    }

	});

	FixedKeyControl_1 = FixedKeyControl;
	return FixedKeyControl_1;
}

var SmoothedKeyControl_1;
var hasRequiredSmoothedKeyControl;

function requireSmoothedKeyControl () {
	if (hasRequiredSmoothedKeyControl) return SmoothedKeyControl_1;
	hasRequiredSmoothedKeyControl = 1;
	var Class = requireClass();
	var GetValue = requireGetValue();

	var SmoothedKeyControl = new Class({

	    initialize:

	    function SmoothedKeyControl (config)
	    {

	        this.camera = GetValue(config, 'camera', null);

	        this.left = GetValue(config, 'left', null);

	        this.right = GetValue(config, 'right', null);

	        this.up = GetValue(config, 'up', null);

	        this.down = GetValue(config, 'down', null);

	        this.zoomIn = GetValue(config, 'zoomIn', null);

	        this.zoomOut = GetValue(config, 'zoomOut', null);

	        this.zoomSpeed = GetValue(config, 'zoomSpeed', 0.01);

	        this.minZoom = GetValue(config, 'minZoom', 0.001);

	        this.maxZoom = GetValue(config, 'maxZoom', 1000);

	        this.accelX = 0;

	        this.accelY = 0;

	        var accel = GetValue(config, 'acceleration', null);

	        if (typeof accel === 'number')
	        {
	            this.accelX = accel;
	            this.accelY = accel;
	        }
	        else
	        {
	            this.accelX = GetValue(config, 'acceleration.x', 0);
	            this.accelY = GetValue(config, 'acceleration.y', 0);
	        }

	        this.dragX = 0;

	        this.dragY = 0;

	        var drag = GetValue(config, 'drag', null);

	        if (typeof drag === 'number')
	        {
	            this.dragX = drag;
	            this.dragY = drag;
	        }
	        else
	        {
	            this.dragX = GetValue(config, 'drag.x', 0);
	            this.dragY = GetValue(config, 'drag.y', 0);
	        }

	        this.maxSpeedX = 0;

	        this.maxSpeedY = 0;

	        var maxSpeed = GetValue(config, 'maxSpeed', null);

	        if (typeof maxSpeed === 'number')
	        {
	            this.maxSpeedX = maxSpeed;
	            this.maxSpeedY = maxSpeed;
	        }
	        else
	        {
	            this.maxSpeedX = GetValue(config, 'maxSpeed.x', 0);
	            this.maxSpeedY = GetValue(config, 'maxSpeed.y', 0);
	        }

	        this._speedX = 0;

	        this._speedY = 0;

	        this._zoom = 0;

	        this.active = (this.camera !== null);
	    },

	    start: function ()
	    {
	        this.active = (this.camera !== null);

	        return this;
	    },

	    stop: function ()
	    {
	        this.active = false;

	        return this;
	    },

	    setCamera: function (camera)
	    {
	        this.camera = camera;

	        return this;
	    },

	    update: function (delta)
	    {
	        if (!this.active)
	        {
	            return;
	        }

	        if (delta === undefined) { delta = 1; }

	        var cam = this.camera;

	        if (this._speedX > 0)
	        {
	            this._speedX -= this.dragX * delta;

	            if (this._speedX < 0)
	            {
	                this._speedX = 0;
	            }
	        }
	        else if (this._speedX < 0)
	        {
	            this._speedX += this.dragX * delta;

	            if (this._speedX > 0)
	            {
	                this._speedX = 0;
	            }
	        }

	        if (this._speedY > 0)
	        {
	            this._speedY -= this.dragY * delta;

	            if (this._speedY < 0)
	            {
	                this._speedY = 0;
	            }
	        }
	        else if (this._speedY < 0)
	        {
	            this._speedY += this.dragY * delta;

	            if (this._speedY > 0)
	            {
	                this._speedY = 0;
	            }
	        }

	        if (this.up && this.up.isDown)
	        {
	            this._speedY += this.accelY;

	            if (this._speedY > this.maxSpeedY)
	            {
	                this._speedY = this.maxSpeedY;
	            }
	        }
	        else if (this.down && this.down.isDown)
	        {
	            this._speedY -= this.accelY;

	            if (this._speedY < -this.maxSpeedY)
	            {
	                this._speedY = -this.maxSpeedY;
	            }
	        }

	        if (this.left && this.left.isDown)
	        {
	            this._speedX += this.accelX;

	            if (this._speedX > this.maxSpeedX)
	            {
	                this._speedX = this.maxSpeedX;
	            }
	        }
	        else if (this.right && this.right.isDown)
	        {
	            this._speedX -= this.accelX;

	            if (this._speedX < -this.maxSpeedX)
	            {
	                this._speedX = -this.maxSpeedX;
	            }
	        }

	        if (this.zoomIn && this.zoomIn.isDown)
	        {
	            this._zoom = -this.zoomSpeed;
	        }
	        else if (this.zoomOut && this.zoomOut.isDown)
	        {
	            this._zoom = this.zoomSpeed;
	        }
	        else
	        {
	            this._zoom = 0;
	        }

	        if (this._speedX !== 0)
	        {
	            cam.scrollX -= ((this._speedX * delta) | 0);
	        }

	        if (this._speedY !== 0)
	        {
	            cam.scrollY -= ((this._speedY * delta) | 0);
	        }

	        if (this._zoom !== 0)
	        {
	            cam.zoom += this._zoom;

	            if (cam.zoom < this.minZoom)
	            {
	                cam.zoom = this.minZoom;
	            }
	            else if (cam.zoom > this.maxZoom)
	            {
	                cam.zoom = this.maxZoom;
	            }
	        }
	    },

	    destroy: function ()
	    {
	        this.camera = null;

	        this.left = null;
	        this.right = null;
	        this.up = null;
	        this.down = null;

	        this.zoomIn = null;
	        this.zoomOut = null;
	    }

	});

	SmoothedKeyControl_1 = SmoothedKeyControl;
	return SmoothedKeyControl_1;
}

var controls;
var hasRequiredControls;

function requireControls () {
	if (hasRequiredControls) return controls;
	hasRequiredControls = 1;
	controls = {

	    FixedKeyControl: requireFixedKeyControl(),
	    SmoothedKeyControl: requireSmoothedKeyControl()

	};
	return controls;
}

var DESTROY_EVENT$3;
var hasRequiredDESTROY_EVENT$3;

function requireDESTROY_EVENT$3 () {
	if (hasRequiredDESTROY_EVENT$3) return DESTROY_EVENT$3;
	hasRequiredDESTROY_EVENT$3 = 1;
	DESTROY_EVENT$3 = 'cameradestroy';
	return DESTROY_EVENT$3;
}

var FADE_IN_COMPLETE_EVENT;
var hasRequiredFADE_IN_COMPLETE_EVENT;

function requireFADE_IN_COMPLETE_EVENT () {
	if (hasRequiredFADE_IN_COMPLETE_EVENT) return FADE_IN_COMPLETE_EVENT;
	hasRequiredFADE_IN_COMPLETE_EVENT = 1;
	FADE_IN_COMPLETE_EVENT = 'camerafadeincomplete';
	return FADE_IN_COMPLETE_EVENT;
}

var FADE_IN_START_EVENT;
var hasRequiredFADE_IN_START_EVENT;

function requireFADE_IN_START_EVENT () {
	if (hasRequiredFADE_IN_START_EVENT) return FADE_IN_START_EVENT;
	hasRequiredFADE_IN_START_EVENT = 1;
	FADE_IN_START_EVENT = 'camerafadeinstart';
	return FADE_IN_START_EVENT;
}

var FADE_OUT_COMPLETE_EVENT;
var hasRequiredFADE_OUT_COMPLETE_EVENT;

function requireFADE_OUT_COMPLETE_EVENT () {
	if (hasRequiredFADE_OUT_COMPLETE_EVENT) return FADE_OUT_COMPLETE_EVENT;
	hasRequiredFADE_OUT_COMPLETE_EVENT = 1;
	FADE_OUT_COMPLETE_EVENT = 'camerafadeoutcomplete';
	return FADE_OUT_COMPLETE_EVENT;
}

var FADE_OUT_START_EVENT;
var hasRequiredFADE_OUT_START_EVENT;

function requireFADE_OUT_START_EVENT () {
	if (hasRequiredFADE_OUT_START_EVENT) return FADE_OUT_START_EVENT;
	hasRequiredFADE_OUT_START_EVENT = 1;
	FADE_OUT_START_EVENT = 'camerafadeoutstart';
	return FADE_OUT_START_EVENT;
}

var FLASH_COMPLETE_EVENT;
var hasRequiredFLASH_COMPLETE_EVENT;

function requireFLASH_COMPLETE_EVENT () {
	if (hasRequiredFLASH_COMPLETE_EVENT) return FLASH_COMPLETE_EVENT;
	hasRequiredFLASH_COMPLETE_EVENT = 1;
	FLASH_COMPLETE_EVENT = 'cameraflashcomplete';
	return FLASH_COMPLETE_EVENT;
}

var FLASH_START_EVENT;
var hasRequiredFLASH_START_EVENT;

function requireFLASH_START_EVENT () {
	if (hasRequiredFLASH_START_EVENT) return FLASH_START_EVENT;
	hasRequiredFLASH_START_EVENT = 1;
	FLASH_START_EVENT = 'cameraflashstart';
	return FLASH_START_EVENT;
}

var FOLLOW_UPDATE_EVENT;
var hasRequiredFOLLOW_UPDATE_EVENT;

function requireFOLLOW_UPDATE_EVENT () {
	if (hasRequiredFOLLOW_UPDATE_EVENT) return FOLLOW_UPDATE_EVENT;
	hasRequiredFOLLOW_UPDATE_EVENT = 1;
	FOLLOW_UPDATE_EVENT = 'followupdate';
	return FOLLOW_UPDATE_EVENT;
}

var PAN_COMPLETE_EVENT;
var hasRequiredPAN_COMPLETE_EVENT;

function requirePAN_COMPLETE_EVENT () {
	if (hasRequiredPAN_COMPLETE_EVENT) return PAN_COMPLETE_EVENT;
	hasRequiredPAN_COMPLETE_EVENT = 1;
	PAN_COMPLETE_EVENT = 'camerapancomplete';
	return PAN_COMPLETE_EVENT;
}

var PAN_START_EVENT;
var hasRequiredPAN_START_EVENT;

function requirePAN_START_EVENT () {
	if (hasRequiredPAN_START_EVENT) return PAN_START_EVENT;
	hasRequiredPAN_START_EVENT = 1;
	PAN_START_EVENT = 'camerapanstart';
	return PAN_START_EVENT;
}

var POST_RENDER_EVENT$1;
var hasRequiredPOST_RENDER_EVENT$1;

function requirePOST_RENDER_EVENT$1 () {
	if (hasRequiredPOST_RENDER_EVENT$1) return POST_RENDER_EVENT$1;
	hasRequiredPOST_RENDER_EVENT$1 = 1;
	POST_RENDER_EVENT$1 = 'postrender';
	return POST_RENDER_EVENT$1;
}

var PRE_RENDER_EVENT$1;
var hasRequiredPRE_RENDER_EVENT$1;

function requirePRE_RENDER_EVENT$1 () {
	if (hasRequiredPRE_RENDER_EVENT$1) return PRE_RENDER_EVENT$1;
	hasRequiredPRE_RENDER_EVENT$1 = 1;
	PRE_RENDER_EVENT$1 = 'prerender';
	return PRE_RENDER_EVENT$1;
}

var ROTATE_COMPLETE_EVENT;
var hasRequiredROTATE_COMPLETE_EVENT;

function requireROTATE_COMPLETE_EVENT () {
	if (hasRequiredROTATE_COMPLETE_EVENT) return ROTATE_COMPLETE_EVENT;
	hasRequiredROTATE_COMPLETE_EVENT = 1;
	ROTATE_COMPLETE_EVENT = 'camerarotatecomplete';
	return ROTATE_COMPLETE_EVENT;
}

var ROTATE_START_EVENT;
var hasRequiredROTATE_START_EVENT;

function requireROTATE_START_EVENT () {
	if (hasRequiredROTATE_START_EVENT) return ROTATE_START_EVENT;
	hasRequiredROTATE_START_EVENT = 1;
	ROTATE_START_EVENT = 'camerarotatestart';
	return ROTATE_START_EVENT;
}

var SHAKE_COMPLETE_EVENT;
var hasRequiredSHAKE_COMPLETE_EVENT;

function requireSHAKE_COMPLETE_EVENT () {
	if (hasRequiredSHAKE_COMPLETE_EVENT) return SHAKE_COMPLETE_EVENT;
	hasRequiredSHAKE_COMPLETE_EVENT = 1;
	SHAKE_COMPLETE_EVENT = 'camerashakecomplete';
	return SHAKE_COMPLETE_EVENT;
}

var SHAKE_START_EVENT;
var hasRequiredSHAKE_START_EVENT;

function requireSHAKE_START_EVENT () {
	if (hasRequiredSHAKE_START_EVENT) return SHAKE_START_EVENT;
	hasRequiredSHAKE_START_EVENT = 1;
	SHAKE_START_EVENT = 'camerashakestart';
	return SHAKE_START_EVENT;
}

var ZOOM_COMPLETE_EVENT;
var hasRequiredZOOM_COMPLETE_EVENT;

function requireZOOM_COMPLETE_EVENT () {
	if (hasRequiredZOOM_COMPLETE_EVENT) return ZOOM_COMPLETE_EVENT;
	hasRequiredZOOM_COMPLETE_EVENT = 1;
	ZOOM_COMPLETE_EVENT = 'camerazoomcomplete';
	return ZOOM_COMPLETE_EVENT;
}

var ZOOM_START_EVENT;
var hasRequiredZOOM_START_EVENT;

function requireZOOM_START_EVENT () {
	if (hasRequiredZOOM_START_EVENT) return ZOOM_START_EVENT;
	hasRequiredZOOM_START_EVENT = 1;
	ZOOM_START_EVENT = 'camerazoomstart';
	return ZOOM_START_EVENT;
}

var events$f;
var hasRequiredEvents$f;

function requireEvents$f () {
	if (hasRequiredEvents$f) return events$f;
	hasRequiredEvents$f = 1;
	events$f = {

	    DESTROY: requireDESTROY_EVENT$3(),
	    FADE_IN_COMPLETE: requireFADE_IN_COMPLETE_EVENT(),
	    FADE_IN_START: requireFADE_IN_START_EVENT(),
	    FADE_OUT_COMPLETE: requireFADE_OUT_COMPLETE_EVENT(),
	    FADE_OUT_START: requireFADE_OUT_START_EVENT(),
	    FLASH_COMPLETE: requireFLASH_COMPLETE_EVENT(),
	    FLASH_START: requireFLASH_START_EVENT(),
	    FOLLOW_UPDATE: requireFOLLOW_UPDATE_EVENT(),
	    PAN_COMPLETE: requirePAN_COMPLETE_EVENT(),
	    PAN_START: requirePAN_START_EVENT(),
	    POST_RENDER: requirePOST_RENDER_EVENT$1(),
	    PRE_RENDER: requirePRE_RENDER_EVENT$1(),
	    ROTATE_COMPLETE: requireROTATE_COMPLETE_EVENT(),
	    ROTATE_START: requireROTATE_START_EVENT(),
	    SHAKE_COMPLETE: requireSHAKE_COMPLETE_EVENT(),
	    SHAKE_START: requireSHAKE_START_EVENT(),
	    ZOOM_COMPLETE: requireZOOM_COMPLETE_EVENT(),
	    ZOOM_START: requireZOOM_START_EVENT()

	};
	return events$f;
}

var GetColor_1;
var hasRequiredGetColor;

function requireGetColor () {
	if (hasRequiredGetColor) return GetColor_1;
	hasRequiredGetColor = 1;
	var GetColor = function (red, green, blue)
	{
	    return red << 16 | green << 8 | blue;
	};

	GetColor_1 = GetColor;
	return GetColor_1;
}

var GetColor32_1;
var hasRequiredGetColor32;

function requireGetColor32 () {
	if (hasRequiredGetColor32) return GetColor32_1;
	hasRequiredGetColor32 = 1;
	var GetColor32 = function (red, green, blue, alpha)
	{
	    return alpha << 24 | red << 16 | green << 8 | blue;
	};

	GetColor32_1 = GetColor32;
	return GetColor32_1;
}

var HSVToRGB_1;
var hasRequiredHSVToRGB;

function requireHSVToRGB () {
	if (hasRequiredHSVToRGB) return HSVToRGB_1;
	hasRequiredHSVToRGB = 1;
	var GetColor = requireGetColor();

	function ConvertValue (n, h, s, v)
	{
	    var k = (n + h * 6) % 6;

	    var min = Math.min(k, 4 - k, 1);

	    return Math.round(255 * (v - v * s * Math.max(0, min)));
	}

	var HSVToRGB = function (h, s, v, out)
	{
	    if (s === undefined) { s = 1; }
	    if (v === undefined) { v = 1; }

	    var r = ConvertValue(5, h, s, v);
	    var g = ConvertValue(3, h, s, v);
	    var b = ConvertValue(1, h, s, v);

	    if (!out)
	    {
	        return { r: r, g: g, b: b, color: GetColor(r, g, b) };
	    }
	    else if (out.setTo)
	    {
	        return out.setTo(r, g, b, out.alpha, true);
	    }
	    else
	    {
	        out.r = r;
	        out.g = g;
	        out.b = b;
	        out.color = GetColor(r, g, b);

	        return out;
	    }
	};

	HSVToRGB_1 = HSVToRGB;
	return HSVToRGB_1;
}

var RGBToHSV_1;
var hasRequiredRGBToHSV;

function requireRGBToHSV () {
	if (hasRequiredRGBToHSV) return RGBToHSV_1;
	hasRequiredRGBToHSV = 1;
	var RGBToHSV = function (r, g, b, out)
	{
	    if (out === undefined) { out = { h: 0, s: 0, v: 0 }; }

	    r /= 255;
	    g /= 255;
	    b /= 255;

	    var min = Math.min(r, g, b);
	    var max = Math.max(r, g, b);
	    var d = max - min;

	    var h = 0;
	    var s = (max === 0) ? 0 : d / max;
	    var v = max;

	    if (max !== min)
	    {
	        if (max === r)
	        {
	            h = (g - b) / d + ((g < b) ? 6 : 0);
	        }
	        else if (max === g)
	        {
	            h = (b - r) / d + 2;
	        }
	        else if (max === b)
	        {
	            h = (r - g) / d + 4;
	        }

	        h /= 6;
	    }

	    if (out.hasOwnProperty('_h'))
	    {
	        out._h = h;
	        out._s = s;
	        out._v = v;
	    }
	    else
	    {
	        out.h = h;
	        out.s = s;
	        out.v = v;
	    }

	    return out;
	};

	RGBToHSV_1 = RGBToHSV;
	return RGBToHSV_1;
}

var Color_1;
var hasRequiredColor$1;

function requireColor$1 () {
	if (hasRequiredColor$1) return Color_1;
	hasRequiredColor$1 = 1;
	var Class = requireClass();
	var GetColor = requireGetColor();
	var GetColor32 = requireGetColor32();
	var HSVToRGB = requireHSVToRGB();
	var RGBToHSV = requireRGBToHSV();

	var Color = new Class({

	    initialize:

	    function Color (red, green, blue, alpha)
	    {
	        if (red === undefined) { red = 0; }
	        if (green === undefined) { green = 0; }
	        if (blue === undefined) { blue = 0; }
	        if (alpha === undefined) { alpha = 255; }

	        this.r = 0;

	        this.g = 0;

	        this.b = 0;

	        this.a = 255;

	        this._h = 0;

	        this._s = 0;

	        this._v = 0;

	        this._locked = false;

	        this.gl = [ 0, 0, 0, 1 ];

	        this._color = 0;

	        this._color32 = 0;

	        this._rgba = '';

	        this.setTo(red, green, blue, alpha);
	    },

	    transparent: function ()
	    {
	        this._locked = true;

	        this.red = 0;
	        this.green = 0;
	        this.blue = 0;
	        this.alpha = 0;

	        this._locked = false;

	        return this.update(true);
	    },

	    setTo: function (red, green, blue, alpha, updateHSV)
	    {
	        if (alpha === undefined) { alpha = 255; }
	        if (updateHSV === undefined) { updateHSV = true; }

	        this._locked = true;

	        this.red = red;
	        this.green = green;
	        this.blue = blue;
	        this.alpha = alpha;

	        this._locked = false;

	        return this.update(updateHSV);
	    },

	    setGLTo: function (red, green, blue, alpha)
	    {
	        if (alpha === undefined) { alpha = 1; }

	        this._locked = true;

	        this.redGL = red;
	        this.greenGL = green;
	        this.blueGL = blue;
	        this.alphaGL = alpha;

	        this._locked = false;

	        return this.update(true);
	    },

	    setFromRGB: function (color)
	    {
	        this._locked = true;

	        this.red = color.r;
	        this.green = color.g;
	        this.blue = color.b;

	        if (color.hasOwnProperty('a'))
	        {
	            this.alpha = color.a;
	        }

	        this._locked = false;

	        return this.update(true);
	    },

	    setFromHSV: function (h, s, v)
	    {
	        return HSVToRGB(h, s, v, this);
	    },

	    update: function (updateHSV)
	    {
	        if (updateHSV === undefined) { updateHSV = false; }

	        if (this._locked)
	        {
	            return this;
	        }

	        var r = this.r;
	        var g = this.g;
	        var b = this.b;
	        var a = this.a;

	        this._color = GetColor(r, g, b);
	        this._color32 = GetColor32(r, g, b, a);
	        this._rgba = 'rgba(' + r + ',' + g + ',' + b + ',' + (a / 255) + ')';

	        if (updateHSV)
	        {
	            RGBToHSV(r, g, b, this);
	        }

	        return this;
	    },

	    updateHSV: function ()
	    {
	        var r = this.r;
	        var g = this.g;
	        var b = this.b;

	        RGBToHSV(r, g, b, this);

	        return this;
	    },

	    clone: function ()
	    {
	        return new Color(this.r, this.g, this.b, this.a);
	    },

	    gray: function (shade)
	    {
	        return this.setTo(shade, shade, shade);
	    },

	    random: function (min, max)
	    {
	        if (min === undefined) { min = 0; }
	        if (max === undefined) { max = 255; }

	        var r = Math.floor(min + Math.random() * (max - min));
	        var g = Math.floor(min + Math.random() * (max - min));
	        var b = Math.floor(min + Math.random() * (max - min));

	        return this.setTo(r, g, b);
	    },

	    randomGray: function (min, max)
	    {
	        if (min === undefined) { min = 0; }
	        if (max === undefined) { max = 255; }

	        var s = Math.floor(min + Math.random() * (max - min));

	        return this.setTo(s, s, s);
	    },

	    saturate: function (amount)
	    {
	        this.s += amount / 100;

	        return this;
	    },

	    desaturate: function (amount)
	    {
	        this.s -= amount / 100;

	        return this;
	    },

	    lighten: function (amount)
	    {
	        this.v += amount / 100;

	        return this;
	    },

	    darken: function (amount)
	    {
	        this.v -= amount / 100;

	        return this;
	    },

	    brighten: function (amount)
	    {
	        var r = this.r;
	        var g = this.g;
	        var b = this.b;

	        r = Math.max(0, Math.min(255, r - Math.round(255 * - (amount / 100))));
	        g = Math.max(0, Math.min(255, g - Math.round(255 * - (amount / 100))));
	        b = Math.max(0, Math.min(255, b - Math.round(255 * - (amount / 100))));

	        return this.setTo(r, g, b);
	    },

	    color: {

	        get: function ()
	        {
	            return this._color;
	        }

	    },

	    color32: {

	        get: function ()
	        {
	            return this._color32;
	        }

	    },

	    rgba: {

	        get: function ()
	        {
	            return this._rgba;
	        }

	    },

	    redGL: {

	        get: function ()
	        {
	            return this.gl[0];
	        },

	        set: function (value)
	        {
	            this.gl[0] = Math.min(Math.abs(value), 1);

	            this.r = Math.floor(this.gl[0] * 255);

	            this.update(true);
	        }

	    },

	    greenGL: {

	        get: function ()
	        {
	            return this.gl[1];
	        },

	        set: function (value)
	        {
	            this.gl[1] = Math.min(Math.abs(value), 1);

	            this.g = Math.floor(this.gl[1] * 255);

	            this.update(true);
	        }

	    },

	    blueGL: {

	        get: function ()
	        {
	            return this.gl[2];
	        },

	        set: function (value)
	        {
	            this.gl[2] = Math.min(Math.abs(value), 1);

	            this.b = Math.floor(this.gl[2] * 255);

	            this.update(true);
	        }

	    },

	    alphaGL: {

	        get: function ()
	        {
	            return this.gl[3];
	        },

	        set: function (value)
	        {
	            this.gl[3] = Math.min(Math.abs(value), 1);

	            this.a = Math.floor(this.gl[3] * 255);

	            this.update();
	        }

	    },

	    red: {

	        get: function ()
	        {
	            return this.r;
	        },

	        set: function (value)
	        {
	            value = Math.floor(Math.abs(value));

	            this.r = Math.min(value, 255);

	            this.gl[0] = value / 255;

	            this.update(true);
	        }

	    },

	    green: {

	        get: function ()
	        {
	            return this.g;
	        },

	        set: function (value)
	        {
	            value = Math.floor(Math.abs(value));

	            this.g = Math.min(value, 255);

	            this.gl[1] = value / 255;

	            this.update(true);
	        }

	    },

	    blue: {

	        get: function ()
	        {
	            return this.b;
	        },

	        set: function (value)
	        {
	            value = Math.floor(Math.abs(value));

	            this.b = Math.min(value, 255);

	            this.gl[2] = value / 255;

	            this.update(true);
	        }

	    },

	    alpha: {

	        get: function ()
	        {
	            return this.a;
	        },

	        set: function (value)
	        {
	            value = Math.floor(Math.abs(value));

	            this.a = Math.min(value, 255);

	            this.gl[3] = value / 255;

	            this.update();
	        }

	    },

	    h: {

	        get: function ()
	        {
	            return this._h;
	        },

	        set: function (value)
	        {
	            this._h = value;

	            HSVToRGB(value, this._s, this._v, this);
	        }

	    },

	    s: {

	        get: function ()
	        {
	            return this._s;
	        },

	        set: function (value)
	        {
	            this._s = value;

	            HSVToRGB(this._h, value, this._v, this);
	        }

	    },

	    v: {

	        get: function ()
	        {
	            return this._v;
	        },

	        set: function (value)
	        {
	            this._v = value;

	            HSVToRGB(this._h, this._s, value, this);
	        }

	    }

	});

	Color_1 = Color;
	return Color_1;
}

var HexStringToColor_1;
var hasRequiredHexStringToColor;

function requireHexStringToColor () {
	if (hasRequiredHexStringToColor) return HexStringToColor_1;
	hasRequiredHexStringToColor = 1;
	var Color = requireColor$1();

	var HexStringToColor = function (hex)
	{
	    var color = new Color();

	    hex = hex.replace(/^(?:#|0x)?([a-f\d])([a-f\d])([a-f\d])$/i, function (m, r, g, b)
	    {
	        return r + r + g + g + b + b;
	    });

	    var result = (/^(?:#|0x)?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i).exec(hex);

	    if (result)
	    {
	        var r = parseInt(result[1], 16);
	        var g = parseInt(result[2], 16);
	        var b = parseInt(result[3], 16);

	        color.setTo(r, g, b);
	    }

	    return color;
	};

	HexStringToColor_1 = HexStringToColor;
	return HexStringToColor_1;
}

var IntegerToRGB_1;
var hasRequiredIntegerToRGB;

function requireIntegerToRGB () {
	if (hasRequiredIntegerToRGB) return IntegerToRGB_1;
	hasRequiredIntegerToRGB = 1;
	var IntegerToRGB = function (color)
	{
	    if (color > 16777215)
	    {

	        return {
	            a: color >>> 24,
	            r: color >> 16 & 0xFF,
	            g: color >> 8 & 0xFF,
	            b: color & 0xFF
	        };
	    }
	    else
	    {
	        return {
	            a: 255,
	            r: color >> 16 & 0xFF,
	            g: color >> 8 & 0xFF,
	            b: color & 0xFF
	        };
	    }
	};

	IntegerToRGB_1 = IntegerToRGB;
	return IntegerToRGB_1;
}

var IntegerToColor_1;
var hasRequiredIntegerToColor;

function requireIntegerToColor () {
	if (hasRequiredIntegerToColor) return IntegerToColor_1;
	hasRequiredIntegerToColor = 1;
	var Color = requireColor$1();
	var IntegerToRGB = requireIntegerToRGB();

	var IntegerToColor = function (input)
	{
	    var rgb = IntegerToRGB(input);

	    return new Color(rgb.r, rgb.g, rgb.b, rgb.a);
	};

	IntegerToColor_1 = IntegerToColor;
	return IntegerToColor_1;
}

var ObjectToColor_1;
var hasRequiredObjectToColor;

function requireObjectToColor () {
	if (hasRequiredObjectToColor) return ObjectToColor_1;
	hasRequiredObjectToColor = 1;
	var Color = requireColor$1();

	var ObjectToColor = function (input)
	{
	    return new Color(input.r, input.g, input.b, input.a);
	};

	ObjectToColor_1 = ObjectToColor;
	return ObjectToColor_1;
}

var RGBStringToColor_1;
var hasRequiredRGBStringToColor;

function requireRGBStringToColor () {
	if (hasRequiredRGBStringToColor) return RGBStringToColor_1;
	hasRequiredRGBStringToColor = 1;
	var Color = requireColor$1();

	var RGBStringToColor = function (rgb)
	{
	    var color = new Color();

	    var result = (/^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d+(?:\.\d+)?))?\s*\)$/).exec(rgb.toLowerCase());

	    if (result)
	    {
	        var r = parseInt(result[1], 10);
	        var g = parseInt(result[2], 10);
	        var b = parseInt(result[3], 10);
	        var a = (result[4] !== undefined) ? parseFloat(result[4]) : 1;

	        color.setTo(r, g, b, a * 255);
	    }

	    return color;
	};

	RGBStringToColor_1 = RGBStringToColor;
	return RGBStringToColor_1;
}

var ValueToColor_1;
var hasRequiredValueToColor;

function requireValueToColor () {
	if (hasRequiredValueToColor) return ValueToColor_1;
	hasRequiredValueToColor = 1;
	var HexStringToColor = requireHexStringToColor();
	var IntegerToColor = requireIntegerToColor();
	var ObjectToColor = requireObjectToColor();
	var RGBStringToColor = requireRGBStringToColor();

	var ValueToColor = function (input)
	{
	    var t = typeof input;

	    switch (t)
	    {
	        case 'string':

	            if (input.substr(0, 3).toLowerCase() === 'rgb')
	            {
	                return RGBStringToColor(input);
	            }
	            else
	            {
	                return HexStringToColor(input);
	            }

	        case 'number':

	            return IntegerToColor(input);

	        case 'object':

	            return ObjectToColor(input);
	    }
	};

	ValueToColor_1 = ValueToColor;
	return ValueToColor_1;
}

var BaseCamera_1;
var hasRequiredBaseCamera;

function requireBaseCamera () {
	if (hasRequiredBaseCamera) return BaseCamera_1;
	hasRequiredBaseCamera = 1;
	var Class = requireClass();
	var Components = requireComponents$2();
	var DegToRad = requireDegToRad();
	var EventEmitter = requireEventemitter3();
	var Events = requireEvents$f();
	var Rectangle = requireRectangle$2();
	var TransformMatrix = requireTransformMatrix();
	var ValueToColor = requireValueToColor();
	var Vector2 = requireVector2();

	var BaseCamera = new Class({

	    Extends: EventEmitter,

	    Mixins: [
	        Components.AlphaSingle,
	        Components.Visible
	    ],

	    initialize:

	    function BaseCamera (x, y, width, height)
	    {
	        if (x === undefined) { x = 0; }
	        if (y === undefined) { y = 0; }
	        if (width === undefined) { width = 0; }
	        if (height === undefined) { height = 0; }

	        EventEmitter.call(this);

	        this.scene;

	        this.sceneManager;

	        this.scaleManager;

	        this.cameraManager;

	        this.id = 0;

	        this.name = '';

	        this.roundPixels = false;

	        this.useBounds = false;

	        this.worldView = new Rectangle();

	        this.dirty = true;

	        this._x = x;

	        this._y = y;

	        this._width = width;

	        this._height = height;

	        this._bounds = new Rectangle();

	        this._scrollX = 0;

	        this._scrollY = 0;

	        this._zoomX = 1;

	        this._zoomY = 1;

	        this._rotation = 0;

	        this.matrix = new TransformMatrix();

	        this.transparent = true;

	        this.backgroundColor = ValueToColor('rgba(0,0,0,0)');

	        this.disableCull = false;

	        this.culledObjects = [];

	        this.midPoint = new Vector2(width / 2, height / 2);

	        this.originX = 0.5;

	        this.originY = 0.5;

	        this._customViewport = false;

	        this.mask = null;

	        this._maskCamera = null;

	        this.renderList = [];

	        this.isSceneCamera = true;

	        this.renderRoundPixels = true;
	    },

	    addToRenderList: function (child)
	    {
	        this.renderList.push(child);
	    },

	    setOrigin: function (x, y)
	    {
	        if (x === undefined) { x = 0.5; }
	        if (y === undefined) { y = x; }

	        this.originX = x;
	        this.originY = y;

	        return this;
	    },

	    getScroll: function (x, y, out)
	    {
	        if (out === undefined) { out = new Vector2(); }

	        var originX = this.width * 0.5;
	        var originY = this.height * 0.5;

	        out.x = x - originX;
	        out.y = y - originY;

	        if (this.useBounds)
	        {
	            out.x = this.clampX(out.x);
	            out.y = this.clampY(out.y);
	        }

	        return out;
	    },

	    centerOnX: function (x)
	    {
	        var originX = this.width * 0.5;

	        this.midPoint.x = x;

	        this.scrollX = x - originX;

	        if (this.useBounds)
	        {
	            this.scrollX = this.clampX(this.scrollX);
	        }

	        return this;
	    },

	    centerOnY: function (y)
	    {
	        var originY = this.height * 0.5;

	        this.midPoint.y = y;

	        this.scrollY = y - originY;

	        if (this.useBounds)
	        {
	            this.scrollY = this.clampY(this.scrollY);
	        }

	        return this;
	    },

	    centerOn: function (x, y)
	    {
	        this.centerOnX(x);
	        this.centerOnY(y);

	        return this;
	    },

	    centerToBounds: function ()
	    {
	        if (this.useBounds)
	        {
	            var bounds = this._bounds;
	            var originX = this.width * 0.5;
	            var originY = this.height * 0.5;

	            this.midPoint.set(bounds.centerX, bounds.centerY);

	            this.scrollX = bounds.centerX - originX;
	            this.scrollY = bounds.centerY - originY;
	        }

	        return this;
	    },

	    centerToSize: function ()
	    {
	        this.scrollX = this.width * 0.5;
	        this.scrollY = this.height * 0.5;

	        return this;
	    },

	    cull: function (renderableObjects)
	    {
	        if (this.disableCull)
	        {
	            return renderableObjects;
	        }

	        var cameraMatrix = this.matrix.matrix;

	        var mva = cameraMatrix[0];
	        var mvb = cameraMatrix[1];
	        var mvc = cameraMatrix[2];
	        var mvd = cameraMatrix[3];

	        var determinant = (mva * mvd) - (mvb * mvc);

	        if (!determinant)
	        {
	            return renderableObjects;
	        }

	        var mve = cameraMatrix[4];
	        var mvf = cameraMatrix[5];

	        var scrollX = this.scrollX;
	        var scrollY = this.scrollY;
	        var cameraW = this.width;
	        var cameraH = this.height;
	        var cullTop = this.y;
	        var cullBottom = cullTop + cameraH;
	        var cullLeft = this.x;
	        var cullRight = cullLeft + cameraW;
	        var culledObjects = this.culledObjects;
	        var length = renderableObjects.length;

	        determinant = 1 / determinant;

	        culledObjects.length = 0;

	        for (var index = 0; index < length; ++index)
	        {
	            var object = renderableObjects[index];

	            if (!object.hasOwnProperty('width') || object.parentContainer)
	            {
	                culledObjects.push(object);
	                continue;
	            }

	            var objectW = object.width;
	            var objectH = object.height;
	            var objectX = (object.x - (scrollX * object.scrollFactorX)) - (objectW * object.originX);
	            var objectY = (object.y - (scrollY * object.scrollFactorY)) - (objectH * object.originY);
	            var tx = (objectX * mva + objectY * mvc + mve);
	            var ty = (objectX * mvb + objectY * mvd + mvf);
	            var tw = ((objectX + objectW) * mva + (objectY + objectH) * mvc + mve);
	            var th = ((objectX + objectW) * mvb + (objectY + objectH) * mvd + mvf);

	            if ((tw > cullLeft && tx < cullRight) && (th > cullTop && ty < cullBottom))
	            {
	                culledObjects.push(object);
	            }
	        }

	        return culledObjects;
	    },

	    getWorldPoint: function (x, y, output)
	    {
	        if (output === undefined) { output = new Vector2(); }

	        var cameraMatrix = this.matrix.matrix;

	        var mva = cameraMatrix[0];
	        var mvb = cameraMatrix[1];
	        var mvc = cameraMatrix[2];
	        var mvd = cameraMatrix[3];
	        var mve = cameraMatrix[4];
	        var mvf = cameraMatrix[5];

	        var determinant = (mva * mvd) - (mvb * mvc);

	        if (!determinant)
	        {
	            output.x = x;
	            output.y = y;

	            return output;
	        }

	        determinant = 1 / determinant;

	        var ima = mvd * determinant;
	        var imb = -mvb * determinant;
	        var imc = -mvc * determinant;
	        var imd = mva * determinant;
	        var ime = (mvc * mvf - mvd * mve) * determinant;
	        var imf = (mvb * mve - mva * mvf) * determinant;

	        var c = Math.cos(this.rotation);
	        var s = Math.sin(this.rotation);

	        var zoomX = this.zoomX;
	        var zoomY = this.zoomY;

	        var scrollX = this.scrollX;
	        var scrollY = this.scrollY;

	        var sx = x + ((scrollX * c - scrollY * s) * zoomX);
	        var sy = y + ((scrollX * s + scrollY * c) * zoomY);

	        output.x = (sx * ima + sy * imc) + ime;
	        output.y = (sx * imb + sy * imd) + imf;

	        return output;
	    },

	    ignore: function (entries)
	    {
	        var id = this.id;

	        if (!Array.isArray(entries))
	        {
	            entries = [ entries ];
	        }

	        for (var i = 0; i < entries.length; i++)
	        {
	            var entry = entries[i];

	            if (Array.isArray(entry))
	            {
	                this.ignore(entry);
	            }
	            else if (entry.isParent)
	            {
	                this.ignore(entry.getChildren());
	            }
	            else
	            {
	                entry.cameraFilter |= id;
	            }
	        }

	        return this;
	    },

	    clampX: function (x)
	    {
	        var bounds = this._bounds;

	        var dw = this.displayWidth;

	        var bx = bounds.x + ((dw - this.width) / 2);
	        var bw = Math.max(bx, bx + bounds.width - dw);

	        if (x < bx)
	        {
	            x = bx;
	        }
	        else if (x > bw)
	        {
	            x = bw;
	        }

	        return x;
	    },

	    clampY: function (y)
	    {
	        var bounds = this._bounds;

	        var dh = this.displayHeight;

	        var by = bounds.y + ((dh - this.height) / 2);
	        var bh = Math.max(by, by + bounds.height - dh);

	        if (y < by)
	        {
	            y = by;
	        }
	        else if (y > bh)
	        {
	            y = bh;
	        }

	        return y;
	    },

	    removeBounds: function ()
	    {
	        this.useBounds = false;

	        this.dirty = true;

	        this._bounds.setEmpty();

	        return this;
	    },

	    setAngle: function (value)
	    {
	        if (value === undefined) { value = 0; }

	        this.rotation = DegToRad(value);

	        return this;
	    },

	    setBackgroundColor: function (color)
	    {
	        if (color === undefined) { color = 'rgba(0,0,0,0)'; }

	        this.backgroundColor = ValueToColor(color);

	        this.transparent = (this.backgroundColor.alpha === 0);

	        return this;
	    },

	    setBounds: function (x, y, width, height, centerOn)
	    {
	        if (centerOn === undefined) { centerOn = false; }

	        this._bounds.setTo(x, y, width, height);

	        this.dirty = true;
	        this.useBounds = true;

	        if (centerOn)
	        {
	            this.centerToBounds();
	        }
	        else
	        {
	            this.scrollX = this.clampX(this.scrollX);
	            this.scrollY = this.clampY(this.scrollY);
	        }

	        return this;
	    },

	    getBounds: function (out)
	    {
	        if (out === undefined) { out = new Rectangle(); }

	        var source = this._bounds;

	        out.setTo(source.x, source.y, source.width, source.height);

	        return out;
	    },

	    setName: function (value)
	    {
	        if (value === undefined) { value = ''; }

	        this.name = value;

	        return this;
	    },

	    setPosition: function (x, y)
	    {
	        if (y === undefined) { y = x; }

	        this.x = x;
	        this.y = y;

	        return this;
	    },

	    setRotation: function (value)
	    {
	        if (value === undefined) { value = 0; }

	        this.rotation = value;

	        return this;
	    },

	    setRoundPixels: function (value)
	    {
	        this.roundPixels = value;

	        return this;
	    },

	    setScene: function (scene, isSceneCamera)
	    {
	        if (isSceneCamera === undefined) { isSceneCamera = true; }

	        if (this.scene && this._customViewport)
	        {
	            this.sceneManager.customViewports--;
	        }

	        this.scene = scene;
	        this.isSceneCamera = isSceneCamera;

	        var sys = scene.sys;

	        this.sceneManager = sys.game.scene;
	        this.scaleManager = sys.scale;
	        this.cameraManager = sys.cameras;

	        this.updateSystem();

	        return this;
	    },

	    setScroll: function (x, y)
	    {
	        if (y === undefined) { y = x; }

	        this.scrollX = x;
	        this.scrollY = y;

	        return this;
	    },

	    setSize: function (width, height)
	    {
	        if (height === undefined) { height = width; }

	        this.width = width;
	        this.height = height;

	        return this;
	    },

	    setViewport: function (x, y, width, height)
	    {
	        this.x = x;
	        this.y = y;
	        this.width = width;
	        this.height = height;

	        return this;
	    },

	    setZoom: function (x, y)
	    {
	        if (x === undefined) { x = 1; }
	        if (y === undefined) { y = x; }

	        if (x === 0)
	        {
	            x = 0.001;
	        }

	        if (y === 0)
	        {
	            y = 0.001;
	        }

	        this.zoomX = x;
	        this.zoomY = y;

	        return this;
	    },

	    setMask: function (mask, fixedPosition)
	    {
	        if (fixedPosition === undefined) { fixedPosition = true; }

	        this.mask = mask;

	        this._maskCamera = (fixedPosition) ? this.cameraManager.default : this;

	        return this;
	    },

	    clearMask: function (destroyMask)
	    {
	        if (destroyMask === undefined) { destroyMask = false; }

	        if (destroyMask && this.mask)
	        {
	            this.mask.destroy();
	        }

	        this.mask = null;

	        return this;
	    },

	    toJSON: function ()
	    {
	        var output = {
	            name: this.name,
	            x: this.x,
	            y: this.y,
	            width: this.width,
	            height: this.height,
	            zoom: this.zoom,
	            rotation: this.rotation,
	            roundPixels: this.roundPixels,
	            scrollX: this.scrollX,
	            scrollY: this.scrollY,
	            backgroundColor: this.backgroundColor.rgba
	        };

	        if (this.useBounds)
	        {
	            output['bounds'] = {
	                x: this._bounds.x,
	                y: this._bounds.y,
	                width: this._bounds.width,
	                height: this._bounds.height
	            };
	        }

	        return output;
	    },

	    update: function ()
	    {

	    },

	    setIsSceneCamera: function (value)
	    {
	        this.isSceneCamera = value;

	        return this;
	    },

	    updateSystem: function ()
	    {
	        if (!this.scaleManager || !this.isSceneCamera)
	        {
	            return;
	        }

	        var custom = (this._x !== 0 || this._y !== 0 || this.scaleManager.width !== this._width || this.scaleManager.height !== this._height);

	        var sceneManager = this.sceneManager;

	        if (custom && !this._customViewport)
	        {

	            sceneManager.customViewports++;
	        }
	        else if (!custom && this._customViewport)
	        {

	            sceneManager.customViewports--;
	        }

	        this.dirty = true;
	        this._customViewport = custom;
	    },

	    destroy: function ()
	    {
	        this.emit(Events.DESTROY, this);

	        this.removeAllListeners();

	        this.matrix.destroy();

	        this.culledObjects = [];

	        if (this._customViewport)
	        {

	            this.sceneManager.customViewports--;
	        }

	        this.renderList = [];

	        this._bounds = null;

	        this.scene = null;
	        this.scaleManager = null;
	        this.sceneManager = null;
	        this.cameraManager = null;
	    },

	    x: {

	        get: function ()
	        {
	            return this._x;
	        },

	        set: function (value)
	        {
	            this._x = value;
	            this.updateSystem();
	        }

	    },

	    y: {

	        get: function ()
	        {
	            return this._y;
	        },

	        set: function (value)
	        {
	            this._y = value;
	            this.updateSystem();
	        }

	    },

	    width: {

	        get: function ()
	        {
	            return this._width;
	        },

	        set: function (value)
	        {
	            this._width = value;
	            this.updateSystem();
	        }

	    },

	    height: {

	        get: function ()
	        {
	            return this._height;
	        },

	        set: function (value)
	        {
	            this._height = value;
	            this.updateSystem();
	        }

	    },

	    scrollX: {

	        get: function ()
	        {
	            return this._scrollX;
	        },

	        set: function (value)
	        {
	            if (value !== this._scrollX)
	            {
	                this._scrollX = value;
	                this.dirty = true;
	            }
	        }

	    },

	    scrollY: {

	        get: function ()
	        {
	            return this._scrollY;
	        },

	        set: function (value)
	        {
	            if (value !== this._scrollY)
	            {
	                this._scrollY = value;
	                this.dirty = true;
	            }
	        }

	    },

	    zoom: {

	        get: function ()
	        {
	            return (this._zoomX + this._zoomY) / 2;
	        },

	        set: function (value)
	        {
	            this._zoomX = value;
	            this._zoomY = value;

	            this.dirty = true;
	        }

	    },

	    zoomX: {

	        get: function ()
	        {
	            return this._zoomX;
	        },

	        set: function (value)
	        {
	            this._zoomX = value;
	            this.dirty = true;
	        }

	    },

	    zoomY: {

	        get: function ()
	        {
	            return this._zoomY;
	        },

	        set: function (value)
	        {
	            this._zoomY = value;
	            this.dirty = true;
	        }

	    },

	    rotation: {

	        get: function ()
	        {
	            return this._rotation;
	        },

	        set: function (value)
	        {
	            this._rotation = value;
	            this.dirty = true;
	        }

	    },

	    centerX: {

	        get: function ()
	        {
	            return this.x + (0.5 * this.width);
	        }

	    },

	    centerY: {

	        get: function ()
	        {
	            return this.y + (0.5 * this.height);
	        }

	    },

	    displayWidth: {

	        get: function ()
	        {
	            return this.width / this.zoomX;
	        }

	    },

	    displayHeight: {

	        get: function ()
	        {
	            return this.height / this.zoomY;
	        }

	    }

	});

	BaseCamera_1 = BaseCamera;
	return BaseCamera_1;
}

var CenterOn_1$2;
var hasRequiredCenterOn$2;

function requireCenterOn$2 () {
	if (hasRequiredCenterOn$2) return CenterOn_1$2;
	hasRequiredCenterOn$2 = 1;
	var CenterOn = function (rect, x, y)
	{
	    rect.x = x - (rect.width / 2);
	    rect.y = y - (rect.height / 2);

	    return rect;
	};

	CenterOn_1$2 = CenterOn;
	return CenterOn_1$2;
}

var Fade_1;
var hasRequiredFade;

function requireFade () {
	if (hasRequiredFade) return Fade_1;
	hasRequiredFade = 1;
	var Clamp = requireClamp();
	var Class = requireClass();
	var Events = requireEvents$f();

	var Fade = new Class({

	    initialize:

	    function Fade (camera)
	    {

	        this.camera = camera;

	        this.isRunning = false;

	        this.isComplete = false;

	        this.direction = true;

	        this.duration = 0;

	        this.red = 0;

	        this.green = 0;

	        this.blue = 0;

	        this.alpha = 0;

	        this.progress = 0;

	        this._elapsed = 0;

	        this._onUpdate;

	        this._onUpdateScope;
	    },

	    start: function (direction, duration, red, green, blue, force, callback, context)
	    {
	        if (direction === undefined) { direction = true; }
	        if (duration === undefined) { duration = 1000; }
	        if (red === undefined) { red = 0; }
	        if (green === undefined) { green = 0; }
	        if (blue === undefined) { blue = 0; }
	        if (force === undefined) { force = false; }
	        if (callback === undefined) { callback = null; }
	        if (context === undefined) { context = this.camera.scene; }

	        if (!force && this.isRunning)
	        {
	            return this.camera;
	        }

	        this.isRunning = true;
	        this.isComplete = false;
	        this.duration = duration;
	        this.direction = direction;
	        this.progress = 0;

	        this.red = red;
	        this.green = green;
	        this.blue = blue;
	        this.alpha = (direction) ? Number.MIN_VALUE : 1;

	        this._elapsed = 0;

	        this._onUpdate = callback;
	        this._onUpdateScope = context;

	        var eventName = (direction) ? Events.FADE_OUT_START : Events.FADE_IN_START;

	        this.camera.emit(eventName, this.camera, this, duration, red, green, blue);

	        return this.camera;
	    },

	    update: function (time, delta)
	    {
	        if (!this.isRunning)
	        {
	            return;
	        }

	        this._elapsed += delta;

	        this.progress = Clamp(this._elapsed / this.duration, 0, 1);

	        if (this._onUpdate)
	        {
	            this._onUpdate.call(this._onUpdateScope, this.camera, this.progress);
	        }

	        if (this._elapsed < this.duration)
	        {
	            this.alpha = (this.direction) ? this.progress : 1 - this.progress;
	        }
	        else
	        {
	            this.alpha = (this.direction) ? 1 : 0;
	            this.effectComplete();
	        }
	    },

	    postRenderCanvas: function (ctx)
	    {
	        if (!this.isRunning && !this.isComplete)
	        {
	            return false;
	        }

	        var camera = this.camera;

	        ctx.fillStyle = 'rgba(' + this.red + ',' + this.green + ',' + this.blue + ',' + this.alpha + ')';
	        ctx.fillRect(camera.x, camera.y, camera.width, camera.height);

	        return true;
	    },

	    postRenderWebGL: function (pipeline, getTintFunction)
	    {
	        if (!this.isRunning && !this.isComplete)
	        {
	            return false;
	        }

	        var camera = this.camera;
	        var red = this.red / 255;
	        var green = this.green / 255;
	        var blue = this.blue / 255;

	        pipeline.drawFillRect(
	            camera.x, camera.y, camera.width, camera.height,
	            getTintFunction(blue, green, red, 1),
	            this.alpha
	        );

	        return true;
	    },

	    effectComplete: function ()
	    {
	        this._onUpdate = null;
	        this._onUpdateScope = null;

	        this.isRunning = false;
	        this.isComplete = true;

	        var eventName = (this.direction) ? Events.FADE_OUT_COMPLETE : Events.FADE_IN_COMPLETE;

	        this.camera.emit(eventName, this.camera, this);
	    },

	    reset: function ()
	    {
	        this.isRunning = false;
	        this.isComplete = false;

	        this._onUpdate = null;
	        this._onUpdateScope = null;
	    },

	    destroy: function ()
	    {
	        this.reset();

	        this.camera = null;
	    }

	});

	Fade_1 = Fade;
	return Fade_1;
}

var Flash_1;
var hasRequiredFlash;

function requireFlash () {
	if (hasRequiredFlash) return Flash_1;
	hasRequiredFlash = 1;
	var Clamp = requireClamp();
	var Class = requireClass();
	var Events = requireEvents$f();

	var Flash = new Class({

	    initialize:

	    function Flash (camera)
	    {

	        this.camera = camera;

	        this.isRunning = false;

	        this.duration = 0;

	        this.red = 0;

	        this.green = 0;

	        this.blue = 0;

	        this.alpha = 1;

	        this.progress = 0;

	        this._elapsed = 0;

	        this._alpha;

	        this._onUpdate;

	        this._onUpdateScope;
	    },

	    start: function (duration, red, green, blue, force, callback, context)
	    {
	        if (duration === undefined) { duration = 250; }
	        if (red === undefined) { red = 255; }
	        if (green === undefined) { green = 255; }
	        if (blue === undefined) { blue = 255; }
	        if (force === undefined) { force = false; }
	        if (callback === undefined) { callback = null; }
	        if (context === undefined) { context = this.camera.scene; }

	        if (!force && this.isRunning)
	        {
	            return this.camera;
	        }

	        this.isRunning = true;
	        this.duration = duration;
	        this.progress = 0;

	        this.red = red;
	        this.green = green;
	        this.blue = blue;

	        this._alpha = this.alpha;
	        this._elapsed = 0;

	        this._onUpdate = callback;
	        this._onUpdateScope = context;

	        this.camera.emit(Events.FLASH_START, this.camera, this, duration, red, green, blue);

	        return this.camera;
	    },

	    update: function (time, delta)
	    {
	        if (!this.isRunning)
	        {
	            return;
	        }

	        this._elapsed += delta;

	        this.progress = Clamp(this._elapsed / this.duration, 0, 1);

	        if (this._onUpdate)
	        {
	            this._onUpdate.call(this._onUpdateScope, this.camera, this.progress);
	        }

	        if (this._elapsed < this.duration)
	        {
	            this.alpha = this._alpha * (1 - this.progress);
	        }
	        else
	        {
	            this.effectComplete();
	        }
	    },

	    postRenderCanvas: function (ctx)
	    {
	        if (!this.isRunning)
	        {
	            return false;
	        }

	        var camera = this.camera;

	        ctx.fillStyle = 'rgba(' + this.red + ',' + this.green + ',' + this.blue + ',' + this.alpha + ')';
	        ctx.fillRect(camera.x, camera.y, camera.width, camera.height);

	        return true;
	    },

	    postRenderWebGL: function (pipeline, getTintFunction)
	    {
	        if (!this.isRunning)
	        {
	            return false;
	        }

	        var camera = this.camera;
	        var red = this.red / 255;
	        var green = this.green / 255;
	        var blue = this.blue / 255;

	        pipeline.drawFillRect(
	            camera.x, camera.y, camera.width, camera.height,
	            getTintFunction(blue, green, red, 1),
	            this.alpha
	        );

	        return true;
	    },

	    effectComplete: function ()
	    {
	        this.alpha = this._alpha;
	        this._onUpdate = null;
	        this._onUpdateScope = null;

	        this.isRunning = false;

	        this.camera.emit(Events.FLASH_COMPLETE, this.camera, this);
	    },

	    reset: function ()
	    {
	        this.isRunning = false;

	        this._onUpdate = null;
	        this._onUpdateScope = null;
	    },

	    destroy: function ()
	    {
	        this.reset();

	        this.camera = null;
	    }

	});

	Flash_1 = Flash;
	return Flash_1;
}

var Pan_1;
var hasRequiredPan;

function requirePan () {
	if (hasRequiredPan) return Pan_1;
	hasRequiredPan = 1;
	var Clamp = requireClamp();
	var Class = requireClass();
	var EaseMap = requireEaseMap();
	var Events = requireEvents$f();
	var Vector2 = requireVector2();

	var Pan = new Class({

	    initialize:

	    function Pan (camera)
	    {

	        this.camera = camera;

	        this.isRunning = false;

	        this.duration = 0;

	        this.source = new Vector2();

	        this.current = new Vector2();

	        this.destination = new Vector2();

	        this.ease;

	        this.progress = 0;

	        this._elapsed = 0;

	        this._onUpdate;

	        this._onUpdateScope;
	    },

	    start: function (x, y, duration, ease, force, callback, context)
	    {
	        if (duration === undefined) { duration = 1000; }
	        if (ease === undefined) { ease = EaseMap.Linear; }
	        if (force === undefined) { force = false; }
	        if (callback === undefined) { callback = null; }
	        if (context === undefined) { context = this.camera.scene; }

	        var cam = this.camera;

	        if (!force && this.isRunning)
	        {
	            return cam;
	        }

	        this.isRunning = true;
	        this.duration = duration;
	        this.progress = 0;

	        this.source.set(cam.scrollX, cam.scrollY);

	        this.destination.set(x, y);

	        cam.getScroll(x, y, this.current);

	        if (typeof ease === 'string' && EaseMap.hasOwnProperty(ease))
	        {
	            this.ease = EaseMap[ease];
	        }
	        else if (typeof ease === 'function')
	        {
	            this.ease = ease;
	        }

	        this._elapsed = 0;

	        this._onUpdate = callback;
	        this._onUpdateScope = context;

	        this.camera.emit(Events.PAN_START, this.camera, this, duration, x, y);

	        return cam;
	    },

	    update: function (time, delta)
	    {
	        if (!this.isRunning)
	        {
	            return;
	        }

	        this._elapsed += delta;

	        var progress = Clamp(this._elapsed / this.duration, 0, 1);

	        this.progress = progress;

	        var cam = this.camera;

	        if (this._elapsed < this.duration)
	        {
	            var v = this.ease(progress);

	            cam.getScroll(this.destination.x, this.destination.y, this.current);

	            var x = this.source.x + ((this.current.x - this.source.x) * v);
	            var y = this.source.y + ((this.current.y - this.source.y) * v);

	            cam.setScroll(x, y);

	            if (this._onUpdate)
	            {
	                this._onUpdate.call(this._onUpdateScope, cam, progress, x, y);
	            }
	        }
	        else
	        {
	            cam.centerOn(this.destination.x, this.destination.y);

	            if (this._onUpdate)
	            {
	                this._onUpdate.call(this._onUpdateScope, cam, progress, cam.scrollX, cam.scrollY);
	            }

	            this.effectComplete();
	        }
	    },

	    effectComplete: function ()
	    {
	        this._onUpdate = null;
	        this._onUpdateScope = null;

	        this.isRunning = false;

	        this.camera.emit(Events.PAN_COMPLETE, this.camera, this);
	    },

	    reset: function ()
	    {
	        this.isRunning = false;

	        this._onUpdate = null;
	        this._onUpdateScope = null;
	    },

	    destroy: function ()
	    {
	        this.reset();

	        this.camera = null;
	        this.source = null;
	        this.destination = null;
	    }

	});

	Pan_1 = Pan;
	return Pan_1;
}

var Shake_1;
var hasRequiredShake;

function requireShake () {
	if (hasRequiredShake) return Shake_1;
	hasRequiredShake = 1;
	var Clamp = requireClamp();
	var Class = requireClass();
	var Events = requireEvents$f();
	var Vector2 = requireVector2();

	var Shake = new Class({

	    initialize:

	    function Shake (camera)
	    {

	        this.camera = camera;

	        this.isRunning = false;

	        this.duration = 0;

	        this.intensity = new Vector2();

	        this.progress = 0;

	        this._elapsed = 0;

	        this._offsetX = 0;

	        this._offsetY = 0;

	        this._onUpdate;

	        this._onUpdateScope;
	    },

	    start: function (duration, intensity, force, callback, context)
	    {
	        if (duration === undefined) { duration = 100; }
	        if (intensity === undefined) { intensity = 0.05; }
	        if (force === undefined) { force = false; }
	        if (callback === undefined) { callback = null; }
	        if (context === undefined) { context = this.camera.scene; }

	        if (!force && this.isRunning)
	        {
	            return this.camera;
	        }

	        this.isRunning = true;
	        this.duration = duration;
	        this.progress = 0;

	        if (typeof intensity === 'number')
	        {
	            this.intensity.set(intensity);
	        }
	        else
	        {
	            this.intensity.set(intensity.x, intensity.y);
	        }

	        this._elapsed = 0;
	        this._offsetX = 0;
	        this._offsetY = 0;

	        this._onUpdate = callback;
	        this._onUpdateScope = context;

	        this.camera.emit(Events.SHAKE_START, this.camera, this, duration, intensity);

	        return this.camera;
	    },

	    preRender: function ()
	    {
	        if (this.isRunning)
	        {
	            this.camera.matrix.translate(this._offsetX, this._offsetY);
	        }
	    },

	    update: function (time, delta)
	    {
	        if (!this.isRunning)
	        {
	            return;
	        }

	        this._elapsed += delta;

	        this.progress = Clamp(this._elapsed / this.duration, 0, 1);

	        if (this._onUpdate)
	        {
	            this._onUpdate.call(this._onUpdateScope, this.camera, this.progress);
	        }

	        if (this._elapsed < this.duration)
	        {
	            var intensity = this.intensity;
	            var width = this.camera.width;
	            var height = this.camera.height;
	            var zoom = this.camera.zoom;

	            this._offsetX = (Math.random() * intensity.x * width * 2 - intensity.x * width) * zoom;
	            this._offsetY = (Math.random() * intensity.y * height * 2 - intensity.y * height) * zoom;

	            if (this.camera.roundPixels)
	            {
	                this._offsetX = Math.round(this._offsetX);
	                this._offsetY = Math.round(this._offsetY);
	            }
	        }
	        else
	        {
	            this.effectComplete();
	        }
	    },

	    effectComplete: function ()
	    {
	        this._offsetX = 0;
	        this._offsetY = 0;

	        this._onUpdate = null;
	        this._onUpdateScope = null;

	        this.isRunning = false;

	        this.camera.emit(Events.SHAKE_COMPLETE, this.camera, this);
	    },

	    reset: function ()
	    {
	        this.isRunning = false;

	        this._offsetX = 0;
	        this._offsetY = 0;

	        this._onUpdate = null;
	        this._onUpdateScope = null;
	    },

	    destroy: function ()
	    {
	        this.reset();

	        this.camera = null;
	        this.intensity = null;
	    }

	});

	Shake_1 = Shake;
	return Shake_1;
}

var RotateTo_1$2;
var hasRequiredRotateTo$2;

function requireRotateTo$2 () {
	if (hasRequiredRotateTo$2) return RotateTo_1$2;
	hasRequiredRotateTo$2 = 1;
	var Clamp = requireClamp();
	var Class = requireClass();
	var Events = requireEvents$f();
	var EaseMap = requireEaseMap();

	var RotateTo = new Class({

	    initialize:

	    function RotateTo (camera)
	    {

	        this.camera = camera;

	        this.isRunning = false;

	        this.duration = 0;

	        this.source = 0;

	        this.current = 0;

	        this.destination = 0;

	        this.ease;

	        this.progress = 0;

	        this._elapsed = 0;

	        this._onUpdate;

	        this._onUpdateScope;

	        this.clockwise = true;

	        this.shortestPath = false;
	    },

	    start: function (radians, shortestPath, duration, ease, force, callback, context)
	    {
	        if (duration === undefined) { duration = 1000; }
	        if (ease === undefined) { ease = EaseMap.Linear; }
	        if (force === undefined) { force = false; }
	        if (callback === undefined) { callback = null; }
	        if (context === undefined) { context = this.camera.scene; }
	        if (shortestPath === undefined) { shortestPath = false; }

	        this.shortestPath = shortestPath;

	        var tmpDestination = radians;

	        if (radians < 0)
	        {
	            tmpDestination = -1 * radians;
	            this.clockwise = false;
	        }
	        else
	        {
	            this.clockwise = true;
	        }

	        var maxRad = (360 * Math.PI) / 180;

	        tmpDestination = tmpDestination - (Math.floor(tmpDestination / maxRad) * maxRad);

	        var cam = this.camera;

	        if (!force && this.isRunning)
	        {
	            return cam;
	        }

	        this.isRunning = true;
	        this.duration = duration;
	        this.progress = 0;

	        this.source = cam.rotation;

	        this.destination = tmpDestination;

	        if (typeof ease === 'string' && EaseMap.hasOwnProperty(ease))
	        {
	            this.ease = EaseMap[ease];
	        }
	        else if (typeof ease === 'function')
	        {
	            this.ease = ease;
	        }

	        this._elapsed = 0;

	        this._onUpdate = callback;
	        this._onUpdateScope = context;

	        if (this.shortestPath)
	        {

	            var cwDist = 0;
	            var acwDist = 0;

	            if (this.destination > this.source)
	            {
	                cwDist = Math.abs(this.destination - this.source);
	            }
	            else
	            {
	                cwDist = (Math.abs(this.destination + maxRad) - this.source);
	            }

	            if (this.source > this.destination)
	            {
	                acwDist = Math.abs(this.source - this.destination);
	            }
	            else
	            {
	                acwDist = (Math.abs(this.source + maxRad) - this.destination);
	            }

	            if (cwDist < acwDist)
	            {
	                this.clockwise = true;
	            }
	            else if (cwDist > acwDist)
	            {
	                this.clockwise = false;
	            }
	        }

	        this.camera.emit(Events.ROTATE_START, this.camera, this, duration, tmpDestination);

	        return cam;
	    },

	    update: function (time, delta)
	    {
	        if (!this.isRunning)
	        {
	            return;
	        }

	        this._elapsed += delta;

	        var progress = Clamp(this._elapsed / this.duration, 0, 1);

	        this.progress = progress;

	        var cam = this.camera;

	        if (this._elapsed < this.duration)
	        {
	            var v = this.ease(progress);

	            this.current = cam.rotation;
	            var distance = 0;
	            var maxRad = (360 * Math.PI) / 180;
	            var target = this.destination;
	            var current = this.current;

	            if (this.clockwise === false)
	            {
	                target = this.current;
	                current = this.destination;
	            }

	            if (target >= current)
	            {
	                distance = Math.abs(target - current);
	            }
	            else
	            {
	                distance = (Math.abs(target + maxRad) - current);
	            }

	            var r = 0;

	            if (this.clockwise)
	            {
	                r = (cam.rotation + (distance * v));
	            }
	            else
	            {
	                r = (cam.rotation - (distance * v));
	            }

	            cam.rotation = r;

	            if (this._onUpdate)
	            {
	                this._onUpdate.call(this._onUpdateScope, cam, progress, r);
	            }
	        }
	        else
	        {
	            cam.rotation = this.destination;

	            if (this._onUpdate)
	            {
	                this._onUpdate.call(this._onUpdateScope, cam, progress, this.destination);
	            }

	            this.effectComplete();
	        }
	    },

	    effectComplete: function ()
	    {
	        this._onUpdate = null;
	        this._onUpdateScope = null;

	        this.isRunning = false;

	        this.camera.emit(Events.ROTATE_COMPLETE, this.camera, this);
	    },

	    reset: function ()
	    {
	        this.isRunning = false;

	        this._onUpdate = null;
	        this._onUpdateScope = null;
	    },

	    destroy: function ()
	    {
	        this.reset();

	        this.camera = null;
	        this.source = null;
	        this.destination = null;
	    }

	});

	RotateTo_1$2 = RotateTo;
	return RotateTo_1$2;
}

var Zoom_1;
var hasRequiredZoom;

function requireZoom () {
	if (hasRequiredZoom) return Zoom_1;
	hasRequiredZoom = 1;
	var Clamp = requireClamp();
	var Class = requireClass();
	var EaseMap = requireEaseMap();
	var Events = requireEvents$f();

	var Zoom = new Class({

	    initialize:

	    function Zoom (camera)
	    {

	        this.camera = camera;

	        this.isRunning = false;

	        this.duration = 0;

	        this.source = 1;

	        this.destination = 1;

	        this.ease;

	        this.progress = 0;

	        this._elapsed = 0;

	        this._onUpdate;

	        this._onUpdateScope;
	    },

	    start: function (zoom, duration, ease, force, callback, context)
	    {
	        if (duration === undefined) { duration = 1000; }
	        if (ease === undefined) { ease = EaseMap.Linear; }
	        if (force === undefined) { force = false; }
	        if (callback === undefined) { callback = null; }
	        if (context === undefined) { context = this.camera.scene; }

	        var cam = this.camera;

	        if (!force && this.isRunning)
	        {
	            return cam;
	        }

	        this.isRunning = true;
	        this.duration = duration;
	        this.progress = 0;

	        this.source = cam.zoom;

	        this.destination = zoom;

	        if (typeof ease === 'string' && EaseMap.hasOwnProperty(ease))
	        {
	            this.ease = EaseMap[ease];
	        }
	        else if (typeof ease === 'function')
	        {
	            this.ease = ease;
	        }

	        this._elapsed = 0;

	        this._onUpdate = callback;
	        this._onUpdateScope = context;

	        this.camera.emit(Events.ZOOM_START, this.camera, this, duration, zoom);

	        return cam;
	    },

	    update: function (time, delta)
	    {
	        if (!this.isRunning)
	        {
	            return;
	        }

	        this._elapsed += delta;

	        this.progress = Clamp(this._elapsed / this.duration, 0, 1);

	        if (this._elapsed < this.duration)
	        {
	            this.camera.zoom = this.source + ((this.destination - this.source) * this.ease(this.progress));

	            if (this._onUpdate)
	            {
	                this._onUpdate.call(this._onUpdateScope, this.camera, this.progress, this.camera.zoom);
	            }
	        }
	        else
	        {
	            this.camera.zoom = this.destination;

	            if (this._onUpdate)
	            {
	                this._onUpdate.call(this._onUpdateScope, this.camera, this.progress, this.destination);
	            }

	            this.effectComplete();
	        }
	    },

	    effectComplete: function ()
	    {
	        this._onUpdate = null;
	        this._onUpdateScope = null;

	        this.isRunning = false;

	        this.camera.emit(Events.ZOOM_COMPLETE, this.camera, this);
	    },

	    reset: function ()
	    {
	        this.isRunning = false;

	        this._onUpdate = null;
	        this._onUpdateScope = null;
	    },

	    destroy: function ()
	    {
	        this.reset();

	        this.camera = null;
	    }

	});

	Zoom_1 = Zoom;
	return Zoom_1;
}

var effects;
var hasRequiredEffects;

function requireEffects () {
	if (hasRequiredEffects) return effects;
	hasRequiredEffects = 1;
	effects = {

	    Fade: requireFade(),
	    Flash: requireFlash(),
	    Pan: requirePan(),
	    Shake: requireShake(),
	    RotateTo: requireRotateTo$2(),
	    Zoom: requireZoom()

	};
	return effects;
}

var Linear_1;
var hasRequiredLinear;

function requireLinear () {
	if (hasRequiredLinear) return Linear_1;
	hasRequiredLinear = 1;
	var Linear = function (p0, p1, t)
	{
	    return (p1 - p0) * t + p0;
	};

	Linear_1 = Linear;
	return Linear_1;
}

var Camera_1;
var hasRequiredCamera;

function requireCamera () {
	if (hasRequiredCamera) return Camera_1;
	hasRequiredCamera = 1;
	var BaseCamera = requireBaseCamera();
	var CenterOn = requireCenterOn$2();
	var Clamp = requireClamp();
	var Class = requireClass();
	var Components = requireComponents$2();
	var Effects = requireEffects();
	var Events = requireEvents$f();
	var Linear = requireLinear();
	var Rectangle = requireRectangle$2();
	var Vector2 = requireVector2();

	var Camera = new Class({

	    Extends: BaseCamera,

	    Mixins: [
	        Components.PostPipeline
	    ],

	    initialize:

	    function Camera (x, y, width, height)
	    {
	        BaseCamera.call(this, x, y, width, height);

	        this.initPostPipeline();

	        this.inputEnabled = true;

	        this.fadeEffect = new Effects.Fade(this);

	        this.flashEffect = new Effects.Flash(this);

	        this.shakeEffect = new Effects.Shake(this);

	        this.panEffect = new Effects.Pan(this);

	        this.rotateToEffect = new Effects.RotateTo(this);

	        this.zoomEffect = new Effects.Zoom(this);

	        this.lerp = new Vector2(1, 1);

	        this.followOffset = new Vector2();

	        this.deadzone = null;

	        this._follow = null;
	    },

	    setDeadzone: function (width, height)
	    {
	        if (width === undefined)
	        {
	            this.deadzone = null;
	        }
	        else
	        {
	            if (this.deadzone)
	            {
	                this.deadzone.width = width;
	                this.deadzone.height = height;
	            }
	            else
	            {
	                this.deadzone = new Rectangle(0, 0, width, height);
	            }

	            if (this._follow)
	            {
	                var originX = this.width / 2;
	                var originY = this.height / 2;

	                var fx = this._follow.x - this.followOffset.x;
	                var fy = this._follow.y - this.followOffset.y;

	                this.midPoint.set(fx, fy);

	                this.scrollX = fx - originX;
	                this.scrollY = fy - originY;
	            }

	            CenterOn(this.deadzone, this.midPoint.x, this.midPoint.y);
	        }

	        return this;
	    },

	    fadeIn: function (duration, red, green, blue, callback, context)
	    {
	        return this.fadeEffect.start(false, duration, red, green, blue, true, callback, context);
	    },

	    fadeOut: function (duration, red, green, blue, callback, context)
	    {
	        return this.fadeEffect.start(true, duration, red, green, blue, true, callback, context);
	    },

	    fadeFrom: function (duration, red, green, blue, force, callback, context)
	    {
	        return this.fadeEffect.start(false, duration, red, green, blue, force, callback, context);
	    },

	    fade: function (duration, red, green, blue, force, callback, context)
	    {
	        return this.fadeEffect.start(true, duration, red, green, blue, force, callback, context);
	    },

	    flash: function (duration, red, green, blue, force, callback, context)
	    {
	        return this.flashEffect.start(duration, red, green, blue, force, callback, context);
	    },

	    shake: function (duration, intensity, force, callback, context)
	    {
	        return this.shakeEffect.start(duration, intensity, force, callback, context);
	    },

	    pan: function (x, y, duration, ease, force, callback, context)
	    {
	        return this.panEffect.start(x, y, duration, ease, force, callback, context);
	    },

	    rotateTo: function (radians, shortestPath, duration, ease, force, callback, context)
	    {
	        return this.rotateToEffect.start(radians, shortestPath, duration, ease, force, callback, context);
	    },

	    zoomTo: function (zoom, duration, ease, force, callback, context)
	    {
	        return this.zoomEffect.start(zoom, duration, ease, force, callback, context);
	    },

	    preRender: function ()
	    {
	        this.renderList.length = 0;

	        var width = this.width;
	        var height = this.height;

	        var halfWidth = width * 0.5;
	        var halfHeight = height * 0.5;

	        var zoomX = this.zoomX;
	        var zoomY = this.zoomY;
	        var matrix = this.matrix;

	        this.renderRoundPixels = (this.roundPixels && Number.isInteger(zoomX) && Number.isInteger(zoomY));

	        var originX = width * this.originX;
	        var originY = height * this.originY;

	        var follow = this._follow;
	        var deadzone = this.deadzone;

	        var sx = this.scrollX;
	        var sy = this.scrollY;

	        if (deadzone)
	        {
	            CenterOn(deadzone, this.midPoint.x, this.midPoint.y);
	        }

	        var emitFollowEvent = false;

	        if (follow && !this.panEffect.isRunning)
	        {
	            var lerp = this.lerp;

	            var fx = follow.x - this.followOffset.x;
	            var fy = follow.y - this.followOffset.y;

	            if (deadzone)
	            {
	                if (fx < deadzone.x)
	                {
	                    sx = Linear(sx, sx - (deadzone.x - fx), lerp.x);
	                }
	                else if (fx > deadzone.right)
	                {
	                    sx = Linear(sx, sx + (fx - deadzone.right), lerp.x);
	                }

	                if (fy < deadzone.y)
	                {
	                    sy = Linear(sy, sy - (deadzone.y - fy), lerp.y);
	                }
	                else if (fy > deadzone.bottom)
	                {
	                    sy = Linear(sy, sy + (fy - deadzone.bottom), lerp.y);
	                }
	            }
	            else
	            {
	                sx = Linear(sx, fx - originX, lerp.x);
	                sy = Linear(sy, fy - originY, lerp.y);
	            }

	            emitFollowEvent = true;
	        }

	        if (this.roundPixels)
	        {
	            sx = Math.floor(sx);
	            sy = Math.floor(sy);
	        }

	        if (this.useBounds)
	        {
	            sx = this.clampX(sx);
	            sy = this.clampY(sy);
	        }

	        this.scrollX = sx;
	        this.scrollY = sy;

	        var midX = sx + halfWidth;
	        var midY = sy + halfHeight;

	        this.midPoint.set(midX, midY);

	        var displayWidth = Math.floor((width / zoomX) + 0.5);
	        var displayHeight = Math.floor((height / zoomY) + 0.5);

	        var vwx = Math.floor((midX - (displayWidth / 2)) + 0.5);
	        var vwy = Math.floor((midY - (displayHeight / 2)) + 0.5);

	        this.worldView.setTo(vwx, vwy, displayWidth, displayHeight);

	        matrix.applyITRS(
	            Math.floor(this.x + originX + 0.5),
	            Math.floor(this.y + originY + 0.5),
	            this.rotation,
	            zoomX, zoomY
	        );

	        matrix.translate(-originX, -originY);

	        this.shakeEffect.preRender();

	        if (emitFollowEvent)
	        {
	            this.emit(Events.FOLLOW_UPDATE, this, follow);
	        }
	    },

	    setLerp: function (x, y)
	    {
	        if (x === undefined) { x = 1; }
	        if (y === undefined) { y = x; }

	        this.lerp.set(x, y);

	        return this;
	    },

	    setFollowOffset: function (x, y)
	    {
	        if (x === undefined) { x = 0; }
	        if (y === undefined) { y = 0; }

	        this.followOffset.set(x, y);

	        return this;
	    },

	    startFollow: function (target, roundPixels, lerpX, lerpY, offsetX, offsetY)
	    {
	        if (roundPixels === undefined) { roundPixels = false; }
	        if (lerpX === undefined) { lerpX = 1; }
	        if (lerpY === undefined) { lerpY = lerpX; }
	        if (offsetX === undefined) { offsetX = 0; }
	        if (offsetY === undefined) { offsetY = offsetX; }

	        this._follow = target;

	        this.roundPixels = roundPixels;

	        lerpX = Clamp(lerpX, 0, 1);
	        lerpY = Clamp(lerpY, 0, 1);

	        this.lerp.set(lerpX, lerpY);

	        this.followOffset.set(offsetX, offsetY);

	        var originX = this.width / 2;
	        var originY = this.height / 2;

	        var fx = target.x - offsetX;
	        var fy = target.y - offsetY;

	        this.midPoint.set(fx, fy);

	        this.scrollX = fx - originX;
	        this.scrollY = fy - originY;

	        if (this.useBounds)
	        {
	            this.scrollX = this.clampX(this.scrollX);
	            this.scrollY = this.clampY(this.scrollY);
	        }

	        return this;
	    },

	    stopFollow: function ()
	    {
	        this._follow = null;

	        return this;
	    },

	    resetFX: function ()
	    {
	        this.rotateToEffect.reset();
	        this.panEffect.reset();
	        this.shakeEffect.reset();
	        this.flashEffect.reset();
	        this.fadeEffect.reset();

	        return this;
	    },

	    update: function (time, delta)
	    {
	        if (this.visible)
	        {
	            this.rotateToEffect.update(time, delta);
	            this.panEffect.update(time, delta);
	            this.zoomEffect.update(time, delta);
	            this.shakeEffect.update(time, delta);
	            this.flashEffect.update(time, delta);
	            this.fadeEffect.update(time, delta);
	        }
	    },

	    destroy: function ()
	    {
	        this.resetFX();

	        BaseCamera.prototype.destroy.call(this);

	        this._follow = null;

	        this.deadzone = null;
	    }

	});

	Camera_1 = Camera;
	return Camera_1;
}

var ENTER_FULLSCREEN_EVENT;
var hasRequiredENTER_FULLSCREEN_EVENT;

function requireENTER_FULLSCREEN_EVENT () {
	if (hasRequiredENTER_FULLSCREEN_EVENT) return ENTER_FULLSCREEN_EVENT;
	hasRequiredENTER_FULLSCREEN_EVENT = 1;
	ENTER_FULLSCREEN_EVENT = 'enterfullscreen';
	return ENTER_FULLSCREEN_EVENT;
}

var FULLSCREEN_FAILED_EVENT;
var hasRequiredFULLSCREEN_FAILED_EVENT;

function requireFULLSCREEN_FAILED_EVENT () {
	if (hasRequiredFULLSCREEN_FAILED_EVENT) return FULLSCREEN_FAILED_EVENT;
	hasRequiredFULLSCREEN_FAILED_EVENT = 1;
	FULLSCREEN_FAILED_EVENT = 'fullscreenfailed';
	return FULLSCREEN_FAILED_EVENT;
}

var FULLSCREEN_UNSUPPORTED_EVENT;
var hasRequiredFULLSCREEN_UNSUPPORTED_EVENT;

function requireFULLSCREEN_UNSUPPORTED_EVENT () {
	if (hasRequiredFULLSCREEN_UNSUPPORTED_EVENT) return FULLSCREEN_UNSUPPORTED_EVENT;
	hasRequiredFULLSCREEN_UNSUPPORTED_EVENT = 1;
	FULLSCREEN_UNSUPPORTED_EVENT = 'fullscreenunsupported';
	return FULLSCREEN_UNSUPPORTED_EVENT;
}

var LEAVE_FULLSCREEN_EVENT;
var hasRequiredLEAVE_FULLSCREEN_EVENT;

function requireLEAVE_FULLSCREEN_EVENT () {
	if (hasRequiredLEAVE_FULLSCREEN_EVENT) return LEAVE_FULLSCREEN_EVENT;
	hasRequiredLEAVE_FULLSCREEN_EVENT = 1;
	LEAVE_FULLSCREEN_EVENT = 'leavefullscreen';
	return LEAVE_FULLSCREEN_EVENT;
}

var ORIENTATION_CHANGE_EVENT;
var hasRequiredORIENTATION_CHANGE_EVENT;

function requireORIENTATION_CHANGE_EVENT () {
	if (hasRequiredORIENTATION_CHANGE_EVENT) return ORIENTATION_CHANGE_EVENT;
	hasRequiredORIENTATION_CHANGE_EVENT = 1;
	ORIENTATION_CHANGE_EVENT = 'orientationchange';
	return ORIENTATION_CHANGE_EVENT;
}

var RESIZE_EVENT$2;
var hasRequiredRESIZE_EVENT$2;

function requireRESIZE_EVENT$2 () {
	if (hasRequiredRESIZE_EVENT$2) return RESIZE_EVENT$2;
	hasRequiredRESIZE_EVENT$2 = 1;
	RESIZE_EVENT$2 = 'resize';
	return RESIZE_EVENT$2;
}

var events$e;
var hasRequiredEvents$e;

function requireEvents$e () {
	if (hasRequiredEvents$e) return events$e;
	hasRequiredEvents$e = 1;
	events$e = {

	    ENTER_FULLSCREEN: requireENTER_FULLSCREEN_EVENT(),
	    FULLSCREEN_FAILED: requireFULLSCREEN_FAILED_EVENT(),
	    FULLSCREEN_UNSUPPORTED: requireFULLSCREEN_UNSUPPORTED_EVENT(),
	    LEAVE_FULLSCREEN: requireLEAVE_FULLSCREEN_EVENT(),
	    ORIENTATION_CHANGE: requireORIENTATION_CHANGE_EVENT(),
	    RESIZE: requireRESIZE_EVENT$2()

	};
	return events$e;
}

var CameraManager_1;
var hasRequiredCameraManager;

function requireCameraManager () {
	if (hasRequiredCameraManager) return CameraManager_1;
	hasRequiredCameraManager = 1;
	var Camera = requireCamera();
	var Class = requireClass();
	var GetFastValue = requireGetFastValue();
	var PluginCache = requirePluginCache();
	var RectangleContains = requireContains$3();
	var ScaleEvents = requireEvents$e();
	var SceneEvents = requireEvents$l();

	var CameraManager = new Class({

	    initialize:

	    function CameraManager (scene)
	    {

	        this.scene = scene;

	        this.systems = scene.sys;

	        this.roundPixels = scene.sys.game.config.roundPixels;

	        this.cameras = [];

	        this.main;

	        this.default;

	        scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
	        scene.sys.events.on(SceneEvents.START, this.start, this);
	    },

	    boot: function ()
	    {
	        var sys = this.systems;

	        if (sys.settings.cameras)
	        {

	            this.fromJSON(sys.settings.cameras);
	        }
	        else
	        {

	            this.add();
	        }

	        this.main = this.cameras[0];

	        this.default = new Camera(0, 0, sys.scale.width, sys.scale.height).setScene(this.scene);

	        sys.game.scale.on(ScaleEvents.RESIZE, this.onResize, this);

	        this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);
	    },

	    start: function ()
	    {
	        if (!this.main)
	        {
	            var sys = this.systems;

	            if (sys.settings.cameras)
	            {

	                this.fromJSON(sys.settings.cameras);
	            }
	            else
	            {

	                this.add();
	            }

	            this.main = this.cameras[0];
	        }

	        var eventEmitter = this.systems.events;

	        eventEmitter.on(SceneEvents.UPDATE, this.update, this);
	        eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);
	    },

	    add: function (x, y, width, height, makeMain, name)
	    {
	        if (x === undefined) { x = 0; }
	        if (y === undefined) { y = 0; }
	        if (width === undefined) { width = this.scene.sys.scale.width; }
	        if (height === undefined) { height = this.scene.sys.scale.height; }
	        if (makeMain === undefined) { makeMain = false; }
	        if (name === undefined) { name = ''; }

	        var camera = new Camera(x, y, width, height);

	        camera.setName(name);
	        camera.setScene(this.scene);
	        camera.setRoundPixels(this.roundPixels);

	        camera.id = this.getNextID();

	        this.cameras.push(camera);

	        if (makeMain)
	        {
	            this.main = camera;
	        }

	        return camera;
	    },

	    addExisting: function (camera, makeMain)
	    {
	        if (makeMain === undefined) { makeMain = false; }

	        var index = this.cameras.indexOf(camera);

	        if (index === -1)
	        {
	            camera.id = this.getNextID();

	            camera.setRoundPixels(this.roundPixels);

	            this.cameras.push(camera);

	            if (makeMain)
	            {
	                this.main = camera;
	            }

	            return camera;
	        }

	        return null;
	    },

	    getNextID: function ()
	    {
	        var cameras = this.cameras;

	        var testID = 1;

	        for (var t = 0; t < 32; t++)
	        {
	            var found = false;

	            for (var i = 0; i < cameras.length; i++)
	            {
	                var camera = cameras[i];

	                if (camera && camera.id === testID)
	                {
	                    found = true;
	                    continue;
	                }
	            }

	            if (found)
	            {
	                testID = testID << 1;
	            }
	            else
	            {
	                return testID;
	            }
	        }

	        return 0;
	    },

	    getTotal: function (isVisible)
	    {
	        if (isVisible === undefined) { isVisible = false; }

	        var total = 0;

	        var cameras = this.cameras;

	        for (var i = 0; i < cameras.length; i++)
	        {
	            var camera = cameras[i];

	            if (!isVisible || (isVisible && camera.visible))
	            {
	                total++;
	            }
	        }

	        return total;
	    },

	    fromJSON: function (config)
	    {
	        if (!Array.isArray(config))
	        {
	            config = [ config ];
	        }

	        var gameWidth = this.scene.sys.scale.width;
	        var gameHeight = this.scene.sys.scale.height;

	        for (var i = 0; i < config.length; i++)
	        {
	            var cameraConfig = config[i];

	            var x = GetFastValue(cameraConfig, 'x', 0);
	            var y = GetFastValue(cameraConfig, 'y', 0);
	            var width = GetFastValue(cameraConfig, 'width', gameWidth);
	            var height = GetFastValue(cameraConfig, 'height', gameHeight);

	            var camera = this.add(x, y, width, height);

	            camera.name = GetFastValue(cameraConfig, 'name', '');
	            camera.zoom = GetFastValue(cameraConfig, 'zoom', 1);
	            camera.rotation = GetFastValue(cameraConfig, 'rotation', 0);
	            camera.scrollX = GetFastValue(cameraConfig, 'scrollX', 0);
	            camera.scrollY = GetFastValue(cameraConfig, 'scrollY', 0);
	            camera.roundPixels = GetFastValue(cameraConfig, 'roundPixels', false);
	            camera.visible = GetFastValue(cameraConfig, 'visible', true);

	            var backgroundColor = GetFastValue(cameraConfig, 'backgroundColor', false);

	            if (backgroundColor)
	            {
	                camera.setBackgroundColor(backgroundColor);
	            }

	            var boundsConfig = GetFastValue(cameraConfig, 'bounds', null);

	            if (boundsConfig)
	            {
	                var bx = GetFastValue(boundsConfig, 'x', 0);
	                var by = GetFastValue(boundsConfig, 'y', 0);
	                var bwidth = GetFastValue(boundsConfig, 'width', gameWidth);
	                var bheight = GetFastValue(boundsConfig, 'height', gameHeight);

	                camera.setBounds(bx, by, bwidth, bheight);
	            }
	        }

	        return this;
	    },

	    getCamera: function (name)
	    {
	        var cameras = this.cameras;

	        for (var i = 0; i < cameras.length; i++)
	        {
	            if (cameras[i].name === name)
	            {
	                return cameras[i];
	            }
	        }

	        return null;
	    },

	    getCamerasBelowPointer: function (pointer)
	    {
	        var cameras = this.cameras;

	        var x = pointer.x;
	        var y = pointer.y;

	        var output = [];

	        for (var i = 0; i < cameras.length; i++)
	        {
	            var camera = cameras[i];

	            if (camera.visible && camera.inputEnabled && RectangleContains(camera, x, y))
	            {

	                output.unshift(camera);
	            }
	        }

	        return output;
	    },

	    remove: function (camera, runDestroy)
	    {
	        if (runDestroy === undefined) { runDestroy = true; }

	        if (!Array.isArray(camera))
	        {
	            camera = [ camera ];
	        }

	        var total = 0;
	        var cameras = this.cameras;

	        for (var i = 0; i < camera.length; i++)
	        {
	            var index = cameras.indexOf(camera[i]);

	            if (index !== -1)
	            {
	                if (runDestroy)
	                {
	                    cameras[index].destroy();
	                }
	                else
	                {
	                    cameras[index].renderList = [];
	                }

	                cameras.splice(index, 1);

	                total++;
	            }
	        }

	        if (!this.main && cameras[0])
	        {
	            this.main = cameras[0];
	        }

	        return total;
	    },

	    render: function (renderer, displayList)
	    {
	        var scene = this.scene;
	        var cameras = this.cameras;

	        for (var i = 0; i < cameras.length; i++)
	        {
	            var camera = cameras[i];

	            if (camera.visible && camera.alpha > 0)
	            {
	                camera.preRender();

	                var visibleChildren = this.getVisibleChildren(displayList.getChildren(), camera);

	                renderer.render(scene, visibleChildren, camera);
	            }
	        }
	    },

	    getVisibleChildren: function (children, camera)
	    {
	        return children.filter(function (child)
	        {
	            return child.willRender(camera);
	        });
	    },

	    resetAll: function ()
	    {
	        for (var i = 0; i < this.cameras.length; i++)
	        {
	            this.cameras[i].destroy();
	        }

	        this.cameras = [];

	        this.main = this.add();

	        return this.main;
	    },

	    update: function (time, delta)
	    {
	        for (var i = 0; i < this.cameras.length; i++)
	        {
	            this.cameras[i].update(time, delta);
	        }
	    },

	    onResize: function (gameSize, baseSize, displaySize, previousWidth, previousHeight)
	    {
	        for (var i = 0; i < this.cameras.length; i++)
	        {
	            var cam = this.cameras[i];

	            if (cam._x === 0 && cam._y === 0 && cam._width === previousWidth && cam._height === previousHeight)
	            {
	                cam.setSize(baseSize.width, baseSize.height);
	            }
	        }
	    },

	    resize: function (width, height)
	    {
	        for (var i = 0; i < this.cameras.length; i++)
	        {
	            this.cameras[i].setSize(width, height);
	        }
	    },

	    shutdown: function ()
	    {
	        this.main = undefined;

	        for (var i = 0; i < this.cameras.length; i++)
	        {
	            this.cameras[i].destroy();
	        }

	        this.cameras = [];

	        var eventEmitter = this.systems.events;

	        eventEmitter.off(SceneEvents.UPDATE, this.update, this);
	        eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);
	    },

	    destroy: function ()
	    {
	        this.shutdown();

	        this.default.destroy();

	        this.systems.events.off(SceneEvents.START, this.start, this);
	        this.systems.events.off(SceneEvents.DESTROY, this.destroy, this);
	        this.systems.game.scale.off(ScaleEvents.RESIZE, this.onResize, this);

	        this.scene = null;
	        this.systems = null;
	    }

	});

	PluginCache.register('CameraManager', CameraManager, 'cameras');

	CameraManager_1 = CameraManager;
	return CameraManager_1;
}

var _2d;
var hasRequired_2d;

function require_2d () {
	if (hasRequired_2d) return _2d;
	hasRequired_2d = 1;
	_2d = {

	    Camera: requireCamera(),
	    BaseCamera: requireBaseCamera(),
	    CameraManager: requireCameraManager(),
	    Effects: requireEffects(),
	    Events: requireEvents$f()

	};
	return _2d;
}

var cameras;
var hasRequiredCameras;

function requireCameras () {
	if (hasRequiredCameras) return cameras;
	hasRequiredCameras = 1;
	cameras = {

	    Controls: requireControls(),
	    Scene2D: require_2d()

	};
	return cameras;
}

var DefaultPlugins_1;
var hasRequiredDefaultPlugins;

function requireDefaultPlugins () {
	if (hasRequiredDefaultPlugins) return DefaultPlugins_1;
	hasRequiredDefaultPlugins = 1;
	var DefaultPlugins = {

	    Global: [

	        'game',
	        'anims',
	        'cache',
	        'plugins',
	        'registry',
	        'scale',
	        'sound',
	        'textures',
	        'renderer'

	    ],

	    CoreScene: [

	        'EventEmitter',

	        'CameraManager',
	        'GameObjectCreator',
	        'GameObjectFactory',
	        'ScenePlugin',
	        'DisplayList',
	        'UpdateList'

	    ],

	    DefaultScene: [

	        'Clock',
	        'DataManagerPlugin',
	        'InputPlugin',
	        'Loader',
	        'TweenManager',
	        'LightsPlugin'

	    ]

	};

	if (typeof PLUGIN_CAMERA3D)
	{
	    DefaultPlugins.DefaultScene.push('CameraManager3D');
	}

	if (typeof PLUGIN_FBINSTANT)
	{
	    DefaultPlugins.Global.push('facebook');
	}

	DefaultPlugins_1 = DefaultPlugins;
	return DefaultPlugins_1;
}

var Between_1;
var hasRequiredBetween;

function requireBetween () {
	if (hasRequiredBetween) return Between_1;
	hasRequiredBetween = 1;
	var Between = function (x1, y1, x2, y2)
	{
	    return Math.atan2(y2 - y1, x2 - x1);
	};

	Between_1 = Between;
	return Between_1;
}

var BetweenPoints_1;
var hasRequiredBetweenPoints;

function requireBetweenPoints () {
	if (hasRequiredBetweenPoints) return BetweenPoints_1;
	hasRequiredBetweenPoints = 1;
	var BetweenPoints = function (point1, point2)
	{
	    return Math.atan2(point2.y - point1.y, point2.x - point1.x);
	};

	BetweenPoints_1 = BetweenPoints;
	return BetweenPoints_1;
}

var BetweenPointsY_1;
var hasRequiredBetweenPointsY;

function requireBetweenPointsY () {
	if (hasRequiredBetweenPointsY) return BetweenPointsY_1;
	hasRequiredBetweenPointsY = 1;
	var BetweenPointsY = function (point1, point2)
	{
	    return Math.atan2(point2.x - point1.x, point2.y - point1.y);
	};

	BetweenPointsY_1 = BetweenPointsY;
	return BetweenPointsY_1;
}

var BetweenY_1;
var hasRequiredBetweenY;

function requireBetweenY () {
	if (hasRequiredBetweenY) return BetweenY_1;
	hasRequiredBetweenY = 1;
	var BetweenY = function (x1, y1, x2, y2)
	{
	    return Math.atan2(x2 - x1, y2 - y1);
	};

	BetweenY_1 = BetweenY;
	return BetweenY_1;
}

var CounterClockwise_1;
var hasRequiredCounterClockwise;

function requireCounterClockwise () {
	if (hasRequiredCounterClockwise) return CounterClockwise_1;
	hasRequiredCounterClockwise = 1;
	var CONST = require_const$c();

	var CounterClockwise = function (angle)
	{
	    if (angle > Math.PI)
	    {
	        angle -= CONST.PI2;
	    }

	    return Math.abs((((angle + CONST.TAU) % CONST.PI2) - CONST.PI2) % CONST.PI2);
	};

	CounterClockwise_1 = CounterClockwise;
	return CounterClockwise_1;
}

var Normalize_1;
var hasRequiredNormalize;

function requireNormalize () {
	if (hasRequiredNormalize) return Normalize_1;
	hasRequiredNormalize = 1;
	var Normalize = function (angle)
	{
	    angle = angle % (2 * Math.PI);

	    if (angle >= 0)
	    {
	        return angle;
	    }
	    else
	    {
	        return angle + 2 * Math.PI;
	    }
	};

	Normalize_1 = Normalize;
	return Normalize_1;
}

var GetClockwiseDistance_1;
var hasRequiredGetClockwiseDistance;

function requireGetClockwiseDistance () {
	if (hasRequiredGetClockwiseDistance) return GetClockwiseDistance_1;
	hasRequiredGetClockwiseDistance = 1;
	var NormalizeAngle = requireNormalize();

	var GetClockwiseDistance = function (angle1, angle2)
	{
	    return NormalizeAngle(angle2 - angle1);
	};

	GetClockwiseDistance_1 = GetClockwiseDistance;
	return GetClockwiseDistance_1;
}

var GetCounterClockwiseDistance_1;
var hasRequiredGetCounterClockwiseDistance;

function requireGetCounterClockwiseDistance () {
	if (hasRequiredGetCounterClockwiseDistance) return GetCounterClockwiseDistance_1;
	hasRequiredGetCounterClockwiseDistance = 1;
	var NormalizeAngle = requireNormalize();

	var TAU = 2 * Math.PI;

	var GetCounterClockwiseDistance = function (angle1, angle2)
	{
	    var distance = NormalizeAngle(angle2 - angle1);

	    if (distance > 0)
	    {
	        distance -= TAU;
	    }

	    return distance;
	};

	GetCounterClockwiseDistance_1 = GetCounterClockwiseDistance;
	return GetCounterClockwiseDistance_1;
}

var GetShortestDistance_1$1;
var hasRequiredGetShortestDistance$1;

function requireGetShortestDistance$1 () {
	if (hasRequiredGetShortestDistance$1) return GetShortestDistance_1$1;
	hasRequiredGetShortestDistance$1 = 1;
	var WrapAngle = requireWrap();

	var GetShortestDistance = function (angle1, angle2)
	{
	    return WrapAngle(angle2 - angle1);
	};

	GetShortestDistance_1$1 = GetShortestDistance;
	return GetShortestDistance_1$1;
}

var FloatBetween_1;
var hasRequiredFloatBetween;

function requireFloatBetween () {
	if (hasRequiredFloatBetween) return FloatBetween_1;
	hasRequiredFloatBetween = 1;
	var FloatBetween = function (min, max)
	{
	    return Math.random() * (max - min) + min;
	};

	FloatBetween_1 = FloatBetween;
	return FloatBetween_1;
}

var Random_1;
var hasRequiredRandom;

function requireRandom () {
	if (hasRequiredRandom) return Random_1;
	hasRequiredRandom = 1;
	var FloatBetween = requireFloatBetween();

	var Random = function ()
	{
	    return FloatBetween(-Math.PI, Math.PI);
	};

	Random_1 = Random;
	return Random_1;
}

var RandomDegrees_1;
var hasRequiredRandomDegrees;

function requireRandomDegrees () {
	if (hasRequiredRandomDegrees) return RandomDegrees_1;
	hasRequiredRandomDegrees = 1;
	var FloatBetween = requireFloatBetween();

	var RandomDegrees = function ()
	{
	    return FloatBetween(-180, 180);
	};

	RandomDegrees_1 = RandomDegrees;
	return RandomDegrees_1;
}

var Reverse_1$2;
var hasRequiredReverse$2;

function requireReverse$2 () {
	if (hasRequiredReverse$2) return Reverse_1$2;
	hasRequiredReverse$2 = 1;
	var Normalize = requireNormalize();

	var Reverse = function (angle)
	{
	    return Normalize(angle + Math.PI);
	};

	Reverse_1$2 = Reverse;
	return Reverse_1$2;
}

var RotateTo_1$1;
var hasRequiredRotateTo$1;

function requireRotateTo$1 () {
	if (hasRequiredRotateTo$1) return RotateTo_1$1;
	hasRequiredRotateTo$1 = 1;
	var MATH_CONST = require_const$c();

	var RotateTo = function (currentAngle, targetAngle, lerp)
	{
	    if (lerp === undefined) { lerp = 0.05; }

	    if (currentAngle === targetAngle)
	    {
	        return currentAngle;
	    }

	    if (Math.abs(targetAngle - currentAngle) <= lerp || Math.abs(targetAngle - currentAngle) >= (MATH_CONST.PI2 - lerp))
	    {
	        currentAngle = targetAngle;
	    }
	    else
	    {
	        if (Math.abs(targetAngle - currentAngle) > Math.PI)
	        {
	            if (targetAngle < currentAngle)
	            {
	                targetAngle += MATH_CONST.PI2;
	            }
	            else
	            {
	                targetAngle -= MATH_CONST.PI2;
	            }
	        }

	        if (targetAngle > currentAngle)
	        {
	            currentAngle += lerp;
	        }
	        else if (targetAngle < currentAngle)
	        {
	            currentAngle -= lerp;
	        }
	    }

	    return currentAngle;
	};

	RotateTo_1$1 = RotateTo;
	return RotateTo_1$1;
}

var ShortestBetween_1;
var hasRequiredShortestBetween;

function requireShortestBetween () {
	if (hasRequiredShortestBetween) return ShortestBetween_1;
	hasRequiredShortestBetween = 1;
	var ShortestBetween = function (angle1, angle2)
	{
	    var difference = angle2 - angle1;

	    if (difference === 0)
	    {
	        return 0;
	    }

	    var times = Math.floor((difference - (-180)) / 360);

	    return difference - (times * 360);

	};

	ShortestBetween_1 = ShortestBetween;
	return ShortestBetween_1;
}

var angle;
var hasRequiredAngle$1;

function requireAngle$1 () {
	if (hasRequiredAngle$1) return angle;
	hasRequiredAngle$1 = 1;
	angle = {

	    Between: requireBetween(),
	    BetweenPoints: requireBetweenPoints(),
	    BetweenPointsY: requireBetweenPointsY(),
	    BetweenY: requireBetweenY(),
	    CounterClockwise: requireCounterClockwise(),
	    GetClockwiseDistance: requireGetClockwiseDistance(),
	    GetCounterClockwiseDistance: requireGetCounterClockwiseDistance(),
	    GetShortestDistance: requireGetShortestDistance$1(),
	    Normalize: requireNormalize(),
	    Random: requireRandom(),
	    RandomDegrees: requireRandomDegrees(),
	    Reverse: requireReverse$2(),
	    RotateTo: requireRotateTo$1(),
	    ShortestBetween: requireShortestBetween(),
	    Wrap: requireWrap(),
	    WrapDegrees: requireWrapDegrees()

	};
	return angle;
}

var DistanceBetweenPointsSquared_1;
var hasRequiredDistanceBetweenPointsSquared;

function requireDistanceBetweenPointsSquared () {
	if (hasRequiredDistanceBetweenPointsSquared) return DistanceBetweenPointsSquared_1;
	hasRequiredDistanceBetweenPointsSquared = 1;
	var DistanceBetweenPointsSquared = function (a, b)
	{
	    var dx = a.x - b.x;
	    var dy = a.y - b.y;

	    return dx * dx + dy * dy;
	};

	DistanceBetweenPointsSquared_1 = DistanceBetweenPointsSquared;
	return DistanceBetweenPointsSquared_1;
}

var DistanceChebyshev;
var hasRequiredDistanceChebyshev;

function requireDistanceChebyshev () {
	if (hasRequiredDistanceChebyshev) return DistanceChebyshev;
	hasRequiredDistanceChebyshev = 1;
	var ChebyshevDistance = function (x1, y1, x2, y2)
	{
	    return Math.max(Math.abs(x1 - x2), Math.abs(y1 - y2));
	};

	DistanceChebyshev = ChebyshevDistance;
	return DistanceChebyshev;
}

var DistancePower_1;
var hasRequiredDistancePower;

function requireDistancePower () {
	if (hasRequiredDistancePower) return DistancePower_1;
	hasRequiredDistancePower = 1;
	var DistancePower = function (x1, y1, x2, y2, pow)
	{
	    if (pow === undefined) { pow = 2; }

	    return Math.sqrt(Math.pow(x2 - x1, pow) + Math.pow(y2 - y1, pow));
	};

	DistancePower_1 = DistancePower;
	return DistancePower_1;
}

var DistanceSnake;
var hasRequiredDistanceSnake;

function requireDistanceSnake () {
	if (hasRequiredDistanceSnake) return DistanceSnake;
	hasRequiredDistanceSnake = 1;
	var SnakeDistance = function (x1, y1, x2, y2)
	{
	    return Math.abs(x1 - x2) + Math.abs(y1 - y2);
	};

	DistanceSnake = SnakeDistance;
	return DistanceSnake;
}

var DistanceSquared_1;
var hasRequiredDistanceSquared;

function requireDistanceSquared () {
	if (hasRequiredDistanceSquared) return DistanceSquared_1;
	hasRequiredDistanceSquared = 1;
	var DistanceSquared = function (x1, y1, x2, y2)
	{
	    var dx = x1 - x2;
	    var dy = y1 - y2;

	    return dx * dx + dy * dy;
	};

	DistanceSquared_1 = DistanceSquared;
	return DistanceSquared_1;
}

var distance;
var hasRequiredDistance;

function requireDistance () {
	if (hasRequiredDistance) return distance;
	hasRequiredDistance = 1;
	distance = {

	    Between: requireDistanceBetween(),
	    BetweenPoints: requireDistanceBetweenPoints(),
	    BetweenPointsSquared: requireDistanceBetweenPointsSquared(),
	    Chebyshev: requireDistanceChebyshev(),
	    Power: requireDistancePower(),
	    Snake: requireDistanceSnake(),
	    Squared: requireDistanceSquared()

	};
	return distance;
}

var easing;
var hasRequiredEasing;

function requireEasing () {
	if (hasRequiredEasing) return easing;
	hasRequiredEasing = 1;
	easing = {

	    Back: requireBack(),
	    Bounce: requireBounce$1(),
	    Circular: requireCircular(),
	    Cubic: requireCubic(),
	    Elastic: requireElastic(),
	    Expo: requireExpo(),
	    Linear: requireLinear$1(),
	    Quadratic: requireQuadratic(),
	    Quartic: requireQuartic(),
	    Quintic: requireQuintic(),
	    Sine: requireSine(),
	    Stepped: requireStepped()

	};
	return easing;
}

var Ceil_1$2;
var hasRequiredCeil$2;

function requireCeil$2 () {
	if (hasRequiredCeil$2) return Ceil_1$2;
	hasRequiredCeil$2 = 1;
	var Ceil = function (value, epsilon)
	{
	    if (epsilon === undefined) { epsilon = 0.0001; }

	    return Math.ceil(value - epsilon);
	};

	Ceil_1$2 = Ceil;
	return Ceil_1$2;
}

var Floor_1$2;
var hasRequiredFloor$2;

function requireFloor$2 () {
	if (hasRequiredFloor$2) return Floor_1$2;
	hasRequiredFloor$2 = 1;
	var Floor = function (value, epsilon)
	{
	    if (epsilon === undefined) { epsilon = 0.0001; }

	    return Math.floor(value + epsilon);
	};

	Floor_1$2 = Floor;
	return Floor_1$2;
}

var GreaterThan_1;
var hasRequiredGreaterThan;

function requireGreaterThan () {
	if (hasRequiredGreaterThan) return GreaterThan_1;
	hasRequiredGreaterThan = 1;
	var GreaterThan = function (a, b, epsilon)
	{
	    if (epsilon === undefined) { epsilon = 0.0001; }

	    return a > b - epsilon;
	};

	GreaterThan_1 = GreaterThan;
	return GreaterThan_1;
}

var LessThan_1;
var hasRequiredLessThan;

function requireLessThan () {
	if (hasRequiredLessThan) return LessThan_1;
	hasRequiredLessThan = 1;
	var LessThan = function (a, b, epsilon)
	{
	    if (epsilon === undefined) { epsilon = 0.0001; }

	    return a < b + epsilon;
	};

	LessThan_1 = LessThan;
	return LessThan_1;
}

var fuzzy;
var hasRequiredFuzzy;

function requireFuzzy () {
	if (hasRequiredFuzzy) return fuzzy;
	hasRequiredFuzzy = 1;
	fuzzy = {

	    Ceil: requireCeil$2(),
	    Equal: requireEqual(),
	    Floor: requireFloor$2(),
	    GreaterThan: requireGreaterThan(),
	    LessThan: requireLessThan()

	};
	return fuzzy;
}

var Factorial_1;
var hasRequiredFactorial;

function requireFactorial () {
	if (hasRequiredFactorial) return Factorial_1;
	hasRequiredFactorial = 1;
	var Factorial = function (value)
	{
	    if (value === 0)
	    {
	        return 1;
	    }

	    var res = value;

	    while (--value)
	    {
	        res *= value;
	    }

	    return res;
	};

	Factorial_1 = Factorial;
	return Factorial_1;
}

var Bernstein_1;
var hasRequiredBernstein;

function requireBernstein () {
	if (hasRequiredBernstein) return Bernstein_1;
	hasRequiredBernstein = 1;
	var Factorial = requireFactorial();

	var Bernstein = function (n, i)
	{
	    return Factorial(n) / Factorial(i) / Factorial(n - i);
	};

	Bernstein_1 = Bernstein;
	return Bernstein_1;
}

var BezierInterpolation_1;
var hasRequiredBezierInterpolation;

function requireBezierInterpolation () {
	if (hasRequiredBezierInterpolation) return BezierInterpolation_1;
	hasRequiredBezierInterpolation = 1;
	var Bernstein = requireBernstein();

	var BezierInterpolation = function (v, k)
	{
	    var b = 0;
	    var n = v.length - 1;

	    for (var i = 0; i <= n; i++)
	    {
	        b += Math.pow(1 - k, n - i) * Math.pow(k, i) * v[i] * Bernstein(n, i);
	    }

	    return b;
	};

	BezierInterpolation_1 = BezierInterpolation;
	return BezierInterpolation_1;
}

var CatmullRom_1;
var hasRequiredCatmullRom;

function requireCatmullRom () {
	if (hasRequiredCatmullRom) return CatmullRom_1;
	hasRequiredCatmullRom = 1;
	var CatmullRom = function (t, p0, p1, p2, p3)
	{
	    var v0 = (p2 - p0) * 0.5;
	    var v1 = (p3 - p1) * 0.5;
	    var t2 = t * t;
	    var t3 = t * t2;

	    return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
	};

	CatmullRom_1 = CatmullRom;
	return CatmullRom_1;
}

var CatmullRomInterpolation_1;
var hasRequiredCatmullRomInterpolation;

function requireCatmullRomInterpolation () {
	if (hasRequiredCatmullRomInterpolation) return CatmullRomInterpolation_1;
	hasRequiredCatmullRomInterpolation = 1;
	var CatmullRom = requireCatmullRom();

	var CatmullRomInterpolation = function (v, k)
	{
	    var m = v.length - 1;
	    var f = m * k;
	    var i = Math.floor(f);

	    if (v[0] === v[m])
	    {
	        if (k < 0)
	        {
	            i = Math.floor(f = m * (1 + k));
	        }

	        return CatmullRom(f - i, v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m]);
	    }
	    else
	    {
	        if (k < 0)
	        {
	            return v[0] - (CatmullRom(-f, v[0], v[0], v[1], v[1]) - v[0]);
	        }

	        if (k > 1)
	        {
	            return v[m] - (CatmullRom(f - m, v[m], v[m], v[m - 1], v[m - 1]) - v[m]);
	        }

	        return CatmullRom(f - i, v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2]);
	    }
	};

	CatmullRomInterpolation_1 = CatmullRomInterpolation;
	return CatmullRomInterpolation_1;
}

var CubicBezierInterpolation_1;
var hasRequiredCubicBezierInterpolation;

function requireCubicBezierInterpolation () {
	if (hasRequiredCubicBezierInterpolation) return CubicBezierInterpolation_1;
	hasRequiredCubicBezierInterpolation = 1;
	function P0 (t, p)
	{
	    var k = 1 - t;

	    return k * k * k * p;
	}

	function P1 (t, p)
	{
	    var k = 1 - t;

	    return 3 * k * k * t * p;
	}

	function P2 (t, p)
	{
	    return 3 * (1 - t) * t * t * p;
	}

	function P3 (t, p)
	{
	    return t * t * t * p;
	}

	var CubicBezierInterpolation = function (t, p0, p1, p2, p3)
	{
	    return P0(t, p0) + P1(t, p1) + P2(t, p2) + P3(t, p3);
	};

	CubicBezierInterpolation_1 = CubicBezierInterpolation;
	return CubicBezierInterpolation_1;
}

var LinearInterpolation_1;
var hasRequiredLinearInterpolation;

function requireLinearInterpolation () {
	if (hasRequiredLinearInterpolation) return LinearInterpolation_1;
	hasRequiredLinearInterpolation = 1;
	var Linear = requireLinear();

	var LinearInterpolation = function (v, k)
	{
	    var m = v.length - 1;
	    var f = m * k;
	    var i = Math.floor(f);

	    if (k < 0)
	    {
	        return Linear(v[0], v[1], f);
	    }
	    else if (k > 1)
	    {
	        return Linear(v[m], v[m - 1], m - f);
	    }
	    else
	    {
	        return Linear(v[i], v[(i + 1 > m) ? m : i + 1], f - i);
	    }
	};

	LinearInterpolation_1 = LinearInterpolation;
	return LinearInterpolation_1;
}

var QuadraticBezierInterpolation_1;
var hasRequiredQuadraticBezierInterpolation;

function requireQuadraticBezierInterpolation () {
	if (hasRequiredQuadraticBezierInterpolation) return QuadraticBezierInterpolation_1;
	hasRequiredQuadraticBezierInterpolation = 1;
	function P0 (t, p)
	{
	    var k = 1 - t;

	    return k * k * p;
	}

	function P1 (t, p)
	{
	    return 2 * (1 - t) * t * p;
	}

	function P2 (t, p)
	{
	    return t * t * p;
	}

	var QuadraticBezierInterpolation = function (t, p0, p1, p2)
	{
	    return P0(t, p0) + P1(t, p1) + P2(t, p2);
	};

	QuadraticBezierInterpolation_1 = QuadraticBezierInterpolation;
	return QuadraticBezierInterpolation_1;
}

var SmoothStepInterpolation_1;
var hasRequiredSmoothStepInterpolation;

function requireSmoothStepInterpolation () {
	if (hasRequiredSmoothStepInterpolation) return SmoothStepInterpolation_1;
	hasRequiredSmoothStepInterpolation = 1;
	var SmoothStep = requireSmoothStep$1();

	var SmoothStepInterpolation = function (t, min, max)
	{
	    return min + (max - min) * SmoothStep(t, 0, 1);
	};

	SmoothStepInterpolation_1 = SmoothStepInterpolation;
	return SmoothStepInterpolation_1;
}

var SmootherStepInterpolation_1;
var hasRequiredSmootherStepInterpolation;

function requireSmootherStepInterpolation () {
	if (hasRequiredSmootherStepInterpolation) return SmootherStepInterpolation_1;
	hasRequiredSmootherStepInterpolation = 1;
	var SmootherStep = requireSmootherStep$1();

	var SmootherStepInterpolation = function (t, min, max)
	{
	    return min + (max - min) * SmootherStep(t, 0, 1);
	};

	SmootherStepInterpolation_1 = SmootherStepInterpolation;
	return SmootherStepInterpolation_1;
}

var interpolation;
var hasRequiredInterpolation;

function requireInterpolation () {
	if (hasRequiredInterpolation) return interpolation;
	hasRequiredInterpolation = 1;
	interpolation = {

	    Bezier: requireBezierInterpolation(),
	    CatmullRom: requireCatmullRomInterpolation(),
	    CubicBezier: requireCubicBezierInterpolation(),
	    Linear: requireLinearInterpolation(),
	    QuadraticBezier: requireQuadraticBezierInterpolation(),
	    SmoothStep: requireSmoothStepInterpolation(),
	    SmootherStep: requireSmootherStepInterpolation()

	};
	return interpolation;
}

var GetPowerOfTwo_1;
var hasRequiredGetPowerOfTwo;

function requireGetPowerOfTwo () {
	if (hasRequiredGetPowerOfTwo) return GetPowerOfTwo_1;
	hasRequiredGetPowerOfTwo = 1;
	var GetPowerOfTwo = function (value)
	{
	    var index = Math.log(value) / 0.6931471805599453;

	    return (1 << Math.ceil(index));
	};

	GetPowerOfTwo_1 = GetPowerOfTwo;
	return GetPowerOfTwo_1;
}

var IsSizePowerOfTwo_1;
var hasRequiredIsSizePowerOfTwo;

function requireIsSizePowerOfTwo () {
	if (hasRequiredIsSizePowerOfTwo) return IsSizePowerOfTwo_1;
	hasRequiredIsSizePowerOfTwo = 1;
	var IsSizePowerOfTwo = function (width, height)
	{
	    return (width > 0 && (width & (width - 1)) === 0 && height > 0 && (height & (height - 1)) === 0);
	};

	IsSizePowerOfTwo_1 = IsSizePowerOfTwo;
	return IsSizePowerOfTwo_1;
}

var IsValuePowerOfTwo_1;
var hasRequiredIsValuePowerOfTwo;

function requireIsValuePowerOfTwo () {
	if (hasRequiredIsValuePowerOfTwo) return IsValuePowerOfTwo_1;
	hasRequiredIsValuePowerOfTwo = 1;
	var IsValuePowerOfTwo = function (value)
	{
	    return (value > 0 && (value & (value - 1)) === 0);
	};

	IsValuePowerOfTwo_1 = IsValuePowerOfTwo;
	return IsValuePowerOfTwo_1;
}

var pow2;
var hasRequiredPow2;

function requirePow2 () {
	if (hasRequiredPow2) return pow2;
	hasRequiredPow2 = 1;
	pow2 = {

	    GetNext: requireGetPowerOfTwo(),
	    IsSize: requireIsSizePowerOfTwo(),
	    IsValue: requireIsValuePowerOfTwo()

	};
	return pow2;
}

var SnapCeil_1;
var hasRequiredSnapCeil;

function requireSnapCeil () {
	if (hasRequiredSnapCeil) return SnapCeil_1;
	hasRequiredSnapCeil = 1;
	var SnapCeil = function (value, gap, start, divide)
	{
	    if (start === undefined) { start = 0; }

	    if (gap === 0)
	    {
	        return value;
	    }

	    value -= start;
	    value = gap * Math.ceil(value / gap);

	    return (divide) ? (start + value) / gap : start + value;
	};

	SnapCeil_1 = SnapCeil;
	return SnapCeil_1;
}

var SnapFloor_1;
var hasRequiredSnapFloor;

function requireSnapFloor () {
	if (hasRequiredSnapFloor) return SnapFloor_1;
	hasRequiredSnapFloor = 1;
	var SnapFloor = function (value, gap, start, divide)
	{
	    if (start === undefined) { start = 0; }

	    if (gap === 0)
	    {
	        return value;
	    }

	    value -= start;
	    value = gap * Math.floor(value / gap);

	    return (divide) ? (start + value) / gap : start + value;
	};

	SnapFloor_1 = SnapFloor;
	return SnapFloor_1;
}

var SnapTo_1;
var hasRequiredSnapTo;

function requireSnapTo () {
	if (hasRequiredSnapTo) return SnapTo_1;
	hasRequiredSnapTo = 1;
	var SnapTo = function (value, gap, start, divide)
	{
	    if (start === undefined) { start = 0; }

	    if (gap === 0)
	    {
	        return value;
	    }

	    value -= start;
	    value = gap * Math.round(value / gap);

	    return (divide) ? (start + value) / gap : start + value;
	};

	SnapTo_1 = SnapTo;
	return SnapTo_1;
}

var snap;
var hasRequiredSnap;

function requireSnap () {
	if (hasRequiredSnap) return snap;
	hasRequiredSnap = 1;
	snap = {

	    Ceil: requireSnapCeil(),
	    Floor: requireSnapFloor(),
	    To: requireSnapTo()

	};
	return snap;
}

var RandomDataGenerator_1;
var hasRequiredRandomDataGenerator;

function requireRandomDataGenerator () {
	if (hasRequiredRandomDataGenerator) return RandomDataGenerator_1;
	hasRequiredRandomDataGenerator = 1;
	var Class = requireClass();

	var RandomDataGenerator = new Class({

	    initialize:

	    function RandomDataGenerator (seeds)
	    {
	        if (seeds === undefined) { seeds = [ (Date.now() * Math.random()).toString() ]; }

	        this.c = 1;

	        this.s0 = 0;

	        this.s1 = 0;

	        this.s2 = 0;

	        this.n = 0;

	        this.signs = [ -1, 1 ];

	        if (seeds)
	        {
	            this.init(seeds);
	        }
	    },

	    rnd: function ()
	    {
	        var t = 2091639 * this.s0 + this.c * 2.3283064365386963e-10; 

	        this.c = t | 0;
	        this.s0 = this.s1;
	        this.s1 = this.s2;
	        this.s2 = t - this.c;

	        return this.s2;
	    },

	    hash: function (data)
	    {
	        var h;
	        var n = this.n;

	        data = data.toString();

	        for (var i = 0; i < data.length; i++)
	        {
	            n += data.charCodeAt(i);
	            h = 0.02519603282416938 * n;
	            n = h >>> 0;
	            h -= n;
	            h *= n;
	            n = h >>> 0;
	            h -= n;
	            n += h * 0x100000000;
	        }

	        this.n = n;

	        return (n >>> 0) * 2.3283064365386963e-10;
	    },

	    init: function (seeds)
	    {
	        if (typeof seeds === 'string')
	        {
	            this.state(seeds);
	        }
	        else
	        {
	            this.sow(seeds);
	        }
	    },

	    sow: function (seeds)
	    {

	        this.n = 0xefc8249d;
	        this.s0 = this.hash(' ');
	        this.s1 = this.hash(' ');
	        this.s2 = this.hash(' ');
	        this.c = 1;

	        if (!seeds)
	        {
	            return;
	        }

	        for (var i = 0; i < seeds.length && (seeds[i] != null); i++)
	        {
	            var seed = seeds[i];

	            this.s0 -= this.hash(seed);
	            this.s0 += ~~(this.s0 < 0);
	            this.s1 -= this.hash(seed);
	            this.s1 += ~~(this.s1 < 0);
	            this.s2 -= this.hash(seed);
	            this.s2 += ~~(this.s2 < 0);
	        }
	    },

	    integer: function ()
	    {

	        return this.rnd() * 0x100000000;
	    },

	    frac: function ()
	    {

	        return this.rnd() + (this.rnd() * 0x200000 | 0) * 1.1102230246251565e-16;
	    },

	    real: function ()
	    {
	        return this.integer() + this.frac();
	    },

	    integerInRange: function (min, max)
	    {
	        return Math.floor(this.realInRange(0, max - min + 1) + min);
	    },

	    between: function (min, max)
	    {
	        return Math.floor(this.realInRange(0, max - min + 1) + min);
	    },

	    realInRange: function (min, max)
	    {
	        return this.frac() * (max - min) + min;
	    },

	    normal: function ()
	    {
	        return 1 - (2 * this.frac());
	    },

	    uuid: function ()
	    {
	        var a = '';
	        var b = '';

	        for (b = a = ''; a++ < 36; b += ~a % 5 | a * 3 & 4 ? (a ^ 15 ? 8 ^ this.frac() * (a ^ 20 ? 16 : 4) : 4).toString(16) : '-')
	        {

	        }

	        return b;
	    },

	    pick: function (array)
	    {
	        return array[this.integerInRange(0, array.length - 1)];
	    },

	    sign: function ()
	    {
	        return this.pick(this.signs);
	    },

	    weightedPick: function (array)
	    {
	        return array[~~(Math.pow(this.frac(), 2) * (array.length - 0.5) + 0.5)];
	    },

	    timestamp: function (min, max)
	    {
	        return this.realInRange(min || 946684800000, max || 1577862000000);
	    },

	    angle: function ()
	    {
	        return this.integerInRange(-180, 180);
	    },

	    rotation: function ()
	    {
	        return this.realInRange(-3.1415926, 3.1415926);
	    },

	    state: function (state)
	    {
	        if (typeof state === 'string' && state.match(/^!rnd/))
	        {
	            state = state.split(',');

	            this.c = parseFloat(state[1]);
	            this.s0 = parseFloat(state[2]);
	            this.s1 = parseFloat(state[3]);
	            this.s2 = parseFloat(state[4]);
	        }

	        return [ '!rnd', this.c, this.s0, this.s1, this.s2 ].join(',');
	    },

	    shuffle: function (array)
	    {
	        var len = array.length - 1;

	        for (var i = len; i > 0; i--)
	        {
	            var randomIndex = Math.floor(this.frac() * (i + 1));
	            var itemAtIndex = array[randomIndex];

	            array[randomIndex] = array[i];
	            array[i] = itemAtIndex;
	        }

	        return array;
	    }

	});

	RandomDataGenerator_1 = RandomDataGenerator;
	return RandomDataGenerator_1;
}

var Average_1;
var hasRequiredAverage;

function requireAverage () {
	if (hasRequiredAverage) return Average_1;
	hasRequiredAverage = 1;
	var Average = function (values)
	{
	    var sum = 0;

	    for (var i = 0; i < values.length; i++)
	    {
	        sum += (+values[i]);
	    }

	    return sum / values.length;
	};

	Average_1 = Average;
	return Average_1;
}

var CeilTo_1;
var hasRequiredCeilTo;

function requireCeilTo () {
	if (hasRequiredCeilTo) return CeilTo_1;
	hasRequiredCeilTo = 1;
	var CeilTo = function (value, place, base)
	{
	    if (place === undefined) { place = 0; }
	    if (base === undefined) { base = 10; }

	    var p = Math.pow(base, -place);

	    return Math.ceil(value * p) / p;
	};

	CeilTo_1 = CeilTo;
	return CeilTo_1;
}

var Difference_1;
var hasRequiredDifference;

function requireDifference () {
	if (hasRequiredDifference) return Difference_1;
	hasRequiredDifference = 1;
	var Difference = function (a, b)
	{
	    return Math.abs(a - b);
	};

	Difference_1 = Difference;
	return Difference_1;
}

var Vector3_1;
var hasRequiredVector3;

function requireVector3 () {
	if (hasRequiredVector3) return Vector3_1;
	hasRequiredVector3 = 1;
	var Class = requireClass();

	var Vector3 = new Class({

	    initialize:

	    function Vector3 (x, y, z)
	    {

	        this.x = 0;

	        this.y = 0;

	        this.z = 0;

	        if (typeof x === 'object')
	        {
	            this.x = x.x || 0;
	            this.y = x.y || 0;
	            this.z = x.z || 0;
	        }
	        else
	        {
	            this.x = x || 0;
	            this.y = y || 0;
	            this.z = z || 0;
	        }
	    },

	    up: function ()
	    {
	        this.x = 0;
	        this.y = 1;
	        this.z = 0;

	        return this;
	    },

	    min: function (v)
	    {
	        this.x = Math.min(this.x, v.x);
	        this.y = Math.min(this.y, v.y);
	        this.z = Math.min(this.z, v.z);

	        return this;
	    },

	    max: function (v)
	    {
	        this.x = Math.max(this.x, v.x);
	        this.y = Math.max(this.y, v.y);
	        this.z = Math.max(this.z, v.z);

	        return this;
	    },

	    clone: function ()
	    {
	        return new Vector3(this.x, this.y, this.z);
	    },

	    addVectors: function (a, b)
	    {
	        this.x = a.x + b.x;
	        this.y = a.y + b.y;
	        this.z = a.z + b.z;

	        return this;
	    },

	    subVectors: function (a, b)
	    {
	        this.x = a.x - b.x;
	        this.y = a.y - b.y;
	        this.z = a.z - b.z;

	        return this;
	    },

	    crossVectors: function (a, b)
	    {
	        var ax = a.x;
	        var ay = a.y;
	        var az = a.z;
	        var bx = b.x;
	        var by = b.y;
	        var bz = b.z;

	        this.x = ay * bz - az * by;
	        this.y = az * bx - ax * bz;
	        this.z = ax * by - ay * bx;

	        return this;
	    },

	    equals: function (v)
	    {
	        return ((this.x === v.x) && (this.y === v.y) && (this.z === v.z));
	    },

	    copy: function (src)
	    {
	        this.x = src.x;
	        this.y = src.y;
	        this.z = src.z || 0;

	        return this;
	    },

	    set: function (x, y, z)
	    {
	        if (typeof x === 'object')
	        {
	            this.x = x.x || 0;
	            this.y = x.y || 0;
	            this.z = x.z || 0;
	        }
	        else
	        {
	            this.x = x || 0;
	            this.y = y || 0;
	            this.z = z || 0;
	        }

	        return this;
	    },

	    setFromMatrixPosition: function (m)
	    {
	        return this.fromArray(m.val, 12);
	    },

	    setFromMatrixColumn: function (mat4, index)
	    {
	        return this.fromArray(mat4.val, index * 4);
	    },

	    fromArray: function (array, offset)
	    {
	        if (offset === undefined) { offset = 0; }

	        this.x = array[offset];
	        this.y = array[offset + 1];
	        this.z = array[offset + 2];

	        return this;
	    },

	    add: function (v)
	    {
	        this.x += v.x;
	        this.y += v.y;
	        this.z += v.z || 0;

	        return this;
	    },

	    addScalar: function (s)
	    {
	        this.x += s;
	        this.y += s;
	        this.z += s;

	        return this;
	    },

	    addScale: function (v, scale)
	    {
	        this.x += v.x * scale;
	        this.y += v.y * scale;
	        this.z += v.z * scale || 0;

	        return this;
	    },

	    subtract: function (v)
	    {
	        this.x -= v.x;
	        this.y -= v.y;
	        this.z -= v.z || 0;

	        return this;
	    },

	    multiply: function (v)
	    {
	        this.x *= v.x;
	        this.y *= v.y;
	        this.z *= v.z || 1;

	        return this;
	    },

	    scale: function (scale)
	    {
	        if (isFinite(scale))
	        {
	            this.x *= scale;
	            this.y *= scale;
	            this.z *= scale;
	        }
	        else
	        {
	            this.x = 0;
	            this.y = 0;
	            this.z = 0;
	        }

	        return this;
	    },

	    divide: function (v)
	    {
	        this.x /= v.x;
	        this.y /= v.y;
	        this.z /= v.z || 1;

	        return this;
	    },

	    negate: function ()
	    {
	        this.x = -this.x;
	        this.y = -this.y;
	        this.z = -this.z;

	        return this;
	    },

	    distance: function (v)
	    {
	        var dx = v.x - this.x;
	        var dy = v.y - this.y;
	        var dz = v.z - this.z || 0;

	        return Math.sqrt(dx * dx + dy * dy + dz * dz);
	    },

	    distanceSq: function (v)
	    {
	        var dx = v.x - this.x;
	        var dy = v.y - this.y;
	        var dz = v.z - this.z || 0;

	        return dx * dx + dy * dy + dz * dz;
	    },

	    length: function ()
	    {
	        var x = this.x;
	        var y = this.y;
	        var z = this.z;

	        return Math.sqrt(x * x + y * y + z * z);
	    },

	    lengthSq: function ()
	    {
	        var x = this.x;
	        var y = this.y;
	        var z = this.z;

	        return x * x + y * y + z * z;
	    },

	    normalize: function ()
	    {
	        var x = this.x;
	        var y = this.y;
	        var z = this.z;
	        var len = x * x + y * y + z * z;

	        if (len > 0)
	        {
	            len = 1 / Math.sqrt(len);

	            this.x = x * len;
	            this.y = y * len;
	            this.z = z * len;
	        }

	        return this;
	    },

	    dot: function (v)
	    {
	        return this.x * v.x + this.y * v.y + this.z * v.z;
	    },

	    cross: function (v)
	    {
	        var ax = this.x;
	        var ay = this.y;
	        var az = this.z;
	        var bx = v.x;
	        var by = v.y;
	        var bz = v.z;

	        this.x = ay * bz - az * by;
	        this.y = az * bx - ax * bz;
	        this.z = ax * by - ay * bx;

	        return this;
	    },

	    lerp: function (v, t)
	    {
	        if (t === undefined) { t = 0; }

	        var ax = this.x;
	        var ay = this.y;
	        var az = this.z;

	        this.x = ax + t * (v.x - ax);
	        this.y = ay + t * (v.y - ay);
	        this.z = az + t * (v.z - az);

	        return this;
	    },

	    applyMatrix3: function (mat3)
	    {
	        var x = this.x;
	        var y = this.y;
	        var z = this.z;
	        var m = mat3.val;

	        this.x = m[0] * x + m[3] * y + m[6] * z;
	        this.y = m[1] * x + m[4] * y + m[7] * z;
	        this.z = m[2] * x + m[5] * y + m[8] * z;

	        return this;
	    },

	    applyMatrix4: function (mat4)
	    {
	        var x = this.x;
	        var y = this.y;
	        var z = this.z;
	        var m = mat4.val;

	        var w = 1 / (m[3] * x + m[7] * y + m[11] * z + m[15]);

	        this.x = (m[0] * x + m[4] * y + m[8] * z + m[12]) * w;
	        this.y = (m[1] * x + m[5] * y + m[9] * z + m[13]) * w;
	        this.z = (m[2] * x + m[6] * y + m[10] * z + m[14]) * w;

	        return this;
	    },

	    transformMat3: function (mat)
	    {
	        var x = this.x;
	        var y = this.y;
	        var z = this.z;
	        var m = mat.val;

	        this.x = x * m[0] + y * m[3] + z * m[6];
	        this.y = x * m[1] + y * m[4] + z * m[7];
	        this.z = x * m[2] + y * m[5] + z * m[8];

	        return this;
	    },

	    transformMat4: function (mat)
	    {
	        var x = this.x;
	        var y = this.y;
	        var z = this.z;
	        var m = mat.val;

	        this.x = m[0] * x + m[4] * y + m[8] * z + m[12];
	        this.y = m[1] * x + m[5] * y + m[9] * z + m[13];
	        this.z = m[2] * x + m[6] * y + m[10] * z + m[14];

	        return this;
	    },

	    transformCoordinates: function (mat)
	    {
	        var x = this.x;
	        var y = this.y;
	        var z = this.z;
	        var m = mat.val;

	        var tx = (x * m[0]) + (y * m[4]) + (z * m[8]) + m[12];
	        var ty = (x * m[1]) + (y * m[5]) + (z * m[9]) + m[13];
	        var tz = (x * m[2]) + (y * m[6]) + (z * m[10]) + m[14];
	        var tw = (x * m[3]) + (y * m[7]) + (z * m[11]) + m[15];

	        this.x = tx / tw;
	        this.y = ty / tw;
	        this.z = tz / tw;

	        return this;
	    },

	    transformQuat: function (q)
	    {

	        var x = this.x;
	        var y = this.y;
	        var z = this.z;
	        var qx = q.x;
	        var qy = q.y;
	        var qz = q.z;
	        var qw = q.w;

	        var ix = qw * x + qy * z - qz * y;
	        var iy = qw * y + qz * x - qx * z;
	        var iz = qw * z + qx * y - qy * x;
	        var iw = -qx * x - qy * y - qz * z;

	        this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
	        this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
	        this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;

	        return this;
	    },

	    project: function (mat)
	    {
	        var x = this.x;
	        var y = this.y;
	        var z = this.z;
	        var m = mat.val;

	        var a00 = m[0];
	        var a01 = m[1];
	        var a02 = m[2];
	        var a03 = m[3];
	        var a10 = m[4];
	        var a11 = m[5];
	        var a12 = m[6];
	        var a13 = m[7];
	        var a20 = m[8];
	        var a21 = m[9];
	        var a22 = m[10];
	        var a23 = m[11];
	        var a30 = m[12];
	        var a31 = m[13];
	        var a32 = m[14];
	        var a33 = m[15];

	        var lw = 1 / (x * a03 + y * a13 + z * a23 + a33);

	        this.x = (x * a00 + y * a10 + z * a20 + a30) * lw;
	        this.y = (x * a01 + y * a11 + z * a21 + a31) * lw;
	        this.z = (x * a02 + y * a12 + z * a22 + a32) * lw;

	        return this;
	    },

	    projectViewMatrix: function (viewMatrix, projectionMatrix)
	    {
	        return this.applyMatrix4(viewMatrix).applyMatrix4(projectionMatrix);
	    },

	    unprojectViewMatrix: function (projectionMatrix, worldMatrix)
	    {
	        return this.applyMatrix4(projectionMatrix).applyMatrix4(worldMatrix);
	    },

	    unproject: function (viewport, invProjectionView)
	    {
	        var viewX = viewport.x;
	        var viewY = viewport.y;
	        var viewWidth = viewport.z;
	        var viewHeight = viewport.w;

	        var x = this.x - viewX;
	        var y = (viewHeight - this.y - 1) - viewY;
	        var z = this.z;

	        this.x = (2 * x) / viewWidth - 1;
	        this.y = (2 * y) / viewHeight - 1;
	        this.z = 2 * z - 1;

	        return this.project(invProjectionView);
	    },

	    reset: function ()
	    {
	        this.x = 0;
	        this.y = 0;
	        this.z = 0;

	        return this;
	    }

	});

	Vector3.ZERO = new Vector3();

	Vector3.RIGHT = new Vector3(1, 0, 0);

	Vector3.LEFT = new Vector3(-1, 0, 0);

	Vector3.UP = new Vector3(0, -1, 0);

	Vector3.DOWN = new Vector3(0, 1, 0);

	Vector3.FORWARD = new Vector3(0, 0, 1);

	Vector3.BACK = new Vector3(0, 0, -1);

	Vector3.ONE = new Vector3(1, 1, 1);

	Vector3_1 = Vector3;
	return Vector3_1;
}

var Matrix4_1;
var hasRequiredMatrix4;

function requireMatrix4 () {
	if (hasRequiredMatrix4) return Matrix4_1;
	hasRequiredMatrix4 = 1;
	var Class = requireClass();
	var Vector3 = requireVector3();

	var EPSILON = 0.000001;

	var Matrix4 = new Class({

	    initialize:

	    function Matrix4 (m)
	    {

	        this.val = new Float32Array(16);

	        if (m)
	        {

	            this.copy(m);
	        }
	        else
	        {

	            this.identity();
	        }
	    },

	    clone: function ()
	    {
	        return new Matrix4(this);
	    },

	    set: function (src)
	    {
	        return this.copy(src);
	    },

	    setValues: function (m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33)
	    {
	        var out = this.val;

	        out[0] = m00;
	        out[1] = m01;
	        out[2] = m02;
	        out[3] = m03;
	        out[4] = m10;
	        out[5] = m11;
	        out[6] = m12;
	        out[7] = m13;
	        out[8] = m20;
	        out[9] = m21;
	        out[10] = m22;
	        out[11] = m23;
	        out[12] = m30;
	        out[13] = m31;
	        out[14] = m32;
	        out[15] = m33;

	        return this;
	    },

	    copy: function (src)
	    {
	        var a = src.val;

	        return this.setValues(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
	    },

	    fromArray: function (a)
	    {
	        return this.setValues(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
	    },

	    zero: function ()
	    {
	        return this.setValues(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
	    },

	    transform: function (position, scale, rotation)
	    {
	        var rotMatrix = _tempMat1.fromQuat(rotation);

	        var rm = rotMatrix.val;

	        var sx = scale.x;
	        var sy = scale.y;
	        var sz = scale.z;

	        return this.setValues(
	            rm[0] * sx,
	            rm[1] * sx,
	            rm[2] * sx,
	            0,

	            rm[4] * sy,
	            rm[5] * sy,
	            rm[6] * sy,
	            0,

	            rm[8] * sz,
	            rm[9] * sz,
	            rm[10] * sz,
	            0,

	            position.x,
	            position.y,
	            position.z,
	            1
	        );
	    },

	    xyz: function (x, y, z)
	    {
	        this.identity();

	        var out = this.val;

	        out[12] = x;
	        out[13] = y;
	        out[14] = z;

	        return this;
	    },

	    scaling: function (x, y, z)
	    {
	        this.zero();

	        var out = this.val;

	        out[0] = x;
	        out[5] = y;
	        out[10] = z;
	        out[15] = 1;

	        return this;
	    },

	    identity: function ()
	    {
	        return this.setValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
	    },

	    transpose: function ()
	    {
	        var a = this.val;

	        var a01 = a[1];
	        var a02 = a[2];
	        var a03 = a[3];
	        var a12 = a[6];
	        var a13 = a[7];
	        var a23 = a[11];

	        a[1] = a[4];
	        a[2] = a[8];
	        a[3] = a[12];
	        a[4] = a01;
	        a[6] = a[9];
	        a[7] = a[13];
	        a[8] = a02;
	        a[9] = a12;
	        a[11] = a[14];
	        a[12] = a03;
	        a[13] = a13;
	        a[14] = a23;

	        return this;
	    },

	    getInverse: function (m)
	    {
	        this.copy(m);

	        return this.invert();
	    },

	    invert: function ()
	    {
	        var a = this.val;

	        var a00 = a[0];
	        var a01 = a[1];
	        var a02 = a[2];
	        var a03 = a[3];

	        var a10 = a[4];
	        var a11 = a[5];
	        var a12 = a[6];
	        var a13 = a[7];

	        var a20 = a[8];
	        var a21 = a[9];
	        var a22 = a[10];
	        var a23 = a[11];

	        var a30 = a[12];
	        var a31 = a[13];
	        var a32 = a[14];
	        var a33 = a[15];

	        var b00 = a00 * a11 - a01 * a10;
	        var b01 = a00 * a12 - a02 * a10;
	        var b02 = a00 * a13 - a03 * a10;
	        var b03 = a01 * a12 - a02 * a11;

	        var b04 = a01 * a13 - a03 * a11;
	        var b05 = a02 * a13 - a03 * a12;
	        var b06 = a20 * a31 - a21 * a30;
	        var b07 = a20 * a32 - a22 * a30;

	        var b08 = a20 * a33 - a23 * a30;
	        var b09 = a21 * a32 - a22 * a31;
	        var b10 = a21 * a33 - a23 * a31;
	        var b11 = a22 * a33 - a23 * a32;

	        var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

	        if (!det)
	        {
	            return this;
	        }

	        det = 1 / det;

	        return this.setValues(
	            (a11 * b11 - a12 * b10 + a13 * b09) * det,
	            (a02 * b10 - a01 * b11 - a03 * b09) * det,
	            (a31 * b05 - a32 * b04 + a33 * b03) * det,
	            (a22 * b04 - a21 * b05 - a23 * b03) * det,
	            (a12 * b08 - a10 * b11 - a13 * b07) * det,
	            (a00 * b11 - a02 * b08 + a03 * b07) * det,
	            (a32 * b02 - a30 * b05 - a33 * b01) * det,
	            (a20 * b05 - a22 * b02 + a23 * b01) * det,
	            (a10 * b10 - a11 * b08 + a13 * b06) * det,
	            (a01 * b08 - a00 * b10 - a03 * b06) * det,
	            (a30 * b04 - a31 * b02 + a33 * b00) * det,
	            (a21 * b02 - a20 * b04 - a23 * b00) * det,
	            (a11 * b07 - a10 * b09 - a12 * b06) * det,
	            (a00 * b09 - a01 * b07 + a02 * b06) * det,
	            (a31 * b01 - a30 * b03 - a32 * b00) * det,
	            (a20 * b03 - a21 * b01 + a22 * b00) * det
	        );
	    },

	    adjoint: function ()
	    {
	        var a = this.val;

	        var a00 = a[0];
	        var a01 = a[1];
	        var a02 = a[2];
	        var a03 = a[3];

	        var a10 = a[4];
	        var a11 = a[5];
	        var a12 = a[6];
	        var a13 = a[7];

	        var a20 = a[8];
	        var a21 = a[9];
	        var a22 = a[10];
	        var a23 = a[11];

	        var a30 = a[12];
	        var a31 = a[13];
	        var a32 = a[14];
	        var a33 = a[15];

	        return this.setValues(
	            (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22)),
	            -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22)),
	            (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12)),
	            -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12)),
	            -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22)),
	            (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22)),
	            -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12)),
	            (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12)),
	            (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21)),
	            -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21)),
	            (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11)),
	            -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11)),
	            -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21)),
	            (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21)),
	            -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11)),
	            (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11))
	        );
	    },

	    determinant: function ()
	    {
	        var a = this.val;

	        var a00 = a[0];
	        var a01 = a[1];
	        var a02 = a[2];
	        var a03 = a[3];

	        var a10 = a[4];
	        var a11 = a[5];
	        var a12 = a[6];
	        var a13 = a[7];

	        var a20 = a[8];
	        var a21 = a[9];
	        var a22 = a[10];
	        var a23 = a[11];

	        var a30 = a[12];
	        var a31 = a[13];
	        var a32 = a[14];
	        var a33 = a[15];

	        var b00 = a00 * a11 - a01 * a10;
	        var b01 = a00 * a12 - a02 * a10;
	        var b02 = a00 * a13 - a03 * a10;
	        var b03 = a01 * a12 - a02 * a11;
	        var b04 = a01 * a13 - a03 * a11;
	        var b05 = a02 * a13 - a03 * a12;
	        var b06 = a20 * a31 - a21 * a30;
	        var b07 = a20 * a32 - a22 * a30;
	        var b08 = a20 * a33 - a23 * a30;
	        var b09 = a21 * a32 - a22 * a31;
	        var b10 = a21 * a33 - a23 * a31;
	        var b11 = a22 * a33 - a23 * a32;

	        return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
	    },

	    multiply: function (src)
	    {
	        var a = this.val;

	        var a00 = a[0];
	        var a01 = a[1];
	        var a02 = a[2];
	        var a03 = a[3];

	        var a10 = a[4];
	        var a11 = a[5];
	        var a12 = a[6];
	        var a13 = a[7];

	        var a20 = a[8];
	        var a21 = a[9];
	        var a22 = a[10];
	        var a23 = a[11];

	        var a30 = a[12];
	        var a31 = a[13];
	        var a32 = a[14];
	        var a33 = a[15];

	        var b = src.val;

	        var b0 = b[0];
	        var b1 = b[1];
	        var b2 = b[2];
	        var b3 = b[3];

	        a[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
	        a[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
	        a[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
	        a[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

	        b0 = b[4];
	        b1 = b[5];
	        b2 = b[6];
	        b3 = b[7];

	        a[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
	        a[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
	        a[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
	        a[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

	        b0 = b[8];
	        b1 = b[9];
	        b2 = b[10];
	        b3 = b[11];

	        a[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
	        a[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
	        a[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
	        a[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

	        b0 = b[12];
	        b1 = b[13];
	        b2 = b[14];
	        b3 = b[15];

	        a[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
	        a[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
	        a[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
	        a[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

	        return this;
	    },

	    multiplyLocal: function (src)
	    {
	        var a = this.val;
	        var b = src.val;

	        return this.setValues(
	            a[0] * b[0] + a[1] * b[4] + a[2] * b[8] + a[3] * b[12],
	            a[0] * b[1] + a[1] * b[5] + a[2] * b[9] + a[3] * b[13],
	            a[0] * b[2] + a[1] * b[6] + a[2] * b[10] + a[3] * b[14],
	            a[0] * b[3] + a[1] * b[7] + a[2] * b[11] + a[3] * b[15],

	            a[4] * b[0] + a[5] * b[4] + a[6] * b[8] + a[7] * b[12],
	            a[4] * b[1] + a[5] * b[5] + a[6] * b[9] + a[7] * b[13],
	            a[4] * b[2] + a[5] * b[6] + a[6] * b[10] + a[7] * b[14],
	            a[4] * b[3] + a[5] * b[7] + a[6] * b[11] + a[7] * b[15],

	            a[8] * b[0] + a[9] * b[4] + a[10] * b[8] + a[11] * b[12],
	            a[8] * b[1] + a[9] * b[5] + a[10] * b[9] + a[11] * b[13],
	            a[8] * b[2] + a[9] * b[6] + a[10] * b[10] + a[11] * b[14],
	            a[8] * b[3] + a[9] * b[7] + a[10] * b[11] + a[11] * b[15],

	            a[12] * b[0] + a[13] * b[4] + a[14] * b[8] + a[15] * b[12],
	            a[12] * b[1] + a[13] * b[5] + a[14] * b[9] + a[15] * b[13],
	            a[12] * b[2] + a[13] * b[6] + a[14] * b[10] + a[15] * b[14],
	            a[12] * b[3] + a[13] * b[7] + a[14] * b[11] + a[15] * b[15]
	        );
	    },

	    premultiply: function (m)
	    {
	        return this.multiplyMatrices(m, this);
	    },

	    multiplyMatrices: function (a, b)
	    {
	        var am = a.val;
	        var bm = b.val;

	        var a11 = am[0];
	        var a12 = am[4];
	        var a13 = am[8];
	        var a14 = am[12];
	        var a21 = am[1];
	        var a22 = am[5];
	        var a23 = am[9];
	        var a24 = am[13];
	        var a31 = am[2];
	        var a32 = am[6];
	        var a33 = am[10];
	        var a34 = am[14];
	        var a41 = am[3];
	        var a42 = am[7];
	        var a43 = am[11];
	        var a44 = am[15];

	        var b11 = bm[0];
	        var b12 = bm[4];
	        var b13 = bm[8];
	        var b14 = bm[12];
	        var b21 = bm[1];
	        var b22 = bm[5];
	        var b23 = bm[9];
	        var b24 = bm[13];
	        var b31 = bm[2];
	        var b32 = bm[6];
	        var b33 = bm[10];
	        var b34 = bm[14];
	        var b41 = bm[3];
	        var b42 = bm[7];
	        var b43 = bm[11];
	        var b44 = bm[15];

	        return this.setValues(
	            a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41,
	            a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41,
	            a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41,
	            a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41,
	            a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42,
	            a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42,
	            a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42,
	            a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42,
	            a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43,
	            a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43,
	            a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43,
	            a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43,
	            a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44,
	            a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44,
	            a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44,
	            a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44
	        );
	    },

	    translate: function (v)
	    {
	        return this.translateXYZ(v.x, v.y, v.z);
	    },

	    translateXYZ: function (x, y, z)
	    {
	        var a = this.val;

	        a[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
	        a[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
	        a[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
	        a[15] = a[3] * x + a[7] * y + a[11] * z + a[15];

	        return this;
	    },

	    scale: function (v)
	    {
	        return this.scaleXYZ(v.x, v.y, v.z);
	    },

	    scaleXYZ: function (x, y, z)
	    {
	        var a = this.val;

	        a[0] = a[0] * x;
	        a[1] = a[1] * x;
	        a[2] = a[2] * x;
	        a[3] = a[3] * x;

	        a[4] = a[4] * y;
	        a[5] = a[5] * y;
	        a[6] = a[6] * y;
	        a[7] = a[7] * y;

	        a[8] = a[8] * z;
	        a[9] = a[9] * z;
	        a[10] = a[10] * z;
	        a[11] = a[11] * z;

	        return this;
	    },

	    makeRotationAxis: function (axis, angle)
	    {

	        var c = Math.cos(angle);
	        var s = Math.sin(angle);
	        var t = 1 - c;
	        var x = axis.x;
	        var y = axis.y;
	        var z = axis.z;
	        var tx = t * x;
	        var ty = t * y;

	        return this.setValues(
	            tx * x + c, tx * y - s * z, tx * z + s * y, 0,
	            tx * y + s * z, ty * y + c, ty * z - s * x, 0,
	            tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
	            0, 0, 0, 1
	        );
	    },

	    rotate: function (rad, axis)
	    {
	        var a = this.val;
	        var x = axis.x;
	        var y = axis.y;
	        var z = axis.z;
	        var len = Math.sqrt(x * x + y * y + z * z);

	        if (Math.abs(len) < EPSILON)
	        {
	            return this;
	        }

	        len = 1 / len;
	        x *= len;
	        y *= len;
	        z *= len;

	        var s = Math.sin(rad);
	        var c = Math.cos(rad);
	        var t = 1 - c;

	        var a00 = a[0];
	        var a01 = a[1];
	        var a02 = a[2];
	        var a03 = a[3];

	        var a10 = a[4];
	        var a11 = a[5];
	        var a12 = a[6];
	        var a13 = a[7];

	        var a20 = a[8];
	        var a21 = a[9];
	        var a22 = a[10];
	        var a23 = a[11];

	        var a30 = a[12];
	        var a31 = a[13];
	        var a32 = a[14];
	        var a33 = a[15];

	        var b00 = x * x * t + c;
	        var b01 = y * x * t + z * s;
	        var b02 = z * x * t - y * s;

	        var b10 = x * y * t - z * s;
	        var b11 = y * y * t + c;
	        var b12 = z * y * t + x * s;

	        var b20 = x * z * t + y * s;
	        var b21 = y * z * t - x * s;
	        var b22 = z * z * t + c;

	        return this.setValues(
	            a00 * b00 + a10 * b01 + a20 * b02,
	            a01 * b00 + a11 * b01 + a21 * b02,
	            a02 * b00 + a12 * b01 + a22 * b02,
	            a03 * b00 + a13 * b01 + a23 * b02,
	            a00 * b10 + a10 * b11 + a20 * b12,
	            a01 * b10 + a11 * b11 + a21 * b12,
	            a02 * b10 + a12 * b11 + a22 * b12,
	            a03 * b10 + a13 * b11 + a23 * b12,
	            a00 * b20 + a10 * b21 + a20 * b22,
	            a01 * b20 + a11 * b21 + a21 * b22,
	            a02 * b20 + a12 * b21 + a22 * b22,
	            a03 * b20 + a13 * b21 + a23 * b22,
	            a30, a31, a32, a33
	        );
	    },

	    rotateX: function (rad)
	    {
	        var a = this.val;
	        var s = Math.sin(rad);
	        var c = Math.cos(rad);

	        var a10 = a[4];
	        var a11 = a[5];
	        var a12 = a[6];
	        var a13 = a[7];

	        var a20 = a[8];
	        var a21 = a[9];
	        var a22 = a[10];
	        var a23 = a[11];

	        a[4] = a10 * c + a20 * s;
	        a[5] = a11 * c + a21 * s;
	        a[6] = a12 * c + a22 * s;
	        a[7] = a13 * c + a23 * s;
	        a[8] = a20 * c - a10 * s;
	        a[9] = a21 * c - a11 * s;
	        a[10] = a22 * c - a12 * s;
	        a[11] = a23 * c - a13 * s;

	        return this;
	    },

	    rotateY: function (rad)
	    {
	        var a = this.val;
	        var s = Math.sin(rad);
	        var c = Math.cos(rad);

	        var a00 = a[0];
	        var a01 = a[1];
	        var a02 = a[2];
	        var a03 = a[3];

	        var a20 = a[8];
	        var a21 = a[9];
	        var a22 = a[10];
	        var a23 = a[11];

	        a[0] = a00 * c - a20 * s;
	        a[1] = a01 * c - a21 * s;
	        a[2] = a02 * c - a22 * s;
	        a[3] = a03 * c - a23 * s;
	        a[8] = a00 * s + a20 * c;
	        a[9] = a01 * s + a21 * c;
	        a[10] = a02 * s + a22 * c;
	        a[11] = a03 * s + a23 * c;

	        return this;
	    },

	    rotateZ: function (rad)
	    {
	        var a = this.val;
	        var s = Math.sin(rad);
	        var c = Math.cos(rad);

	        var a00 = a[0];
	        var a01 = a[1];
	        var a02 = a[2];
	        var a03 = a[3];

	        var a10 = a[4];
	        var a11 = a[5];
	        var a12 = a[6];
	        var a13 = a[7];

	        a[0] = a00 * c + a10 * s;
	        a[1] = a01 * c + a11 * s;
	        a[2] = a02 * c + a12 * s;
	        a[3] = a03 * c + a13 * s;
	        a[4] = a10 * c - a00 * s;
	        a[5] = a11 * c - a01 * s;
	        a[6] = a12 * c - a02 * s;
	        a[7] = a13 * c - a03 * s;

	        return this;
	    },

	    fromRotationTranslation: function (q, v)
	    {

	        var x = q.x;
	        var y = q.y;
	        var z = q.z;
	        var w = q.w;

	        var x2 = x + x;
	        var y2 = y + y;
	        var z2 = z + z;

	        var xx = x * x2;
	        var xy = x * y2;
	        var xz = x * z2;

	        var yy = y * y2;
	        var yz = y * z2;
	        var zz = z * z2;

	        var wx = w * x2;
	        var wy = w * y2;
	        var wz = w * z2;

	        return this.setValues(
	            1 - (yy + zz),
	            xy + wz,
	            xz - wy,
	            0,

	            xy - wz,
	            1 - (xx + zz),
	            yz + wx,
	            0,

	            xz + wy,
	            yz - wx,
	            1 - (xx + yy),
	            0,

	            v.x,
	            v.y,
	            v.z,
	            1
	        );
	    },

	    fromQuat: function (q)
	    {
	        var x = q.x;
	        var y = q.y;
	        var z = q.z;
	        var w = q.w;

	        var x2 = x + x;
	        var y2 = y + y;
	        var z2 = z + z;

	        var xx = x * x2;
	        var xy = x * y2;
	        var xz = x * z2;

	        var yy = y * y2;
	        var yz = y * z2;
	        var zz = z * z2;

	        var wx = w * x2;
	        var wy = w * y2;
	        var wz = w * z2;

	        return this.setValues(
	            1 - (yy + zz),
	            xy + wz,
	            xz - wy,
	            0,

	            xy - wz,
	            1 - (xx + zz),
	            yz + wx,
	            0,

	            xz + wy,
	            yz - wx,
	            1 - (xx + yy),
	            0,

	            0,
	            0,
	            0,
	            1
	        );
	    },

	    frustum: function (left, right, bottom, top, near, far)
	    {
	        var rl = 1 / (right - left);
	        var tb = 1 / (top - bottom);
	        var nf = 1 / (near - far);

	        return this.setValues(
	            (near * 2) * rl,
	            0,
	            0,
	            0,

	            0,
	            (near * 2) * tb,
	            0,
	            0,

	            (right + left) * rl,
	            (top + bottom) * tb,
	            (far + near) * nf,
	            -1,

	            0,
	            0,
	            (far * near * 2) * nf,
	            0
	        );
	    },

	    perspective: function (fovy, aspect, near, far)
	    {
	        var f = 1.0 / Math.tan(fovy / 2);
	        var nf = 1 / (near - far);

	        return this.setValues(
	            f / aspect,
	            0,
	            0,
	            0,

	            0,
	            f,
	            0,
	            0,

	            0,
	            0,
	            (far + near) * nf,
	            -1,

	            0,
	            0,
	            (2 * far * near) * nf,
	            0
	        );
	    },

	    perspectiveLH: function (width, height, near, far)
	    {
	        return this.setValues(
	            (2 * near) / width,
	            0,
	            0,
	            0,

	            0,
	            (2 * near) / height,
	            0,
	            0,

	            0,
	            0,
	            -far / (near - far),
	            1,

	            0,
	            0,
	            (near * far) / (near - far),
	            0
	        );
	    },

	    ortho: function (left, right, bottom, top, near, far)
	    {
	        var lr = left - right;
	        var bt = bottom - top;
	        var nf = near - far;

	        lr = (lr === 0) ? lr : 1 / lr;
	        bt = (bt === 0) ? bt : 1 / bt;
	        nf = (nf === 0) ? nf : 1 / nf;

	        return this.setValues(
	            -2 * lr,
	            0,
	            0,
	            0,

	            0,
	            -2 * bt,
	            0,
	            0,

	            0,
	            0,
	            2 * nf,
	            0,

	            (left + right) * lr,
	            (top + bottom) * bt,
	            (far + near) * nf,
	            1
	        );
	    },

	    lookAtRH: function (eye, target, up)
	    {
	        var m = this.val;

	        _z.subVectors(eye, target);

	        if (_z.lengthSq() === 0)
	        {

	            _z.z = 1;
	        }

	        _z.normalize();
	        _x.crossVectors(up, _z);

	        if (_x.lengthSq() === 0)
	        {

	            if (Math.abs(up.z) === 1)
	            {
	                _z.x += 0.0001;
	            }
	            else
	            {
	                _z.z += 0.0001;
	            }

	            _z.normalize();
	            _x.crossVectors(up, _z);
	        }

	        _x.normalize();
	        _y.crossVectors(_z, _x);

	        m[0] = _x.x;
	        m[1] = _x.y;
	        m[2] = _x.z;
	        m[4] = _y.x;
	        m[5] = _y.y;
	        m[6] = _y.z;
	        m[8] = _z.x;
	        m[9] = _z.y;
	        m[10] = _z.z;

	        return this;
	    },

	    lookAt: function (eye, center, up)
	    {
	        var eyex = eye.x;
	        var eyey = eye.y;
	        var eyez = eye.z;

	        var upx = up.x;
	        var upy = up.y;
	        var upz = up.z;

	        var centerx = center.x;
	        var centery = center.y;
	        var centerz = center.z;

	        if (Math.abs(eyex - centerx) < EPSILON &&
	            Math.abs(eyey - centery) < EPSILON &&
	            Math.abs(eyez - centerz) < EPSILON)
	        {
	            return this.identity();
	        }

	        var z0 = eyex - centerx;
	        var z1 = eyey - centery;
	        var z2 = eyez - centerz;

	        var len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);

	        z0 *= len;
	        z1 *= len;
	        z2 *= len;

	        var x0 = upy * z2 - upz * z1;
	        var x1 = upz * z0 - upx * z2;
	        var x2 = upx * z1 - upy * z0;

	        len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);

	        if (!len)
	        {
	            x0 = 0;
	            x1 = 0;
	            x2 = 0;
	        }
	        else
	        {
	            len = 1 / len;
	            x0 *= len;
	            x1 *= len;
	            x2 *= len;
	        }

	        var y0 = z1 * x2 - z2 * x1;
	        var y1 = z2 * x0 - z0 * x2;
	        var y2 = z0 * x1 - z1 * x0;

	        len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);

	        if (!len)
	        {
	            y0 = 0;
	            y1 = 0;
	            y2 = 0;
	        }
	        else
	        {
	            len = 1 / len;
	            y0 *= len;
	            y1 *= len;
	            y2 *= len;
	        }

	        return this.setValues(
	            x0,
	            y0,
	            z0,
	            0,

	            x1,
	            y1,
	            z1,
	            0,

	            x2,
	            y2,
	            z2,
	            0,

	            -(x0 * eyex + x1 * eyey + x2 * eyez),
	            -(y0 * eyex + y1 * eyey + y2 * eyez),
	            -(z0 * eyex + z1 * eyey + z2 * eyez),
	            1
	        );
	    },

	    yawPitchRoll: function (yaw, pitch, roll)
	    {
	        this.zero();
	        _tempMat1.zero();
	        _tempMat2.zero();

	        var m0 = this.val;
	        var m1 = _tempMat1.val;
	        var m2 = _tempMat2.val;

	        var s = Math.sin(roll);
	        var c = Math.cos(roll);

	        m0[10] = 1;
	        m0[15] = 1;
	        m0[0] = c;
	        m0[1] = s;
	        m0[4] = -s;
	        m0[5] = c;

	        s = Math.sin(pitch);
	        c = Math.cos(pitch);

	        m1[0] = 1;
	        m1[15] = 1;
	        m1[5] = c;
	        m1[10] = c;
	        m1[9] = -s;
	        m1[6] = s;

	        s = Math.sin(yaw);
	        c = Math.cos(yaw);

	        m2[5] = 1;
	        m2[15] = 1;
	        m2[0] = c;
	        m2[2] = -s;
	        m2[8] = s;
	        m2[10] = c;

	        this.multiplyLocal(_tempMat1);
	        this.multiplyLocal(_tempMat2);

	        return this;
	    },

	    setWorldMatrix: function (rotation, position, scale, viewMatrix, projectionMatrix)
	    {
	        this.yawPitchRoll(rotation.y, rotation.x, rotation.z);

	        _tempMat1.scaling(scale.x, scale.y, scale.z);
	        _tempMat2.xyz(position.x, position.y, position.z);

	        this.multiplyLocal(_tempMat1);
	        this.multiplyLocal(_tempMat2);

	        if (viewMatrix)
	        {
	            this.multiplyLocal(viewMatrix);
	        }

	        if (projectionMatrix)
	        {
	            this.multiplyLocal(projectionMatrix);
	        }

	        return this;
	    },

	    multiplyToMat4: function (src, out)
	    {
	        var a = this.val;
	        var b = src.val;

	        var a00 = a[0];
	        var a01 = a[1];
	        var a02 = a[2];
	        var a03 = a[3];
	        var a10 = a[4];
	        var a11 = a[5];
	        var a12 = a[6];
	        var a13 = a[7];
	        var a20 = a[8];
	        var a21 = a[9];
	        var a22 = a[10];
	        var a23 = a[11];
	        var a30 = a[12];
	        var a31 = a[13];
	        var a32 = a[14];
	        var a33 = a[15];

	        var b00 = b[0];
	        var b01 = b[1];
	        var b02 = b[2];
	        var b03 = b[3];
	        var b10 = b[4];
	        var b11 = b[5];
	        var b12 = b[6];
	        var b13 = b[7];
	        var b20 = b[8];
	        var b21 = b[9];
	        var b22 = b[10];
	        var b23 = b[11];
	        var b30 = b[12];
	        var b31 = b[13];
	        var b32 = b[14];
	        var b33 = b[15];

	        return out.setValues(
	            b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30,
	            b01 * a01 + b01 * a11 + b02 * a21 + b03 * a31,
	            b02 * a02 + b01 * a12 + b02 * a22 + b03 * a32,
	            b03 * a03 + b01 * a13 + b02 * a23 + b03 * a33,

	            b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30,
	            b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31,
	            b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32,
	            b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33,

	            b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30,
	            b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31,
	            b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32,
	            b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33,

	            b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30,
	            b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31,
	            b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32,
	            b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33
	        );
	    },

	    fromRotationXYTranslation: function (rotation, position, translateFirst)
	    {
	        var x = position.x;
	        var y = position.y;
	        var z = position.z;

	        var sx = Math.sin(rotation.x);
	        var cx = Math.cos(rotation.x);

	        var sy = Math.sin(rotation.y);
	        var cy = Math.cos(rotation.y);

	        var a30 = x;
	        var a31 = y;
	        var a32 = z;

	        var b21 = -sx;

	        var c01 = 0 - b21 * sy;

	        var c02 = 0 - cx * sy;

	        var c21 = b21 * cy;

	        var c22 = cx * cy;

	        if (!translateFirst)
	        {

	            a30 = cy * x + sy * z;
	            a31 = c01 * x + cx * y + c21 * z;
	            a32 = c02 * x + sx * y + c22 * z;
	        }

	        return this.setValues(
	            cy,
	            c01,
	            c02,
	            0,
	            0,
	            cx,
	            sx,
	            0,
	            sy,
	            c21,
	            c22,
	            0,
	            a30,
	            a31,
	            a32,
	            1
	        );
	    },

	    getMaxScaleOnAxis: function ()
	    {
	        var m = this.val;

	        var scaleXSq = m[0] * m[0] + m[1] * m[1] + m[2] * m[2];
	        var scaleYSq = m[4] * m[4] + m[5] * m[5] + m[6] * m[6];
	        var scaleZSq = m[8] * m[8] + m[9] * m[9] + m[10] * m[10];

	        return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
	    }

	});

	var _tempMat1 = new Matrix4();

	var _tempMat2 = new Matrix4();

	var _x = new Vector3();

	var _y = new Vector3();

	var _z = new Vector3();

	Matrix4_1 = Matrix4;
	return Matrix4_1;
}

var Euler_1;
var hasRequiredEuler;

function requireEuler () {
	if (hasRequiredEuler) return Euler_1;
	hasRequiredEuler = 1;
	var Clamp = requireClamp();
	var Class = requireClass();
	var Matrix4 = requireMatrix4();
	var NOOP = requireNOOP();

	var tempMatrix = new Matrix4();

	var Euler = new Class({

	    initialize:

	    function Euler (x, y, z, order)
	    {
	        if (x === undefined) { x = 0; }
	        if (y === undefined) { y = 0; }
	        if (z === undefined) { z = 0; }
	        if (order === undefined) { order = Euler.DefaultOrder; }

	        this._x = x;
	        this._y = y;
	        this._z = z;
	        this._order = order;

	        this.onChangeCallback = NOOP;
	    },

	    x: {
	        get: function ()
	        {
	            return this._x;
	        },

	        set: function (value)
	        {
	            this._x = value;

	            this.onChangeCallback(this);
	        }
	    },

	    y: {
	        get: function ()
	        {
	            return this._y;
	        },

	        set: function (value)
	        {
	            this._y = value;

	            this.onChangeCallback(this);
	        }
	    },

	    z: {
	        get: function ()
	        {
	            return this._z;
	        },

	        set: function (value)
	        {
	            this._z = value;

	            this.onChangeCallback(this);
	        }
	    },

	    order: {
	        get: function ()
	        {
	            return this._order;
	        },

	        set: function (value)
	        {
	            this._order = value;

	            this.onChangeCallback(this);
	        }
	    },

	    set: function (x, y, z, order)
	    {
	        if (order === undefined) { order = this._order; }

	        this._x = x;
	        this._y = y;
	        this._z = z;
	        this._order = order;

	        this.onChangeCallback(this);

	        return this;
	    },

	    copy: function (euler)
	    {
	        return this.set(euler.x, euler.y, euler.z, euler.order);
	    },

	    setFromQuaternion: function (quaternion, order, update)
	    {
	        if (order === undefined) { order = this._order; }
	        if (update === undefined) { update = false; }

	        tempMatrix.fromQuat(quaternion);

	        return this.setFromRotationMatrix(tempMatrix, order, update);
	    },

	    setFromRotationMatrix: function (matrix, order, update)
	    {
	        if (order === undefined) { order = this._order; }
	        if (update === undefined) { update = false; }

	        var elements = matrix.val;

	        var m11 = elements[0];
	        var m12 = elements[4];
	        var m13 = elements[8];
	        var m21 = elements[1];
	        var m22 = elements[5];
	        var m23 = elements[9];
	        var m31 = elements[2];
	        var m32 = elements[6];
	        var m33 = elements[10];

	        var x = 0;
	        var y = 0;
	        var z = 0;
	        var epsilon = 0.99999;

	        switch (order)
	        {
	            case 'XYZ':
	            {
	                y = Math.asin(Clamp(m13, -1, 1));

	                if (Math.abs(m13) < epsilon)
	                {
	                    x = Math.atan2(-m23, m33);
	                    z = Math.atan2(-m12, m11);
	                }
	                else
	                {
	                    x = Math.atan2(m32, m22);
	                }

	                break;
	            }

	            case 'YXZ':
	            {
	                x = Math.asin(-Clamp(m23, -1, 1));

	                if (Math.abs(m23) < epsilon)
	                {
	                    y = Math.atan2(m13, m33);
	                    z = Math.atan2(m21, m22);
	                }
	                else
	                {
	                    y = Math.atan2(-m31, m11);
	                }

	                break;
	            }

	            case 'ZXY':
	            {
	                x = Math.asin(Clamp(m32, -1, 1));

	                if (Math.abs(m32) < epsilon)
	                {
	                    y = Math.atan2(-m31, m33);
	                    z = Math.atan2(-m12, m22);
	                }
	                else
	                {
	                    z = Math.atan2(m21, m11);
	                }

	                break;
	            }

	            case 'ZYX':
	            {
	                y = Math.asin(-Clamp(m31, -1, 1));

	                if (Math.abs(m31) < epsilon)
	                {
	                    x = Math.atan2(m32, m33);
	                    z = Math.atan2(m21, m11);
	                }
	                else
	                {
	                    z = Math.atan2(-m12, m22);
	                }

	                break;
	            }

	            case 'YZX':
	            {
	                z = Math.asin(Clamp(m21, -1, 1));

	                if (Math.abs(m21) < epsilon)
	                {
	                    x = Math.atan2(-m23, m22);
	                    y = Math.atan2(-m31, m11);
	                }
	                else
	                {
	                    y = Math.atan2(m13, m33);
	                }

	                break;
	            }

	            case 'XZY':
	            {
	                z = Math.asin(-Clamp(m12, -1, 1));

	                if (Math.abs(m12) < epsilon)
	                {
	                    x = Math.atan2(m32, m22);
	                    y = Math.atan2(m13, m11);
	                }
	                else
	                {
	                    x = Math.atan2(-m23, m33);
	                }

	                break;
	            }
	        }

	        this._x = x;
	        this._y = y;
	        this._z = z;
	        this._order = order;

	        if (update)
	        {
	            this.onChangeCallback(this);
	        }

	        return this;
	    }

	});

	Euler.RotationOrders = [ 'XYZ', 'YXZ', 'ZXY', 'ZYX', 'YZX', 'XZY' ];

	Euler.DefaultOrder = 'XYZ';

	Euler_1 = Euler;
	return Euler_1;
}

var FloorTo_1;
var hasRequiredFloorTo;

function requireFloorTo () {
	if (hasRequiredFloorTo) return FloorTo_1;
	hasRequiredFloorTo = 1;
	var FloorTo = function (value, place, base)
	{
	    if (place === undefined) { place = 0; }
	    if (base === undefined) { base = 10; }

	    var p = Math.pow(base, -place);

	    return Math.floor(value * p) / p;
	};

	FloorTo_1 = FloorTo;
	return FloorTo_1;
}

var GetSpeed_1;
var hasRequiredGetSpeed;

function requireGetSpeed () {
	if (hasRequiredGetSpeed) return GetSpeed_1;
	hasRequiredGetSpeed = 1;
	var GetSpeed = function (distance, time)
	{
	    return (distance / time) / 1000;
	};

	GetSpeed_1 = GetSpeed;
	return GetSpeed_1;
}

var IsEven_1;
var hasRequiredIsEven;

function requireIsEven () {
	if (hasRequiredIsEven) return IsEven_1;
	hasRequiredIsEven = 1;
	var IsEven = function (value)
	{

	    return (value == parseFloat(value)) ? !(value % 2) : void 0;
	};

	IsEven_1 = IsEven;
	return IsEven_1;
}

var IsEvenStrict_1;
var hasRequiredIsEvenStrict;

function requireIsEvenStrict () {
	if (hasRequiredIsEvenStrict) return IsEvenStrict_1;
	hasRequiredIsEvenStrict = 1;
	var IsEvenStrict = function (value)
	{

	    return (value === parseFloat(value)) ? !(value % 2) : void 0;
	};

	IsEvenStrict_1 = IsEvenStrict;
	return IsEvenStrict_1;
}

var LinearXY_1;
var hasRequiredLinearXY;

function requireLinearXY () {
	if (hasRequiredLinearXY) return LinearXY_1;
	hasRequiredLinearXY = 1;
	var LinearXY = function (vector1, vector2, t)
	{
	    if (t === undefined) { t = 0; }

	    return vector1.clone().lerp(vector2, t);
	};

	LinearXY_1 = LinearXY;
	return LinearXY_1;
}

var MaxAdd_1;
var hasRequiredMaxAdd;

function requireMaxAdd () {
	if (hasRequiredMaxAdd) return MaxAdd_1;
	hasRequiredMaxAdd = 1;
	var MaxAdd = function (value, amount, max)
	{
	    return Math.min(value + amount, max);
	};

	MaxAdd_1 = MaxAdd;
	return MaxAdd_1;
}

var Median_1;
var hasRequiredMedian;

function requireMedian () {
	if (hasRequiredMedian) return Median_1;
	hasRequiredMedian = 1;
	var Median = function (values)
	{
	    var valuesNum = values.length;
	    if (valuesNum === 0)
	    {
	        return 0;
	    }

	    values.sort(function (a, b) { return a - b; });

	    var halfIndex = Math.floor(valuesNum / 2);

	    return valuesNum % 2 === 0
	        ? (values[halfIndex] + values[halfIndex - 1]) / 2
	        : values[halfIndex];
	};

	Median_1 = Median;
	return Median_1;
}

var MinSub_1;
var hasRequiredMinSub;

function requireMinSub () {
	if (hasRequiredMinSub) return MinSub_1;
	hasRequiredMinSub = 1;
	var MinSub = function (value, amount, min)
	{
	    return Math.max(value - amount, min);
	};

	MinSub_1 = MinSub;
	return MinSub_1;
}

var Percent_1;
var hasRequiredPercent;

function requirePercent () {
	if (hasRequiredPercent) return Percent_1;
	hasRequiredPercent = 1;
	var Percent = function (value, min, max, upperMax)
	{
	    if (max === undefined) { max = min + 1; }

	    var percentage = (value - min) / (max - min);

	    if (percentage > 1)
	    {
	        if (upperMax !== undefined)
	        {
	            percentage = ((upperMax - value)) / (upperMax - max);

	            if (percentage < 0)
	            {
	                percentage = 0;
	            }
	        }
	        else
	        {
	            percentage = 1;
	        }
	    }
	    else if (percentage < 0)
	    {
	        percentage = 0;
	    }

	    return percentage;
	};

	Percent_1 = Percent;
	return Percent_1;
}

var RadToDeg_1;
var hasRequiredRadToDeg;

function requireRadToDeg () {
	if (hasRequiredRadToDeg) return RadToDeg_1;
	hasRequiredRadToDeg = 1;
	var CONST = require_const$c();

	var RadToDeg = function (radians)
	{
	    return radians * CONST.RAD_TO_DEG;
	};

	RadToDeg_1 = RadToDeg;
	return RadToDeg_1;
}

var RandomXY_1;
var hasRequiredRandomXY;

function requireRandomXY () {
	if (hasRequiredRandomXY) return RandomXY_1;
	hasRequiredRandomXY = 1;
	var RandomXY = function (vector, scale)
	{
	    if (scale === undefined) { scale = 1; }

	    var r = Math.random() * 2 * Math.PI;

	    vector.x = Math.cos(r) * scale;
	    vector.y = Math.sin(r) * scale;

	    return vector;
	};

	RandomXY_1 = RandomXY;
	return RandomXY_1;
}

var RandomXYZ_1;
var hasRequiredRandomXYZ;

function requireRandomXYZ () {
	if (hasRequiredRandomXYZ) return RandomXYZ_1;
	hasRequiredRandomXYZ = 1;
	var RandomXYZ = function (vec3, radius)
	{
	    if (radius === undefined) { radius = 1; }

	    var r = Math.random() * 2 * Math.PI;
	    var z = (Math.random() * 2) - 1;
	    var zScale = Math.sqrt(1 - z * z) * radius;

	    vec3.x = Math.cos(r) * zScale;
	    vec3.y = Math.sin(r) * zScale;
	    vec3.z = z * radius;

	    return vec3;
	};

	RandomXYZ_1 = RandomXYZ;
	return RandomXYZ_1;
}

var RandomXYZW_1;
var hasRequiredRandomXYZW;

function requireRandomXYZW () {
	if (hasRequiredRandomXYZW) return RandomXYZW_1;
	hasRequiredRandomXYZW = 1;
	var RandomXYZW = function (vec4, scale)
	{
	    if (scale === undefined) { scale = 1; }

	    vec4.x = (Math.random() * 2 - 1) * scale;
	    vec4.y = (Math.random() * 2 - 1) * scale;
	    vec4.z = (Math.random() * 2 - 1) * scale;
	    vec4.w = (Math.random() * 2 - 1) * scale;

	    return vec4;
	};

	RandomXYZW_1 = RandomXYZW;
	return RandomXYZW_1;
}

var Rotate_1$2;
var hasRequiredRotate$2;

function requireRotate$2 () {
	if (hasRequiredRotate$2) return Rotate_1$2;
	hasRequiredRotate$2 = 1;
	var Rotate = function (point, angle)
	{
	    var x = point.x;
	    var y = point.y;

	    point.x = (x * Math.cos(angle)) - (y * Math.sin(angle));
	    point.y = (x * Math.sin(angle)) + (y * Math.cos(angle));

	    return point;
	};

	Rotate_1$2 = Rotate;
	return Rotate_1$2;
}

var RotateTo_1;
var hasRequiredRotateTo;

function requireRotateTo () {
	if (hasRequiredRotateTo) return RotateTo_1;
	hasRequiredRotateTo = 1;
	var RotateTo = function (point, x, y, angle, distance)
	{
	    point.x = x + (distance * Math.cos(angle));
	    point.y = y + (distance * Math.sin(angle));

	    return point;
	};

	RotateTo_1 = RotateTo;
	return RotateTo_1;
}

var RoundTo_1;
var hasRequiredRoundTo;

function requireRoundTo () {
	if (hasRequiredRoundTo) return RoundTo_1;
	hasRequiredRoundTo = 1;
	var RoundTo = function (value, place, base)
	{
	    if (place === undefined) { place = 0; }
	    if (base === undefined) { base = 10; }

	    var p = Math.pow(base, -place);

	    return Math.round(value * p) / p;
	};

	RoundTo_1 = RoundTo;
	return RoundTo_1;
}

var SinCosTableGenerator_1;
var hasRequiredSinCosTableGenerator;

function requireSinCosTableGenerator () {
	if (hasRequiredSinCosTableGenerator) return SinCosTableGenerator_1;
	hasRequiredSinCosTableGenerator = 1;
	var SinCosTableGenerator = function (length, sinAmp, cosAmp, frequency)
	{
	    if (sinAmp === undefined) { sinAmp = 1; }
	    if (cosAmp === undefined) { cosAmp = 1; }
	    if (frequency === undefined) { frequency = 1; }

	    frequency *= Math.PI / length;

	    var cos = [];
	    var sin = [];

	    for (var c = 0; c < length; c++)
	    {
	        cosAmp -= sinAmp * frequency;
	        sinAmp += cosAmp * frequency;

	        cos[c] = cosAmp;
	        sin[c] = sinAmp;
	    }

	    return {
	        sin: sin,
	        cos: cos,
	        length: length
	    };
	};

	SinCosTableGenerator_1 = SinCosTableGenerator;
	return SinCosTableGenerator_1;
}

var ToXY_1;
var hasRequiredToXY;

function requireToXY () {
	if (hasRequiredToXY) return ToXY_1;
	hasRequiredToXY = 1;
	var Vector2 = requireVector2();

	var ToXY = function (index, width, height, out)
	{
	    if (out === undefined) { out = new Vector2(); }

	    var x = 0;
	    var y = 0;
	    var total = width * height;

	    if (index > 0 && index <= total)
	    {
	        if (index > width - 1)
	        {
	            y = Math.floor(index / width);
	            x = index - (y * width);
	        }
	        else
	        {
	            x = index;
	        }
	    }

	    return out.set(x, y);
	};

	ToXY_1 = ToXY;
	return ToXY_1;
}

var Within_1;
var hasRequiredWithin;

function requireWithin () {
	if (hasRequiredWithin) return Within_1;
	hasRequiredWithin = 1;
	var Within = function (a, b, tolerance)
	{
	    return (Math.abs(a - b) <= tolerance);
	};

	Within_1 = Within;
	return Within_1;
}

var Vector4_1;
var hasRequiredVector4;

function requireVector4 () {
	if (hasRequiredVector4) return Vector4_1;
	hasRequiredVector4 = 1;
	var Class = requireClass();

	var Vector4 = new Class({

	    initialize:

	    function Vector4 (x, y, z, w)
	    {

	        this.x = 0;

	        this.y = 0;

	        this.z = 0;

	        this.w = 0;

	        if (typeof x === 'object')
	        {
	            this.x = x.x || 0;
	            this.y = x.y || 0;
	            this.z = x.z || 0;
	            this.w = x.w || 0;
	        }
	        else
	        {
	            this.x = x || 0;
	            this.y = y || 0;
	            this.z = z || 0;
	            this.w = w || 0;
	        }
	    },

	    clone: function ()
	    {
	        return new Vector4(this.x, this.y, this.z, this.w);
	    },

	    copy: function (src)
	    {
	        this.x = src.x;
	        this.y = src.y;
	        this.z = src.z || 0;
	        this.w = src.w || 0;

	        return this;
	    },

	    equals: function (v)
	    {
	        return ((this.x === v.x) && (this.y === v.y) && (this.z === v.z) && (this.w === v.w));
	    },

	    set: function (x, y, z, w)
	    {
	        if (typeof x === 'object')
	        {
	            this.x = x.x || 0;
	            this.y = x.y || 0;
	            this.z = x.z || 0;
	            this.w = x.w || 0;
	        }
	        else
	        {
	            this.x = x || 0;
	            this.y = y || 0;
	            this.z = z || 0;
	            this.w = w || 0;
	        }

	        return this;
	    },

	    add: function (v)
	    {
	        this.x += v.x;
	        this.y += v.y;
	        this.z += v.z || 0;
	        this.w += v.w || 0;

	        return this;
	    },

	    subtract: function (v)
	    {
	        this.x -= v.x;
	        this.y -= v.y;
	        this.z -= v.z || 0;
	        this.w -= v.w || 0;

	        return this;
	    },

	    scale: function (scale)
	    {
	        this.x *= scale;
	        this.y *= scale;
	        this.z *= scale;
	        this.w *= scale;

	        return this;
	    },

	    length: function ()
	    {
	        var x = this.x;
	        var y = this.y;
	        var z = this.z;
	        var w = this.w;

	        return Math.sqrt(x * x + y * y + z * z + w * w);
	    },

	    lengthSq: function ()
	    {
	        var x = this.x;
	        var y = this.y;
	        var z = this.z;
	        var w = this.w;

	        return x * x + y * y + z * z + w * w;
	    },

	    normalize: function ()
	    {
	        var x = this.x;
	        var y = this.y;
	        var z = this.z;
	        var w = this.w;
	        var len = x * x + y * y + z * z + w * w;

	        if (len > 0)
	        {
	            len = 1 / Math.sqrt(len);

	            this.x = x * len;
	            this.y = y * len;
	            this.z = z * len;
	            this.w = w * len;
	        }

	        return this;
	    },

	    dot: function (v)
	    {
	        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
	    },

	    lerp: function (v, t)
	    {
	        if (t === undefined) { t = 0; }

	        var ax = this.x;
	        var ay = this.y;
	        var az = this.z;
	        var aw = this.w;

	        this.x = ax + t * (v.x - ax);
	        this.y = ay + t * (v.y - ay);
	        this.z = az + t * (v.z - az);
	        this.w = aw + t * (v.w - aw);

	        return this;
	    },

	    multiply: function (v)
	    {
	        this.x *= v.x;
	        this.y *= v.y;
	        this.z *= v.z || 1;
	        this.w *= v.w || 1;

	        return this;
	    },

	    divide: function (v)
	    {
	        this.x /= v.x;
	        this.y /= v.y;
	        this.z /= v.z || 1;
	        this.w /= v.w || 1;

	        return this;
	    },

	    distance: function (v)
	    {
	        var dx = v.x - this.x;
	        var dy = v.y - this.y;
	        var dz = v.z - this.z || 0;
	        var dw = v.w - this.w || 0;

	        return Math.sqrt(dx * dx + dy * dy + dz * dz + dw * dw);
	    },

	    distanceSq: function (v)
	    {
	        var dx = v.x - this.x;
	        var dy = v.y - this.y;
	        var dz = v.z - this.z || 0;
	        var dw = v.w - this.w || 0;

	        return dx * dx + dy * dy + dz * dz + dw * dw;
	    },

	    negate: function ()
	    {
	        this.x = -this.x;
	        this.y = -this.y;
	        this.z = -this.z;
	        this.w = -this.w;

	        return this;
	    },

	    transformMat4: function (mat)
	    {
	        var x = this.x;
	        var y = this.y;
	        var z = this.z;
	        var w = this.w;
	        var m = mat.val;

	        this.x = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
	        this.y = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
	        this.z = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
	        this.w = m[3] * x + m[7] * y + m[11] * z + m[15] * w;

	        return this;
	    },

	    transformQuat: function (q)
	    {
	        var x = this.x;
	        var y = this.y;
	        var z = this.z;
	        var qx = q.x;
	        var qy = q.y;
	        var qz = q.z;
	        var qw = q.w;

	        var ix = qw * x + qy * z - qz * y;
	        var iy = qw * y + qz * x - qx * z;
	        var iz = qw * z + qx * y - qy * x;
	        var iw = -qx * x - qy * y - qz * z;

	        this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
	        this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
	        this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;

	        return this;
	    },

	    reset: function ()
	    {
	        this.x = 0;
	        this.y = 0;
	        this.z = 0;
	        this.w = 0;

	        return this;
	    }

	});

	Vector4.prototype.sub = Vector4.prototype.subtract;
	Vector4.prototype.mul = Vector4.prototype.multiply;
	Vector4.prototype.div = Vector4.prototype.divide;
	Vector4.prototype.dist = Vector4.prototype.distance;
	Vector4.prototype.distSq = Vector4.prototype.distanceSq;
	Vector4.prototype.len = Vector4.prototype.length;
	Vector4.prototype.lenSq = Vector4.prototype.lengthSq;

	Vector4_1 = Vector4;
	return Vector4_1;
}

var Matrix3_1;
var hasRequiredMatrix3;

function requireMatrix3 () {
	if (hasRequiredMatrix3) return Matrix3_1;
	hasRequiredMatrix3 = 1;
	var Class = requireClass();

	var Matrix3 = new Class({

	    initialize:

	    function Matrix3 (m)
	    {

	        this.val = new Float32Array(9);

	        if (m)
	        {

	            this.copy(m);
	        }
	        else
	        {

	            this.identity();
	        }
	    },

	    clone: function ()
	    {
	        return new Matrix3(this);
	    },

	    set: function (src)
	    {
	        return this.copy(src);
	    },

	    copy: function (src)
	    {
	        var out = this.val;
	        var a = src.val;

	        out[0] = a[0];
	        out[1] = a[1];
	        out[2] = a[2];
	        out[3] = a[3];
	        out[4] = a[4];
	        out[5] = a[5];
	        out[6] = a[6];
	        out[7] = a[7];
	        out[8] = a[8];

	        return this;
	    },

	    fromMat4: function (m)
	    {
	        var a = m.val;
	        var out = this.val;

	        out[0] = a[0];
	        out[1] = a[1];
	        out[2] = a[2];
	        out[3] = a[4];
	        out[4] = a[5];
	        out[5] = a[6];
	        out[6] = a[8];
	        out[7] = a[9];
	        out[8] = a[10];

	        return this;
	    },

	    fromArray: function (a)
	    {
	        var out = this.val;

	        out[0] = a[0];
	        out[1] = a[1];
	        out[2] = a[2];
	        out[3] = a[3];
	        out[4] = a[4];
	        out[5] = a[5];
	        out[6] = a[6];
	        out[7] = a[7];
	        out[8] = a[8];

	        return this;
	    },

	    identity: function ()
	    {
	        var out = this.val;

	        out[0] = 1;
	        out[1] = 0;
	        out[2] = 0;
	        out[3] = 0;
	        out[4] = 1;
	        out[5] = 0;
	        out[6] = 0;
	        out[7] = 0;
	        out[8] = 1;

	        return this;
	    },

	    transpose: function ()
	    {
	        var a = this.val;
	        var a01 = a[1];
	        var a02 = a[2];
	        var a12 = a[5];

	        a[1] = a[3];
	        a[2] = a[6];
	        a[3] = a01;
	        a[5] = a[7];
	        a[6] = a02;
	        a[7] = a12;

	        return this;
	    },

	    invert: function ()
	    {
	        var a = this.val;

	        var a00 = a[0];
	        var a01 = a[1];
	        var a02 = a[2];
	        var a10 = a[3];
	        var a11 = a[4];
	        var a12 = a[5];
	        var a20 = a[6];
	        var a21 = a[7];
	        var a22 = a[8];

	        var b01 = a22 * a11 - a12 * a21;
	        var b11 = -a22 * a10 + a12 * a20;
	        var b21 = a21 * a10 - a11 * a20;

	        var det = a00 * b01 + a01 * b11 + a02 * b21;

	        if (!det)
	        {
	            return null;
	        }

	        det = 1 / det;

	        a[0] = b01 * det;
	        a[1] = (-a22 * a01 + a02 * a21) * det;
	        a[2] = (a12 * a01 - a02 * a11) * det;
	        a[3] = b11 * det;
	        a[4] = (a22 * a00 - a02 * a20) * det;
	        a[5] = (-a12 * a00 + a02 * a10) * det;
	        a[6] = b21 * det;
	        a[7] = (-a21 * a00 + a01 * a20) * det;
	        a[8] = (a11 * a00 - a01 * a10) * det;

	        return this;
	    },

	    adjoint: function ()
	    {
	        var a = this.val;

	        var a00 = a[0];
	        var a01 = a[1];
	        var a02 = a[2];
	        var a10 = a[3];
	        var a11 = a[4];
	        var a12 = a[5];
	        var a20 = a[6];
	        var a21 = a[7];
	        var a22 = a[8];

	        a[0] = (a11 * a22 - a12 * a21);
	        a[1] = (a02 * a21 - a01 * a22);
	        a[2] = (a01 * a12 - a02 * a11);
	        a[3] = (a12 * a20 - a10 * a22);
	        a[4] = (a00 * a22 - a02 * a20);
	        a[5] = (a02 * a10 - a00 * a12);
	        a[6] = (a10 * a21 - a11 * a20);
	        a[7] = (a01 * a20 - a00 * a21);
	        a[8] = (a00 * a11 - a01 * a10);

	        return this;
	    },

	    determinant: function ()
	    {
	        var a = this.val;

	        var a00 = a[0];
	        var a01 = a[1];
	        var a02 = a[2];
	        var a10 = a[3];
	        var a11 = a[4];
	        var a12 = a[5];
	        var a20 = a[6];
	        var a21 = a[7];
	        var a22 = a[8];

	        return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
	    },

	    multiply: function (src)
	    {
	        var a = this.val;

	        var a00 = a[0];
	        var a01 = a[1];
	        var a02 = a[2];
	        var a10 = a[3];
	        var a11 = a[4];
	        var a12 = a[5];
	        var a20 = a[6];
	        var a21 = a[7];
	        var a22 = a[8];

	        var b = src.val;

	        var b00 = b[0];
	        var b01 = b[1];
	        var b02 = b[2];
	        var b10 = b[3];
	        var b11 = b[4];
	        var b12 = b[5];
	        var b20 = b[6];
	        var b21 = b[7];
	        var b22 = b[8];

	        a[0] = b00 * a00 + b01 * a10 + b02 * a20;
	        a[1] = b00 * a01 + b01 * a11 + b02 * a21;
	        a[2] = b00 * a02 + b01 * a12 + b02 * a22;

	        a[3] = b10 * a00 + b11 * a10 + b12 * a20;
	        a[4] = b10 * a01 + b11 * a11 + b12 * a21;
	        a[5] = b10 * a02 + b11 * a12 + b12 * a22;

	        a[6] = b20 * a00 + b21 * a10 + b22 * a20;
	        a[7] = b20 * a01 + b21 * a11 + b22 * a21;
	        a[8] = b20 * a02 + b21 * a12 + b22 * a22;

	        return this;
	    },

	    translate: function (v)
	    {
	        var a = this.val;
	        var x = v.x;
	        var y = v.y;

	        a[6] = x * a[0] + y * a[3] + a[6];
	        a[7] = x * a[1] + y * a[4] + a[7];
	        a[8] = x * a[2] + y * a[5] + a[8];

	        return this;
	    },

	    rotate: function (rad)
	    {
	        var a = this.val;

	        var a00 = a[0];
	        var a01 = a[1];
	        var a02 = a[2];
	        var a10 = a[3];
	        var a11 = a[4];
	        var a12 = a[5];

	        var s = Math.sin(rad);
	        var c = Math.cos(rad);

	        a[0] = c * a00 + s * a10;
	        a[1] = c * a01 + s * a11;
	        a[2] = c * a02 + s * a12;

	        a[3] = c * a10 - s * a00;
	        a[4] = c * a11 - s * a01;
	        a[5] = c * a12 - s * a02;

	        return this;
	    },

	    scale: function (v)
	    {
	        var a = this.val;
	        var x = v.x;
	        var y = v.y;

	        a[0] = x * a[0];
	        a[1] = x * a[1];
	        a[2] = x * a[2];

	        a[3] = y * a[3];
	        a[4] = y * a[4];
	        a[5] = y * a[5];

	        return this;
	    },

	    fromQuat: function (q)
	    {
	        var x = q.x;
	        var y = q.y;
	        var z = q.z;
	        var w = q.w;

	        var x2 = x + x;
	        var y2 = y + y;
	        var z2 = z + z;

	        var xx = x * x2;
	        var xy = x * y2;
	        var xz = x * z2;

	        var yy = y * y2;
	        var yz = y * z2;
	        var zz = z * z2;

	        var wx = w * x2;
	        var wy = w * y2;
	        var wz = w * z2;

	        var out = this.val;

	        out[0] = 1 - (yy + zz);
	        out[3] = xy + wz;
	        out[6] = xz - wy;

	        out[1] = xy - wz;
	        out[4] = 1 - (xx + zz);
	        out[7] = yz + wx;

	        out[2] = xz + wy;
	        out[5] = yz - wx;
	        out[8] = 1 - (xx + yy);

	        return this;
	    },

	    normalFromMat4: function (m)
	    {
	        var a = m.val;
	        var out = this.val;

	        var a00 = a[0];
	        var a01 = a[1];
	        var a02 = a[2];
	        var a03 = a[3];

	        var a10 = a[4];
	        var a11 = a[5];
	        var a12 = a[6];
	        var a13 = a[7];

	        var a20 = a[8];
	        var a21 = a[9];
	        var a22 = a[10];
	        var a23 = a[11];

	        var a30 = a[12];
	        var a31 = a[13];
	        var a32 = a[14];
	        var a33 = a[15];

	        var b00 = a00 * a11 - a01 * a10;
	        var b01 = a00 * a12 - a02 * a10;
	        var b02 = a00 * a13 - a03 * a10;
	        var b03 = a01 * a12 - a02 * a11;

	        var b04 = a01 * a13 - a03 * a11;
	        var b05 = a02 * a13 - a03 * a12;
	        var b06 = a20 * a31 - a21 * a30;
	        var b07 = a20 * a32 - a22 * a30;

	        var b08 = a20 * a33 - a23 * a30;
	        var b09 = a21 * a32 - a22 * a31;
	        var b10 = a21 * a33 - a23 * a31;
	        var b11 = a22 * a33 - a23 * a32;

	        var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

	        if (!det)
	        {
	            return null;
	        }

	        det = 1 / det;

	        out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
	        out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
	        out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;

	        out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
	        out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
	        out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;

	        out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
	        out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
	        out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;

	        return this;
	    }

	});

	Matrix3_1 = Matrix3;
	return Matrix3_1;
}

var Quaternion_1;
var hasRequiredQuaternion;

function requireQuaternion () {
	if (hasRequiredQuaternion) return Quaternion_1;
	hasRequiredQuaternion = 1;
	var Class = requireClass();
	var Matrix3 = requireMatrix3();
	var NOOP = requireNOOP();
	var Vector3 = requireVector3();

	var EPSILON = 0.000001;

	var siNext = new Int8Array([ 1, 2, 0 ]);
	var tmp = new Float32Array([ 0, 0, 0 ]);

	var xUnitVec3 = new Vector3(1, 0, 0);
	var yUnitVec3 = new Vector3(0, 1, 0);

	var tmpvec = new Vector3();
	var tmpMat3 = new Matrix3();

	var Quaternion = new Class({

	    initialize:

	    function Quaternion (x, y, z, w)
	    {

	        this.onChangeCallback = NOOP;

	        this.set(x, y, z, w);
	    },

	    x: {
	        get: function ()
	        {
	            return this._x;
	        },

	        set: function (value)
	        {
	            this._x = value;

	            this.onChangeCallback(this);
	        }
	    },

	    y: {
	        get: function ()
	        {
	            return this._y;
	        },

	        set: function (value)
	        {
	            this._y = value;

	            this.onChangeCallback(this);
	        }
	    },

	    z: {
	        get: function ()
	        {
	            return this._z;
	        },

	        set: function (value)
	        {
	            this._z = value;

	            this.onChangeCallback(this);
	        }
	    },

	    w: {
	        get: function ()
	        {
	            return this._w;
	        },

	        set: function (value)
	        {
	            this._w = value;

	            this.onChangeCallback(this);
	        }
	    },

	    copy: function (src)
	    {
	        return this.set(src);
	    },

	    set: function (x, y, z, w, update)
	    {
	        if (update === undefined) { update = true; }

	        if (typeof x === 'object')
	        {
	            this._x = x.x || 0;
	            this._y = x.y || 0;
	            this._z = x.z || 0;
	            this._w = x.w || 0;
	        }
	        else
	        {
	            this._x = x || 0;
	            this._y = y || 0;
	            this._z = z || 0;
	            this._w = w || 0;
	        }

	        if (update)
	        {
	            this.onChangeCallback(this);
	        }

	        return this;
	    },

	    add: function (v)
	    {
	        this._x += v.x;
	        this._y += v.y;
	        this._z += v.z;
	        this._w += v.w;

	        this.onChangeCallback(this);

	        return this;
	    },

	    subtract: function (v)
	    {
	        this._x -= v.x;
	        this._y -= v.y;
	        this._z -= v.z;
	        this._w -= v.w;

	        this.onChangeCallback(this);

	        return this;
	    },

	    scale: function (scale)
	    {
	        this._x *= scale;
	        this._y *= scale;
	        this._z *= scale;
	        this._w *= scale;

	        this.onChangeCallback(this);

	        return this;
	    },

	    length: function ()
	    {
	        var x = this.x;
	        var y = this.y;
	        var z = this.z;
	        var w = this.w;

	        return Math.sqrt(x * x + y * y + z * z + w * w);
	    },

	    lengthSq: function ()
	    {
	        var x = this.x;
	        var y = this.y;
	        var z = this.z;
	        var w = this.w;

	        return x * x + y * y + z * z + w * w;
	    },

	    normalize: function ()
	    {
	        var x = this.x;
	        var y = this.y;
	        var z = this.z;
	        var w = this.w;
	        var len = x * x + y * y + z * z + w * w;

	        if (len > 0)
	        {
	            len = 1 / Math.sqrt(len);

	            this._x = x * len;
	            this._y = y * len;
	            this._z = z * len;
	            this._w = w * len;
	        }

	        this.onChangeCallback(this);

	        return this;
	    },

	    dot: function (v)
	    {
	        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
	    },

	    lerp: function (v, t)
	    {
	        if (t === undefined) { t = 0; }

	        var ax = this.x;
	        var ay = this.y;
	        var az = this.z;
	        var aw = this.w;

	        return this.set(
	            ax + t * (v.x - ax),
	            ay + t * (v.y - ay),
	            az + t * (v.z - az),
	            aw + t * (v.w - aw)
	        );
	    },

	    rotationTo: function (a, b)
	    {
	        var dot = a.x * b.x + a.y * b.y + a.z * b.z;

	        if (dot < -0.999999)
	        {
	            if (tmpvec.copy(xUnitVec3).cross(a).length() < EPSILON)
	            {
	                tmpvec.copy(yUnitVec3).cross(a);
	            }

	            tmpvec.normalize();

	            return this.setAxisAngle(tmpvec, Math.PI);

	        }
	        else if (dot > 0.999999)
	        {
	            return this.set(0, 0, 0, 1);
	        }
	        else
	        {
	            tmpvec.copy(a).cross(b);

	            this._x = tmpvec.x;
	            this._y = tmpvec.y;
	            this._z = tmpvec.z;
	            this._w = 1 + dot;

	            return this.normalize();
	        }
	    },

	    setAxes: function (view, right, up)
	    {
	        var m = tmpMat3.val;

	        m[0] = right.x;
	        m[3] = right.y;
	        m[6] = right.z;

	        m[1] = up.x;
	        m[4] = up.y;
	        m[7] = up.z;

	        m[2] = -view.x;
	        m[5] = -view.y;
	        m[8] = -view.z;

	        return this.fromMat3(tmpMat3).normalize();
	    },

	    identity: function ()
	    {
	        return this.set(0, 0, 0, 1);
	    },

	    setAxisAngle: function (axis, rad)
	    {
	        rad = rad * 0.5;

	        var s = Math.sin(rad);

	        return this.set(
	            s * axis.x,
	            s * axis.y,
	            s * axis.z,
	            Math.cos(rad)
	        );
	    },

	    multiply: function (b)
	    {
	        var ax = this.x;
	        var ay = this.y;
	        var az = this.z;
	        var aw = this.w;

	        var bx = b.x;
	        var by = b.y;
	        var bz = b.z;
	        var bw = b.w;

	        return this.set(
	            ax * bw + aw * bx + ay * bz - az * by,
	            ay * bw + aw * by + az * bx - ax * bz,
	            az * bw + aw * bz + ax * by - ay * bx,
	            aw * bw - ax * bx - ay * by - az * bz
	        );
	    },

	    slerp: function (b, t)
	    {

	        var ax = this.x;
	        var ay = this.y;
	        var az = this.z;
	        var aw = this.w;

	        var bx = b.x;
	        var by = b.y;
	        var bz = b.z;
	        var bw = b.w;

	        var cosom = ax * bx + ay * by + az * bz + aw * bw;

	        if (cosom < 0)
	        {
	            cosom = -cosom;
	            bx = - bx;
	            by = - by;
	            bz = - bz;
	            bw = - bw;
	        }

	        var scale0 = 1 - t;
	        var scale1 = t;

	        if ((1 - cosom) > EPSILON)
	        {

	            var omega = Math.acos(cosom);
	            var sinom = Math.sin(omega);

	            scale0 = Math.sin((1.0 - t) * omega) / sinom;
	            scale1 = Math.sin(t * omega) / sinom;
	        }

	        return this.set(
	            scale0 * ax + scale1 * bx,
	            scale0 * ay + scale1 * by,
	            scale0 * az + scale1 * bz,
	            scale0 * aw + scale1 * bw
	        );
	    },

	    invert: function ()
	    {
	        var a0 = this.x;
	        var a1 = this.y;
	        var a2 = this.z;
	        var a3 = this.w;

	        var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
	        var invDot = (dot) ? 1 / dot : 0;

	        return this.set(
	            -a0 * invDot,
	            -a1 * invDot,
	            -a2 * invDot,
	            a3 * invDot
	        );
	    },

	    conjugate: function ()
	    {
	        this._x = -this.x;
	        this._y = -this.y;
	        this._z = -this.z;

	        this.onChangeCallback(this);

	        return this;
	    },

	    rotateX: function (rad)
	    {
	        rad *= 0.5;

	        var ax = this.x;
	        var ay = this.y;
	        var az = this.z;
	        var aw = this.w;

	        var bx = Math.sin(rad);
	        var bw = Math.cos(rad);

	        return this.set(
	            ax * bw + aw * bx,
	            ay * bw + az * bx,
	            az * bw - ay * bx,
	            aw * bw - ax * bx
	        );
	    },

	    rotateY: function (rad)
	    {
	        rad *= 0.5;

	        var ax = this.x;
	        var ay = this.y;
	        var az = this.z;
	        var aw = this.w;

	        var by = Math.sin(rad);
	        var bw = Math.cos(rad);

	        return this.set(
	            ax * bw - az * by,
	            ay * bw + aw * by,
	            az * bw + ax * by,
	            aw * bw - ay * by
	        );
	    },

	    rotateZ: function (rad)
	    {
	        rad *= 0.5;

	        var ax = this.x;
	        var ay = this.y;
	        var az = this.z;
	        var aw = this.w;

	        var bz = Math.sin(rad);
	        var bw = Math.cos(rad);

	        return this.set(
	            ax * bw + ay * bz,
	            ay * bw - ax * bz,
	            az * bw + aw * bz,
	            aw * bw - az * bz
	        );
	    },

	    calculateW: function ()
	    {
	        var x = this.x;
	        var y = this.y;
	        var z = this.z;

	        this.w = -Math.sqrt(1.0 - x * x - y * y - z * z);

	        return this;
	    },

	    setFromEuler: function (euler, update)
	    {
	        var x = euler.x / 2;
	        var y = euler.y / 2;
	        var z = euler.z / 2;

	        var c1 = Math.cos(x);
	        var c2 = Math.cos(y);
	        var c3 = Math.cos(z);

	        var s1 = Math.sin(x);
	        var s2 = Math.sin(y);
	        var s3 = Math.sin(z);

	        switch (euler.order)
	        {
	            case 'XYZ':
	            {
	                this.set(
	                    s1 * c2 * c3 + c1 * s2 * s3,
	                    c1 * s2 * c3 - s1 * c2 * s3,
	                    c1 * c2 * s3 + s1 * s2 * c3,
	                    c1 * c2 * c3 - s1 * s2 * s3,
	                    update
	                );

	                break;
	            }

	            case 'YXZ':
	            {
	                this.set(
	                    s1 * c2 * c3 + c1 * s2 * s3,
	                    c1 * s2 * c3 - s1 * c2 * s3,
	                    c1 * c2 * s3 - s1 * s2 * c3,
	                    c1 * c2 * c3 + s1 * s2 * s3,
	                    update
	                );

	                break;
	            }

	            case 'ZXY':
	            {
	                this.set(
	                    s1 * c2 * c3 - c1 * s2 * s3,
	                    c1 * s2 * c3 + s1 * c2 * s3,
	                    c1 * c2 * s3 + s1 * s2 * c3,
	                    c1 * c2 * c3 - s1 * s2 * s3,
	                    update
	                );

	                break;
	            }

	            case 'ZYX':
	            {
	                this.set(
	                    s1 * c2 * c3 - c1 * s2 * s3,
	                    c1 * s2 * c3 + s1 * c2 * s3,
	                    c1 * c2 * s3 - s1 * s2 * c3,
	                    c1 * c2 * c3 + s1 * s2 * s3,
	                    update
	                );

	                break;
	            }

	            case 'YZX':
	            {
	                this.set(
	                    s1 * c2 * c3 + c1 * s2 * s3,
	                    c1 * s2 * c3 + s1 * c2 * s3,
	                    c1 * c2 * s3 - s1 * s2 * c3,
	                    c1 * c2 * c3 - s1 * s2 * s3,
	                    update
	                );

	                break;
	            }

	            case 'XZY':
	            {
	                this.set(
	                    s1 * c2 * c3 - c1 * s2 * s3,
	                    c1 * s2 * c3 - s1 * c2 * s3,
	                    c1 * c2 * s3 + s1 * s2 * c3,
	                    c1 * c2 * c3 + s1 * s2 * s3,
	                    update
	                );

	                break;
	            }
	        }

	        return this;
	    },

	    setFromRotationMatrix: function (mat4)
	    {
	        var m = mat4.val;

	        var m11 = m[0];
	        var m12 = m[4];
	        var m13 = m[8];
	        var m21 = m[1];
	        var m22 = m[5];
	        var m23 = m[9];
	        var m31 = m[2];
	        var m32 = m[6];
	        var m33 = m[10];

	        var trace = m11 + m22 + m33;
	        var s;

	        if (trace > 0)
	        {
	            s = 0.5 / Math.sqrt(trace + 1.0);

	            this.set(
	                (m32 - m23) * s,
	                (m13 - m31) * s,
	                (m21 - m12) * s,
	                0.25 / s
	            );
	        }
	        else if (m11 > m22 && m11 > m33)
	        {
	            s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);

	            this.set(
	                0.25 * s,
	                (m12 + m21) / s,
	                (m13 + m31) / s,
	                (m32 - m23) / s
	            );
	        }
	        else if (m22 > m33)
	        {
	            s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);

	            this.set(
	                (m12 + m21) / s,
	                0.25 * s,
	                (m23 + m32) / s,
	                (m13 - m31) / s
	            );
	        }
	        else
	        {
	            s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);

	            this.set(
	                (m13 + m31) / s,
	                (m23 + m32) / s,
	                0.25 * s,
	                (m21 - m12) / s
	            );
	        }

	        return this;
	    },

	    fromMat3: function (mat)
	    {

	        var m = mat.val;
	        var fTrace = m[0] + m[4] + m[8];
	        var fRoot;

	        if (fTrace > 0)
	        {

	            fRoot = Math.sqrt(fTrace + 1.0); 

	            this.w = 0.5 * fRoot;

	            fRoot = 0.5 / fRoot; 

	            this._x = (m[7] - m[5]) * fRoot;
	            this._y = (m[2] - m[6]) * fRoot;
	            this._z = (m[3] - m[1]) * fRoot;
	        }
	        else
	        {

	            var i = 0;

	            if (m[4] > m[0])
	            {
	                i = 1;
	            }

	            if (m[8] > m[i * 3 + i])
	            {
	                i = 2;
	            }

	            var j = siNext[i];
	            var k = siNext[j];

	            fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1);
	            tmp[i] = 0.5 * fRoot;

	            fRoot = 0.5 / fRoot;

	            tmp[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
	            tmp[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;

	            this._x = tmp[0];
	            this._y = tmp[1];
	            this._z = tmp[2];
	            this._w = (m[k * 3 + j] - m[j * 3 + k]) * fRoot;
	        }

	        this.onChangeCallback(this);

	        return this;
	    }

	});

	Quaternion_1 = Quaternion;
	return Quaternion_1;
}

var RotateVec3_1;
var hasRequiredRotateVec3;

function requireRotateVec3 () {
	if (hasRequiredRotateVec3) return RotateVec3_1;
	hasRequiredRotateVec3 = 1;
	var Vector3 = requireVector3();
	var Matrix4 = requireMatrix4();
	var Quaternion = requireQuaternion();

	var tmpMat4 = new Matrix4();
	var tmpQuat = new Quaternion();
	var tmpVec3 = new Vector3();

	var RotateVec3 = function (vec, axis, radians)
	{

	    tmpQuat.setAxisAngle(axis, radians);

	    tmpMat4.fromRotationTranslation(tmpQuat, tmpVec3.set(0, 0, 0));

	    return vec.transformMat4(tmpMat4);
	};

	RotateVec3_1 = RotateVec3;
	return RotateVec3_1;
}

var math;
var hasRequiredMath;

function requireMath () {
	if (hasRequiredMath) return math;
	hasRequiredMath = 1;
	var CONST = require_const$c();
	var Extend = requireExtend$1();

	var HawkMath = {

	    Angle: requireAngle$1(),
	    Distance: requireDistance(),
	    Easing: requireEasing(),
	    Fuzzy: requireFuzzy(),
	    Interpolation: requireInterpolation(),
	    Pow2: requirePow2(),
	    Snap: requireSnap(),

	    RandomDataGenerator: requireRandomDataGenerator(),

	    Average: requireAverage(),
	    Bernstein: requireBernstein(),
	    Between: requireBetween$1(),
	    CatmullRom: requireCatmullRom(),
	    CeilTo: requireCeilTo(),
	    Clamp: requireClamp(),
	    DegToRad: requireDegToRad(),
	    Difference: requireDifference(),
	    Euler: requireEuler(),
	    Factorial: requireFactorial(),
	    FloatBetween: requireFloatBetween(),
	    FloorTo: requireFloorTo(),
	    FromPercent: requireFromPercent(),
	    GetSpeed: requireGetSpeed(),
	    IsEven: requireIsEven(),
	    IsEvenStrict: requireIsEvenStrict(),
	    Linear: requireLinear(),
	    LinearXY: requireLinearXY(),
	    MaxAdd: requireMaxAdd(),
	    Median: requireMedian(),
	    MinSub: requireMinSub(),
	    Percent: requirePercent(),
	    RadToDeg: requireRadToDeg(),
	    RandomXY: requireRandomXY(),
	    RandomXYZ: requireRandomXYZ(),
	    RandomXYZW: requireRandomXYZW(),
	    Rotate: requireRotate$2(),
	    RotateAround: requireRotateAround$1(),
	    RotateAroundDistance: requireRotateAroundDistance$1(),
	    RotateTo: requireRotateTo(),
	    RoundAwayFromZero: requireRoundAwayFromZero(),
	    RoundTo: requireRoundTo(),
	    SinCosTableGenerator: requireSinCosTableGenerator(),
	    SmootherStep: requireSmootherStep$1(),
	    SmoothStep: requireSmoothStep$1(),
	    ToXY: requireToXY(),
	    TransformXY: requireTransformXY(),
	    Within: requireWithin(),
	    Wrap: requireWrap$1(),

	    Vector2: requireVector2(),
	    Vector3: requireVector3(),
	    Vector4: requireVector4(),
	    Matrix3: requireMatrix3(),
	    Matrix4: requireMatrix4(),
	    Quaternion: requireQuaternion(),
	    RotateVec3: requireRotateVec3()

	};

	HawkMath = Extend(false, HawkMath, CONST);

	math = HawkMath;
	return math;
}

var _const$9;
var hasRequired_const$9;

function require_const$9 () {
	if (hasRequired_const$9) return _const$9;
	hasRequired_const$9 = 1;
	var PIPELINE_CONST = {

	    BITMAPMASK_PIPELINE: 'BitmapMaskPipeline',

	    LIGHT_PIPELINE: 'Light2D',

	    POINTLIGHT_PIPELINE: 'PointLightPipeline',

	    SINGLE_PIPELINE: 'SinglePipeline',

	    MULTI_PIPELINE: 'MultiPipeline',

	    ROPE_PIPELINE: 'RopePipeline',

	    GRAPHICS_PIPELINE: 'GraphicsPipeline',

	    POSTFX_PIPELINE: 'PostFXPipeline',

	    UTILITY_PIPELINE: 'UtilityPipeline',

	    MOBILE_PIPELINE: 'MobilePipeline',

	    FX_PIPELINE: 'FxPipeline'

	};

	_const$9 = PIPELINE_CONST;
	return _const$9;
}

var Config_1;
var hasRequiredConfig;

function requireConfig () {
	if (hasRequiredConfig) return Config_1;
	hasRequiredConfig = 1;
	var Class = requireClass();
	var CONST = require_const$f();
	var DefaultPlugins = requireDefaultPlugins();
	var Device = requireDevice();
	var GetFastValue = requireGetFastValue();
	var GetValue = requireGetValue();
	var IsPlainObject = requireIsPlainObject();
	var NOOP = requireNOOP();
	var HawkMath = requireMath();
	var PIPELINE_CONST = require_const$9();
	var ValueToColor = requireValueToColor();

	var Config = new Class({

	    initialize:

	    function Config (config)
	    {
	        if (config === undefined) { config = {}; }

	        var defaultBannerColor = [
	            '#ff0000',
	            '#ffff00',
	            '#00ff00',
	            '#00ffff',
	            '#000000'
	        ];

	        var defaultBannerTextColor = '#ffffff';

	        var scaleConfig = GetValue(config, 'scale', null);

	        this.width = GetValue(scaleConfig, 'width', 1024, config);

	        this.height = GetValue(scaleConfig, 'height', 768, config);

	        this.zoom = GetValue(scaleConfig, 'zoom', 1, config);

	        this.parent = GetValue(scaleConfig, 'parent', undefined, config);

	        this.scaleMode = GetValue(scaleConfig, (scaleConfig) ? 'mode' : 'scaleMode', 0, config);

	        this.expandParent = GetValue(scaleConfig, 'expandParent', true, config);

	        this.autoRound = GetValue(scaleConfig, 'autoRound', false, config);

	        this.autoCenter = GetValue(scaleConfig, 'autoCenter', 0, config);

	        this.resizeInterval = GetValue(scaleConfig, 'resizeInterval', 500, config);

	        this.fullscreenTarget = GetValue(scaleConfig, 'fullscreenTarget', null, config);

	        this.minWidth = GetValue(scaleConfig, 'min.width', 0, config);

	        this.maxWidth = GetValue(scaleConfig, 'max.width', 0, config);

	        this.minHeight = GetValue(scaleConfig, 'min.height', 0, config);

	        this.maxHeight = GetValue(scaleConfig, 'max.height', 0, config);

	        this.snapWidth = GetValue(scaleConfig, 'snap.width', 0, config);

	        this.snapHeight = GetValue(scaleConfig, 'snap.height', 0, config);

	        this.renderType = CONST.WEBGL;

	        this.canvas = GetValue(config, 'canvas', null);

	        this.context = GetValue(config, 'context', null);

	        this.canvasStyle = GetValue(config, 'canvasStyle', null);

	        this.customEnvironment = GetValue(config, 'customEnvironment', false);

	        this.sceneConfig = GetValue(config, 'scene', null);

	        this.seed = GetValue(config, 'seed', [ (Date.now() * Math.random()).toString() ]);

	        HawkMath.RND = new HawkMath.RandomDataGenerator(this.seed);

	        this.gameTitle = GetValue(config, 'title', '');

	        this.gameURL = GetValue(config, 'url', '');

	        this.gameVersion = GetValue(config, 'version', '');

	        this.autoFocus = GetValue(config, 'autoFocus', true);

	        this.stableSort = GetValue(config, 'stableSort', -1);

	        if (this.stableSort === -1)
	        {
	            this.stableSort = (Device.browser.es2019) ? 1 : 0;
	        }

	        Device.features.stableSort = this.stableSort;

	        this.domCreateContainer = GetValue(config, 'dom.createContainer', false);

	        this.domPointerEvents = GetValue(config, 'dom.pointerEvents', 'none');

	        this.inputKeyboard = GetValue(config, 'input.keyboard', true);

	        this.inputKeyboardEventTarget = GetValue(config, 'input.keyboard.target', window);

	        this.inputKeyboardCapture = GetValue(config, 'input.keyboard.capture', []);

	        this.inputMouse = GetValue(config, 'input.mouse', true);

	        this.inputMouseEventTarget = GetValue(config, 'input.mouse.target', null);

	        this.inputMousePreventDefaultDown = GetValue(config, 'input.mouse.preventDefaultDown', true);

	        this.inputMousePreventDefaultUp = GetValue(config, 'input.mouse.preventDefaultUp', true);

	        this.inputMousePreventDefaultMove = GetValue(config, 'input.mouse.preventDefaultMove', true);

	        this.inputMousePreventDefaultWheel = GetValue(config, 'input.mouse.preventDefaultWheel', true);

	        this.inputTouch = GetValue(config, 'input.touch', Device.input.touch);

	        this.inputTouchEventTarget = GetValue(config, 'input.touch.target', null);

	        this.inputTouchCapture = GetValue(config, 'input.touch.capture', true);

	        this.inputActivePointers = GetValue(config, 'input.activePointers', 1);

	        this.inputSmoothFactor = GetValue(config, 'input.smoothFactor', 0);

	        this.inputWindowEvents = GetValue(config, 'input.windowEvents', true);

	        this.inputGamepad = GetValue(config, 'input.gamepad', false);

	        this.inputGamepadEventTarget = GetValue(config, 'input.gamepad.target', window);

	        this.disableContextMenu = GetValue(config, 'disableContextMenu', false);

	        this.audio = GetValue(config, 'audio', {});

	        this.bannerTextColor = GetValue(config, 'banner.text', defaultBannerTextColor);

	        this.bannerBackgroundColor = GetValue(config, 'banner.background', defaultBannerColor);

	        this.fps = GetValue(config, 'fps', null);

	        this.disablePreFX = GetValue(config, 'disablePreFX', false);

	        this.disablePostFX = GetValue(config, 'disablePostFX', false);

	        var renderConfig = GetValue(config, 'render', null);

	        this.pipeline = GetValue(renderConfig, 'pipeline', null, config);

	        this.autoMobilePipeline = GetValue(renderConfig, 'autoMobilePipeline', true, config);

	        this.defaultPipeline = GetValue(renderConfig, 'defaultPipeline', PIPELINE_CONST.MULTI_PIPELINE, config);

	        this.antialias = GetValue(renderConfig, 'antialias', true, config);

	        this.antialiasGL = GetValue(renderConfig, 'antialiasGL', true, config);

	        this.mipmapFilter = GetValue(renderConfig, 'mipmapFilter', '', config);

	        this.desynchronized = GetValue(renderConfig, 'desynchronized', false, config);

	        this.roundPixels = GetValue(renderConfig, 'roundPixels', false, config);

	        this.pixelArt = GetValue(renderConfig, 'pixelArt', this.zoom !== 1, config);

	        if (this.pixelArt)
	        {
	            this.antialias = false;
	            this.antialiasGL = false;
	            this.roundPixels = true;
	        }

	        this.transparent = GetValue(renderConfig, 'transparent', false, config);

	        this.clearBeforeRender = GetValue(renderConfig, 'clearBeforeRender', true, config);

	        this.preserveDrawingBuffer = GetValue(renderConfig, 'preserveDrawingBuffer', false, config);

	        this.premultipliedAlpha = GetValue(renderConfig, 'premultipliedAlpha', true, config);

	        this.failIfMajorPerformanceCaveat = GetValue(renderConfig, 'failIfMajorPerformanceCaveat', false, config);

	        this.powerPreference = GetValue(renderConfig, 'powerPreference', 'default', config);

	        this.batchSize = GetValue(renderConfig, 'batchSize', 4096, config);

	        this.maxTextures = GetValue(renderConfig, 'maxTextures', -1, config);

	        this.maxLights = GetValue(renderConfig, 'maxLights', 10, config);

	        var bgc = GetValue(config, 'backgroundColor', 0);

	        this.backgroundColor = ValueToColor(bgc);

	        if (this.transparent)
	        {
	            this.backgroundColor = ValueToColor(0x000000);
	            this.backgroundColor.alpha = 0;
	        }

	        this.preBoot = GetValue(config, 'callbacks.preBoot', NOOP);

	        this.postBoot = GetValue(config, 'callbacks.postBoot', NOOP);

	        this.physics = GetValue(config, 'physics', {});

	        this.defaultPhysicsSystem = GetValue(this.physics, 'default', false);

	        this.loaderBaseURL = GetValue(config, 'loader.baseURL', '');

	        this.loaderPath = GetValue(config, 'loader.path', '');

	        this.loaderMaxParallelDownloads = GetValue(config, 'loader.maxParallelDownloads', (Device.os.android) ? 6 : 32);

	        this.loaderCrossOrigin = GetValue(config, 'loader.crossOrigin', undefined);

	        this.loaderResponseType = GetValue(config, 'loader.responseType', '');

	        this.loaderAsync = GetValue(config, 'loader.async', true);

	        this.loaderUser = GetValue(config, 'loader.user', '');

	        this.loaderPassword = GetValue(config, 'loader.password', '');

	        this.loaderTimeout = GetValue(config, 'loader.timeout', 0);

	        this.loaderMaxRetries = GetValue(config, 'loader.maxRetries', 2);

	        this.loaderWithCredentials = GetValue(config, 'loader.withCredentials', false);

	        this.loaderImageLoadType = GetValue(config, 'loader.imageLoadType', 'XHR');

	        this.loaderLocalScheme = GetValue(config, 'loader.localScheme', [ 'file://', 'capacitor://' ]);

	        this.glowFXQuality = GetValue(config, 'fx.glow.quality', 0.1);

	        this.glowFXDistance = GetValue(config, 'fx.glow.distance', 10);

	        this.installGlobalPlugins = [];

	        this.installScenePlugins = [];

	        var plugins = GetValue(config, 'plugins', null);
	        var defaultPlugins = DefaultPlugins.DefaultScene;

	        if (plugins)
	        {

	            if (Array.isArray(plugins))
	            {
	                this.defaultPlugins = plugins;
	            }
	            else if (IsPlainObject(plugins))
	            {
	                this.installGlobalPlugins = GetFastValue(plugins, 'global', []);
	                this.installScenePlugins = GetFastValue(plugins, 'scene', []);

	                if (Array.isArray(plugins.default))
	                {
	                    defaultPlugins = plugins.default;
	                }
	                else if (Array.isArray(plugins.defaultMerge))
	                {
	                    defaultPlugins = defaultPlugins.concat(plugins.defaultMerge);
	                }
	            }
	        }

	        this.defaultPlugins = defaultPlugins;

	        var pngPrefix = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAg';
	        this.defaultImage = GetValue(config, 'images.default', pngPrefix + 'AQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg==');
	        this.missingImage = GetValue(config, 'images.missing', pngPrefix + 'CAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg==');
	        this.whiteImage = GetValue(config, 'images.white', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAIAAAAmkwkpAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAABdJREFUeNpi/P//PwMMMDEgAdwcgAADAJZuAwXJYZOzAAAAAElFTkSuQmCC');
	    }

	});

	Config_1 = Config;
	return Config_1;
}

var CanvasInterpolation_1;
var hasRequiredCanvasInterpolation;

function requireCanvasInterpolation () {
	if (hasRequiredCanvasInterpolation) return CanvasInterpolation_1;
	hasRequiredCanvasInterpolation = 1;
	var CanvasInterpolation = {

	    setCrisp: function (canvas)
	    {
	        var types = [ 'optimizeSpeed', '-moz-crisp-edges', '-o-crisp-edges', '-webkit-optimize-contrast', 'optimize-contrast', 'crisp-edges', 'pixelated' ];

	        types.forEach(function (type)
	        {
	            canvas.style['image-rendering'] = type;
	        });

	        canvas.style.msInterpolationMode = 'nearest-neighbor';

	        return canvas;
	    },

	    setBicubic: function (canvas)
	    {
	        canvas.style['image-rendering'] = 'auto';
	        canvas.style.msInterpolationMode = 'bicubic';

	        return canvas;
	    }

	};

	CanvasInterpolation_1 = CanvasInterpolation;
	return CanvasInterpolation_1;
}

var CanvasSnapshot_1;
var hasRequiredCanvasSnapshot;

function requireCanvasSnapshot () {
	if (hasRequiredCanvasSnapshot) return CanvasSnapshot_1;
	hasRequiredCanvasSnapshot = 1;
	var CanvasPool = requireCanvasPool();
	var Color = requireColor$1();
	var GetFastValue = requireGetFastValue();

	var CanvasSnapshot = function (canvas, config)
	{
	    var callback = GetFastValue(config, 'callback');
	    var type = GetFastValue(config, 'type', 'image/png');
	    var encoderOptions = GetFastValue(config, 'encoder', 0.92);
	    var x = Math.abs(Math.round(GetFastValue(config, 'x', 0)));
	    var y = Math.abs(Math.round(GetFastValue(config, 'y', 0)));
	    var width = Math.floor(GetFastValue(config, 'width', canvas.width));
	    var height = Math.floor(GetFastValue(config, 'height', canvas.height));
	    var getPixel = GetFastValue(config, 'getPixel', false);

	    if (getPixel)
	    {
	        var context = canvas.getContext('2d', { willReadFrequently: false });
	        var imageData = context.getImageData(x, y, 1, 1);
	        var data = imageData.data;

	        callback.call(null, new Color(data[0], data[1], data[2], data[3]));
	    }
	    else if (x !== 0 || y !== 0 || width !== canvas.width || height !== canvas.height)
	    {

	        var copyCanvas = CanvasPool.createWebGL(this, width, height);
	        var ctx = copyCanvas.getContext('2d', { willReadFrequently: true });

	        if (width > 0 && height > 0)
	        {
	            ctx.drawImage(canvas, x, y, width, height, 0, 0, width, height);
	        }

	        var image1 = new Image();

	        image1.onerror = function ()
	        {
	            callback.call(null);

	            CanvasPool.remove(copyCanvas);
	        };

	        image1.onload = function ()
	        {
	            callback.call(null, image1);

	            CanvasPool.remove(copyCanvas);
	        };

	        image1.src = copyCanvas.toDataURL(type, encoderOptions);
	    }
	    else
	    {

	        var image2 = new Image();

	        image2.onerror = function ()
	        {
	            callback.call(null);
	        };

	        image2.onload = function ()
	        {
	            callback.call(null, image2);
	        };

	        image2.src = canvas.toDataURL(type, encoderOptions);
	    }
	};

	CanvasSnapshot_1 = CanvasSnapshot;
	return CanvasSnapshot_1;
}

var LOSE_WEBGL_EVENT;
var hasRequiredLOSE_WEBGL_EVENT;

function requireLOSE_WEBGL_EVENT () {
	if (hasRequiredLOSE_WEBGL_EVENT) return LOSE_WEBGL_EVENT;
	hasRequiredLOSE_WEBGL_EVENT = 1;
	LOSE_WEBGL_EVENT = 'losewebgl';
	return LOSE_WEBGL_EVENT;
}

var POST_RENDER_EVENT;
var hasRequiredPOST_RENDER_EVENT;

function requirePOST_RENDER_EVENT () {
	if (hasRequiredPOST_RENDER_EVENT) return POST_RENDER_EVENT;
	hasRequiredPOST_RENDER_EVENT = 1;
	POST_RENDER_EVENT = 'postrender';
	return POST_RENDER_EVENT;
}

var PRE_RENDER_EVENT;
var hasRequiredPRE_RENDER_EVENT;

function requirePRE_RENDER_EVENT () {
	if (hasRequiredPRE_RENDER_EVENT) return PRE_RENDER_EVENT;
	hasRequiredPRE_RENDER_EVENT = 1;
	PRE_RENDER_EVENT = 'prerender';
	return PRE_RENDER_EVENT;
}

var RENDER_EVENT;
var hasRequiredRENDER_EVENT;

function requireRENDER_EVENT () {
	if (hasRequiredRENDER_EVENT) return RENDER_EVENT;
	hasRequiredRENDER_EVENT = 1;
	RENDER_EVENT = 'render';
	return RENDER_EVENT;
}

var RESIZE_EVENT$1;
var hasRequiredRESIZE_EVENT$1;

function requireRESIZE_EVENT$1 () {
	if (hasRequiredRESIZE_EVENT$1) return RESIZE_EVENT$1;
	hasRequiredRESIZE_EVENT$1 = 1;
	RESIZE_EVENT$1 = 'resize';
	return RESIZE_EVENT$1;
}

var RESTORE_WEBGL_EVENT;
var hasRequiredRESTORE_WEBGL_EVENT;

function requireRESTORE_WEBGL_EVENT () {
	if (hasRequiredRESTORE_WEBGL_EVENT) return RESTORE_WEBGL_EVENT;
	hasRequiredRESTORE_WEBGL_EVENT = 1;
	RESTORE_WEBGL_EVENT = 'restorewebgl';
	return RESTORE_WEBGL_EVENT;
}

var events$d;
var hasRequiredEvents$d;

function requireEvents$d () {
	if (hasRequiredEvents$d) return events$d;
	hasRequiredEvents$d = 1;
	events$d = {

	    LOSE_WEBGL: requireLOSE_WEBGL_EVENT(),
	    POST_RENDER: requirePOST_RENDER_EVENT(),
	    PRE_RENDER: requirePRE_RENDER_EVENT(),
	    RENDER: requireRENDER_EVENT(),
	    RESIZE: requireRESIZE_EVENT$1(),
	    RESTORE_WEBGL: requireRESTORE_WEBGL_EVENT()

	};
	return events$d;
}

var GetBlendModes_1;
var hasRequiredGetBlendModes;

function requireGetBlendModes () {
	if (hasRequiredGetBlendModes) return GetBlendModes_1;
	hasRequiredGetBlendModes = 1;
	var modes = requireBlendModes();
	var CanvasFeatures = requireCanvasFeatures();

	var GetBlendModes = function ()
	{
	    var output = [];
	    var useNew = CanvasFeatures.supportNewBlendModes;
	    var so = 'source-over';

	    output[modes.NORMAL] = so;
	    output[modes.ADD] = 'lighter';
	    output[modes.MULTIPLY] = (useNew) ? 'multiply' : so;
	    output[modes.SCREEN] = (useNew) ? 'screen' : so;
	    output[modes.OVERLAY] = (useNew) ? 'overlay' : so;
	    output[modes.DARKEN] = (useNew) ? 'darken' : so;
	    output[modes.LIGHTEN] = (useNew) ? 'lighten' : so;
	    output[modes.COLOR_DODGE] = (useNew) ? 'color-dodge' : so;
	    output[modes.COLOR_BURN] = (useNew) ? 'color-burn' : so;
	    output[modes.HARD_LIGHT] = (useNew) ? 'hard-light' : so;
	    output[modes.SOFT_LIGHT] = (useNew) ? 'soft-light' : so;
	    output[modes.DIFFERENCE] = (useNew) ? 'difference' : so;
	    output[modes.EXCLUSION] = (useNew) ? 'exclusion' : so;
	    output[modes.HUE] = (useNew) ? 'hue' : so;
	    output[modes.SATURATION] = (useNew) ? 'saturation' : so;
	    output[modes.COLOR] = (useNew) ? 'color' : so;
	    output[modes.LUMINOSITY] = (useNew) ? 'luminosity' : so;
	    output[modes.ERASE] = 'destination-out';
	    output[modes.SOURCE_IN] = 'source-in';
	    output[modes.SOURCE_OUT] = 'source-out';
	    output[modes.SOURCE_ATOP] = 'source-atop';
	    output[modes.DESTINATION_OVER] = 'destination-over';
	    output[modes.DESTINATION_IN] = 'destination-in';
	    output[modes.DESTINATION_OUT] = 'destination-out';
	    output[modes.DESTINATION_ATOP] = 'destination-atop';
	    output[modes.LIGHTER] = 'lighter';
	    output[modes.COPY] = 'copy';
	    output[modes.XOR] = 'xor';

	    return output;
	};

	GetBlendModes_1 = GetBlendModes;
	return GetBlendModes_1;
}

var ADD_EVENT$1;
var hasRequiredADD_EVENT$1;

function requireADD_EVENT$1 () {
	if (hasRequiredADD_EVENT$1) return ADD_EVENT$1;
	hasRequiredADD_EVENT$1 = 1;
	ADD_EVENT$1 = 'addtexture';
	return ADD_EVENT$1;
}

var ADD_KEY_EVENT;
var hasRequiredADD_KEY_EVENT;

function requireADD_KEY_EVENT () {
	if (hasRequiredADD_KEY_EVENT) return ADD_KEY_EVENT;
	hasRequiredADD_KEY_EVENT = 1;
	ADD_KEY_EVENT = 'addtexture-';
	return ADD_KEY_EVENT;
}

var ERROR_EVENT;
var hasRequiredERROR_EVENT;

function requireERROR_EVENT () {
	if (hasRequiredERROR_EVENT) return ERROR_EVENT;
	hasRequiredERROR_EVENT = 1;
	ERROR_EVENT = 'onerror';
	return ERROR_EVENT;
}

var LOAD_EVENT;
var hasRequiredLOAD_EVENT;

function requireLOAD_EVENT () {
	if (hasRequiredLOAD_EVENT) return LOAD_EVENT;
	hasRequiredLOAD_EVENT = 1;
	LOAD_EVENT = 'onload';
	return LOAD_EVENT;
}

var READY_EVENT;
var hasRequiredREADY_EVENT;

function requireREADY_EVENT () {
	if (hasRequiredREADY_EVENT) return READY_EVENT;
	hasRequiredREADY_EVENT = 1;
	READY_EVENT = 'ready';
	return READY_EVENT;
}

var REMOVE_EVENT;
var hasRequiredREMOVE_EVENT;

function requireREMOVE_EVENT () {
	if (hasRequiredREMOVE_EVENT) return REMOVE_EVENT;
	hasRequiredREMOVE_EVENT = 1;
	REMOVE_EVENT = 'removetexture';
	return REMOVE_EVENT;
}

var REMOVE_KEY_EVENT;
var hasRequiredREMOVE_KEY_EVENT;

function requireREMOVE_KEY_EVENT () {
	if (hasRequiredREMOVE_KEY_EVENT) return REMOVE_KEY_EVENT;
	hasRequiredREMOVE_KEY_EVENT = 1;
	REMOVE_KEY_EVENT = 'removetexture-';
	return REMOVE_KEY_EVENT;
}

var events$c;
var hasRequiredEvents$c;

function requireEvents$c () {
	if (hasRequiredEvents$c) return events$c;
	hasRequiredEvents$c = 1;
	events$c = {

	    ADD: requireADD_EVENT$1(),
	    ADD_KEY: requireADD_KEY_EVENT(),
	    ERROR: requireERROR_EVENT(),
	    LOAD: requireLOAD_EVENT(),
	    READY: requireREADY_EVENT(),
	    REMOVE: requireREMOVE_EVENT(),
	    REMOVE_KEY: requireREMOVE_KEY_EVENT()

	};
	return events$c;
}

var CanvasRenderer_1;
var hasRequiredCanvasRenderer;

function requireCanvasRenderer () {
	if (hasRequiredCanvasRenderer) return CanvasRenderer_1;
	hasRequiredCanvasRenderer = 1;
	var CameraEvents = requireEvents$f();
	var CanvasSnapshot = requireCanvasSnapshot();
	var Class = requireClass();
	var CONST = require_const$f();
	var EventEmitter = requireEventemitter3();
	var Events = requireEvents$d();
	var GetBlendModes = requireGetBlendModes();
	var ScaleEvents = requireEvents$e();
	var TextureEvents = requireEvents$c();
	var GameEvents = requireEvents$h();
	var TransformMatrix = requireTransformMatrix();

	var CanvasRenderer = new Class({

	    Extends: EventEmitter,

	    initialize:

	    function CanvasRenderer (game)
	    {
	        EventEmitter.call(this);

	        var gameConfig = game.config;

	        this.config = {
	            clearBeforeRender: gameConfig.clearBeforeRender,
	            backgroundColor: gameConfig.backgroundColor,
	            antialias: gameConfig.antialias,
	            roundPixels: gameConfig.roundPixels,
	            transparent: gameConfig.transparent
	        };

	        this.game = game;

	        this.type = CONST.CANVAS;

	        this.drawCount = 0;

	        this.width = 0;

	        this.height = 0;

	        this.gameCanvas = game.canvas;

	        var contextOptions = {
	            alpha: gameConfig.transparent,
	            desynchronized: gameConfig.desynchronized,
	            willReadFrequently: false
	        };

	        this.gameContext = (gameConfig.context) ? gameConfig.context : this.gameCanvas.getContext('2d', contextOptions);

	        this.currentContext = this.gameContext;

	        this.antialias = gameConfig.antialias;

	        this.blendModes = GetBlendModes();

	        this.snapshotState = {
	            x: 0,
	            y: 0,
	            width: 1,
	            height: 1,
	            getPixel: false,
	            callback: null,
	            type: 'image/png',
	            encoder: 0.92
	        };

	        this._tempMatrix1 = new TransformMatrix();

	        this._tempMatrix2 = new TransformMatrix();

	        this._tempMatrix3 = new TransformMatrix();

	        this.isBooted = false;

	        this.init();
	    },

	    init: function ()
	    {
	        var game = this.game;

	        game.events.once(GameEvents.BOOT, function ()
	        {
	            var config = this.config;

	            if (!config.transparent)
	            {
	                var ctx = this.gameContext;
	                var gameCanvas = this.gameCanvas;

	                ctx.fillStyle = config.backgroundColor.rgba;
	                ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
	            }

	        }, this);

	        game.textures.once(TextureEvents.READY, this.boot, this);
	    },

	    boot: function ()
	    {
	        var game = this.game;

	        var baseSize = game.scale.baseSize;

	        this.width = baseSize.width;
	        this.height = baseSize.height;

	        this.isBooted = true;

	        game.scale.on(ScaleEvents.RESIZE, this.onResize, this);

	        this.resize(baseSize.width, baseSize.height);
	    },

	    onResize: function (gameSize, baseSize)
	    {

	        if (baseSize.width !== this.width || baseSize.height !== this.height)
	        {
	            this.resize(baseSize.width, baseSize.height);
	        }
	    },

	    resize: function (width, height)
	    {
	        this.width = width;
	        this.height = height;

	        this.emit(Events.RESIZE, width, height);
	    },

	    resetTransform: function ()
	    {
	        this.currentContext.setTransform(1, 0, 0, 1, 0, 0);
	    },

	    setBlendMode: function (blendMode)
	    {
	        this.currentContext.globalCompositeOperation = blendMode;

	        return this;
	    },

	    setContext: function (ctx)
	    {
	        this.currentContext = (ctx) ? ctx : this.gameContext;

	        return this;
	    },

	    setAlpha: function (alpha)
	    {
	        this.currentContext.globalAlpha = alpha;

	        return this;
	    },

	    preRender: function ()
	    {
	        var ctx = this.gameContext;
	        var config = this.config;

	        var width = this.width;
	        var height = this.height;

	        ctx.globalAlpha = 1;
	        ctx.globalCompositeOperation = 'source-over';
	        ctx.setTransform(1, 0, 0, 1, 0, 0);

	        this.emit(Events.PRE_RENDER_CLEAR);

	        if (config.clearBeforeRender)
	        {
	            ctx.clearRect(0, 0, width, height);

	            if (!config.transparent)
	            {
	                ctx.fillStyle = config.backgroundColor.rgba;
	                ctx.fillRect(0, 0, width, height);
	            }
	        }

	        ctx.save();

	        this.drawCount = 0;

	        this.emit(Events.PRE_RENDER);
	    },

	    render: function (scene, children, camera)
	    {
	        var childCount = children.length;

	        this.emit(Events.RENDER, scene, camera);

	        var cx = camera.x;
	        var cy = camera.y;
	        var cw = camera.width;
	        var ch = camera.height;

	        var ctx = (camera.renderToTexture) ? camera.context : scene.sys.context;

	        ctx.save();

	        if (this.game.scene.customViewports)
	        {
	            ctx.beginPath();
	            ctx.rect(cx, cy, cw, ch);
	            ctx.clip();
	        }

	        camera.emit(CameraEvents.PRE_RENDER, camera);

	        this.currentContext = ctx;

	        var mask = camera.mask;

	        if (mask)
	        {
	            mask.preRenderCanvas(this, null, camera._maskCamera);
	        }

	        if (!camera.transparent)
	        {
	            ctx.fillStyle = camera.backgroundColor.rgba;
	            ctx.fillRect(cx, cy, cw, ch);
	        }

	        ctx.globalAlpha = camera.alpha;

	        ctx.globalCompositeOperation = 'source-over';

	        this.drawCount += childCount;

	        if (camera.renderToTexture)
	        {
	            camera.emit(CameraEvents.PRE_RENDER, camera);
	        }

	        camera.matrix.copyToContext(ctx);

	        for (var i = 0; i < childCount; i++)
	        {
	            var child = children[i];

	            if (child.mask)
	            {
	                child.mask.preRenderCanvas(this, child, camera);
	            }

	            child.renderCanvas(this, child, camera);

	            if (child.mask)
	            {
	                child.mask.postRenderCanvas(this, child, camera);
	            }
	        }

	        ctx.setTransform(1, 0, 0, 1, 0, 0);
	        ctx.globalCompositeOperation = 'source-over';
	        ctx.globalAlpha = 1;

	        camera.flashEffect.postRenderCanvas(ctx);
	        camera.fadeEffect.postRenderCanvas(ctx);

	        camera.dirty = false;

	        if (mask)
	        {
	            mask.postRenderCanvas(this);
	        }

	        ctx.restore();

	        if (camera.renderToTexture)
	        {
	            camera.emit(CameraEvents.POST_RENDER, camera);

	            if (camera.renderToGame)
	            {
	                scene.sys.context.drawImage(camera.canvas, cx, cy);
	            }
	        }

	        camera.emit(CameraEvents.POST_RENDER, camera);
	    },

	    postRender: function ()
	    {
	        var ctx = this.gameContext;

	        ctx.restore();

	        this.emit(Events.POST_RENDER);

	        var state = this.snapshotState;

	        if (state.callback)
	        {
	            CanvasSnapshot(this.gameCanvas, state);

	            state.callback = null;
	        }
	    },

	    snapshotCanvas: function (canvas, callback, getPixel, x, y, width, height, type, encoderOptions)
	    {
	        if (getPixel === undefined) { getPixel = false; }

	        this.snapshotArea(x, y, width, height, callback, type, encoderOptions);

	        var state = this.snapshotState;

	        state.getPixel = getPixel;

	        CanvasSnapshot(canvas, state);

	        state.callback = null;

	        return this;
	    },

	    snapshot: function (callback, type, encoderOptions)
	    {
	        return this.snapshotArea(0, 0, this.gameCanvas.width, this.gameCanvas.height, callback, type, encoderOptions);
	    },

	    snapshotArea: function (x, y, width, height, callback, type, encoderOptions)
	    {
	        var state = this.snapshotState;

	        state.callback = callback;
	        state.type = type;
	        state.encoder = encoderOptions;
	        state.getPixel = false;
	        state.x = x;
	        state.y = y;
	        state.width = Math.min(width, this.gameCanvas.width);
	        state.height = Math.min(height, this.gameCanvas.height);

	        return this;
	    },

	    snapshotPixel: function (x, y, callback)
	    {
	        this.snapshotArea(x, y, 1, 1, callback);

	        this.snapshotState.getPixel = true;

	        return this;
	    },

	    batchSprite: function (sprite, frame, camera, parentTransformMatrix)
	    {
	        var alpha = camera.alpha * sprite.alpha;

	        if (alpha === 0)
	        {

	            return;
	        }

	        var ctx = this.currentContext;

	        var camMatrix = this._tempMatrix1;
	        var spriteMatrix = this._tempMatrix2;

	        var cd = frame.canvasData;

	        var frameX = cd.x;
	        var frameY = cd.y;
	        var frameWidth = frame.cutWidth;
	        var frameHeight = frame.cutHeight;
	        var customPivot = frame.customPivot;

	        var res = frame.source.resolution;

	        var displayOriginX = sprite.displayOriginX;
	        var displayOriginY = sprite.displayOriginY;

	        var x = -displayOriginX + frame.x;
	        var y = -displayOriginY + frame.y;

	        if (sprite.isCropped)
	        {
	            var crop = sprite._crop;

	            if (crop.flipX !== sprite.flipX || crop.flipY !== sprite.flipY)
	            {
	                frame.updateCropUVs(crop, sprite.flipX, sprite.flipY);
	            }

	            frameWidth = crop.cw;
	            frameHeight = crop.ch;

	            frameX = crop.cx;
	            frameY = crop.cy;

	            x = -displayOriginX + crop.x;
	            y = -displayOriginY + crop.y;

	            if (sprite.flipX)
	            {
	                if (x >= 0)
	                {
	                    x = -(x + frameWidth);
	                }
	                else if (x < 0)
	                {
	                    x = (Math.abs(x) - frameWidth);
	                }
	            }

	            if (sprite.flipY)
	            {
	                if (y >= 0)
	                {
	                    y = -(y + frameHeight);
	                }
	                else if (y < 0)
	                {
	                    y = (Math.abs(y) - frameHeight);
	                }
	            }
	        }

	        var flipX = 1;
	        var flipY = 1;

	        if (sprite.flipX)
	        {
	            if (!customPivot)
	            {
	                x += (-frame.realWidth + (displayOriginX * 2));
	            }

	            flipX = -1;
	        }

	        if (sprite.flipY)
	        {
	            if (!customPivot)
	            {
	                y += (-frame.realHeight + (displayOriginY * 2));
	            }

	            flipY = -1;
	        }

	        var gx = sprite.x;
	        var gy = sprite.y;

	        if (camera.roundPixels)
	        {
	            gx = Math.floor(gx);
	            gy = Math.floor(gy);
	        }

	        spriteMatrix.applyITRS(gx, gy, sprite.rotation, sprite.scaleX * flipX, sprite.scaleY * flipY);

	        camMatrix.copyFrom(camera.matrix);

	        if (parentTransformMatrix)
	        {

	            camMatrix.multiplyWithOffset(parentTransformMatrix, -camera.scrollX * sprite.scrollFactorX, -camera.scrollY * sprite.scrollFactorY);

	            spriteMatrix.e = gx;
	            spriteMatrix.f = gy;
	        }
	        else
	        {
	            spriteMatrix.e -= camera.scrollX * sprite.scrollFactorX;
	            spriteMatrix.f -= camera.scrollY * sprite.scrollFactorY;
	        }

	        camMatrix.multiply(spriteMatrix);

	        if (camera.renderRoundPixels)
	        {
	            camMatrix.e = Math.floor(camMatrix.e + 0.5);
	            camMatrix.f = Math.floor(camMatrix.f + 0.5);
	        }

	        ctx.save();

	        camMatrix.setToContext(ctx);

	        ctx.globalCompositeOperation = this.blendModes[sprite.blendMode];

	        ctx.globalAlpha = alpha;

	        ctx.imageSmoothingEnabled = !frame.source.scaleMode;

	        if (sprite.mask)
	        {
	            sprite.mask.preRenderCanvas(this, sprite, camera);
	        }

	        if (frameWidth > 0 && frameHeight > 0)
	        {
	            var fw = frameWidth / res;
	            var fh = frameHeight / res;

	            if (camera.roundPixels)
	            {
	                x = Math.floor(x + 0.5);
	                y = Math.floor(y + 0.5);
	                fw += 0.5;
	                fh += 0.5;
	            }

	            ctx.drawImage(
	                frame.source.image,
	                frameX, frameY,
	                frameWidth, frameHeight,
	                x, y,
	                fw, fh
	            );
	        }

	        if (sprite.mask)
	        {
	            sprite.mask.postRenderCanvas(this, sprite, camera);
	        }

	        ctx.restore();
	    },

	    destroy: function ()
	    {
	        this.removeAllListeners();

	        this.game = null;
	        this.gameCanvas = null;
	        this.gameContext = null;
	    }

	});

	CanvasRenderer_1 = CanvasRenderer;
	return CanvasRenderer_1;
}

var RenderTarget_1;
var hasRequiredRenderTarget;

function requireRenderTarget () {
	if (hasRequiredRenderTarget) return RenderTarget_1;
	hasRequiredRenderTarget = 1;
	var Class = requireClass();
	var Events = requireEvents$d();

	var RenderTarget = new Class({

	    initialize:

	    function RenderTarget (renderer, width, height, scale, minFilter, autoClear, autoResize, addDepthBuffer, forceClamp)
	    {
	        if (scale === undefined) { scale = 1; }
	        if (minFilter === undefined) { minFilter = 0; }
	        if (autoClear === undefined) { autoClear = true; }
	        if (autoResize === undefined) { autoResize = false; }
	        if (addDepthBuffer === undefined) { addDepthBuffer = true; }
	        if (forceClamp === undefined) { forceClamp = true; }

	        this.renderer = renderer;

	        this.framebuffer = null;

	        this.texture = null;

	        this.width = 0;

	        this.height = 0;

	        this.scale = scale;

	        this.minFilter = minFilter;

	        this.autoClear = autoClear;

	        this.autoResize = true;

	        this.hasDepthBuffer = addDepthBuffer;

	        this.forceClamp = forceClamp;

	        this.init(width, height);

	        if (autoResize)
	        {
	            this.renderer.on(Events.RESIZE, this.resize, this);
	        }
	        else
	        {

	            this.autoResize = false;
	        }
	    },

	    init: function (width, height)
	    {
	        var renderer = this.renderer;

	        this.texture = renderer.createTextureFromSource(null, width, height, this.minFilter, this.forceClamp);
	        this.framebuffer = renderer.createFramebuffer(width, height, this.texture, this.hasDepthBuffer);

	        this.width = width;
	        this.height = height;
	    },

	    setAutoResize: function (autoResize)
	    {
	        if (autoResize && !this.autoResize)
	        {
	            this.renderer.on(Events.RESIZE, this.resize, this);

	            this.autoResize = true;
	        }
	        else if (!autoResize && this.autoResize)
	        {
	            this.renderer.off(Events.RESIZE, this.resize, this);

	            this.autoResize = false;
	        }

	        return this;
	    },

	    resize: function (width, height)
	    {
	        if (this.autoResize && this.willResize(width, height))
	        {
	            var renderer = this.renderer;

	            renderer.deleteFramebuffer(this.framebuffer);

	            renderer.deleteTexture(this.texture);

	            this.texture = renderer.createTextureFromSource(null, width, height, this.minFilter, this.forceClamp);
	            this.framebuffer = renderer.createFramebuffer(width, height, this.texture, this.hasDepthBuffer);

	            this.width = width;
	            this.height = height;
	        }

	        return this;
	    },

	    willResize: function (width, height)
	    {
	        if (typeof width !== 'number' || typeof height !== 'number')
	        {
	            return false;
	        }

	        width = Math.round(width * this.scale);
	        height = Math.round(height * this.scale);

	        width = Math.max(width, 1);
	        height = Math.max(height, 1);

	        return (width !== this.width || height !== this.height);
	    },

	    bind: function (adjustViewport, width, height)
	    {
	        if (adjustViewport === undefined) { adjustViewport = false; }

	        var renderer = this.renderer;

	        if (adjustViewport)
	        {
	            renderer.flush();
	        }

	        if (width && height)
	        {
	            this.resize(width, height);
	        }

	        renderer.pushFramebuffer(this.framebuffer, false, false);

	        if (adjustViewport)
	        {
	            this.adjustViewport();
	        }

	        if (this.autoClear)
	        {
	            var gl = this.renderer.gl;

	            gl.clearColor(0, 0, 0, 0);

	            gl.clear(gl.COLOR_BUFFER_BIT);
	        }

	        renderer.clearStencilMask();
	    },

	    adjustViewport: function ()
	    {
	        var gl = this.renderer.gl;

	        gl.viewport(0, 0, this.width, this.height);

	        gl.disable(gl.SCISSOR_TEST);
	    },

	    clear: function (x, y, width, height)
	    {
	        var renderer = this.renderer;
	        var gl = renderer.gl;

	        renderer.pushFramebuffer(this.framebuffer);

	        if (x !== undefined && y !== undefined && width !== undefined && height !== undefined)
	        {
	            gl.enable(gl.SCISSOR_TEST);
	            gl.scissor(x, y, width, height);
	        }
	        else
	        {
	            gl.disable(gl.SCISSOR_TEST);
	        }

	        gl.clearColor(0, 0, 0, 0);

	        gl.clear(gl.COLOR_BUFFER_BIT);

	        renderer.popFramebuffer();

	        renderer.resetScissor();
	    },

	    unbind: function (flush)
	    {
	        if (flush === undefined) { flush = false; }

	        var renderer = this.renderer;

	        if (flush)
	        {
	            renderer.flush();
	        }

	        return renderer.popFramebuffer();
	    },

	    destroy: function ()
	    {
	        var renderer = this.renderer;

	        renderer.off(Events.RESIZE, this.resize, this);

	        renderer.deleteFramebuffer(this.framebuffer);
	        renderer.deleteTexture(this.texture);

	        this.renderer = null;
	        this.framebuffer = null;
	        this.texture = null;
	    }

	});

	RenderTarget_1 = RenderTarget;
	return RenderTarget_1;
}

var BitmapMaskFrag;
var hasRequiredBitmapMaskFrag;

function requireBitmapMaskFrag () {
	if (hasRequiredBitmapMaskFrag) return BitmapMaskFrag;
	hasRequiredBitmapMaskFrag = 1;
	BitmapMaskFrag = [
	    '#define SHADER_NAME PHASER_BITMAP_MASK_FS',
	    'precision mediump float;',
	    'uniform vec2 uResolution;',
	    'uniform sampler2D uMainSampler;',
	    'uniform sampler2D uMaskSampler;',
	    'uniform bool uInvertMaskAlpha;',
	    'void main ()',
	    '{',
	    '    vec2 uv = gl_FragCoord.xy / uResolution;',
	    '    vec4 mainColor = texture2D(uMainSampler, uv);',
	    '    vec4 maskColor = texture2D(uMaskSampler, uv);',
	    '    if (!uInvertMaskAlpha)',
	    '    {',
	    '        mainColor *= maskColor.a;',
	    '    }',
	    '    else',
	    '    {',
	    '        mainColor *= (1.0 - maskColor.a);',
	    '    }',
	    '    gl_FragColor = mainColor;',
	    '}',
	].join('\n');
	return BitmapMaskFrag;
}

var BitmapMaskVert;
var hasRequiredBitmapMaskVert;

function requireBitmapMaskVert () {
	if (hasRequiredBitmapMaskVert) return BitmapMaskVert;
	hasRequiredBitmapMaskVert = 1;
	BitmapMaskVert = [
	    '#define SHADER_NAME PHASER_BITMAP_MASK_VS',
	    'precision mediump float;',
	    'attribute vec2 inPosition;',
	    'void main ()',
	    '{',
	    '    gl_Position = vec4(inPosition, 0.0, 1.0);',
	    '}',
	].join('\n');
	return BitmapMaskVert;
}

var _const$8;
var hasRequired_const$8;

function require_const$8 () {
	if (hasRequired_const$8) return _const$8;
	hasRequired_const$8 = 1;
	var WEBGL_CONST = {

	    BYTE: { enum: 0x1400, size: 1 },

	    UNSIGNED_BYTE: { enum: 0x1401, size: 1 },

	    SHORT: { enum: 0x1402, size: 2 },

	    UNSIGNED_SHORT: { enum: 0x1403, size: 2 },

	    INT: { enum: 0x1404, size: 4 },

	    UNSIGNED_INT: { enum: 0x1405, size: 4 },

	    FLOAT: { enum: 0x1406, size: 4 }

	};

	_const$8 = WEBGL_CONST;
	return _const$8;
}

var AFTER_FLUSH_EVENT;
var hasRequiredAFTER_FLUSH_EVENT;

function requireAFTER_FLUSH_EVENT () {
	if (hasRequiredAFTER_FLUSH_EVENT) return AFTER_FLUSH_EVENT;
	hasRequiredAFTER_FLUSH_EVENT = 1;
	AFTER_FLUSH_EVENT = 'pipelineafterflush';
	return AFTER_FLUSH_EVENT;
}

var BEFORE_FLUSH_EVENT;
var hasRequiredBEFORE_FLUSH_EVENT;

function requireBEFORE_FLUSH_EVENT () {
	if (hasRequiredBEFORE_FLUSH_EVENT) return BEFORE_FLUSH_EVENT;
	hasRequiredBEFORE_FLUSH_EVENT = 1;
	BEFORE_FLUSH_EVENT = 'pipelinebeforeflush';
	return BEFORE_FLUSH_EVENT;
}

var BIND_EVENT;
var hasRequiredBIND_EVENT;

function requireBIND_EVENT () {
	if (hasRequiredBIND_EVENT) return BIND_EVENT;
	hasRequiredBIND_EVENT = 1;
	BIND_EVENT = 'pipelinebind';
	return BIND_EVENT;
}

var BOOT_EVENT$1;
var hasRequiredBOOT_EVENT$1;

function requireBOOT_EVENT$1 () {
	if (hasRequiredBOOT_EVENT$1) return BOOT_EVENT$1;
	hasRequiredBOOT_EVENT$1 = 1;
	BOOT_EVENT$1 = 'pipelineboot';
	return BOOT_EVENT$1;
}

var DESTROY_EVENT$2;
var hasRequiredDESTROY_EVENT$2;

function requireDESTROY_EVENT$2 () {
	if (hasRequiredDESTROY_EVENT$2) return DESTROY_EVENT$2;
	hasRequiredDESTROY_EVENT$2 = 1;
	DESTROY_EVENT$2 = 'pipelinedestroy';
	return DESTROY_EVENT$2;
}

var REBIND_EVENT;
var hasRequiredREBIND_EVENT;

function requireREBIND_EVENT () {
	if (hasRequiredREBIND_EVENT) return REBIND_EVENT;
	hasRequiredREBIND_EVENT = 1;
	REBIND_EVENT = 'pipelinerebind';
	return REBIND_EVENT;
}

var RESIZE_EVENT;
var hasRequiredRESIZE_EVENT;

function requireRESIZE_EVENT () {
	if (hasRequiredRESIZE_EVENT) return RESIZE_EVENT;
	hasRequiredRESIZE_EVENT = 1;
	RESIZE_EVENT = 'pipelineresize';
	return RESIZE_EVENT;
}

var events$b;
var hasRequiredEvents$b;

function requireEvents$b () {
	if (hasRequiredEvents$b) return events$b;
	hasRequiredEvents$b = 1;
	events$b = {

	    AFTER_FLUSH: requireAFTER_FLUSH_EVENT(),
	    BEFORE_FLUSH: requireBEFORE_FLUSH_EVENT(),
	    BIND: requireBIND_EVENT(),
	    BOOT: requireBOOT_EVENT$1(),
	    DESTROY: requireDESTROY_EVENT$2(),
	    REBIND: requireREBIND_EVENT(),
	    RESIZE: requireRESIZE_EVENT()

	};
	return events$b;
}

var Utils;
var hasRequiredUtils$1;

function requireUtils$1 () {
	if (hasRequiredUtils$1) return Utils;
	hasRequiredUtils$1 = 1;
	Utils = {

	    getTintFromFloats: function (r, g, b, a)
	    {
	        var ur = ((r * 255) | 0) & 0xff;
	        var ug = ((g * 255) | 0) & 0xff;
	        var ub = ((b * 255) | 0) & 0xff;
	        var ua = ((a * 255) | 0) & 0xff;

	        return ((ua << 24) | (ur << 16) | (ug << 8) | ub) >>> 0;
	    },

	    getTintAppendFloatAlpha: function (rgb, a)
	    {
	        var ua = ((a * 255) | 0) & 0xff;

	        return ((ua << 24) | rgb) >>> 0;
	    },

	    getTintAppendFloatAlphaAndSwap: function (rgb, a)
	    {
	        var ur = ((rgb >> 16) | 0) & 0xff;
	        var ug = ((rgb >> 8) | 0) & 0xff;
	        var ub = (rgb | 0) & 0xff;
	        var ua = ((a * 255) | 0) & 0xff;

	        return ((ua << 24) | (ub << 16) | (ug << 8) | ur) >>> 0;
	    },

	    getFloatsFromUintRGB: function (rgb)
	    {
	        var ur = ((rgb >> 16) | 0) & 0xff;
	        var ug = ((rgb >> 8) | 0) & 0xff;
	        var ub = (rgb | 0) & 0xff;

	        return [ ur / 255, ug / 255, ub / 255 ];
	    },

	    checkShaderMax: function (gl, maxTextures)
	    {

	        var gpuMax = Math.min(16, gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS));

	        if (!maxTextures || maxTextures === -1)
	        {
	            return gpuMax;
	        }
	        else
	        {
	            return Math.min(gpuMax, maxTextures);
	        }
	    },

	    parseFragmentShaderMaxTextures: function (fragmentShaderSource, maxTextures)
	    {
	        if (!fragmentShaderSource)
	        {
	            return '';
	        }

	        var src = '';

	        for (var i = 0; i < maxTextures; i++)
	        {
	            if (i > 0)
	            {
	                src += '\n\telse ';
	            }

	            if (i < maxTextures - 1)
	            {
	                src += 'if (outTexId < ' + i + '.5)';
	            }

	            src += '\n\t{';
	            src += '\n\t\ttexture = texture2D(uMainSampler[' + i + '], outTexCoord);';
	            src += '\n\t}';
	        }

	        fragmentShaderSource = fragmentShaderSource.replace(/%count%/gi, maxTextures.toString());

	        return fragmentShaderSource.replace(/%forloop%/gi, src);
	    },

	    setGlowQuality: function (shader, game, quality, distance)
	    {
	        if (quality === undefined)
	        {
	            quality = game.config.glowFXQuality;
	        }

	        if (distance === undefined)
	        {
	            distance = game.config.glowFXDistance;
	        }

	        shader = shader.replace(/__SIZE__/gi, (1 / quality / distance).toFixed(7));
	        shader = shader.replace(/__DIST__/gi, distance.toFixed(0) + '.0');

	        return shader;
	    }

	};
	return Utils;
}

var WebGLShader_1;
var hasRequiredWebGLShader;

function requireWebGLShader () {
	if (hasRequiredWebGLShader) return WebGLShader_1;
	hasRequiredWebGLShader = 1;
	var Class = requireClass();
	var ArrayEach = requireEach();
	var GetFastValue = requireGetFastValue();
	var WEBGL_CONST = require_const$8();

	var WebGLShader = new Class({

	    initialize:

	    function WebGLShader (pipeline, name, vertexShader, fragmentShader, attributes)
	    {

	        this.pipeline = pipeline;

	        this.name = name;

	        this.renderer = pipeline.renderer;

	        this.gl = this.renderer.gl;

	        this.fragSrc = fragmentShader;

	        this.vertSrc = vertexShader;

	        this.program = this.renderer.createProgram(vertexShader, fragmentShader);

	        this.attributes;

	        this.vertexComponentCount = 0;

	        this.vertexSize = 0;

	        this.uniforms = {};

	        this.createAttributes(attributes);
	        this.createUniforms();
	    },

	    createAttributes: function (attributes)
	    {
	        var count = 0;
	        var offset = 0;
	        var result = [];

	        this.vertexComponentCount = 0;

	        for (var i = 0; i < attributes.length; i++)
	        {
	            var element = attributes[i];

	            var name = element.name;
	            var size = GetFastValue(element, 'size', 1); 
	            var glType = GetFastValue(element, 'type', WEBGL_CONST.FLOAT);
	            var type = glType.enum; 
	            var typeSize = glType.size; 

	            var normalized = (element.normalized) ? true : false;

	            result.push({
	                name: name,
	                size: size,
	                type: type,
	                normalized: normalized,
	                offset: offset,
	                enabled: false,
	                location: -1
	            });

	            if (typeSize === 4)
	            {
	                count += size;
	            }
	            else
	            {
	                count++;
	            }

	            offset += size * typeSize;
	        }

	        this.vertexSize = offset;
	        this.vertexComponentCount = count;
	        this.attributes = result;
	    },

	    bind: function (setAttributes, flush)
	    {
	        if (setAttributes === undefined) { setAttributes = false; }
	        if (flush === undefined) { flush = false; }

	        if (flush)
	        {
	            this.pipeline.flush();
	        }

	        this.renderer.setProgram(this.program);

	        if (setAttributes)
	        {
	            this.setAttribPointers();
	        }

	        return this;
	    },

	    rebind: function ()
	    {
	        this.renderer.setProgram(this.program);

	        this.setAttribPointers(true);

	        return this;
	    },

	    setAttribPointers: function (reset)
	    {
	        if (reset === undefined) { reset = false; }

	        var gl = this.gl;
	        var renderer = this.renderer;
	        var vertexSize = this.vertexSize;
	        var attributes = this.attributes;
	        var program = this.program;

	        for (var i = 0; i < attributes.length; i++)
	        {
	            var element = attributes[i];

	            var size = element.size;
	            var type = element.type;
	            var offset = element.offset;
	            var enabled = element.enabled;
	            var location = element.location;
	            var normalized = (element.normalized) ? true : false;

	            if (reset)
	            {
	                if (location !== -1)
	                {
	                    renderer.deleteAttribLocation(location);
	                }
	                var attribLocation = this.renderer.createAttribLocation(program, element.name);

	                if (attribLocation.webGLAttribLocation >= 0)
	                {
	                    gl.enableVertexAttribArray(attribLocation.webGLAttribLocation);

	                    gl.vertexAttribPointer(attribLocation.webGLAttribLocation, size, type, normalized, vertexSize, offset);

	                    element.enabled = true;
	                    element.location = attribLocation;
	                }
	                else if (attribLocation.webGLAttribLocation !== -1)
	                {
	                    gl.disableVertexAttribArray(attribLocation.webGLAttribLocation);
	                }
	            }
	            else if (enabled)
	            {
	                gl.vertexAttribPointer(location.webGLAttribLocation, size, type, normalized, vertexSize, offset);
	            }
	            else if (!enabled && location !== -1 && location.webGLAttribLocation > -1)
	            {
	                gl.disableVertexAttribArray(location.webGLAttribLocation);

	                element.location = -1;
	            }
	        }

	        return this;
	    },

	    createUniforms: function ()
	    {
	        var gl = this.gl;
	        var program = this.program;
	        var uniforms = this.uniforms;

	        var i;
	        var name;
	        var location;

	        var totalUniforms = gl.getProgramParameter(program.webGLProgram, gl.ACTIVE_UNIFORMS);

	        for (i = 0; i < totalUniforms; i++)
	        {
	            var info = gl.getActiveUniform(program.webGLProgram, i);

	            if (info)
	            {
	                name = info.name;

	                location = this.renderer.createUniformLocation(program, name);

	                if (location !== null)
	                {
	                    uniforms[name] =
	                    {
	                        name: name,
	                        location: location,
	                        setter: null,
	                        value1: null,
	                        value2: null,
	                        value3: null,
	                        value4: null
	                    };
	                }

	                var struct = name.indexOf('[');

	                if (struct > 0)
	                {
	                    name = name.substr(0, struct);

	                    if (!uniforms.hasOwnProperty(name))
	                    {
	                        location = this.renderer.createUniformLocation(program, name);

	                        if (location !== null)
	                        {
	                            uniforms[name] =
	                            {
	                                name: name,
	                                location: location,
	                                setter: null,
	                                value1: null,
	                                value2: null,
	                                value3: null,
	                                value4: null
	                            };
	                        }
	                    }
	                }
	            }
	        }

	        return this;
	    },

	    syncUniforms: function ()
	    {
	        var gl = this.gl;
	        this.renderer.setProgram(this.program);
	        for (var name in this.uniforms)
	        {
	            var uniform = this.uniforms[name];

	            if (uniform.setter)
	            {
	                uniform.setter.call(gl, uniform.location.webGLUniformLocation, uniform.value1, uniform.value2, uniform.value3, uniform.value4);
	            }
	        }
	    },

	    hasUniform: function (name)
	    {
	        return this.uniforms.hasOwnProperty(name);
	    },

	    resetUniform: function (name)
	    {
	        var uniform = this.uniforms[name];

	        if (uniform)
	        {
	            uniform.value1 = null;
	            uniform.value2 = null;
	            uniform.value3 = null;
	            uniform.value4 = null;
	        }

	        return this;
	    },

	    setUniform1: function (setter, name, value1, skipCheck)
	    {
	        var uniform = this.uniforms[name];

	        if (!uniform)
	        {
	            return this;
	        }

	        if (skipCheck || uniform.value1 !== value1)
	        {
	            if (!uniform.setter)
	            {
	                uniform.setter = setter;
	            }

	            uniform.value1 = value1;

	            this.renderer.setProgram(this.program);

	            setter.call(this.gl, uniform.location.webGLUniformLocation, value1);

	            this.pipeline.currentShader = this;
	        }

	        return this;
	    },

	    setUniform2: function (setter, name, value1, value2, skipCheck)
	    {
	        var uniform = this.uniforms[name];

	        if (!uniform)
	        {
	            return this;
	        }

	        if (skipCheck || uniform.value1 !== value1 || uniform.value2 !== value2)
	        {
	            if (!uniform.setter)
	            {
	                uniform.setter = setter;
	            }

	            uniform.value1 = value1;
	            uniform.value2 = value2;

	            this.renderer.setProgram(this.program);

	            setter.call(this.gl, uniform.location.webGLUniformLocation, value1, value2);

	            this.pipeline.currentShader = this;
	        }

	        return this;
	    },

	    setUniform3: function (setter, name, value1, value2, value3, skipCheck)
	    {
	        var uniform = this.uniforms[name];

	        if (!uniform)
	        {
	            return this;
	        }

	        if (skipCheck || uniform.value1 !== value1 || uniform.value2 !== value2 || uniform.value3 !== value3)
	        {
	            if (!uniform.setter)
	            {
	                uniform.setter = setter;
	            }

	            uniform.value1 = value1;
	            uniform.value2 = value2;
	            uniform.value3 = value3;

	            this.renderer.setProgram(this.program);

	            setter.call(this.gl, uniform.location.webGLUniformLocation, value1, value2, value3);

	            this.pipeline.currentShader = this;
	        }

	        return this;
	    },

	    setUniform4: function (setter, name, value1, value2, value3, value4, skipCheck)
	    {
	        var uniform = this.uniforms[name];

	        if (!uniform)
	        {
	            return this;
	        }

	        if (skipCheck || uniform.value1 !== value1 || uniform.value2 !== value2 || uniform.value3 !== value3 || uniform.value4 !== value4)
	        {
	            if (!uniform.setter)
	            {
	                uniform.setter = setter;
	            }

	            uniform.value1 = value1;
	            uniform.value2 = value2;
	            uniform.value3 = value3;
	            uniform.value4 = value4;

	            this.renderer.setProgram(this.program);

	            setter.call(this.gl, uniform.location.webGLUniformLocation, value1, value2, value3, value4);

	            this.pipeline.currentShader = this;
	        }

	        return this;
	    },

	    setBoolean: function (name, value)
	    {
	        return this.setUniform1(this.gl.uniform1i, name, Number(value));
	    },

	    set1f: function (name, x)
	    {
	        return this.setUniform1(this.gl.uniform1f, name, x);
	    },

	    set2f: function (name, x, y)
	    {
	        return this.setUniform2(this.gl.uniform2f, name, x, y);
	    },

	    set3f: function (name, x, y, z)
	    {
	        return this.setUniform3(this.gl.uniform3f, name, x, y, z);
	    },

	    set4f: function (name, x, y, z, w)
	    {
	        return this.setUniform4(this.gl.uniform4f, name, x, y, z, w);
	    },

	    set1fv: function (name, arr)
	    {
	        return this.setUniform1(this.gl.uniform1fv, name, arr, true);
	    },

	    set2fv: function (name, arr)
	    {
	        return this.setUniform1(this.gl.uniform2fv, name, arr, true);
	    },

	    set3fv: function (name, arr)
	    {
	        return this.setUniform1(this.gl.uniform3fv, name, arr, true);
	    },

	    set4fv: function (name, arr)
	    {
	        return this.setUniform1(this.gl.uniform4fv, name, arr, true);
	    },

	    set1iv: function (name, arr)
	    {
	        return this.setUniform1(this.gl.uniform1iv, name, arr, true);
	    },

	    set2iv: function (name, arr)
	    {
	        return this.setUniform1(this.gl.uniform2iv, name, arr, true);
	    },

	    set3iv: function (name, arr)
	    {
	        return this.setUniform1(this.gl.uniform3iv, name, arr, true);
	    },

	    set4iv: function (name, arr)
	    {
	        return this.setUniform1(this.gl.uniform4iv, name, arr, true);
	    },

	    set1i: function (name, x)
	    {
	        return this.setUniform1(this.gl.uniform1i, name, x);
	    },

	    set2i: function (name, x, y)
	    {
	        return this.setUniform2(this.gl.uniform2i, name, x, y);
	    },

	    set3i: function (name, x, y, z)
	    {
	        return this.setUniform3(this.gl.uniform3i, name, x, y, z);
	    },

	    set4i: function (name, x, y, z, w)
	    {
	        return this.setUniform4(this.gl.uniform4i, name, x, y, z, w);
	    },

	    setMatrix2fv: function (name, transpose, matrix)
	    {
	        return this.setUniform2(this.gl.uniformMatrix2fv, name, transpose, matrix, true);
	    },

	    setMatrix3fv: function (name, transpose, matrix)
	    {
	        return this.setUniform2(this.gl.uniformMatrix3fv, name, transpose, matrix, true);
	    },

	    setMatrix4fv: function (name, transpose, matrix)
	    {
	        return this.setUniform2(this.gl.uniformMatrix4fv, name, transpose, matrix, true);
	    },

	    createProgram: function (vertSrc, fragSrc)
	    {
	        if (vertSrc === undefined) { vertSrc = this.vertSrc; }
	        if (fragSrc === undefined) { fragSrc = this.fragSrc; }

	        if (this.program)
	        {
	            this.renderer.deleteProgram(this.program);
	        }

	        this.vertSrc = vertSrc;
	        this.fragSrc = fragSrc;

	        this.program = this.renderer.createProgram(vertSrc, fragSrc);

	        this.createUniforms();

	        return this.rebind();
	    },

	    destroy: function ()
	    {
	        var renderer = this.renderer;
	        ArrayEach(this.uniforms, function (uniform)
	        {
	            renderer.deleteUniformLocation(uniform.location);
	        });
	        this.uniforms = null;

	        ArrayEach(this.attributes, function (attrib)
	        {
	            renderer.deleteAttribLocation(attrib.location);
	        });
	        this.attributes = null;

	        renderer.deleteProgram(this.program);

	        this.pipeline = null;
	        this.renderer = null;
	        this.gl = null;
	        this.program = null;
	    }

	});

	WebGLShader_1 = WebGLShader;
	return WebGLShader_1;
}

var WebGLPipeline_1;
var hasRequiredWebGLPipeline;

function requireWebGLPipeline () {
	if (hasRequiredWebGLPipeline) return WebGLPipeline_1;
	hasRequiredWebGLPipeline = 1;
	var Class = requireClass();
	var DeepCopy = requireDeepCopy();
	var EventEmitter = requireEventemitter3();
	var Events = requireEvents$b();
	var GetFastValue = requireGetFastValue();
	var Matrix4 = requireMatrix4();
	var RendererEvents = requireEvents$d();
	var RenderTarget = requireRenderTarget();
	var Utils = requireUtils$1();
	var WebGLShader = requireWebGLShader();

	var WebGLPipeline = new Class({

	    Extends: EventEmitter,

	    initialize:

	    function WebGLPipeline (config)
	    {
	        EventEmitter.call(this);

	        var game = config.game;
	        var renderer = game.renderer;
	        var gl = renderer.gl;

	        this.name = GetFastValue(config, 'name', 'WebGLPipeline');

	        this.game = game;

	        this.renderer = renderer;

	        this.manager;

	        this.gl = gl;

	        this.view = game.canvas;

	        this.width = 0;

	        this.height = 0;

	        this.vertexCount = 0;

	        this.vertexCapacity = 0;

	        this.vertexData;

	        this.vertexBuffer;

	        this.activeBuffer;

	        this.topology = GetFastValue(config, 'topology', gl.TRIANGLES);

	        this.bytes;

	        this.vertexViewF32;

	        this.vertexViewU32;

	        this.active = true;

	        this.forceZero = GetFastValue(config, 'forceZero', false);

	        this.hasBooted = false;

	        this.isPostFX = false;

	        this.isPreFX = false;

	        this.renderTargets = [];

	        this.currentRenderTarget;

	        this.shaders = [];

	        this.currentShader;

	        this.projectionMatrix;

	        this.projectionWidth = 0;

	        this.projectionHeight = 0;

	        this.config = config;

	        this.glReset = false;

	        this.batch = [];

	        this.currentBatch = null;

	        this.currentTexture = null;

	        this.currentUnit = 0;

	        this.activeTextures = [];

	        this.resizeUniform = GetFastValue(config, 'resizeUniform', '');
	    },

	    boot: function ()
	    {
	        var i;
	        var gl = this.gl;
	        var config = this.config;
	        var renderer = this.renderer;

	        if (!this.isPostFX)
	        {
	            this.projectionMatrix = new Matrix4().identity();
	        }

	        var renderTargets = this.renderTargets;

	        var targets = GetFastValue(config, 'renderTarget', false);

	        if (typeof(targets) === 'boolean' && targets)
	        {
	            targets = 1;
	        }

	        var width = renderer.width;
	        var height = renderer.height;

	        if (typeof(targets) === 'number')
	        {

	            for (i = 0; i < targets; i++)
	            {
	                renderTargets.push(new RenderTarget(renderer, width, height, 1, 0, true));
	            }
	        }
	        else if (Array.isArray(targets))
	        {
	            for (i = 0; i < targets.length; i++)
	            {
	                var scale = GetFastValue(targets[i], 'scale', 1);
	                var minFilter = GetFastValue(targets[i], 'minFilter', 0);
	                var autoClear = GetFastValue(targets[i], 'autoClear', 1);
	                var autoResize = GetFastValue(targets[i], 'autoResize', false);
	                var targetWidth = GetFastValue(targets[i], 'width', null);
	                var targetHeight = GetFastValue(targets[i], 'height', targetWidth);

	                if (targetWidth)
	                {
	                    renderTargets.push(new RenderTarget(renderer, targetWidth, targetHeight, 1, minFilter, autoClear, autoResize));
	                }
	                else
	                {
	                    renderTargets.push(new RenderTarget(renderer, width, height, scale, minFilter, autoClear, autoResize));
	                }
	            }
	        }

	        if (renderTargets.length)
	        {

	            this.currentRenderTarget = renderTargets[0];
	        }

	        this.setShadersFromConfig(config);

	        var shaders = this.shaders;
	        var vertexSize = 0;

	        for (i = 0; i < shaders.length; i++)
	        {
	            if (shaders[i].vertexSize > vertexSize)
	            {
	                vertexSize = shaders[i].vertexSize;
	            }
	        }

	        var batchSize = GetFastValue(config, 'batchSize', renderer.config.batchSize);

	        this.vertexCapacity = batchSize * 6;

	        var data = new ArrayBuffer(this.vertexCapacity * vertexSize);

	        this.vertexData = data;
	        this.bytes = new Uint8Array(data);
	        this.vertexViewF32 = new Float32Array(data);
	        this.vertexViewU32 = new Uint32Array(data);

	        var configVerts = GetFastValue(config, 'vertices', null);

	        if (configVerts)
	        {
	            this.vertexViewF32.set(configVerts);

	            this.vertexBuffer = renderer.createVertexBuffer(data, gl.STATIC_DRAW);
	        }
	        else
	        {
	            this.vertexBuffer = renderer.createVertexBuffer(data.byteLength, gl.DYNAMIC_DRAW);
	        }

	        this.setVertexBuffer();

	        for (i = shaders.length - 1; i >= 0; i--)
	        {
	            shaders[i].rebind();
	        }

	        this.hasBooted = true;

	        renderer.on(RendererEvents.RESIZE, this.resize, this);
	        renderer.on(RendererEvents.PRE_RENDER, this.onPreRender, this);
	        renderer.on(RendererEvents.RENDER, this.onRender, this);
	        renderer.on(RendererEvents.POST_RENDER, this.onPostRender, this);

	        this.emit(Events.BOOT, this);

	        this.onBoot();
	    },

	    onBoot: function ()
	    {
	    },

	    onResize: function ()
	    {
	    },

	    setShader: function (shader, setAttributes, vertexBuffer)
	    {
	        var renderer = this.renderer;

	        if (shader !== this.currentShader || renderer.currentProgram !== this.currentShader.program)
	        {
	            this.flush();

	            var wasBound = this.setVertexBuffer(vertexBuffer);

	            if (wasBound && !setAttributes)
	            {
	                setAttributes = true;
	            }

	            shader.bind(setAttributes, false);

	            this.currentShader = shader;
	        }

	        return this;
	    },

	    getShaderByName: function (name)
	    {
	        var shaders = this.shaders;

	        for (var i = 0; i < shaders.length; i++)
	        {
	            if (shaders[i].name === name)
	            {
	                return shaders[i];
	            }
	        }
	    },

	    setShadersFromConfig: function (config)
	    {
	        var i;
	        var shaders = this.shaders;
	        var renderer = this.renderer;

	        for (i = 0; i < shaders.length; i++)
	        {
	            shaders[i].destroy();
	        }

	        var vName = 'vertShader';
	        var fName = 'fragShader';
	        var aName = 'attributes';

	        var defaultVertShader = GetFastValue(config, vName, null);
	        var defaultFragShader = Utils.parseFragmentShaderMaxTextures(GetFastValue(config, fName, null), renderer.maxTextures);
	        var defaultAttribs = GetFastValue(config, aName, null);

	        var configShaders = GetFastValue(config, 'shaders', []);

	        var len = configShaders.length;

	        if (len === 0)
	        {
	            if (defaultVertShader && defaultFragShader)
	            {
	                this.shaders = [ new WebGLShader(this, 'default', defaultVertShader, defaultFragShader, DeepCopy(defaultAttribs)) ];
	            }
	        }
	        else
	        {
	            var newShaders = [];

	            for (i = 0; i < len; i++)
	            {
	                var shaderEntry = configShaders[i];

	                var name;
	                var vertShader;
	                var fragShader;
	                var attributes;

	                if (typeof shaderEntry === 'string')
	                {
	                    name = 'default';
	                    vertShader = defaultVertShader;
	                    fragShader = Utils.parseFragmentShaderMaxTextures(shaderEntry, renderer.maxTextures);
	                    attributes = defaultAttribs;
	                }
	                else
	                {
	                    name = GetFastValue(shaderEntry, 'name', 'default');
	                    vertShader = GetFastValue(shaderEntry, vName, defaultVertShader);
	                    fragShader = Utils.parseFragmentShaderMaxTextures(GetFastValue(shaderEntry, fName, defaultFragShader), renderer.maxTextures);
	                    attributes = GetFastValue(shaderEntry, aName, defaultAttribs);
	                }

	                if (name === 'default')
	                {
	                    var lines = fragShader.split('\n');
	                    var test = lines[0].trim();

	                    if (test.indexOf('#define SHADER_NAME') > -1)
	                    {
	                        name = test.substring(20);
	                    }
	                }

	                if (vertShader && fragShader)
	                {
	                    newShaders.push(new WebGLShader(this, name, vertShader, fragShader, DeepCopy(attributes)));
	                }
	            }

	            this.shaders = newShaders;
	        }

	        if (this.shaders.length === 0)
	        {
	            console.warn('Pipeline: ' + this.name + ' - Invalid shader config');
	        }
	        else
	        {
	            this.currentShader = this.shaders[0];
	        }

	        return this;
	    },

	    createBatch: function (texture)
	    {
	        this.currentBatch = {
	            start: this.vertexCount,
	            count: 0,
	            texture: [ texture ],
	            unit: 0,
	            maxUnit: 0
	        };

	        this.currentUnit = 0;
	        this.currentTexture = texture;

	        this.batch.push(this.currentBatch);

	        return 0;
	    },

	    addTextureToBatch: function (texture)
	    {
	        var batch = this.currentBatch;

	        if (batch)
	        {
	            batch.texture.push(texture);
	            batch.unit++;
	            batch.maxUnit++;
	        }
	    },

	    pushBatch: function (texture)
	    {

	        if (!this.currentBatch || (this.forceZero && texture !== this.currentTexture))
	        {
	            return this.createBatch(texture);
	        }

	        if (texture === this.currentTexture)
	        {
	            return this.currentUnit;
	        }
	        else
	        {
	            var current = this.currentBatch;

	            var idx = current.texture.indexOf(texture);

	            if (idx === -1)
	            {

	                if (current.texture.length === this.renderer.maxTextures)
	                {
	                    return this.createBatch(texture);
	                }
	                else
	                {

	                    current.unit++;
	                    current.maxUnit++;
	                    current.texture.push(texture);

	                    this.currentUnit = current.unit;
	                    this.currentTexture = texture;

	                    return current.unit;
	                }
	            }
	            else
	            {
	                this.currentUnit = idx;
	                this.currentTexture = texture;

	                return idx;
	            }
	        }
	    },

	    setGameObject: function (gameObject, frame)
	    {
	        if (frame === undefined) { frame = gameObject.frame; }

	        return this.pushBatch(frame.source.glTexture);
	    },

	    shouldFlush: function (amount)
	    {
	        if (amount === undefined) { amount = 0; }

	        return (this.vertexCount + amount > this.vertexCapacity);
	    },

	    vertexAvailable: function ()
	    {
	        return this.vertexCapacity - this.vertexCount;
	    },

	    resize: function (width, height)
	    {
	        if (width !== this.width || height !== this.height)
	        {
	            this.flush();
	        }

	        this.width = width;
	        this.height = height;

	        var targets = this.renderTargets;

	        for (var i = 0; i < targets.length; i++)
	        {
	            targets[i].resize(width, height);
	        }

	        this.setProjectionMatrix(width, height);

	        if (this.resizeUniform)
	        {
	            this.set2f(this.resizeUniform, width, height);
	        }

	        this.emit(Events.RESIZE, width, height, this);

	        this.onResize(width, height);

	        return this;
	    },

	    setProjectionMatrix: function (width, height)
	    {
	        var projectionMatrix = this.projectionMatrix;

	        if (!projectionMatrix)
	        {
	            return this;
	        }

	        this.projectionWidth = width;
	        this.projectionHeight = height;

	        projectionMatrix.ortho(0, width, height, 0, -1000, 1000);

	        var shaders = this.shaders;

	        var name = 'uProjectionMatrix';

	        for (var i = 0; i < shaders.length; i++)
	        {
	            var shader = shaders[i];

	            if (shader.hasUniform(name))
	            {
	                shader.resetUniform(name);

	                shader.setMatrix4fv(name, false, projectionMatrix.val, shader);
	            }
	        }

	        return this;
	    },

	    flipProjectionMatrix: function (flipY)
	    {
	        if (flipY === undefined) { flipY = true; }

	        var projectionMatrix = this.projectionMatrix;

	        if (!projectionMatrix)
	        {
	            return this;
	        }

	        var width = this.projectionWidth;
	        var height = this.projectionHeight;

	        if (flipY)
	        {
	            projectionMatrix.ortho(0, width, 0, height, -1000, 1000);
	        }
	        else
	        {
	            projectionMatrix.ortho(0, width, height, 0, -1000, 1000);
	        }

	        this.setMatrix4fv('uProjectionMatrix', false, projectionMatrix.val);
	    },

	    updateProjectionMatrix: function ()
	    {
	        if (this.projectionMatrix)
	        {
	            var globalWidth = this.renderer.projectionWidth;
	            var globalHeight = this.renderer.projectionHeight;

	            if (this.projectionWidth !== globalWidth || this.projectionHeight !== globalHeight)
	            {
	                this.setProjectionMatrix(globalWidth, globalHeight);
	            }
	        }
	    },

	    bind: function (currentShader)
	    {
	        if (currentShader === undefined) { currentShader = this.currentShader; }

	        if (this.glReset)
	        {
	            return this.rebind(currentShader);
	        }

	        var wasBound = false;

	        var gl = this.gl;

	        if (gl.getParameter(gl.ARRAY_BUFFER_BINDING) !== this.vertexBuffer)
	        {
	            gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer.webGLBuffer);

	            this.activeBuffer = this.vertexBuffer;

	            wasBound = true;
	        }

	        currentShader.bind(wasBound);

	        this.currentShader = currentShader;

	        this.activeTextures.length = 0;

	        this.emit(Events.BIND, this, currentShader);

	        this.onActive(currentShader);

	        return this;
	    },

	    rebind: function (currentShader)
	    {
	        this.activeBuffer = null;

	        this.setVertexBuffer();

	        var shaders = this.shaders;

	        for (var i = shaders.length - 1; i >= 0; i--)
	        {
	            var shader = shaders[i].rebind();

	            if (!currentShader || shader === currentShader)
	            {
	                this.currentShader = shader;
	            }
	        }

	        this.activeTextures.length = 0;

	        this.emit(Events.REBIND, this.currentShader);

	        this.onActive(this.currentShader);

	        this.onRebind();

	        this.glReset = false;

	        return this;
	    },

	    restoreContext: function ()
	    {
	        var shaders = this.shaders;
	        var hasVertexBuffer = !!this.vertexBuffer;

	        this.activeBuffer = null;
	        this.activeTextures.length = 0;
	        this.batch.length = 0;
	        this.currentBatch = null;
	        this.currentTexture = null;
	        this.currentUnit = 0;

	        if (hasVertexBuffer)
	        {
	            this.setVertexBuffer();
	        }

	        for (var i = 0; i < shaders.length; i++)
	        {
	            var shader = shaders[i];
	            shader.syncUniforms();
	            if (hasVertexBuffer)
	            {
	                shader.rebind();
	            }
	        }
	    },

	    setVertexBuffer: function (buffer)
	    {
	        if (buffer === undefined) { buffer = this.vertexBuffer; }

	        if (buffer !== this.activeBuffer)
	        {
	            var gl = this.gl;

	            this.gl.bindBuffer(gl.ARRAY_BUFFER, buffer.webGLBuffer);

	            this.activeBuffer = buffer;

	            return true;
	        }

	        return false;
	    },

	    preBatch: function (gameObject)
	    {
	        if (this.currentRenderTarget)
	        {
	            this.currentRenderTarget.bind();
	        }

	        this.onPreBatch(gameObject);

	        return this;
	    },

	    postBatch: function (gameObject)
	    {
	        this.onDraw(this.currentRenderTarget);

	        this.onPostBatch(gameObject);

	        return this;
	    },

	    onDraw: function ()
	    {
	    },

	    unbind: function ()
	    {
	        if (this.currentRenderTarget)
	        {
	            this.currentRenderTarget.unbind();
	        }
	    },

	    flush: function (isPostFlush)
	    {
	        if (isPostFlush === undefined) { isPostFlush = false; }

	        if (this.vertexCount > 0)
	        {
	            this.emit(Events.BEFORE_FLUSH, this, isPostFlush);

	            this.onBeforeFlush(isPostFlush);

	            var gl = this.gl;
	            var vertexCount = this.vertexCount;
	            var vertexSize = this.currentShader.vertexSize;
	            var topology = this.topology;

	            if (this.active)
	            {
	                this.setVertexBuffer();

	                if (vertexCount === this.vertexCapacity)
	                {
	                    gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.DYNAMIC_DRAW);
	                }
	                else
	                {
	                    gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.bytes.subarray(0, vertexCount * vertexSize));
	                }

	                var i;
	                var entry;
	                var texture;
	                var batch = this.batch;
	                var activeTextures = this.activeTextures;

	                if (this.forceZero)
	                {

	                    if (!activeTextures[0])
	                    {
	                        gl.activeTexture(gl.TEXTURE0);
	                    }

	                    for (i = 0; i < batch.length; i++)
	                    {
	                        entry = batch[i];
	                        texture = entry.texture[0];

	                        if (activeTextures[0] !== texture)
	                        {
	                            gl.bindTexture(gl.TEXTURE_2D, texture.webGLTexture);

	                            activeTextures[0] = texture;
	                        }

	                        gl.drawArrays(topology, entry.start, entry.count);
	                    }
	                }
	                else
	                {
	                    for (i = 0; i < batch.length; i++)
	                    {
	                        entry = batch[i];

	                        for (var t = 0; t <= entry.maxUnit; t++)
	                        {
	                            texture = entry.texture[t];

	                            if (activeTextures[t] !== texture)
	                            {
	                                gl.activeTexture(gl.TEXTURE0 + t);
	                                gl.bindTexture(gl.TEXTURE_2D, texture.webGLTexture);

	                                activeTextures[t] = texture;
	                            }
	                        }

	                        gl.drawArrays(topology, entry.start, entry.count);
	                    }
	                }
	            }

	            this.vertexCount = 0;

	            this.batch.length = 0;
	            this.currentBatch = null;
	            this.currentTexture = null;
	            this.currentUnit = 0;

	            this.emit(Events.AFTER_FLUSH, this, isPostFlush);

	            this.onAfterFlush(isPostFlush);
	        }

	        return this;
	    },

	    onActive: function ()
	    {
	    },

	    onBind: function ()
	    {
	    },

	    onRebind: function ()
	    {
	    },

	    onBatch: function ()
	    {
	    },

	    onPreBatch: function ()
	    {
	    },

	    onPostBatch: function ()
	    {
	    },

	    onPreRender: function ()
	    {
	    },

	    onRender: function ()
	    {
	    },

	    onPostRender: function ()
	    {
	    },

	    onBeforeFlush: function ()
	    {
	    },

	    onAfterFlush: function ()
	    {
	    },

	    batchVert: function (x, y, u, v, unit, tintEffect, tint)
	    {
	        var vertexViewF32 = this.vertexViewF32;
	        var vertexViewU32 = this.vertexViewU32;

	        var vertexOffset = (this.vertexCount * this.currentShader.vertexComponentCount) - 1;

	        vertexViewF32[++vertexOffset] = x;
	        vertexViewF32[++vertexOffset] = y;
	        vertexViewF32[++vertexOffset] = u;
	        vertexViewF32[++vertexOffset] = v;
	        vertexViewF32[++vertexOffset] = unit;
	        vertexViewF32[++vertexOffset] = tintEffect;
	        vertexViewU32[++vertexOffset] = tint;

	        this.vertexCount++;

	        this.currentBatch.count = (this.vertexCount - this.currentBatch.start);
	    },

	    batchQuad: function (gameObject, x0, y0, x1, y1, x2, y2, x3, y3, u0, v0, u1, v1, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, unit)
	    {
	        if (unit === undefined) { unit = this.currentUnit; }

	        var hasFlushed = false;

	        if (this.shouldFlush(6))
	        {
	            this.flush();

	            hasFlushed = true;
	        }

	        if (!this.currentBatch)
	        {
	            unit = this.setTexture2D(texture);
	        }

	        var vertexViewF32 = this.vertexViewF32;
	        var vertexViewU32 = this.vertexViewU32;

	        var vertexOffset = (this.vertexCount * this.currentShader.vertexComponentCount) - 1;

	        vertexViewF32[++vertexOffset] = x0;
	        vertexViewF32[++vertexOffset] = y0;
	        vertexViewF32[++vertexOffset] = u0;
	        vertexViewF32[++vertexOffset] = v0;
	        vertexViewF32[++vertexOffset] = unit;
	        vertexViewF32[++vertexOffset] = tintEffect;
	        vertexViewU32[++vertexOffset] = tintTL;

	        vertexViewF32[++vertexOffset] = x1;
	        vertexViewF32[++vertexOffset] = y1;
	        vertexViewF32[++vertexOffset] = u0;
	        vertexViewF32[++vertexOffset] = v1;
	        vertexViewF32[++vertexOffset] = unit;
	        vertexViewF32[++vertexOffset] = tintEffect;
	        vertexViewU32[++vertexOffset] = tintBL;

	        vertexViewF32[++vertexOffset] = x2;
	        vertexViewF32[++vertexOffset] = y2;
	        vertexViewF32[++vertexOffset] = u1;
	        vertexViewF32[++vertexOffset] = v1;
	        vertexViewF32[++vertexOffset] = unit;
	        vertexViewF32[++vertexOffset] = tintEffect;
	        vertexViewU32[++vertexOffset] = tintBR;

	        vertexViewF32[++vertexOffset] = x0;
	        vertexViewF32[++vertexOffset] = y0;
	        vertexViewF32[++vertexOffset] = u0;
	        vertexViewF32[++vertexOffset] = v0;
	        vertexViewF32[++vertexOffset] = unit;
	        vertexViewF32[++vertexOffset] = tintEffect;
	        vertexViewU32[++vertexOffset] = tintTL;

	        vertexViewF32[++vertexOffset] = x2;
	        vertexViewF32[++vertexOffset] = y2;
	        vertexViewF32[++vertexOffset] = u1;
	        vertexViewF32[++vertexOffset] = v1;
	        vertexViewF32[++vertexOffset] = unit;
	        vertexViewF32[++vertexOffset] = tintEffect;
	        vertexViewU32[++vertexOffset] = tintBR;

	        vertexViewF32[++vertexOffset] = x3;
	        vertexViewF32[++vertexOffset] = y3;
	        vertexViewF32[++vertexOffset] = u1;
	        vertexViewF32[++vertexOffset] = v0;
	        vertexViewF32[++vertexOffset] = unit;
	        vertexViewF32[++vertexOffset] = tintEffect;
	        vertexViewU32[++vertexOffset] = tintTR;

	        this.vertexCount += 6;

	        this.currentBatch.count = (this.vertexCount - this.currentBatch.start);

	        this.onBatch(gameObject);

	        return hasFlushed;
	    },

	    batchTri: function (gameObject, x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, tintTL, tintTR, tintBL, tintEffect, texture, unit)
	    {
	        if (unit === undefined) { unit = this.currentUnit; }

	        var hasFlushed = false;

	        if (this.shouldFlush(3))
	        {
	            this.flush();

	            hasFlushed = true;
	        }

	        if (!this.currentBatch)
	        {
	            unit = this.setTexture2D(texture);
	        }

	        var vertexViewF32 = this.vertexViewF32;
	        var vertexViewU32 = this.vertexViewU32;

	        var vertexOffset = (this.vertexCount * this.currentShader.vertexComponentCount) - 1;

	        vertexViewF32[++vertexOffset] = x0;
	        vertexViewF32[++vertexOffset] = y0;
	        vertexViewF32[++vertexOffset] = u0;
	        vertexViewF32[++vertexOffset] = v0;
	        vertexViewF32[++vertexOffset] = unit;
	        vertexViewF32[++vertexOffset] = tintEffect;
	        vertexViewU32[++vertexOffset] = tintTL;

	        vertexViewF32[++vertexOffset] = x1;
	        vertexViewF32[++vertexOffset] = y1;
	        vertexViewF32[++vertexOffset] = u0;
	        vertexViewF32[++vertexOffset] = v1;
	        vertexViewF32[++vertexOffset] = unit;
	        vertexViewF32[++vertexOffset] = tintEffect;
	        vertexViewU32[++vertexOffset] = tintTR;

	        vertexViewF32[++vertexOffset] = x2;
	        vertexViewF32[++vertexOffset] = y2;
	        vertexViewF32[++vertexOffset] = u1;
	        vertexViewF32[++vertexOffset] = v1;
	        vertexViewF32[++vertexOffset] = unit;
	        vertexViewF32[++vertexOffset] = tintEffect;
	        vertexViewU32[++vertexOffset] = tintBL;

	        this.vertexCount += 3;

	        this.currentBatch.count = (this.vertexCount - this.currentBatch.start);

	        this.onBatch(gameObject);

	        return hasFlushed;
	    },

	    drawFillRect: function (x, y, width, height, color, alpha, texture, flipUV)
	    {
	        if (texture === undefined) { texture = this.renderer.whiteTexture; }
	        if (flipUV === undefined) { flipUV = true; }

	        x = Math.floor(x);
	        y = Math.floor(y);

	        var xw = Math.floor(x + width);
	        var yh = Math.floor(y + height);

	        var unit = this.setTexture2D(texture);

	        var tint = Utils.getTintAppendFloatAlphaAndSwap(color, alpha);

	        var u0 = 0;
	        var v0 = 0;
	        var u1 = 1;
	        var v1 = 1;

	        if (flipUV)
	        {
	            v0 = 1;
	            v1 = 0;
	        }

	        this.batchQuad(null, x, y, x, yh, xw, yh, xw, y, u0, v0, u1, v1, tint, tint, tint, tint, 0, texture, unit);
	    },

	    setTexture2D: function (texture)
	    {
	        if (texture === undefined) { texture = this.renderer.whiteTexture; }

	        return this.pushBatch(texture);
	    },

	    bindTexture: function (texture, unit)
	    {
	        if (unit === undefined) { unit = 0; }

	        var gl = this.gl;

	        gl.activeTexture(gl.TEXTURE0 + unit);

	        gl.bindTexture(gl.TEXTURE_2D, texture.webGLTexture);

	        return this;
	    },

	    bindRenderTarget: function (target, unit)
	    {
	        return this.bindTexture(target.texture, unit);
	    },

	    setTime: function (name, shader)
	    {
	        this.set1f(name, this.game.loop.getDuration(), shader);

	        return this;
	    },

	    setBoolean: function (name, value, shader)
	    {
	        if (shader === undefined) { shader = this.currentShader; }

	        shader.setBoolean(name, value);

	        return this;
	    },

	    set1f: function (name, x, shader)
	    {
	        if (shader === undefined) { shader = this.currentShader; }

	        shader.set1f(name, x);

	        return this;
	    },

	    set2f: function (name, x, y, shader)
	    {
	        if (shader === undefined) { shader = this.currentShader; }

	        shader.set2f(name, x, y);

	        return this;
	    },

	    set3f: function (name, x, y, z, shader)
	    {
	        if (shader === undefined) { shader = this.currentShader; }

	        shader.set3f(name, x, y, z);

	        return this;
	    },

	    set4f: function (name, x, y, z, w, shader)
	    {
	        if (shader === undefined) { shader = this.currentShader; }

	        shader.set4f(name, x, y, z, w);

	        return this;
	    },

	    set1fv: function (name, arr, shader)
	    {
	        if (shader === undefined) { shader = this.currentShader; }

	        shader.set1fv(name, arr);

	        return this;
	    },

	    set2fv: function (name, arr, shader)
	    {
	        if (shader === undefined) { shader = this.currentShader; }

	        shader.set2fv(name, arr);

	        return this;
	    },

	    set3fv: function (name, arr, shader)
	    {
	        if (shader === undefined) { shader = this.currentShader; }

	        shader.set3fv(name, arr);

	        return this;
	    },

	    set4fv: function (name, arr, shader)
	    {
	        if (shader === undefined) { shader = this.currentShader; }

	        shader.set4fv(name, arr);

	        return this;
	    },

	    set1iv: function (name, arr, shader)
	    {
	        if (shader === undefined) { shader = this.currentShader; }

	        shader.set1iv(name, arr);

	        return this;
	    },

	    set2iv: function (name, arr, shader)
	    {
	        if (shader === undefined) { shader = this.currentShader; }

	        shader.set2iv(name, arr);

	        return this;
	    },

	    set3iv: function (name, arr, shader)
	    {
	        if (shader === undefined) { shader = this.currentShader; }

	        shader.set3iv(name, arr);

	        return this;
	    },

	    set4iv: function (name, arr, shader)
	    {
	        if (shader === undefined) { shader = this.currentShader; }

	        shader.set4iv(name, arr);

	        return this;
	    },

	    set1i: function (name, x, shader)
	    {
	        if (shader === undefined) { shader = this.currentShader; }

	        shader.set1i(name, x);

	        return this;
	    },

	    set2i: function (name, x, y, shader)
	    {
	        if (shader === undefined) { shader = this.currentShader; }

	        shader.set2i(name, x, y);

	        return this;
	    },

	    set3i: function (name, x, y, z, shader)
	    {
	        if (shader === undefined) { shader = this.currentShader; }

	        shader.set3i(name, x, y, z);

	        return this;
	    },

	    set4i: function (name, x, y, z, w, shader)
	    {
	        if (shader === undefined) { shader = this.currentShader; }

	        shader.set4i(name, x, y, z, w);

	        return this;
	    },

	    setMatrix2fv: function (name, transpose, matrix, shader)
	    {
	        if (shader === undefined) { shader = this.currentShader; }

	        shader.setMatrix2fv(name, transpose, matrix);

	        return this;
	    },

	    setMatrix3fv: function (name, transpose, matrix, shader)
	    {
	        if (shader === undefined) { shader = this.currentShader; }

	        shader.setMatrix3fv(name, transpose, matrix);

	        return this;
	    },

	    setMatrix4fv: function (name, transpose, matrix, shader)
	    {
	        if (shader === undefined) { shader = this.currentShader; }

	        shader.setMatrix4fv(name, transpose, matrix);

	        return this;
	    },

	    destroy: function ()
	    {
	        this.emit(Events.DESTROY, this);

	        var i;

	        var shaders = this.shaders;

	        for (i = 0; i < shaders.length; i++)
	        {
	            shaders[i].destroy();
	        }

	        var targets = this.renderTargets;

	        for (i = 0; i < targets.length; i++)
	        {
	            targets[i].destroy();
	        }

	        var renderer = this.renderer;

	        renderer.deleteBuffer(this.vertexBuffer);

	        renderer.off(RendererEvents.RESIZE, this.resize, this);
	        renderer.off(RendererEvents.PRE_RENDER, this.onPreRender, this);
	        renderer.off(RendererEvents.RENDER, this.onRender, this);
	        renderer.off(RendererEvents.POST_RENDER, this.onPostRender, this);

	        this.removeAllListeners();

	        this.game = null;
	        this.renderer = null;
	        this.manager = null;
	        this.gl = null;
	        this.view = null;
	        this.shaders = null;
	        this.renderTargets = null;
	        this.bytes = null;
	        this.vertexViewF32 = null;
	        this.vertexViewU32 = null;
	        this.vertexData = null;
	        this.vertexBuffer = null;
	        this.currentShader = null;
	        this.currentRenderTarget = null;
	        this.activeTextures = null;

	        return this;
	    }

	});

	WebGLPipeline_1 = WebGLPipeline;
	return WebGLPipeline_1;
}

var BitmapMaskPipeline_1;
var hasRequiredBitmapMaskPipeline;

function requireBitmapMaskPipeline () {
	if (hasRequiredBitmapMaskPipeline) return BitmapMaskPipeline_1;
	hasRequiredBitmapMaskPipeline = 1;
	var Class = requireClass();
	var GetFastValue = requireGetFastValue();
	var ShaderSourceFS = requireBitmapMaskFrag();
	var ShaderSourceVS = requireBitmapMaskVert();
	var WEBGL_CONST = require_const$8();
	var WebGLPipeline = requireWebGLPipeline();

	var BitmapMaskPipeline = new Class({

	    Extends: WebGLPipeline,

	    initialize:

	    function BitmapMaskPipeline (config)
	    {
	        config.fragShader = GetFastValue(config, 'fragShader', ShaderSourceFS),
	        config.vertShader = GetFastValue(config, 'vertShader', ShaderSourceVS),
	        config.batchSize = GetFastValue(config, 'batchSize', 1),
	        config.vertices = GetFastValue(config, 'vertices', [ -1, 1, -1, -7, 7, 1 ]),
	        config.attributes = GetFastValue(config, 'attributes', [
	            {
	                name: 'inPosition',
	                size: 2,
	                type: WEBGL_CONST.FLOAT
	            }
	        ]);

	        WebGLPipeline.call(this, config);
	    },

	    boot: function ()
	    {
	        WebGLPipeline.prototype.boot.call(this);

	        this.set1i('uMainSampler', 0);
	        this.set1i('uMaskSampler', 1);
	    },

	    resize: function (width, height)
	    {
	        WebGLPipeline.prototype.resize.call(this, width, height);

	        this.set2f('uResolution', width, height);
	    },

	    beginMask: function (mask, maskedObject, camera)
	    {
	        this.renderer.beginBitmapMask(mask, camera);
	    },

	    endMask: function (mask, camera, renderTarget)
	    {
	        var gl = this.gl;
	        var renderer = this.renderer;

	        var bitmapMask = mask.bitmapMask;

	        if (bitmapMask && gl)
	        {
	            renderer.drawBitmapMask(bitmapMask, camera, this);

	            if (renderTarget)
	            {
	                this.set2f('uResolution', renderTarget.width, renderTarget.height);
	            }

	            this.set1i('uInvertMaskAlpha', mask.invertAlpha);

	            gl.drawArrays(this.topology, 0, 3);

	            if (renderTarget)
	            {
	                this.set2f('uResolution', this.width, this.height);
	            }

	            gl.bindTexture(gl.TEXTURE_2D, null);
	        }
	    }

	});

	BitmapMaskPipeline_1 = BitmapMaskPipeline;
	return BitmapMaskPipeline_1;
}

var FXBarrelFrag;
var hasRequiredFXBarrelFrag;

function requireFXBarrelFrag () {
	if (hasRequiredFXBarrelFrag) return FXBarrelFrag;
	hasRequiredFXBarrelFrag = 1;
	FXBarrelFrag = [
	    '#define SHADER_NAME BARREL_FS',
	    'precision mediump float;',
	    'uniform sampler2D uMainSampler;',
	    'uniform float amount;',
	    'varying vec2 outTexCoord;',
	    'vec2 Distort(vec2 p)',
	    '{',
	    '    float theta  = atan(p.y, p.x);',
	    '    float radius = length(p);',
	    '    radius = pow(radius, amount);',
	    '    p.x = radius * cos(theta);',
	    '    p.y = radius * sin(theta);',
	    '    return 0.5 * (p + 1.0);',
	    '}',
	    'void main()',
	    '{',
	    '    vec2 xy = 2.0 * outTexCoord - 1.0;',
	    '    vec2 texCoord = outTexCoord;',
	    '    if (length(xy) < 1.0)',
	    '    {',
	    '        texCoord = Distort(xy);',
	    '    }',
	    '    gl_FragColor = texture2D(uMainSampler, texCoord);',
	    '}',
	].join('\n');
	return FXBarrelFrag;
}

var PostFXFrag;
var hasRequiredPostFXFrag;

function requirePostFXFrag () {
	if (hasRequiredPostFXFrag) return PostFXFrag;
	hasRequiredPostFXFrag = 1;
	PostFXFrag = [
	    '#define SHADER_NAME PHASER_POSTFX_FS',
	    'precision mediump float;',
	    'uniform sampler2D uMainSampler;',
	    'varying vec2 outTexCoord;',
	    'void main ()',
	    '{',
	    '    gl_FragColor = texture2D(uMainSampler, outTexCoord);',
	    '}',
	].join('\n');
	return PostFXFrag;
}

var QuadVert;
var hasRequiredQuadVert;

function requireQuadVert () {
	if (hasRequiredQuadVert) return QuadVert;
	hasRequiredQuadVert = 1;
	QuadVert = [
	    '#define SHADER_NAME PHASER_QUAD_VS',
	    'precision mediump float;',
	    'attribute vec2 inPosition;',
	    'attribute vec2 inTexCoord;',
	    'varying vec2 outFragCoord;',
	    'varying vec2 outTexCoord;',
	    'void main ()',
	    '{',
	    '    outFragCoord = inPosition.xy * 0.5 + 0.5;',
	    '    outTexCoord = inTexCoord;',
	    '    gl_Position = vec4(inPosition, 0, 1);',
	    '}',
	].join('\n');
	return QuadVert;
}

var PostFXPipeline_1;
var hasRequiredPostFXPipeline;

function requirePostFXPipeline () {
	if (hasRequiredPostFXPipeline) return PostFXPipeline_1;
	hasRequiredPostFXPipeline = 1;
	var Class = requireClass();
	var ColorMatrix = requireColorMatrix$1();
	var GetFastValue = requireGetFastValue();
	var ShaderSourceFS = requirePostFXFrag();
	var ShaderSourceVS = requireQuadVert();
	var WebGLPipeline = requireWebGLPipeline();

	var PostFXPipeline = new Class({

	    Extends: WebGLPipeline,

	    initialize:

	    function PostFXPipeline (config)
	    {
	        config.renderTarget = GetFastValue(config, 'renderTarget', 1);
	        config.fragShader = GetFastValue(config, 'fragShader', ShaderSourceFS);
	        config.vertShader = GetFastValue(config, 'vertShader', ShaderSourceVS);
	        config.attributes = GetFastValue(config, 'attributes', [
	            {
	                name: 'inPosition',
	                size: 2
	            },
	            {
	                name: 'inTexCoord',
	                size: 2
	            }
	        ]);
	        config.batchSize = 1;
	        config.vertices = [
	            -1, -1, 0, 0,
	            -1, 1, 0, 1,
	            1, 1, 1, 1,
	            -1, -1, 0, 0,
	            1, 1, 1, 1,
	            1, -1, 1, 0
	        ];

	        WebGLPipeline.call(this, config);

	        this.isPostFX = true;

	        this.gameObject;

	        this.controller;

	        this.colorMatrix = new ColorMatrix();

	        this.fullFrame1;

	        this.fullFrame2;

	        this.halfFrame1;

	        this.halfFrame2;

	        if (this.renderer.isBooted)
	        {
	            this.manager = this.renderer.pipelines;
	        }
	    },

	    bootFX: function ()
	    {
	        WebGLPipeline.prototype.boot.call(this);

	        var utility = this.manager.UTILITY_PIPELINE;

	        this.fullFrame1 = utility.fullFrame1;
	        this.fullFrame2 = utility.fullFrame2;
	        this.halfFrame1 = utility.halfFrame1;
	        this.halfFrame2 = utility.halfFrame2;

	        var renderer = this.renderer;

	        this.set1i('uMainSampler', 0);
	        this.set2f('uResolution', renderer.width, renderer.height);

	        var targets = this.renderTargets;

	        for (var i = 0; i < targets.length; i++)
	        {
	            targets[i].autoResize = true;
	        }
	    },

	    postBatch: function (gameObject)
	    {
	        if (!this.hasBooted)
	        {
	            this.bootFX();

	            if (this.currentRenderTarget)
	            {
	                this.currentRenderTarget.bind();
	            }
	        }

	        this.onDraw(this.currentRenderTarget);

	        this.onPostBatch(gameObject);

	        return this;
	    },

	    onDraw: function (renderTarget)
	    {
	        this.bindAndDraw(renderTarget);
	    },

	    getController: function (controller)
	    {
	        if (controller !== undefined)
	        {
	            return controller;
	        }
	        else if (this.controller)
	        {
	            return this.controller;
	        }
	        else
	        {
	            return this;
	        }
	    },

	    copySprite: function (source, target, reset)
	    {
	        if (reset === undefined) { reset = false; }

	        var gl = this.gl;

	        gl.activeTexture(gl.TEXTURE0);
	        gl.bindTexture(gl.TEXTURE_2D, source.texture.webGLTexture);

	        var currentFBO = gl.getParameter(gl.FRAMEBUFFER_BINDING);

	        gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer.webGLFramebuffer);
	        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target.texture.webGLTexture, 0);

	        gl.clearColor(0, 0, 0, 0);
	        gl.clear(gl.COLOR_BUFFER_BIT);

	        gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.STATIC_DRAW);
	        gl.drawArrays(gl.TRIANGLES, 0, 6);

	        if (reset)
	        {
	            gl.bindTexture(gl.TEXTURE_2D, null);
	            gl.bindFramebuffer(gl.FRAMEBUFFER, currentFBO);
	        }
	    },

	    copyFrame: function (source, target, brightness, clear, clearAlpha)
	    {
	        this.manager.copyFrame(source, target, brightness, clear, clearAlpha);
	    },

	    copyToGame: function (source)
	    {
	        this.manager.copyToGame(source);
	    },

	    drawFrame: function (source, target, clearAlpha)
	    {
	        this.manager.drawFrame(source, target, clearAlpha, this.colorMatrix);
	    },

	    blendFrames: function (source1, source2, target, strength, clearAlpha)
	    {
	        this.manager.blendFrames(source1, source2, target, strength, clearAlpha);
	    },

	    blendFramesAdditive: function (source1, source2, target, strength, clearAlpha)
	    {
	        this.manager.blendFramesAdditive(source1, source2, target, strength, clearAlpha);
	    },

	    clearFrame: function (target, clearAlpha)
	    {
	        this.manager.clearFrame(target, clearAlpha);
	    },

	    blitFrame: function (source, target, brightness, clear, clearAlpha, eraseMode)
	    {
	        this.manager.blitFrame(source, target, brightness, clear, clearAlpha, eraseMode);
	    },

	    copyFrameRect: function (source, target, x, y, width, height, clear, clearAlpha)
	    {
	        this.manager.copyFrameRect(source, target, x, y, width, height, clear, clearAlpha);
	    },

	    bindAndDraw: function (source, target, clear, clearAlpha, currentShader)
	    {
	        if (clear === undefined) { clear = true; }
	        if (clearAlpha === undefined) { clearAlpha = true; }

	        var gl = this.gl;
	        var renderer = this.renderer;

	        this.bind(currentShader);

	        this.set1i('uMainSampler', 0);

	        if (target)
	        {
	            gl.viewport(0, 0, target.width, target.height);
	            gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer.webGLFramebuffer);
	            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target.texture.webGLTexture, 0);

	            if (clear)
	            {
	                if (clearAlpha)
	                {
	                    gl.clearColor(0, 0, 0, 0);
	                }
	                else
	                {
	                    gl.clearColor(0, 0, 0, 1);
	                }

	                gl.clear(gl.COLOR_BUFFER_BIT);
	            }
	        }
	        else
	        {
	            renderer.popFramebuffer(false, false);

	            if (!renderer.currentFramebuffer)
	            {
	                gl.viewport(0, 0, renderer.width, renderer.height);
	            }
	        }

	        renderer.restoreStencilMask();

	        gl.activeTexture(gl.TEXTURE0);
	        gl.bindTexture(gl.TEXTURE_2D, source.texture.webGLTexture);

	        gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.STATIC_DRAW);
	        gl.drawArrays(gl.TRIANGLES, 0, 6);

	        if (target)
	        {
	            gl.bindTexture(gl.TEXTURE_2D, null);
	            gl.bindFramebuffer(gl.FRAMEBUFFER, renderer.currentFramebuffer.webGLFramebuffer);
	        }
	    },

	    destroy: function ()
	    {
	        if (this.controller)
	        {
	            this.controller.destroy();
	        }

	        this.gameObject = null;
	        this.controller = null;
	        this.colorMatrix = null;
	        this.fullFrame1 = null;
	        this.fullFrame2 = null;
	        this.halfFrame1 = null;
	        this.halfFrame2 = null;

	        this.manager.removePostPipeline(this);

	        WebGLPipeline.prototype.destroy.call(this);

	        return this;
	    }

	});

	PostFXPipeline_1 = PostFXPipeline;
	return PostFXPipeline_1;
}

var BarrelFXPipeline_1;
var hasRequiredBarrelFXPipeline;

function requireBarrelFXPipeline () {
	if (hasRequiredBarrelFXPipeline) return BarrelFXPipeline_1;
	hasRequiredBarrelFXPipeline = 1;
	var Class = requireClass();
	var BarrelFrag = requireFXBarrelFrag();
	var PostFXPipeline = requirePostFXPipeline();

	var BarrelFXPipeline = new Class({

	    Extends: PostFXPipeline,

	    initialize:

	    function BarrelFXPipeline (game)
	    {
	        PostFXPipeline.call(this, {
	            game: game,
	            fragShader: BarrelFrag
	        });

	        this.amount = 1;
	    },

	    onPreRender: function (controller, shader)
	    {
	        controller = this.getController(controller);

	        this.set1f('amount', controller.amount, shader);
	    }

	});

	BarrelFXPipeline_1 = BarrelFXPipeline;
	return BarrelFXPipeline_1;
}

var FXBloomFrag;
var hasRequiredFXBloomFrag;

function requireFXBloomFrag () {
	if (hasRequiredFXBloomFrag) return FXBloomFrag;
	hasRequiredFXBloomFrag = 1;
	FXBloomFrag = [
	    '#define SHADER_NAME BLOOM_FS',
	    'precision mediump float;',
	    'uniform sampler2D uMainSampler;',
	    'uniform vec2 offset;',
	    'uniform float strength;',
	    'uniform vec3 color;',
	    'varying vec2 outTexCoord;',
	    'void main ()',
	    '{',
	    '    vec4 sum = texture2D(uMainSampler, outTexCoord) * 0.204164 * strength;',
	    '    sum = sum + texture2D(uMainSampler, outTexCoord + offset * 1.407333) * 0.304005;',
	    '    sum = sum + texture2D(uMainSampler, outTexCoord - offset * 1.407333) * 0.304005;',
	    '    sum = sum + texture2D(uMainSampler, outTexCoord + offset * 3.294215) * 0.093913;',
	    '    gl_FragColor = (sum + texture2D(uMainSampler, outTexCoord - offset * 3.294215) * 0.093913) * vec4(color, 1);',
	    '}',
	].join('\n');
	return FXBloomFrag;
}

var BloomFXPipeline_1;
var hasRequiredBloomFXPipeline;

function requireBloomFXPipeline () {
	if (hasRequiredBloomFXPipeline) return BloomFXPipeline_1;
	hasRequiredBloomFXPipeline = 1;
	var Class = requireClass();
	var BloomFrag = requireFXBloomFrag();
	var PostFXPipeline = requirePostFXPipeline();

	var BloomFXPipeline = new Class({

	    Extends: PostFXPipeline,

	    initialize:

	    function BloomFXPipeline (game)
	    {
	        PostFXPipeline.call(this, {
	            game: game,
	            fragShader: BloomFrag
	        });

	        this.steps = 4;

	        this.offsetX = 1;

	        this.offsetY = 1;

	        this.blurStrength = 1;

	        this.strength = 1;

	        this.glcolor = [ 1, 1, 1 ];
	    },

	    onPreRender: function (controller)
	    {
	        controller = this.getController(controller);

	        this.set1f('strength', controller.blurStrength);
	        this.set3fv('color', controller.glcolor);
	    },

	    onDraw: function (target1)
	    {
	        var controller = this.getController();

	        var target2 = this.fullFrame1;
	        var target3 = this.fullFrame2;

	        this.copyFrame(target1, target3);

	        var x = (2 / target1.width) * controller.offsetX;
	        var y = (2 / target1.height) * controller.offsetY;

	        for (var i = 0; i < controller.steps; i++)
	        {
	            this.set2f('offset', x, 0);
	            this.copySprite(target1, target2);

	            this.set2f('offset', 0, y);
	            this.copySprite(target2, target1);
	        }

	        this.blendFrames(target3, target1, target2, controller.strength);

	        this.copyToGame(target2);
	    }

	});

	BloomFXPipeline_1 = BloomFXPipeline;
	return BloomFXPipeline_1;
}

var FXBlurLowFrag;
var hasRequiredFXBlurLowFrag;

function requireFXBlurLowFrag () {
	if (hasRequiredFXBlurLowFrag) return FXBlurLowFrag;
	hasRequiredFXBlurLowFrag = 1;
	FXBlurLowFrag = [
	    '#define SHADER_NAME BLUR_LOW_FS',
	    'precision mediump float;',
	    'uniform sampler2D uMainSampler;',
	    'uniform vec2 resolution;',
	    'uniform vec2 offset;',
	    'uniform float strength;',
	    'uniform vec3 color;',
	    'varying vec2 outTexCoord;',
	    'void main ()',
	    '{',
	    '    vec2 uv = outTexCoord;',
	    '    vec4 col = vec4(0.0);',
	    '    vec2 offset = vec2(1.333) * offset * strength;',
	    '    col += texture2D(uMainSampler, uv) * 0.29411764705882354;',
	    '    col += texture2D(uMainSampler, uv + (offset / resolution)) * 0.35294117647058826;',
	    '    col += texture2D(uMainSampler, uv - (offset / resolution)) * 0.35294117647058826;',
	    '    gl_FragColor = col * vec4(color, 1.0);',
	    '}',
	].join('\n');
	return FXBlurLowFrag;
}

var FXBlurMedFrag;
var hasRequiredFXBlurMedFrag;

function requireFXBlurMedFrag () {
	if (hasRequiredFXBlurMedFrag) return FXBlurMedFrag;
	hasRequiredFXBlurMedFrag = 1;
	FXBlurMedFrag = [
	    '#define SHADER_NAME BLUR_MED_FS',
	    'precision mediump float;',
	    'uniform sampler2D uMainSampler;',
	    'uniform vec2 resolution;',
	    'uniform vec2 offset;',
	    'uniform float strength;',
	    'uniform vec3 color;',
	    'varying vec2 outTexCoord;',
	    'void main ()',
	    '{',
	    '    vec2 uv = outTexCoord;',
	    '    vec4 col = vec4(0.0);',
	    '    vec2 off1 = vec2(1.3846153846) * offset * strength;',
	    '    vec2 off2 = vec2(3.2307692308) * offset * strength;',
	    '    col += texture2D(uMainSampler, uv) * 0.2270270270;',
	    '    col += texture2D(uMainSampler, uv + (off1 / resolution)) * 0.3162162162;',
	    '    col += texture2D(uMainSampler, uv - (off1 / resolution)) * 0.3162162162;',
	    '    col += texture2D(uMainSampler, uv + (off2 / resolution)) * 0.0702702703;',
	    '    col += texture2D(uMainSampler, uv - (off2 / resolution)) * 0.0702702703;',
	    '    gl_FragColor = col * vec4(color, 1.0);',
	    '}',
	].join('\n');
	return FXBlurMedFrag;
}

var FXBlurHighFrag;
var hasRequiredFXBlurHighFrag;

function requireFXBlurHighFrag () {
	if (hasRequiredFXBlurHighFrag) return FXBlurHighFrag;
	hasRequiredFXBlurHighFrag = 1;
	FXBlurHighFrag = [
	    '#define SHADER_NAME BLUR_HIGH_FS',
	    'precision mediump float;',
	    'uniform sampler2D uMainSampler;',
	    'uniform vec2 resolution;',
	    'uniform vec2 offset;',
	    'uniform float strength;',
	    'uniform vec3 color;',
	    'varying vec2 outTexCoord;',
	    'void main ()',
	    '{',
	    '    vec2 uv = outTexCoord;',
	    '    vec4 col = vec4(0.0);',
	    '    vec2 off1 = vec2(1.411764705882353) * offset * strength;',
	    '    vec2 off2 = vec2(3.2941176470588234) * offset * strength;',
	    '    vec2 off3 = vec2(5.176470588235294) * offset * strength;',
	    '    col += texture2D(uMainSampler, uv) * 0.1964825501511404;',
	    '    col += texture2D(uMainSampler, uv + (off1 / resolution)) * 0.2969069646728344;',
	    '    col += texture2D(uMainSampler, uv - (off1 / resolution)) * 0.2969069646728344;',
	    '    col += texture2D(uMainSampler, uv + (off2 / resolution)) * 0.09447039785044732;',
	    '    col += texture2D(uMainSampler, uv - (off2 / resolution)) * 0.09447039785044732;',
	    '    col += texture2D(uMainSampler, uv + (off3 / resolution)) * 0.010381362401148057;',
	    '    col += texture2D(uMainSampler, uv - (off3 / resolution)) * 0.010381362401148057;',
	    '    gl_FragColor = col * vec4(color, 1.0);',
	    '}',
	].join('\n');
	return FXBlurHighFrag;
}

var BlurFXPipeline_1;
var hasRequiredBlurFXPipeline;

function requireBlurFXPipeline () {
	if (hasRequiredBlurFXPipeline) return BlurFXPipeline_1;
	hasRequiredBlurFXPipeline = 1;
	var Class = requireClass();
	var BlurLowFrag = requireFXBlurLowFrag();
	var BlurMedFrag = requireFXBlurMedFrag();
	var BlurHighFrag = requireFXBlurHighFrag();
	var PostFXPipeline = requirePostFXPipeline();

	var BlurFXPipeline = new Class({

	    Extends: PostFXPipeline,

	    initialize:

	    function BlurFXPipeline (game)
	    {
	        PostFXPipeline.call(this, {
	            game: game,
	            shaders: [
	                {
	                    name: 'Gaussian5',
	                    fragShader: BlurLowFrag
	                },
	                {
	                    name: 'Gaussian9',
	                    fragShader: BlurMedFrag
	                },
	                {
	                    name: 'Gaussian13',
	                    fragShader: BlurHighFrag
	                }
	            ]
	        });

	        this.activeShader = this.shaders[0];

	        this.x = 2;

	        this.y = 2;

	        this.steps = 4;

	        this.strength = 1;

	        this.glcolor = [ 1, 1, 1 ];
	    },

	    setQualityLow: function ()
	    {
	        this.activeShader = this.shaders[0];

	        return this;
	    },

	    setQualityMedium: function ()
	    {
	        this.activeShader = this.shaders[1];

	        return this;
	    },

	    setQualityHigh: function ()
	    {
	        this.activeShader = this.shaders[2];

	        return this;
	    },

	    onDraw: function (target1)
	    {
	        var controller = this.getController();

	        var gl = this.gl;
	        var target2 = this.fullFrame1;

	        var currentFBO = gl.getParameter(gl.FRAMEBUFFER_BINDING);

	        this.bind(this.shaders[controller.quality]);

	        gl.activeTexture(gl.TEXTURE0);
	        gl.viewport(0, 0, target1.width, target1.height);

	        this.set1i('uMainSampler', 0);
	        this.set2f('resolution', target1.width, target1.height);
	        this.set1f('strength', controller.strength);
	        this.set3fv('color', controller.glcolor);

	        for (var i = 0; i < controller.steps; i++)
	        {
	            this.set2f('offset', controller.x, 0);
	            this.copySprite(target1, target2);

	            this.set2f('offset', 0, controller.y);
	            this.copySprite(target2, target1);
	        }

	        gl.bindFramebuffer(gl.FRAMEBUFFER, currentFBO);
	        gl.bindTexture(gl.TEXTURE_2D, null);

	        this.copyToGame(target1);
	    }

	});

	BlurFXPipeline_1 = BlurFXPipeline;
	return BlurFXPipeline_1;
}

var FXBokehFrag;
var hasRequiredFXBokehFrag;

function requireFXBokehFrag () {
	if (hasRequiredFXBokehFrag) return FXBokehFrag;
	hasRequiredFXBokehFrag = 1;
	FXBokehFrag = [
	    '#define SHADER_NAME BOKEH_FS',
	    'precision mediump float;',
	    '#define ITERATIONS 100.0',
	    '#define ONEOVER_ITR 1.0 / ITERATIONS',
	    '#define PI 3.141596',
	    '#define GOLDEN_ANGLE 2.39996323',
	    'uniform sampler2D uMainSampler;',
	    'uniform vec2 resolution;',
	    'uniform float radius;',
	    'uniform float amount;',
	    'uniform float contrast;',
	    'uniform bool isTiltShift;',
	    'uniform float strength;',
	    'uniform vec2 blur;',
	    'varying vec2 outTexCoord;',
	    'vec2 Sample (in float theta, inout float r)',
	    '{',
	    '    r += 1.0 / r;',
	    '    return (r - 1.0) * vec2(cos(theta), sin(theta)) * 0.06;',
	    '}',
	    'vec3 Bokeh (sampler2D tex, vec2 uv, float radius)',
	    '{',
	    '    vec3 acc = vec3(0.0);',
	    '    vec3 div = vec3(0.0);',
	    '    vec2 pixel = vec2(resolution.y / resolution.x, 1.0) * radius * .025;',
	    '    float r = 1.0;',
	    '    for (float j = 0.0; j < GOLDEN_ANGLE * ITERATIONS; j += GOLDEN_ANGLE)',
	    '    {',
	    '        vec3 col = texture2D(tex, uv + pixel * Sample(j, r)).xyz;',
	    '        col = contrast > 0.0 ? col * col * (1.0 + contrast) : col;',
	    '        vec3 bokeh = vec3(0.5) + pow(col, vec3(10.0)) * amount;',
	    '        acc += col * bokeh;',
	    '        div += bokeh;',
	    '    }',
	    '    return acc / div;',
	    '}',
	    'void main ()',
	    '{',
	    '    float shift = 1.0;',
	    '    if (isTiltShift)',
	    '    {',
	    '        vec2 uv = vec2(gl_FragCoord.xy / resolution + vec2(-0.5, -0.5)) * 2.0;',
	    '        float centerStrength = 1.0;',
	    '        shift = length(uv * blur * strength) * centerStrength;',
	    '    }',
	    '    gl_FragColor = vec4(Bokeh(uMainSampler, outTexCoord * vec2(1.0, 1.0), radius * shift), 0.0);',
	    '}',
	].join('\n');
	return FXBokehFrag;
}

var BokehFXPipeline_1;
var hasRequiredBokehFXPipeline;

function requireBokehFXPipeline () {
	if (hasRequiredBokehFXPipeline) return BokehFXPipeline_1;
	hasRequiredBokehFXPipeline = 1;
	var Class = requireClass();
	var BokehFrag = requireFXBokehFrag();
	var PostFXPipeline = requirePostFXPipeline();

	var BokehFXPipeline = new Class({

	    Extends: PostFXPipeline,

	    initialize:

	    function BokehFXPipeline (game)
	    {
	        PostFXPipeline.call(this, {
	            game: game,
	            fragShader: BokehFrag
	        });

	        this.isTiltShift = false;

	        this.strength = 1;

	        this.blurX = 1;

	        this.blurY = 1;

	        this.radius = 0.5;

	        this.amount = 1;

	        this.contrast = 0.2;
	    },

	    onPreRender: function (controller, shader, width, height)
	    {
	        controller = this.getController(controller);

	        this.set1f('radius', controller.radius, shader);
	        this.set1f('amount', controller.amount, shader);
	        this.set1f('contrast', controller.contrast, shader);
	        this.set1f('strength', controller.strength, shader);
	        this.set2f('blur', controller.blurX, controller.blurY, shader);
	        this.setBoolean('isTiltShift', controller.isTiltShift, shader);

	        if (width && height)
	        {
	            this.set2f('resolution', width, height, shader);
	        }
	    },

	    onDraw: function (target)
	    {
	        this.set2f('resolution', target.width, target.height);

	        this.bindAndDraw(target);
	    }

	});

	BokehFXPipeline_1 = BokehFXPipeline;
	return BokehFXPipeline_1;
}

var FXCircleFrag;
var hasRequiredFXCircleFrag;

function requireFXCircleFrag () {
	if (hasRequiredFXCircleFrag) return FXCircleFrag;
	hasRequiredFXCircleFrag = 1;
	FXCircleFrag = [
	    '#define SHADER_NAME CIRCLE_FS',
	    'precision mediump float;',
	    'uniform sampler2D uMainSampler;',
	    'uniform vec2 resolution;',
	    'uniform vec3 color;',
	    'uniform vec4 backgroundColor;',
	    'uniform float thickness;',
	    'uniform float scale;',
	    'uniform float feather;',
	    'varying vec2 outTexCoord;',
	    'void main ()',
	    '{',
	    '    vec4 texture = texture2D(uMainSampler, outTexCoord);',
	    '    vec2 position = (gl_FragCoord.xy / resolution.xy) * 2.0 - 1.0;',
	    '    float aspectRatio = resolution.x / resolution.y;',
	    '    position.x *= aspectRatio;',
	    '    float grad = length(position);',
	    '    float outer = aspectRatio;',
	    '    float inner = outer - (thickness * 2.0 / resolution.y);',
	    '    if (aspectRatio >= 1.0)',
	    '    {',
	    '        float f = 2.0 + (resolution.y / resolution.x);',
	    '        outer = 1.0;',
	    '        inner = 1.0 - (thickness * f / resolution.x);',
	    '    }',
	    '    outer *= scale;',
	    '    inner *= scale;',
	    '    float circle = smoothstep(outer, outer - 0.01, grad);',
	    '    float ring = circle - smoothstep(inner, inner - feather, grad);',
	    '    texture = mix(backgroundColor * backgroundColor.a, texture, texture.a);',
	    '    texture = (texture * (circle - ring));',
	    '    gl_FragColor = vec4(texture.rgb + (ring * color), texture.a);',
	    '}',
	].join('\n');
	return FXCircleFrag;
}

var CircleFXPipeline_1;
var hasRequiredCircleFXPipeline;

function requireCircleFXPipeline () {
	if (hasRequiredCircleFXPipeline) return CircleFXPipeline_1;
	hasRequiredCircleFXPipeline = 1;
	var Class = requireClass();
	var CircleFrag = requireFXCircleFrag();
	var PostFXPipeline = requirePostFXPipeline();

	var CircleFXPipeline = new Class({

	    Extends: PostFXPipeline,

	    initialize:

	    function CircleFXPipeline (game)
	    {
	        PostFXPipeline.call(this, {
	            game: game,
	            fragShader: CircleFrag
	        });

	        this.scale = 1;

	        this.feather = 0.005;

	        this.thickness = 8;

	        this.glcolor = [ 1, 0.2, 0.7 ];

	        this.glcolor2 = [ 1, 0, 0, 0.4 ];
	    },

	    onPreRender: function (controller, shader, width, height)
	    {
	        controller = this.getController(controller);

	        this.set1f('scale', controller.scale, shader);
	        this.set1f('feather', controller.feather, shader);
	        this.set1f('thickness', controller.thickness, shader);
	        this.set3fv('color', controller.glcolor, shader);
	        this.set4fv('backgroundColor', controller.glcolor2, shader);

	        if (width && height)
	        {
	            this.set2f('resolution', width, height, shader);
	        }
	    },

	    onDraw: function (target)
	    {
	        this.set2f('resolution', target.width, target.height);

	        this.bindAndDraw(target);
	    }

	});

	CircleFXPipeline_1 = CircleFXPipeline;
	return CircleFXPipeline_1;
}

var ColorMatrixFXPipeline_1;
var hasRequiredColorMatrixFXPipeline;

function requireColorMatrixFXPipeline () {
	if (hasRequiredColorMatrixFXPipeline) return ColorMatrixFXPipeline_1;
	hasRequiredColorMatrixFXPipeline = 1;
	var Class = requireClass();
	var PostFXPipeline = requirePostFXPipeline();

	var ColorMatrixFXPipeline = new Class({

	    Extends: PostFXPipeline,

	    initialize:

	    function ColorMatrixFXPipeline (game)
	    {
	        PostFXPipeline.call(this, {
	            game: game
	        });
	    },

	    onDraw: function (source)
	    {
	        var target = this.fullFrame1;

	        if (this.controller)
	        {
	            this.manager.drawFrame(source, target, true, this.controller);
	        }
	        else
	        {
	            this.drawFrame(source, target);
	        }

	        this.copyToGame(target);
	    }

	});

	ColorMatrixFXPipeline_1 = ColorMatrixFXPipeline;
	return ColorMatrixFXPipeline_1;
}

var FXDisplacementFrag;
var hasRequiredFXDisplacementFrag;

function requireFXDisplacementFrag () {
	if (hasRequiredFXDisplacementFrag) return FXDisplacementFrag;
	hasRequiredFXDisplacementFrag = 1;
	FXDisplacementFrag = [
	    '#define SHADER_NAME DISPLACEMENT_FS',
	    'precision mediump float;',
	    'uniform sampler2D uMainSampler;',
	    'uniform sampler2D uDisplacementSampler;',
	    'uniform vec2 amount;',
	    'varying vec2 outTexCoord;',
	    'void main ()',
	    '{',
	    '    vec2 disp = (-vec2(0.5, 0.5) + texture2D(uDisplacementSampler, outTexCoord).rr) * amount;',
	    '    gl_FragColor = texture2D(uMainSampler, outTexCoord + disp).rgba;',
	    '}',
	].join('\n');
	return FXDisplacementFrag;
}

var DisplacementFXPipeline_1;
var hasRequiredDisplacementFXPipeline;

function requireDisplacementFXPipeline () {
	if (hasRequiredDisplacementFXPipeline) return DisplacementFXPipeline_1;
	hasRequiredDisplacementFXPipeline = 1;
	var Class = requireClass();
	var DisplacementFrag = requireFXDisplacementFrag();
	var PostFXPipeline = requirePostFXPipeline();

	var DisplacementFXPipeline = new Class({

	    Extends: PostFXPipeline,

	    initialize:

	    function DisplacementFXPipeline (game)
	    {
	        PostFXPipeline.call(this, {
	            game: game,
	            fragShader: DisplacementFrag
	        });

	        this.x = 0.005;

	        this.y = 0.005;

	        this.glTexture;
	    },

	    onBoot: function ()
	    {
	        this.setTexture('__WHITE');
	    },

	    setTexture: function (texture)
	    {
	        var hawkTexture = this.game.textures.getFrame(texture);

	        if (hawkTexture)
	        {
	            this.glTexture = hawkTexture.glTexture;
	        }
	    },

	    onDraw: function (source)
	    {
	        var controller = this.getController();

	        var target = this.fullFrame1;

	        this.bind();

	        this.set1i('uMainSampler', 0);
	        this.set1i('uDisplacementSampler', 1);
	        this.set2f('amount', controller.x, controller.y);

	        this.bindTexture(controller.glTexture, 1);

	        this.copySprite(source, target);

	        this.copyToGame(target);
	    }

	});

	DisplacementFXPipeline_1 = DisplacementFXPipeline;
	return DisplacementFXPipeline_1;
}

var FXGlowFrag;
var hasRequiredFXGlowFrag;

function requireFXGlowFrag () {
	if (hasRequiredFXGlowFrag) return FXGlowFrag;
	hasRequiredFXGlowFrag = 1;
	FXGlowFrag = [
	    '#define SHADER_NAME GLOW_FS',
	    'precision mediump float;',
	    'uniform sampler2D uMainSampler;',
	    'varying vec2 outTexCoord;',
	    'uniform float outerStrength;',
	    'uniform float innerStrength;',
	    'uniform vec2 resolution;',
	    'uniform vec4 glowColor;',
	    'uniform bool knockout;',
	    'const float PI = 3.14159265358979323846264;',
	    'const float DIST = __DIST__;',
	    'const float SIZE = min(__SIZE__, PI * 2.0);',
	    'const float STEP = ceil(PI * 2.0 / SIZE);',
	    'const float MAX_ALPHA = STEP * DIST * (DIST + 1.0) / 2.0;',
	    'void main ()',
	    '{',
	    '    vec2 px = vec2(1.0 / resolution.x, 1.0 / resolution.y);',
	    '    float totalAlpha = 0.0;',
	    '    vec2 direction;',
	    '    vec2 displaced;',
	    '    vec4 color;',
	    '    for (float angle = 0.0; angle < PI * 2.0; angle += SIZE)',
	    '    {',
	    '        direction = vec2(cos(angle), sin(angle)) * px;',
	    '        for (float curDistance = 0.0; curDistance < DIST; curDistance++)',
	    '        {',
	    '            displaced = outTexCoord + direction * (curDistance + 1.0);',
	    '            color = texture2D(uMainSampler, displaced);',
	    '            totalAlpha += (DIST - curDistance) * color.a;',
	    '        }',
	    '    }',
	    '    color = texture2D(uMainSampler, outTexCoord);',
	    '    float alphaRatio = (totalAlpha / MAX_ALPHA);',
	    '    float innerGlowAlpha = (1.0 - alphaRatio) * innerStrength * color.a;',
	    '    float innerGlowStrength = min(1.0, innerGlowAlpha);',
	    '    vec4 innerColor = mix(color, glowColor, innerGlowStrength);',
	    '    float outerGlowAlpha = alphaRatio * outerStrength * (1.0 - color.a);',
	    '    float outerGlowStrength = min(1.0 - innerColor.a, outerGlowAlpha);',
	    '    vec4 outerGlowColor = outerGlowStrength * glowColor.rgba;',
	    '    if (knockout)',
	    '    {',
	    '        float resultAlpha = outerGlowAlpha + innerGlowAlpha;',
	    '        gl_FragColor = vec4(glowColor.rgb * resultAlpha, resultAlpha);',
	    '    }',
	    '    else',
	    '    {',
	    '        gl_FragColor = innerColor + outerGlowColor;',
	    '    }',
	    '}',
	].join('\n');
	return FXGlowFrag;
}

var GlowFXPipeline_1;
var hasRequiredGlowFXPipeline;

function requireGlowFXPipeline () {
	if (hasRequiredGlowFXPipeline) return GlowFXPipeline_1;
	hasRequiredGlowFXPipeline = 1;
	var Class = requireClass();
	var GetFastValue = requireGetFastValue();
	var GlowFrag = requireFXGlowFrag();
	var PostFXPipeline = requirePostFXPipeline();
	var Utils = requireUtils$1();

	var GlowFXPipeline = new Class({

	    Extends: PostFXPipeline,

	    initialize:

	    function GlowFXPipeline (game, config)
	    {
	        var quality = GetFastValue(config, 'quality', 0.1);
	        var distance = GetFastValue(config, 'distance', 10);

	        PostFXPipeline.call(this, {
	            game: game,
	            fragShader: Utils.setGlowQuality(GlowFrag, game, quality, distance)
	        });

	        this.outerStrength = 4;

	        this.innerStrength = 0;

	        this.knockout = false;

	        this.glcolor = [ 1, 1, 1, 1 ];
	    },

	    onPreRender: function (controller, shader, width, height)
	    {
	        controller = this.getController(controller);

	        this.set1f('outerStrength', controller.outerStrength, shader);
	        this.set1f('innerStrength', controller.innerStrength, shader);
	        this.set4fv('glowColor', controller.glcolor, shader);
	        this.setBoolean('knockout', controller.knockout, shader);

	        if (width && height)
	        {
	            this.set2f('resolution', width, height, shader);
	        }
	    },

	    onDraw: function (target)
	    {
	        this.set2f('resolution', target.width, target.height);

	        this.bindAndDraw(target);
	    }

	});

	GlowFXPipeline_1 = GlowFXPipeline;
	return GlowFXPipeline_1;
}

var FXGradientFrag;
var hasRequiredFXGradientFrag;

function requireFXGradientFrag () {
	if (hasRequiredFXGradientFrag) return FXGradientFrag;
	hasRequiredFXGradientFrag = 1;
	FXGradientFrag = [
	    '#define SHADER_NAME GRADIENT_FS',
	    '#define SRGB_TO_LINEAR(c) pow((c), vec3(2.2))',
	    '#define LINEAR_TO_SRGB(c) pow((c), vec3(1.0 / 2.2))',
	    '#define SRGB(r, g, b) SRGB_TO_LINEAR(vec3(float(r), float(g), float(b)) / 255.0)',
	    'precision mediump float;',
	    'uniform sampler2D uMainSampler;',
	    'uniform vec2 positionFrom;',
	    'uniform vec2 positionTo;',
	    'uniform vec3 color1;',
	    'uniform vec3 color2;',
	    'uniform float alpha;',
	    'uniform int size;',
	    'varying vec2 outTexCoord;',
	    'float gradientNoise(in vec2 uv)',
	    '{',
	    '    const vec3 magic = vec3(0.06711056, 0.00583715, 52.9829189);',
	    '    return fract(magic.z * fract(dot(uv, magic.xy)));',
	    '}',
	    'float stepped (in float s, in float scale, in int steps)',
	    '{',
	    '    return steps > 0 ? floor( s / ((1.0 * scale) / float(steps))) * 1.0 / float(steps - 1) : s;',
	    '}',
	    'void main ()',
	    '{',
	    '    vec2 a = positionFrom;',
	    '    vec2 b = positionTo;',
	    '    vec2 ba = b - a;',
	    '    float d = dot(outTexCoord - a, ba) / dot(ba, ba);',
	    '    float t = size > 0 ? stepped(d, 1.0, size) : d;',
	    '    t = smoothstep(0.0, 1.0, clamp(t, 0.0, 1.0));',
	    '    vec3 color = mix(SRGB(color1.r, color1.g, color1.b), SRGB(color2.r, color2.g, color2.b), t);',
	    '    color = LINEAR_TO_SRGB(color);',
	    '    color += (1.0 / 255.0) * gradientNoise(outTexCoord) - (0.5 / 255.0);',
	    '    vec4 texture = texture2D(uMainSampler, outTexCoord);',
	    '    gl_FragColor = vec4(mix(color.rgb, texture.rgb, alpha), 1.0) * texture.a;',
	    '}',
	].join('\n');
	return FXGradientFrag;
}

var GradientFXPipeline_1;
var hasRequiredGradientFXPipeline;

function requireGradientFXPipeline () {
	if (hasRequiredGradientFXPipeline) return GradientFXPipeline_1;
	hasRequiredGradientFXPipeline = 1;
	var Class = requireClass();
	var GradientFrag = requireFXGradientFrag();
	var PostFXPipeline = requirePostFXPipeline();

	var GradientFXPipeline = new Class({

	    Extends: PostFXPipeline,

	    initialize:

	    function GradientFXPipeline (game)
	    {
	        PostFXPipeline.call(this, {
	            game: game,
	            fragShader: GradientFrag
	        });

	        this.alpha = 0.2;

	        this.size = 0;

	        this.fromX = 0;

	        this.fromY = 0;

	        this.toX = 0;

	        this.toY = 1;

	        this.glcolor1 = [ 255, 0, 0 ];

	        this.glcolor2 = [ 0, 255, 0 ];
	    },

	    onPreRender: function (controller, shader)
	    {
	        controller = this.getController(controller);

	        this.set1f('alpha', controller.alpha, shader);
	        this.set1i('size', controller.size, shader);
	        this.set3fv('color1', controller.glcolor1, shader);
	        this.set3fv('color2', controller.glcolor2, shader);
	        this.set2f('positionFrom', controller.fromX, controller.fromY, shader);
	        this.set2f('positionTo', controller.toX, controller.toY, shader);
	    }

	});

	GradientFXPipeline_1 = GradientFXPipeline;
	return GradientFXPipeline_1;
}

var FXPixelateFrag;
var hasRequiredFXPixelateFrag;

function requireFXPixelateFrag () {
	if (hasRequiredFXPixelateFrag) return FXPixelateFrag;
	hasRequiredFXPixelateFrag = 1;
	FXPixelateFrag = [
	    '#define SHADER_NAME PIXELATE_FS',
	    'precision mediump float;',
	    'uniform sampler2D uMainSampler;',
	    'uniform vec2 resolution;',
	    'uniform float amount;',
	    'varying vec2 outTexCoord;',
	    'void main ()',
	    '{',
	    '    float pixelSize = floor(2.0 + amount);',
	    '    vec2 center = pixelSize * floor(outTexCoord * resolution / pixelSize) + pixelSize * vec2(0.5, 0.5);',
	    '    vec2 corner1 = center + pixelSize * vec2(-0.5, -0.5);',
	    '    vec2 corner2 = center + pixelSize * vec2(+0.5, -0.5);',
	    '    vec2 corner3 = center + pixelSize * vec2(+0.5, +0.5);',
	    '    vec2 corner4 = center + pixelSize * vec2(-0.5, +0.5);',
	    '    vec4 pixel = 0.4 * texture2D(uMainSampler, center / resolution);',
	    '    pixel += 0.15 * texture2D(uMainSampler, corner1 / resolution);',
	    '    pixel += 0.15 * texture2D(uMainSampler, corner2 / resolution);',
	    '    pixel += 0.15 * texture2D(uMainSampler, corner3 / resolution);',
	    '    pixel += 0.15 * texture2D(uMainSampler, corner4 / resolution);',
	    '    gl_FragColor = pixel;',
	    '}',
	].join('\n');
	return FXPixelateFrag;
}

var PixelateFXPipeline_1;
var hasRequiredPixelateFXPipeline;

function requirePixelateFXPipeline () {
	if (hasRequiredPixelateFXPipeline) return PixelateFXPipeline_1;
	hasRequiredPixelateFXPipeline = 1;
	var Class = requireClass();
	var PixelateFrag = requireFXPixelateFrag();
	var PostFXPipeline = requirePostFXPipeline();

	var PixelateFXPipeline = new Class({

	    Extends: PostFXPipeline,

	    initialize:

	    function PixelateFXPipeline (game)
	    {
	        PostFXPipeline.call(this, {
	            game: game,
	            fragShader: PixelateFrag
	        });

	        this.amount = 1;
	    },

	    onPreRender: function (controller, shader, width, height)
	    {
	        controller = this.getController(controller);

	        this.set1f('amount', controller.amount, shader);

	        if (width && height)
	        {
	            this.set2f('resolution', width, height, shader);
	        }
	    },

	    onDraw: function (target)
	    {
	        this.set2f('resolution', target.width, target.height);

	        this.bindAndDraw(target);
	    }

	});

	PixelateFXPipeline_1 = PixelateFXPipeline;
	return PixelateFXPipeline_1;
}

var FXShadowFrag;
var hasRequiredFXShadowFrag;

function requireFXShadowFrag () {
	if (hasRequiredFXShadowFrag) return FXShadowFrag;
	hasRequiredFXShadowFrag = 1;
	FXShadowFrag = [
	    '#define SHADER_NAME SHADOW_FS',
	    'precision mediump float;',
	    'uniform sampler2D uMainSampler;',
	    'varying vec2 outTexCoord;',
	    'uniform vec2 lightPosition;',
	    'uniform vec4 color;',
	    'uniform float decay;',
	    'uniform float power;',
	    'uniform float intensity;',
	    'uniform int samples;',
	    'const int MAX = 12;',
	    'void main ()',
	    '{',
	    '    vec4 texture = texture2D(uMainSampler, outTexCoord);',
	    '    vec2 pc = (lightPosition - outTexCoord) * intensity;',
	    '    float shadow = 0.0;',
	    '    float limit = max(float(MAX), float(samples));',
	    '    for (int i = 0; i < MAX; ++i)',
	    '    {',
	    '        if (i >= samples)',
	    '        {',
	    '            break;',
	    '        }',
	    '        shadow += texture2D(uMainSampler, outTexCoord + float(i) * decay / limit * pc).a * power;',
	    '    }',
	    '    float mask = 1.0 - texture.a;',
	    '    gl_FragColor = mix(texture, color, shadow * mask);',
	    '}',
	].join('\n');
	return FXShadowFrag;
}

var ShadowFXPipeline_1;
var hasRequiredShadowFXPipeline;

function requireShadowFXPipeline () {
	if (hasRequiredShadowFXPipeline) return ShadowFXPipeline_1;
	hasRequiredShadowFXPipeline = 1;
	var Class = requireClass();
	var ShadowFrag = requireFXShadowFrag();
	var PostFXPipeline = requirePostFXPipeline();

	var ShadowFXPipeline = new Class({

	    Extends: PostFXPipeline,

	    initialize:

	    function ShadowFXPipeline (game)
	    {
	        PostFXPipeline.call(this, {
	            game: game,
	            fragShader: ShadowFrag
	        });

	        this.x = 0;

	        this.y = 0;

	        this.decay = 0.1;

	        this.power = 1;

	        this.glcolor = [ 0, 0, 0, 1 ];

	        this.samples = 6;

	        this.intensity = 1;
	    },

	    onPreRender: function (controller, shader)
	    {
	        controller = this.getController(controller);

	        var samples = controller.samples;

	        this.set1i('samples', samples, shader);
	        this.set1f('intensity', controller.intensity, shader);
	        this.set1f('decay', controller.decay, shader);
	        this.set1f('power', (controller.power / samples), shader);
	        this.set2f('lightPosition', controller.x, controller.y, shader);
	        this.set4fv('color', controller.glcolor, shader);
	    }

	});

	ShadowFXPipeline_1 = ShadowFXPipeline;
	return ShadowFXPipeline_1;
}

var FXShineFrag;
var hasRequiredFXShineFrag;

function requireFXShineFrag () {
	if (hasRequiredFXShineFrag) return FXShineFrag;
	hasRequiredFXShineFrag = 1;
	FXShineFrag = [
	    '#define SHADER_NAME SHINE_FS',
	    'precision mediump float;',
	    'uniform sampler2D uMainSampler;',
	    'uniform vec2 resolution;',
	    'uniform bool reveal;',
	    'uniform float speed;',
	    'uniform float time;',
	    'uniform float lineWidth;',
	    'uniform float gradient;',
	    'varying vec2 outTexCoord;',
	    'void main ()',
	    '{',
	    '	vec2 uv = gl_FragCoord.xy / resolution.xy;',
	    '    vec4 tex = texture2D(uMainSampler, outTexCoord);',
	    '    vec4 col1 = vec4(0.3, 0.0, 0.0, 1.0);',
	    '    vec4 col2 = vec4(0.85, 0.85, 0.85, 1.0);',
	    '    uv.x = uv.x - mod(time * speed, 2.0) + 0.5;',
	    '    float y = uv.x * gradient;',
	    '    float s = smoothstep(y - lineWidth, y, uv.y) - smoothstep(y, y + lineWidth, uv.y);',
	    '    gl_FragColor = (((s * col1) + (s * col2)) * tex);',
	    '    if (!reveal)',
	    '    {',
	    '        gl_FragColor += tex;',
	    '    }',
	    '}',
	].join('\n');
	return FXShineFrag;
}

var ShineFXPipeline_1;
var hasRequiredShineFXPipeline;

function requireShineFXPipeline () {
	if (hasRequiredShineFXPipeline) return ShineFXPipeline_1;
	hasRequiredShineFXPipeline = 1;
	var Class = requireClass();
	var ShineFrag = requireFXShineFrag();
	var PostFXPipeline = requirePostFXPipeline();

	var ShineFXPipeline = new Class({

	    Extends: PostFXPipeline,

	    initialize:

	    function ShineFXPipeline (game)
	    {
	        PostFXPipeline.call(this, {
	            game: game,
	            fragShader: ShineFrag
	        });

	        this.speed = 0.5;

	        this.lineWidth = 0.5;

	        this.gradient = 3;

	        this.reveal = false;
	    },

	    onPreRender: function (controller, shader, width, height)
	    {
	        controller = this.getController(controller);

	        this.setTime('time', shader);

	        this.set1f('speed', controller.speed, shader);
	        this.set1f('lineWidth', controller.lineWidth, shader);
	        this.set1f('gradient', controller.gradient, shader);
	        this.setBoolean('reveal', controller.reveal, shader);

	        if (width && height)
	        {
	            this.set2f('resolution', width, height, shader);
	        }
	    },

	    onDraw: function (target)
	    {
	        this.set2f('resolution', target.width, target.height);

	        this.bindAndDraw(target);
	    }

	});

	ShineFXPipeline_1 = ShineFXPipeline;
	return ShineFXPipeline_1;
}

var FXVignetteFrag;
var hasRequiredFXVignetteFrag;

function requireFXVignetteFrag () {
	if (hasRequiredFXVignetteFrag) return FXVignetteFrag;
	hasRequiredFXVignetteFrag = 1;
	FXVignetteFrag = [
	    '#define SHADER_NAME VIGNETTE_FS',
	    'precision mediump float;',
	    'uniform sampler2D uMainSampler;',
	    'uniform float radius;',
	    'uniform float strength;',
	    'uniform vec2 position;',
	    'varying vec2 outTexCoord;',
	    'void main ()',
	    '{',
	    '    vec4 col = vec4(1.0);',
	    '    float d = length(outTexCoord - position);',
	    '    if (d <= radius)',
	    '    {',
	    '        float g = d / radius;',
	    '        g = sin(g * 3.14 * strength);',
	    '    	col = vec4(g * g * g);',
	    '    }',
	    '    vec4 texture = texture2D(uMainSampler, outTexCoord);',
	    '    gl_FragColor = texture * (1.0 - col);',
	    '}',
	].join('\n');
	return FXVignetteFrag;
}

var VignetteFXPipeline_1;
var hasRequiredVignetteFXPipeline;

function requireVignetteFXPipeline () {
	if (hasRequiredVignetteFXPipeline) return VignetteFXPipeline_1;
	hasRequiredVignetteFXPipeline = 1;
	var Class = requireClass();
	var VignetteFrag = requireFXVignetteFrag();
	var PostFXPipeline = requirePostFXPipeline();

	var VignetteFXPipeline = new Class({

	    Extends: PostFXPipeline,

	    initialize:

	    function VignetteFXPipeline (game)
	    {
	        PostFXPipeline.call(this, {
	            game: game,
	            fragShader: VignetteFrag
	        });

	        this.x = 0.5;

	        this.y = 0.5;

	        this.radius = 0.5;

	        this.strength = 0.5;
	    },

	    onPreRender: function (controller, shader)
	    {
	        controller = this.getController(controller);

	        this.set1f('radius', controller.radius, shader);
	        this.set1f('strength', controller.strength, shader);
	        this.set2f('position', controller.x, controller.y, shader);
	    }

	});

	VignetteFXPipeline_1 = VignetteFXPipeline;
	return VignetteFXPipeline_1;
}

var FXWipeFrag;
var hasRequiredFXWipeFrag;

function requireFXWipeFrag () {
	if (hasRequiredFXWipeFrag) return FXWipeFrag;
	hasRequiredFXWipeFrag = 1;
	FXWipeFrag = [
	    '#define SHADER_NAME WIPE_FS',
	    'precision mediump float;',
	    'uniform sampler2D uMainSampler;',
	    'uniform vec4 config;',
	    'uniform bool reveal;',
	    'varying vec2 outTexCoord;',
	    'void main ()',
	    '{',
	    '    vec2 uv = outTexCoord;',
	    '    vec4 color0;',
	    '    vec4 color1;',
	    '    if (reveal)',
	    '    {',
	    '        color0 = vec4(0);',
	    '        color1 = texture2D(uMainSampler, uv);',
	    '    }',
	    '    else',
	    '    {',
	    '        color0 = texture2D(uMainSampler, uv);',
	    '        color1 = vec4(0);',
	    '    }',
	    '    float distance = config.x;',
	    '    float width = config.y;',
	    '    float direction = config.z;',
	    '    float axis = uv.x;',
	    '    if (config.w == 1.0)',
	    '    {',
	    '        axis = uv.y;',
	    '    }',
	    '    float adjust = mix(width, -width, distance);',
	    '    float value = smoothstep(distance - width, distance + width, abs(direction - axis) + adjust);',
	    '    gl_FragColor = mix(color1, color0, value);',
	    '}',
	].join('\n');
	return FXWipeFrag;
}

var WipeFXPipeline_1;
var hasRequiredWipeFXPipeline;

function requireWipeFXPipeline () {
	if (hasRequiredWipeFXPipeline) return WipeFXPipeline_1;
	hasRequiredWipeFXPipeline = 1;
	var Class = requireClass();
	var WipeFrag = requireFXWipeFrag();
	var PostFXPipeline = requirePostFXPipeline();

	var WipeFXPipeline = new Class({

	    Extends: PostFXPipeline,

	    initialize:

	    function WipeFXPipeline (game)
	    {
	        PostFXPipeline.call(this, {
	            game: game,
	            fragShader: WipeFrag
	        });

	        this.progress = 0;

	        this.wipeWidth = 0.1;

	        this.direction = 0;

	        this.axis = 0;

	        this.reveal = false;
	    },

	    onPreRender: function (controller, shader)
	    {
	        controller = this.getController(controller);

	        var progress = controller.progress;
	        var wipeWidth = controller.wipeWidth;
	        var direction = controller.direction;
	        var axis = controller.axis;

	        this.set4f('config', progress, wipeWidth, direction, axis, shader);
	        this.setBoolean('reveal', controller.reveal, shader);
	    }

	});

	WipeFXPipeline_1 = WipeFXPipeline;
	return WipeFXPipeline_1;
}

var fx;
var hasRequiredFx;

function requireFx () {
	if (hasRequiredFx) return fx;
	hasRequiredFx = 1;
	var FX = {

	    Barrel: requireBarrelFXPipeline(),
	    Bloom: requireBloomFXPipeline(),
	    Blur: requireBlurFXPipeline(),
	    Bokeh: requireBokehFXPipeline(),
	    Circle: requireCircleFXPipeline(),
	    ColorMatrix: requireColorMatrixFXPipeline(),
	    Displacement: requireDisplacementFXPipeline(),
	    Glow: requireGlowFXPipeline(),
	    Gradient: requireGradientFXPipeline(),
	    Pixelate: requirePixelateFXPipeline(),
	    Shadow: requireShadowFXPipeline(),
	    Shine: requireShineFXPipeline(),
	    Vignette: requireVignetteFXPipeline(),
	    Wipe: requireWipeFXPipeline()

	};

	fx = FX;
	return fx;
}

var ColorMatrixFrag;
var hasRequiredColorMatrixFrag;

function requireColorMatrixFrag () {
	if (hasRequiredColorMatrixFrag) return ColorMatrixFrag;
	hasRequiredColorMatrixFrag = 1;
	ColorMatrixFrag = [
	    '#define SHADER_NAME PHASER_COLORMATRIX_FS',
	    'precision mediump float;',
	    'uniform sampler2D uMainSampler;',
	    'uniform float uColorMatrix[20];',
	    'uniform float uAlpha;',
	    'varying vec2 outTexCoord;',
	    'void main ()',
	    '{',
	    '    vec4 c = texture2D(uMainSampler, outTexCoord);',
	    '    if (uAlpha == 0.0)',
	    '    {',
	    '        gl_FragColor = c;',
	    '        return;',
	    '    }',
	    '    if (c.a > 0.0)',
	    '    {',
	    '        c.rgb /= c.a;',
	    '    }',
	    '    vec4 result;',
	    '    result.r = (uColorMatrix[0] * c.r) + (uColorMatrix[1] * c.g) + (uColorMatrix[2] * c.b) + (uColorMatrix[3] * c.a) + uColorMatrix[4];',
	    '    result.g = (uColorMatrix[5] * c.r) + (uColorMatrix[6] * c.g) + (uColorMatrix[7] * c.b) + (uColorMatrix[8] * c.a) + uColorMatrix[9];',
	    '    result.b = (uColorMatrix[10] * c.r) + (uColorMatrix[11] * c.g) + (uColorMatrix[12] * c.b) + (uColorMatrix[13] * c.a) + uColorMatrix[14];',
	    '    result.a = (uColorMatrix[15] * c.r) + (uColorMatrix[16] * c.g) + (uColorMatrix[17] * c.b) + (uColorMatrix[18] * c.a) + uColorMatrix[19];',
	    '    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);',
	    '    rgb *= result.a;',
	    '    gl_FragColor = vec4(rgb, result.a);',
	    '}',
	].join('\n');
	return ColorMatrixFrag;
}

var Earcut;
var hasRequiredEarcut;

function requireEarcut () {
	if (hasRequiredEarcut) return Earcut;
	hasRequiredEarcut = 1;

	function earcut(data, holeIndices, dim) {

	    dim = dim || 2;

	    var hasHoles = holeIndices && holeIndices.length,
	        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
	        outerNode = linkedList(data, 0, outerLen, dim, true),
	        triangles = [];

	    if (!outerNode || outerNode.next === outerNode.prev) return triangles;

	    var minX, minY, maxX, maxY, x, y, invSize;

	    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

	    if (data.length > 80 * dim) {
	        minX = maxX = data[0];
	        minY = maxY = data[1];

	        for (var i = dim; i < outerLen; i += dim) {
	            x = data[i];
	            y = data[i + 1];
	            if (x < minX) minX = x;
	            if (y < minY) minY = y;
	            if (x > maxX) maxX = x;
	            if (y > maxY) maxY = y;
	        }

	        invSize = Math.max(maxX - minX, maxY - minY);
	        invSize = invSize !== 0 ? 32767 / invSize : 0;
	    }

	    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);

	    return triangles;
	}

	function linkedList(data, start, end, dim, clockwise) {
	    var i, last;

	    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
	        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
	    } else {
	        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
	    }

	    if (last && equals(last, last.next)) {
	        removeNode(last);
	        last = last.next;
	    }

	    return last;
	}

	function filterPoints(start, end) {
	    if (!start) return start;
	    if (!end) end = start;

	    var p = start,
	        again;
	    do {
	        again = false;

	        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
	            removeNode(p);
	            p = end = p.prev;
	            if (p === p.next) break;
	            again = true;

	        } else {
	            p = p.next;
	        }
	    } while (again || p !== end);

	    return end;
	}

	function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
	    if (!ear) return;

	    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);

	    var stop = ear,
	        prev, next;

	    while (ear.prev !== ear.next) {
	        prev = ear.prev;
	        next = ear.next;

	        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {

	            triangles.push(prev.i / dim | 0);
	            triangles.push(ear.i / dim | 0);
	            triangles.push(next.i / dim | 0);

	            removeNode(ear);

	            ear = next.next;
	            stop = next.next;

	            continue;
	        }

	        ear = next;

	        if (ear === stop) {

	            if (!pass) {
	                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

	            } else if (pass === 1) {
	                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
	                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

	            } else if (pass === 2) {
	                splitEarcut(ear, triangles, dim, minX, minY, invSize);
	            }

	            break;
	        }
	    }
	}

	function isEar(ear) {
	    var a = ear.prev,
	        b = ear,
	        c = ear.next;

	    if (area(a, b, c) >= 0) return false; 

	    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;

	    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),
	        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),
	        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),
	        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);

	    var p = c.next;
	    while (p !== a) {
	        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&
	            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) &&
	            area(p.prev, p, p.next) >= 0) return false;
	        p = p.next;
	    }

	    return true;
	}

	function isEarHashed(ear, minX, minY, invSize) {
	    var a = ear.prev,
	        b = ear,
	        c = ear.next;

	    if (area(a, b, c) >= 0) return false; 

	    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;

	    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),
	        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),
	        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),
	        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);

	    var minZ = zOrder(x0, y0, minX, minY, invSize),
	        maxZ = zOrder(x1, y1, minX, minY, invSize);

	    var p = ear.prevZ,
	        n = ear.nextZ;

	    while (p && p.z >= minZ && n && n.z <= maxZ) {
	        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
	            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
	        p = p.prevZ;

	        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
	            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
	        n = n.nextZ;
	    }

	    while (p && p.z >= minZ) {
	        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
	            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
	        p = p.prevZ;
	    }

	    while (n && n.z <= maxZ) {
	        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
	            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
	        n = n.nextZ;
	    }

	    return true;
	}

	function cureLocalIntersections(start, triangles, dim) {
	    var p = start;
	    do {
	        var a = p.prev,
	            b = p.next.next;

	        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

	            triangles.push(a.i / dim | 0);
	            triangles.push(p.i / dim | 0);
	            triangles.push(b.i / dim | 0);

	            removeNode(p);
	            removeNode(p.next);

	            p = start = b;
	        }
	        p = p.next;
	    } while (p !== start);

	    return filterPoints(p);
	}

	function splitEarcut(start, triangles, dim, minX, minY, invSize) {

	    var a = start;
	    do {
	        var b = a.next.next;
	        while (b !== a.prev) {
	            if (a.i !== b.i && isValidDiagonal(a, b)) {

	                var c = splitPolygon(a, b);

	                a = filterPoints(a, a.next);
	                c = filterPoints(c, c.next);

	                earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
	                earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
	                return;
	            }
	            b = b.next;
	        }
	        a = a.next;
	    } while (a !== start);
	}

	function eliminateHoles(data, holeIndices, outerNode, dim) {
	    var queue = [],
	        i, len, start, end, list;

	    for (i = 0, len = holeIndices.length; i < len; i++) {
	        start = holeIndices[i] * dim;
	        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
	        list = linkedList(data, start, end, dim, false);
	        if (list === list.next) list.steiner = true;
	        queue.push(getLeftmost(list));
	    }

	    queue.sort(compareX);

	    for (i = 0; i < queue.length; i++) {
	        outerNode = eliminateHole(queue[i], outerNode);
	    }

	    return outerNode;
	}

	function compareX(a, b) {
	    return a.x - b.x;
	}

	function eliminateHole(hole, outerNode) {
	    var bridge = findHoleBridge(hole, outerNode);
	    if (!bridge) {
	        return outerNode;
	    }

	    var bridgeReverse = splitPolygon(bridge, hole);

	    filterPoints(bridgeReverse, bridgeReverse.next);
	    return filterPoints(bridge, bridge.next);
	}

	function findHoleBridge(hole, outerNode) {
	    var p = outerNode,
	        hx = hole.x,
	        hy = hole.y,
	        qx = -Infinity,
	        m;

	    do {
	        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
	            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
	            if (x <= hx && x > qx) {
	                qx = x;
	                m = p.x < p.next.x ? p : p.next;
	                if (x === hx) return m; 
	            }
	        }
	        p = p.next;
	    } while (p !== outerNode);

	    if (!m) return null;

	    var stop = m,
	        mx = m.x,
	        my = m.y,
	        tanMin = Infinity,
	        tan;

	    p = m;

	    do {
	        if (hx >= p.x && p.x >= mx && hx !== p.x &&
	                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

	            tan = Math.abs(hy - p.y) / (hx - p.x); 

	            if (locallyInside(p, hole) &&
	                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {
	                m = p;
	                tanMin = tan;
	            }
	        }

	        p = p.next;
	    } while (p !== stop);

	    return m;
	}

	function sectorContainsSector(m, p) {
	    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
	}

	function indexCurve(start, minX, minY, invSize) {
	    var p = start;
	    do {
	        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);
	        p.prevZ = p.prev;
	        p.nextZ = p.next;
	        p = p.next;
	    } while (p !== start);

	    p.prevZ.nextZ = null;
	    p.prevZ = null;

	    sortLinked(p);
	}

	function sortLinked(list) {
	    var i, p, q, e, tail, numMerges, pSize, qSize,
	        inSize = 1;

	    do {
	        p = list;
	        list = null;
	        tail = null;
	        numMerges = 0;

	        while (p) {
	            numMerges++;
	            q = p;
	            pSize = 0;
	            for (i = 0; i < inSize; i++) {
	                pSize++;
	                q = q.nextZ;
	                if (!q) break;
	            }
	            qSize = inSize;

	            while (pSize > 0 || (qSize > 0 && q)) {

	                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
	                    e = p;
	                    p = p.nextZ;
	                    pSize--;
	                } else {
	                    e = q;
	                    q = q.nextZ;
	                    qSize--;
	                }

	                if (tail) tail.nextZ = e;
	                else list = e;

	                e.prevZ = tail;
	                tail = e;
	            }

	            p = q;
	        }

	        tail.nextZ = null;
	        inSize *= 2;

	    } while (numMerges > 1);

	    return list;
	}

	function zOrder(x, y, minX, minY, invSize) {

	    x = (x - minX) * invSize | 0;
	    y = (y - minY) * invSize | 0;

	    x = (x | (x << 8)) & 0x00FF00FF;
	    x = (x | (x << 4)) & 0x0F0F0F0F;
	    x = (x | (x << 2)) & 0x33333333;
	    x = (x | (x << 1)) & 0x55555555;

	    y = (y | (y << 8)) & 0x00FF00FF;
	    y = (y | (y << 4)) & 0x0F0F0F0F;
	    y = (y | (y << 2)) & 0x33333333;
	    y = (y | (y << 1)) & 0x55555555;

	    return x | (y << 1);
	}

	function getLeftmost(start) {
	    var p = start,
	        leftmost = start;
	    do {
	        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;
	        p = p.next;
	    } while (p !== start);

	    return leftmost;
	}

	function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
	    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) &&
	           (ax - px) * (by - py) >= (bx - px) * (ay - py) &&
	           (bx - px) * (cy - py) >= (cx - px) * (by - py);
	}

	function isValidDiagonal(a, b) {
	    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && 
	           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && 
	            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || 
	            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); 
	}

	function area(p, q, r) {
	    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
	}

	function equals(p1, p2) {
	    return p1.x === p2.x && p1.y === p2.y;
	}

	function intersects(p1, q1, p2, q2) {
	    var o1 = sign(area(p1, q1, p2));
	    var o2 = sign(area(p1, q1, q2));
	    var o3 = sign(area(p2, q2, p1));
	    var o4 = sign(area(p2, q2, q1));

	    if (o1 !== o2 && o3 !== o4) return true; 

	    if (o1 === 0 && onSegment(p1, p2, q1)) return true; 
	    if (o2 === 0 && onSegment(p1, q2, q1)) return true; 
	    if (o3 === 0 && onSegment(p2, p1, q2)) return true; 
	    if (o4 === 0 && onSegment(p2, q1, q2)) return true; 

	    return false;
	}

	function onSegment(p, q, r) {
	    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
	}

	function sign(num) {
	    return num > 0 ? 1 : num < 0 ? -1 : 0;
	}

	function intersectsPolygon(a, b) {
	    var p = a;
	    do {
	        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
	                intersects(p, p.next, a, b)) return true;
	        p = p.next;
	    } while (p !== a);

	    return false;
	}

	function locallyInside(a, b) {
	    return area(a.prev, a, a.next) < 0 ?
	        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
	        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
	}

	function middleInside(a, b) {
	    var p = a,
	        inside = false,
	        px = (a.x + b.x) / 2,
	        py = (a.y + b.y) / 2;
	    do {
	        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
	                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
	            inside = !inside;
	        p = p.next;
	    } while (p !== a);

	    return inside;
	}

	function splitPolygon(a, b) {
	    var a2 = new Node(a.i, a.x, a.y),
	        b2 = new Node(b.i, b.x, b.y),
	        an = a.next,
	        bp = b.prev;

	    a.next = b;
	    b.prev = a;

	    a2.next = an;
	    an.prev = a2;

	    b2.next = a2;
	    a2.prev = b2;

	    bp.next = b2;
	    b2.prev = bp;

	    return b2;
	}

	function insertNode(i, x, y, last) {
	    var p = new Node(i, x, y);

	    if (!last) {
	        p.prev = p;
	        p.next = p;

	    } else {
	        p.next = last.next;
	        p.prev = last;
	        last.next.prev = p;
	        last.next = p;
	    }
	    return p;
	}

	function removeNode(p) {
	    p.next.prev = p.prev;
	    p.prev.next = p.next;

	    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
	    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
	}

	function Node(i, x, y) {

	    this.i = i;

	    this.x = x;
	    this.y = y;

	    this.prev = null;
	    this.next = null;

	    this.z = 0;

	    this.prevZ = null;
	    this.nextZ = null;

	    this.steiner = false;
	}

	earcut.deviation = function (data, holeIndices, dim, triangles) {
	    var hasHoles = holeIndices && holeIndices.length;
	    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

	    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
	    if (hasHoles) {
	        for (var i = 0, len = holeIndices.length; i < len; i++) {
	            var start = holeIndices[i] * dim;
	            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
	            polygonArea -= Math.abs(signedArea(data, start, end, dim));
	        }
	    }

	    var trianglesArea = 0;
	    for (i = 0; i < triangles.length; i += 3) {
	        var a = triangles[i] * dim;
	        var b = triangles[i + 1] * dim;
	        var c = triangles[i + 2] * dim;
	        trianglesArea += Math.abs(
	            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
	            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
	    }

	    return polygonArea === 0 && trianglesArea === 0 ? 0 :
	        Math.abs((trianglesArea - polygonArea) / polygonArea);
	};

	function signedArea(data, start, end, dim) {
	    var sum = 0;
	    for (var i = start, j = end - dim; i < end; i += dim) {
	        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
	        j = i;
	    }
	    return sum;
	}

	earcut.flatten = function (data) {
	    var dim = data[0][0].length,
	        result = {vertices: [], holes: [], dimensions: dim},
	        holeIndex = 0;

	    for (var i = 0; i < data.length; i++) {
	        for (var j = 0; j < data[i].length; j++) {
	            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
	        }
	        if (i > 0) {
	            holeIndex += data[i - 1].length;
	            result.holes.push(holeIndex);
	        }
	    }
	    return result;
	};

	Earcut = earcut;
	return Earcut;
}

var MultiFrag;
var hasRequiredMultiFrag;

function requireMultiFrag () {
	if (hasRequiredMultiFrag) return MultiFrag;
	hasRequiredMultiFrag = 1;
	MultiFrag = [
	    '#define SHADER_NAME PHASER_MULTI_FS',
	    '#ifdef GL_FRAGMENT_PRECISION_HIGH',
	    'precision highp float;',
	    '#else',
	    'precision mediump float;',
	    '#endif',
	    'uniform sampler2D uMainSampler[%count%];',
	    'varying vec2 outTexCoord;',
	    'varying float outTexId;',
	    'varying float outTintEffect;',
	    'varying vec4 outTint;',
	    'void main ()',
	    '{',
	    '    vec4 texture;',
	    '    %forloop%',
	    '    vec4 texel = vec4(outTint.bgr * outTint.a, outTint.a);',
	    '    vec4 color = texture * texel;',
	    '    if (outTintEffect == 1.0)',
	    '    {',
	    '        color.rgb = mix(texture.rgb, outTint.bgr * outTint.a, texture.a);',
	    '    }',
	    '    else if (outTintEffect == 2.0)',
	    '    {',
	    '        color = texel;',
	    '    }',
	    '    gl_FragColor = color;',
	    '}',
	].join('\n');
	return MultiFrag;
}

var MultiVert;
var hasRequiredMultiVert;

function requireMultiVert () {
	if (hasRequiredMultiVert) return MultiVert;
	hasRequiredMultiVert = 1;
	MultiVert = [
	    '#define SHADER_NAME PHASER_MULTI_VS',
	    'precision mediump float;',
	    'uniform mat4 uProjectionMatrix;',
	    'uniform vec2 uResolution;',
	    'attribute vec2 inPosition;',
	    'attribute vec2 inTexCoord;',
	    'attribute float inTexId;',
	    'attribute float inTintEffect;',
	    'attribute vec4 inTint;',
	    'varying vec2 outTexCoord;',
	    'varying float outTexId;',
	    'varying float outTintEffect;',
	    'varying vec4 outTint;',
	    'void main ()',
	    '{',
	    '    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);',
	    '    outTexCoord = inTexCoord;',
	    '    outTexId = inTexId;',
	    '    outTint = inTint;',
	    '    outTintEffect = inTintEffect;',
	    '}',
	].join('\n');
	return MultiVert;
}

var MultiPipeline_1;
var hasRequiredMultiPipeline;

function requireMultiPipeline () {
	if (hasRequiredMultiPipeline) return MultiPipeline_1;
	hasRequiredMultiPipeline = 1;
	var Class = requireClass();
	var Earcut = requireEarcut();
	var GetFastValue = requireGetFastValue();
	var ShaderSourceFS = requireMultiFrag();
	var ShaderSourceVS = requireMultiVert();
	var TransformMatrix = requireTransformMatrix();
	var Utils = requireUtils$1();
	var WEBGL_CONST = require_const$8();
	var WebGLPipeline = requireWebGLPipeline();

	var MultiPipeline = new Class({

	    Extends: WebGLPipeline,

	    initialize:

	    function MultiPipeline (config)
	    {
	        var renderer = config.game.renderer;

	        var fragmentShaderSource = GetFastValue(config, 'fragShader', ShaderSourceFS);

	        config.fragShader = Utils.parseFragmentShaderMaxTextures(fragmentShaderSource, renderer.maxTextures);
	        config.vertShader = GetFastValue(config, 'vertShader', ShaderSourceVS);
	        config.attributes = GetFastValue(config, 'attributes', [
	            {
	                name: 'inPosition',
	                size: 2
	            },
	            {
	                name: 'inTexCoord',
	                size: 2
	            },
	            {
	                name: 'inTexId'
	            },
	            {
	                name: 'inTintEffect'
	            },
	            {
	                name: 'inTint',
	                size: 4,
	                type: WEBGL_CONST.UNSIGNED_BYTE,
	                normalized: true
	            }
	        ]);
	        config.resizeUniform = 'uResolution';

	        WebGLPipeline.call(this, config);

	        this._tempMatrix1 = new TransformMatrix();

	        this._tempMatrix2 = new TransformMatrix();

	        this._tempMatrix3 = new TransformMatrix();

	        this.calcMatrix = new TransformMatrix();

	        this.tempTriangle = [
	            { x: 0, y: 0, width: 0 },
	            { x: 0, y: 0, width: 0 },
	            { x: 0, y: 0, width: 0 },
	            { x: 0, y: 0, width: 0 }
	        ];

	        this.strokeTint = { TL: 0, TR: 0, BL: 0, BR: 0 };

	        this.fillTint = { TL: 0, TR: 0, BL: 0, BR: 0 };

	        this.currentFrame = { u0: 0, v0: 0, u1: 1, v1: 1 };

	        this.firstQuad = [ 0, 0, 0, 0, 0 ];

	        this.prevQuad = [ 0, 0, 0, 0, 0 ];

	        this.polygonCache = [];
	    },

	    boot: function ()
	    {
	        WebGLPipeline.prototype.boot.call(this);

	        var renderer = this.renderer;

	        this.set1iv('uMainSampler', renderer.textureIndexes);
	        this.set2f('uResolution', renderer.width, renderer.height);
	    },

	    batchSprite: function (gameObject, camera, parentTransformMatrix)
	    {
	        this.manager.set(this, gameObject);

	        var camMatrix = this._tempMatrix1;
	        var spriteMatrix = this._tempMatrix2;
	        var calcMatrix = this._tempMatrix3;

	        var frame = gameObject.frame;
	        var texture = frame.glTexture;

	        var u0 = frame.u0;
	        var v0 = frame.v0;
	        var u1 = frame.u1;
	        var v1 = frame.v1;
	        var frameX = frame.x;
	        var frameY = frame.y;
	        var frameWidth = frame.cutWidth;
	        var frameHeight = frame.cutHeight;
	        var customPivot = frame.customPivot;

	        var displayOriginX = gameObject.displayOriginX;
	        var displayOriginY = gameObject.displayOriginY;

	        var x = -displayOriginX + frameX;
	        var y = -displayOriginY + frameY;

	        if (gameObject.isCropped)
	        {
	            var crop = gameObject._crop;

	            if (crop.flipX !== gameObject.flipX || crop.flipY !== gameObject.flipY)
	            {
	                frame.updateCropUVs(crop, gameObject.flipX, gameObject.flipY);
	            }

	            u0 = crop.u0;
	            v0 = crop.v0;
	            u1 = crop.u1;
	            v1 = crop.v1;

	            frameWidth = crop.width;
	            frameHeight = crop.height;

	            frameX = crop.x;
	            frameY = crop.y;

	            x = -displayOriginX + frameX;
	            y = -displayOriginY + frameY;
	        }

	        var flipX = 1;
	        var flipY = 1;

	        if (gameObject.flipX)
	        {
	            if (!customPivot)
	            {
	                x += (-frame.realWidth + (displayOriginX * 2));
	            }

	            flipX = -1;
	        }

	        if (gameObject.flipY)
	        {
	            if (!customPivot)
	            {
	                y += (-frame.realHeight + (displayOriginY * 2));
	            }

	            flipY = -1;
	        }

	        var gx = gameObject.x;
	        var gy = gameObject.y;

	        if (camera.roundPixels)
	        {
	            gx = Math.floor(gx);
	            gy = Math.floor(gy);
	        }

	        spriteMatrix.applyITRS(gx, gy, gameObject.rotation, gameObject.scaleX * flipX, gameObject.scaleY * flipY);

	        camMatrix.copyFrom(camera.matrix);

	        if (parentTransformMatrix)
	        {

	            camMatrix.multiplyWithOffset(parentTransformMatrix, -camera.scrollX * gameObject.scrollFactorX, -camera.scrollY * gameObject.scrollFactorY);

	            spriteMatrix.e = gx;
	            spriteMatrix.f = gy;
	        }
	        else
	        {
	            spriteMatrix.e -= camera.scrollX * gameObject.scrollFactorX;
	            spriteMatrix.f -= camera.scrollY * gameObject.scrollFactorY;
	        }

	        camMatrix.multiply(spriteMatrix, calcMatrix);

	        var quad = calcMatrix.setQuad(x, y, x + frameWidth, y + frameHeight, camera.renderRoundPixels);

	        var getTint = Utils.getTintAppendFloatAlpha;
	        var cameraAlpha = camera.alpha;

	        var tintTL = getTint(gameObject.tintTopLeft, cameraAlpha * gameObject._alphaTL);
	        var tintTR = getTint(gameObject.tintTopRight, cameraAlpha * gameObject._alphaTR);
	        var tintBL = getTint(gameObject.tintBottomLeft, cameraAlpha * gameObject._alphaBL);
	        var tintBR = getTint(gameObject.tintBottomRight, cameraAlpha * gameObject._alphaBR);

	        if (this.shouldFlush(6))
	        {
	            this.flush();
	        }

	        var unit = this.setGameObject(gameObject, frame);

	        this.manager.preBatch(gameObject);

	        this.batchQuad(gameObject, quad[0], quad[1], quad[2], quad[3], quad[4], quad[5], quad[6], quad[7], u0, v0, u1, v1, tintTL, tintTR, tintBL, tintBR, gameObject.tintFill, texture, unit);

	        this.manager.postBatch(gameObject);
	    },

	    batchTexture: function (
	        gameObject,
	        texture,
	        textureWidth, textureHeight,
	        srcX, srcY,
	        srcWidth, srcHeight,
	        scaleX, scaleY,
	        rotation,
	        flipX, flipY,
	        scrollFactorX, scrollFactorY,
	        displayOriginX, displayOriginY,
	        frameX, frameY, frameWidth, frameHeight,
	        tintTL, tintTR, tintBL, tintBR, tintEffect,
	        uOffset, vOffset,
	        camera,
	        parentTransformMatrix,
	        skipFlip,
	        textureUnit,
	        skipPrePost)
	    {
	        if (skipPrePost === undefined) { skipPrePost = false; }

	        this.manager.set(this, gameObject);

	        var camMatrix = this._tempMatrix1;
	        var spriteMatrix = this._tempMatrix2;
	        var calcMatrix = this._tempMatrix3;

	        var u0 = (frameX / textureWidth) + uOffset;
	        var v0 = (frameY / textureHeight) + vOffset;
	        var u1 = (frameX + frameWidth) / textureWidth + uOffset;
	        var v1 = (frameY + frameHeight) / textureHeight + vOffset;

	        var width = srcWidth;
	        var height = srcHeight;

	        var x = -displayOriginX;
	        var y = -displayOriginY;

	        if (gameObject.isCropped)
	        {
	            var crop = gameObject._crop;

	            var cropWidth = crop.width;
	            var cropHeight = crop.height;

	            width = cropWidth;
	            height = cropHeight;

	            srcWidth = cropWidth;
	            srcHeight = cropHeight;

	            frameX = crop.x;
	            frameY = crop.y;

	            var ox = frameX;
	            var oy = frameY;

	            if (flipX)
	            {
	                ox = (frameWidth - crop.x - cropWidth);
	            }

	            if (flipY)
	            {
	                oy = (frameHeight - crop.y - cropHeight);
	            }

	            u0 = (ox / textureWidth) + uOffset;
	            v0 = (oy / textureHeight) + vOffset;
	            u1 = (ox + cropWidth) / textureWidth + uOffset;
	            v1 = (oy + cropHeight) / textureHeight + vOffset;

	            x = -displayOriginX + frameX;
	            y = -displayOriginY + frameY;
	        }

	        flipY = flipY ^ (!skipFlip && texture.isRenderTexture ? 1 : 0);

	        if (flipX)
	        {
	            width *= -1;
	            x += srcWidth;
	        }

	        if (flipY)
	        {
	            height *= -1;
	            y += srcHeight;
	        }

	        if (camera.roundPixels)
	        {
	            srcX = Math.floor(srcX);
	            srcY = Math.floor(srcY);
	        }

	        spriteMatrix.applyITRS(srcX, srcY, rotation, scaleX, scaleY);

	        camMatrix.copyFrom(camera.matrix);

	        if (parentTransformMatrix)
	        {

	            camMatrix.multiplyWithOffset(parentTransformMatrix, -camera.scrollX * scrollFactorX, -camera.scrollY * scrollFactorY);

	            spriteMatrix.e = srcX;
	            spriteMatrix.f = srcY;
	        }
	        else
	        {
	            spriteMatrix.e -= camera.scrollX * scrollFactorX;
	            spriteMatrix.f -= camera.scrollY * scrollFactorY;
	        }

	        camMatrix.multiply(spriteMatrix, calcMatrix);

	        var quad = calcMatrix.setQuad(x, y, x + width, y + height, camera.renderRoundPixels);

	        if (textureUnit === undefined || textureUnit === null)
	        {
	            textureUnit = this.setTexture2D(texture);
	        }

	        if (gameObject && !skipPrePost)
	        {
	            this.manager.preBatch(gameObject);
	        }

	        this.batchQuad(gameObject, quad[0], quad[1], quad[2], quad[3], quad[4], quad[5], quad[6], quad[7], u0, v0, u1, v1, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, textureUnit);

	        if (gameObject && !skipPrePost)
	        {
	            this.manager.postBatch(gameObject);
	        }
	    },

	    batchTextureFrame: function (
	        frame,
	        x, y,
	        tint, alpha,
	        transformMatrix,
	        parentTransformMatrix
	    )
	    {
	        this.manager.set(this);

	        var spriteMatrix = this._tempMatrix1.copyFrom(transformMatrix);
	        var calcMatrix = this._tempMatrix2;

	        if (parentTransformMatrix)
	        {
	            spriteMatrix.multiply(parentTransformMatrix, calcMatrix);
	        }
	        else
	        {
	            calcMatrix = spriteMatrix;
	        }

	        var quad = calcMatrix.setQuad(x, y, x + frame.width, y + frame.height);

	        var unit = this.setTexture2D(frame.source.glTexture);

	        tint = Utils.getTintAppendFloatAlpha(tint, alpha);

	        this.batchQuad(null, quad[0], quad[1], quad[2], quad[3], quad[4], quad[5], quad[6], quad[7], frame.u0, frame.v0, frame.u1, frame.v1, tint, tint, tint, tint, 0, frame.glTexture, unit);
	    },

	    batchFillRect: function (x, y, width, height, currentMatrix, parentMatrix)
	    {
	        this.renderer.pipelines.set(this);

	        var calcMatrix = this.calcMatrix;

	        if (parentMatrix)
	        {
	            parentMatrix.multiply(currentMatrix, calcMatrix);
	        }

	        var quad = calcMatrix.setQuad(x, y, x + width, y + height);

	        var tint = this.fillTint;

	        this.batchQuad(null, quad[0], quad[1], quad[2], quad[3], quad[4], quad[5], quad[6], quad[7], 0, 0, 1, 1, tint.TL, tint.TR, tint.BL, tint.BR, 2);
	    },

	    batchFillTriangle: function (x0, y0, x1, y1, x2, y2, currentMatrix, parentMatrix)
	    {
	        this.renderer.pipelines.set(this);

	        var calcMatrix = this.calcMatrix;

	        if (parentMatrix)
	        {
	            parentMatrix.multiply(currentMatrix, calcMatrix);
	        }

	        var tx0 = calcMatrix.getX(x0, y0);
	        var ty0 = calcMatrix.getY(x0, y0);

	        var tx1 = calcMatrix.getX(x1, y1);
	        var ty1 = calcMatrix.getY(x1, y1);

	        var tx2 = calcMatrix.getX(x2, y2);
	        var ty2 = calcMatrix.getY(x2, y2);

	        var tint = this.fillTint;

	        this.batchTri(null, tx0, ty0, tx1, ty1, tx2, ty2, 0, 0, 1, 1, tint.TL, tint.TR, tint.BL, 2);
	    },

	    batchStrokeTriangle: function (x0, y0, x1, y1, x2, y2, lineWidth, currentMatrix, parentMatrix)
	    {
	        var tempTriangle = this.tempTriangle;

	        tempTriangle[0].x = x0;
	        tempTriangle[0].y = y0;
	        tempTriangle[0].width = lineWidth;

	        tempTriangle[1].x = x1;
	        tempTriangle[1].y = y1;
	        tempTriangle[1].width = lineWidth;

	        tempTriangle[2].x = x2;
	        tempTriangle[2].y = y2;
	        tempTriangle[2].width = lineWidth;

	        tempTriangle[3].x = x0;
	        tempTriangle[3].y = y0;
	        tempTriangle[3].width = lineWidth;

	        this.batchStrokePath(tempTriangle, lineWidth, false, currentMatrix, parentMatrix);
	    },

	    batchFillPath: function (path, currentMatrix, parentMatrix)
	    {
	        this.renderer.pipelines.set(this);

	        var calcMatrix = this.calcMatrix;

	        if (parentMatrix)
	        {
	            parentMatrix.multiply(currentMatrix, calcMatrix);
	        }

	        var length = path.length;
	        var polygonCache = this.polygonCache;
	        var polygonIndexArray;
	        var point;

	        var tintTL = this.fillTint.TL;
	        var tintTR = this.fillTint.TR;
	        var tintBL = this.fillTint.BL;

	        for (var pathIndex = 0; pathIndex < length; ++pathIndex)
	        {
	            point = path[pathIndex];
	            polygonCache.push(point.x, point.y);
	        }

	        polygonIndexArray = Earcut(polygonCache);
	        length = polygonIndexArray.length;

	        for (var index = 0; index < length; index += 3)
	        {
	            var p0 = polygonIndexArray[index + 0] * 2;
	            var p1 = polygonIndexArray[index + 1] * 2;
	            var p2 = polygonIndexArray[index + 2] * 2;

	            var x0 = polygonCache[p0 + 0];
	            var y0 = polygonCache[p0 + 1];
	            var x1 = polygonCache[p1 + 0];
	            var y1 = polygonCache[p1 + 1];
	            var x2 = polygonCache[p2 + 0];
	            var y2 = polygonCache[p2 + 1];

	            var tx0 = calcMatrix.getX(x0, y0);
	            var ty0 = calcMatrix.getY(x0, y0);

	            var tx1 = calcMatrix.getX(x1, y1);
	            var ty1 = calcMatrix.getY(x1, y1);

	            var tx2 = calcMatrix.getX(x2, y2);
	            var ty2 = calcMatrix.getY(x2, y2);

	            this.batchTri(null, tx0, ty0, tx1, ty1, tx2, ty2, 0, 0, 1, 1, tintTL, tintTR, tintBL, 2);
	        }

	        polygonCache.length = 0;
	    },

	    batchStrokePath: function (path, lineWidth, pathOpen, currentMatrix, parentMatrix)
	    {
	        this.renderer.pipelines.set(this);

	        this.prevQuad[4] = 0;
	        this.firstQuad[4] = 0;

	        var pathLength = path.length - 1;

	        for (var pathIndex = 0; pathIndex < pathLength; pathIndex++)
	        {
	            var point0 = path[pathIndex];
	            var point1 = path[pathIndex + 1];

	            this.batchLine(
	                point0.x,
	                point0.y,
	                point1.x,
	                point1.y,
	                point0.width / 2,
	                point1.width / 2,
	                lineWidth,
	                pathIndex,
	                !pathOpen && (pathIndex === pathLength - 1),
	                currentMatrix,
	                parentMatrix
	            );
	        }
	    },

	    batchLine: function (ax, ay, bx, by, aLineWidth, bLineWidth, lineWidth, index, closePath, currentMatrix, parentMatrix)
	    {
	        this.renderer.pipelines.set(this);

	        var calcMatrix = this.calcMatrix;

	        if (parentMatrix)
	        {
	            parentMatrix.multiply(currentMatrix, calcMatrix);
	        }

	        var dx = bx - ax;
	        var dy = by - ay;

	        var len = Math.sqrt(dx * dx + dy * dy);

	        if (len === 0)
	        {

	            return;
	        }

	        var al0 = aLineWidth * (by - ay) / len;
	        var al1 = aLineWidth * (ax - bx) / len;
	        var bl0 = bLineWidth * (by - ay) / len;
	        var bl1 = bLineWidth * (ax - bx) / len;

	        var lx0 = bx - bl0;
	        var ly0 = by - bl1;
	        var lx1 = ax - al0;
	        var ly1 = ay - al1;
	        var lx2 = bx + bl0;
	        var ly2 = by + bl1;
	        var lx3 = ax + al0;
	        var ly3 = ay + al1;

	        var brX = calcMatrix.getX(lx0, ly0);
	        var brY = calcMatrix.getY(lx0, ly0);

	        var blX = calcMatrix.getX(lx1, ly1);
	        var blY = calcMatrix.getY(lx1, ly1);

	        var trX = calcMatrix.getX(lx2, ly2);
	        var trY = calcMatrix.getY(lx2, ly2);

	        var tlX = calcMatrix.getX(lx3, ly3);
	        var tlY = calcMatrix.getY(lx3, ly3);

	        var tint = this.strokeTint;

	        var tintTL = tint.TL;
	        var tintTR = tint.TR;
	        var tintBL = tint.BL;
	        var tintBR = tint.BR;

	        this.batchQuad(null, tlX, tlY, blX, blY, brX, brY, trX, trY, 0, 0, 1, 1, tintTL, tintTR, tintBL, tintBR, 2);

	        if (lineWidth <= 2)
	        {

	            return;
	        }

	        var prev = this.prevQuad;
	        var first = this.firstQuad;

	        if (index > 0 && prev[4])
	        {
	            this.batchQuad(null, tlX, tlY, blX, blY, prev[0], prev[1], prev[2], prev[3], 0, 0, 1, 1, tintTL, tintTR, tintBL, tintBR, 2);
	        }
	        else
	        {
	            first[0] = tlX;
	            first[1] = tlY;
	            first[2] = blX;
	            first[3] = blY;
	            first[4] = 1;
	        }

	        if (closePath && first[4])
	        {

	            this.batchQuad(null, brX, brY, trX, trY, first[0], first[1], first[2], first[3], 0, 0, 1, 1, tintTL, tintTR, tintBL, tintBR, 2);
	        }
	        else
	        {

	            prev[0] = brX;
	            prev[1] = brY;
	            prev[2] = trX;
	            prev[3] = trY;
	            prev[4] = 1;
	        }
	    },

	    destroy: function ()
	    {
	        this._tempMatrix1.destroy();
	        this._tempMatrix2.destroy();
	        this._tempMatrix3.destroy();

	        this._tempMatrix1 = null;
	        this._tempMatrix1 = null;
	        this._tempMatrix1 = null;

	        WebGLPipeline.prototype.destroy.call(this);

	        return this;
	    }

	});

	MultiPipeline_1 = MultiPipeline;
	return MultiPipeline_1;
}

var SingleFrag;
var hasRequiredSingleFrag;

function requireSingleFrag () {
	if (hasRequiredSingleFrag) return SingleFrag;
	hasRequiredSingleFrag = 1;
	SingleFrag = [
	    '#define SHADER_NAME PHASER_SINGLE_FS',
	    '#ifdef GL_FRAGMENT_PRECISION_HIGH',
	    'precision highp float;',
	    '#else',
	    'precision mediump float;',
	    '#endif',
	    'uniform sampler2D uMainSampler;',
	    'varying vec2 outTexCoord;',
	    'varying float outTintEffect;',
	    'varying vec4 outTint;',
	    'void main ()',
	    '{',
	    '    vec4 texture = texture2D(uMainSampler, outTexCoord);',
	    '    vec4 texel = vec4(outTint.bgr * outTint.a, outTint.a);',
	    '    vec4 color = texture * texel;',
	    '    if (outTintEffect == 1.0)',
	    '    {',
	    '        color.rgb = mix(texture.rgb, outTint.bgr * outTint.a, texture.a);',
	    '    }',
	    '    else if (outTintEffect == 2.0)',
	    '    {',
	    '        color = texel;',
	    '    }',
	    '    gl_FragColor = color;',
	    '}',
	].join('\n');
	return SingleFrag;
}

var SingleVert;
var hasRequiredSingleVert;

function requireSingleVert () {
	if (hasRequiredSingleVert) return SingleVert;
	hasRequiredSingleVert = 1;
	SingleVert = [
	    '#define SHADER_NAME PHASER_SINGLE_VS',
	    'precision mediump float;',
	    'uniform mat4 uProjectionMatrix;',
	    'uniform vec2 uResolution;',
	    'attribute vec2 inPosition;',
	    'attribute vec2 inTexCoord;',
	    'attribute float inTexId;',
	    'attribute float inTintEffect;',
	    'attribute vec4 inTint;',
	    'varying vec2 outTexCoord;',
	    'varying float outTintEffect;',
	    'varying vec4 outTint;',
	    'void main ()',
	    '{',
	    '    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);',
	    '    outTexCoord = inTexCoord;',
	    '    outTint = inTint;',
	    '    outTintEffect = inTintEffect;',
	    '}',
	].join('\n');
	return SingleVert;
}

var PreFXPipeline_1;
var hasRequiredPreFXPipeline;

function requirePreFXPipeline () {
	if (hasRequiredPreFXPipeline) return PreFXPipeline_1;
	hasRequiredPreFXPipeline = 1;
	var BlendModes = requireBlendModes();
	var CenterOn = requireCenterOn$2();
	var Class = requireClass();
	var ColorMatrixFS = requireColorMatrixFrag();
	var GetFastValue = requireGetFastValue();
	var MultiPipeline = requireMultiPipeline();
	var PostFXFS = requirePostFXFrag();
	var Rectangle = requireRectangle$2();
	var RenderTarget = requireRenderTarget();
	var SingleQuadFS = requireSingleFrag();
	var SingleQuadVS = requireSingleVert();
	var WebGLPipeline = requireWebGLPipeline();

	var PreFXPipeline = new Class({

	    Extends: MultiPipeline,

	    initialize:

	    function PreFXPipeline (config)
	    {
	        var fragShader = GetFastValue(config, 'fragShader', PostFXFS);
	        var vertShader = GetFastValue(config, 'vertShader', SingleQuadVS);
	        var drawShader = GetFastValue(config, 'drawShader', PostFXFS);

	        var defaultShaders = [
	            {
	                name: 'DrawSprite',
	                fragShader: SingleQuadFS,
	                vertShader: SingleQuadVS
	            },
	            {
	                name: 'CopySprite',
	                fragShader: fragShader,
	                vertShader: vertShader
	            },
	            {
	                name: 'DrawGame',
	                fragShader: drawShader,
	                vertShader: SingleQuadVS
	            },
	            {
	                name: 'ColorMatrix',
	                fragShader: ColorMatrixFS
	            }
	        ];

	        var configShaders = GetFastValue(config, 'shaders', []);

	        config.shaders = defaultShaders.concat(configShaders);

	        if (!config.vertShader)
	        {
	            config.vertShader = vertShader;
	        }

	        config.batchSize = 1;

	        MultiPipeline.call(this, config);

	        this.isPreFX = true;

	        this.customMainSampler = null;

	        this.drawSpriteShader;

	        this.copyShader;

	        this.gameShader;

	        this.colorMatrixShader;

	        this.quadVertexData;

	        this.quadVertexBuffer;

	        this.quadVertexViewF32;

	        this.spriteBounds = new Rectangle();

	        this.targetBounds = new Rectangle();

	        this.fsTarget;

	        this.tempSprite;

	        if (this.renderer.isBooted)
	        {
	            this.manager = this.renderer.pipelines;

	            this.boot();
	        }
	    },

	    boot: function ()
	    {
	        WebGLPipeline.prototype.boot.call(this);

	        var shaders = this.shaders;
	        var renderer = this.renderer;

	        this.drawSpriteShader = shaders[0];
	        this.copyShader = shaders[1];
	        this.gameShader = shaders[2];
	        this.colorMatrixShader = shaders[3];

	        this.fsTarget = new RenderTarget(renderer, renderer.width, renderer.height, 1, 0, true, true);

	        this.renderTargets = this.manager.renderTargets.concat(this.fsTarget);

	        var data = new ArrayBuffer(168);

	        this.quadVertexData = data;

	        this.quadVertexViewF32 = new Float32Array(data);

	        this.quadVertexBuffer = renderer.createVertexBuffer(data, this.gl.STATIC_DRAW);

	        this.onResize(renderer.width, renderer.height);

	        this.currentShader = this.copyShader;

	        this.set2f('uResolution', renderer.width, renderer.height);
	    },

	    onResize: function (width, height)
	    {
	        var vertexViewF32 = this.quadVertexViewF32;

	        vertexViewF32[1] = height; 
	        vertexViewF32[22] = height; 
	        vertexViewF32[14] = width; 
	        vertexViewF32[28] = width; 
	        vertexViewF32[35] = width; 
	        vertexViewF32[36] = height; 
	    },

	    batchQuad: function (gameObject, x0, y0, x1, y1, x2, y2, x3, y3, u0, v0, u1, v1, tintTL, tintTR, tintBL, tintBR, tintEffect, texture)
	    {
	        var bx = Math.min(x0, x1, x2, x3);
	        var by = Math.min(y0, y1, y2, y3);
	        var br = Math.max(x0, x1, x2, x3);
	        var bb = Math.max(y0, y1, y2, y3);
	        var bw = br - bx;
	        var bh = bb - by;

	        var bounds = this.spriteBounds.setTo(bx, by, bw, bh);

	        var padding = (gameObject) ? gameObject.preFX.padding : 0;
	        var width = bw + (padding * 2);
	        var height = bh + (padding * 2);
	        var maxDimension = Math.abs(Math.max(width, height));

	        var target = this.manager.getRenderTarget(maxDimension);

	        var targetBounds = this.targetBounds.setTo(0, 0, target.width, target.height);

	        CenterOn(targetBounds, Math.round(bounds.centerX), Math.round(bounds.centerY));

	        this.tempSprite = gameObject;

	        var gl = this.gl;
	        var renderer = this.renderer;

	        renderer.clearStencilMask();

	        this.setShader(this.drawSpriteShader);

	        this.set1i('uMainSampler', 0);
	        this.set2f('uResolution', renderer.width, renderer.height);

	        this.flipProjectionMatrix(true);

	        if (gameObject)
	        {
	            this.onDrawSprite(gameObject, target);

	            gameObject.preFX.onFX(this);
	        }

	        var fsTarget = this.fsTarget;

	        this.flush();

	        gl.viewport(0, 0, renderer.width, renderer.height);
	        gl.bindFramebuffer(gl.FRAMEBUFFER, fsTarget.framebuffer.webGLFramebuffer);
	        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, fsTarget.texture.webGLTexture, 0);

	        gl.clearColor(0, 0, 0, 0);
	        gl.clear(gl.COLOR_BUFFER_BIT);

	        this.setTexture2D(texture);

	        this.batchVert(x0, y0, u0, v0, 0, tintEffect, tintTL);
	        this.batchVert(x1, y1, u0, v1, 0, tintEffect, tintBL);
	        this.batchVert(x2, y2, u1, v1, 0, tintEffect, tintBR);

	        this.batchVert(x0, y0, u0, v0, 0, tintEffect, tintTL);
	        this.batchVert(x2, y2, u1, v1, 0, tintEffect, tintBR);
	        this.batchVert(x3, y3, u1, v0, 0, tintEffect, tintTR);

	        this.flush();

	        this.flipProjectionMatrix(false);

	        gl.activeTexture(gl.TEXTURE0);
	        gl.bindTexture(gl.TEXTURE_2D, target.texture.webGLTexture);
	        gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, targetBounds.x, targetBounds.y, targetBounds.width, targetBounds.height);

	        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
	        gl.bindTexture(gl.TEXTURE_2D, null);

	        this.onBatch(gameObject);

	        this.currentShader = this.copyShader;

	        this.onDraw(target, this.manager.getSwapRenderTarget(), this.manager.getAltSwapRenderTarget());

	        return true;
	    },

	    onDrawSprite: function ()
	    {
	    },

	    onCopySprite: function ()
	    {
	    },

	    copySprite: function (source, target, clear, clearAlpha, eraseMode, colorMatrix, shader)
	    {
	        if (clear === undefined) { clear = true; }
	        if (clearAlpha === undefined) { clearAlpha = true; }
	        if (eraseMode === undefined) { eraseMode = false; }
	        if (shader === undefined) { shader = this.copyShader; }

	        var gl = this.gl;
	        var sprite = this.tempSprite;

	        if (colorMatrix)
	        {
	            shader = this.colorMatrixShader;
	        }

	        this.currentShader = shader;

	        var wasBound = this.setVertexBuffer(this.quadVertexBuffer);

	        shader.bind(wasBound, false);

	        var renderer = this.renderer;

	        this.set1i('uMainSampler', 0);
	        this.set2f('uResolution', renderer.width, renderer.height);

	        sprite.preFX.onFXCopy(this);

	        this.onCopySprite(source, target, sprite);

	        if (colorMatrix)
	        {
	            this.set1fv('uColorMatrix', colorMatrix.getData());
	            this.set1f('uAlpha', colorMatrix.alpha);
	        }

	        gl.activeTexture(gl.TEXTURE0);
	        gl.bindTexture(gl.TEXTURE_2D, source.texture.webGLTexture);

	        if (source.height > target.height)
	        {
	            gl.viewport(0, 0, source.width, source.height);

	            this.setTargetUVs(source, target);
	        }
	        else
	        {
	            var diff = target.height - source.height;

	            gl.viewport(0, diff, source.width, source.height);

	            this.resetUVs();
	        }

	        gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer.webGLFramebuffer);
	        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target.texture.webGLTexture, 0);

	        if (clear)
	        {
	            gl.clearColor(0, 0, 0, Number(!clearAlpha));

	            gl.clear(gl.COLOR_BUFFER_BIT);
	        }

	        if (eraseMode)
	        {
	            var blendMode = this.renderer.currentBlendMode;

	            this.renderer.setBlendMode(BlendModes.ERASE);
	        }

	        gl.bufferData(gl.ARRAY_BUFFER, this.quadVertexData, gl.STATIC_DRAW);
	        gl.drawArrays(gl.TRIANGLES, 0, 6);

	        if (eraseMode)
	        {
	            this.renderer.setBlendMode(blendMode);
	        }

	        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
	    },

	    copy: function (source, target)
	    {
	        var gl = this.gl;

	        this.set1i('uMainSampler', 0);

	        gl.activeTexture(gl.TEXTURE0);
	        gl.bindTexture(gl.TEXTURE_2D, source.texture.webGLTexture);

	        gl.viewport(0, 0, source.width, source.height);

	        this.setUVs(0, 0, 0, 1, 1, 1, 1, 0);

	        gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer.webGLFramebuffer);
	        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target.texture.webGLTexture, 0);

	        gl.clearColor(0, 0, 0, 0);
	        gl.clear(gl.COLOR_BUFFER_BIT);

	        gl.bufferData(gl.ARRAY_BUFFER, this.quadVertexData, gl.STATIC_DRAW);
	        gl.drawArrays(gl.TRIANGLES, 0, 6);

	        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
	    },

	    blendFrames: function (source1, source2, target, strength, clearAlpha)
	    {
	        this.manager.blendFrames(source1, source2, target, strength, clearAlpha);
	    },

	    blendFramesAdditive: function (source1, source2, target, strength, clearAlpha)
	    {
	        this.manager.blendFramesAdditive(source1, source2, target, strength, clearAlpha);
	    },

	    drawToGame: function (source)
	    {
	        this.currentShader = null;

	        this.setShader(this.copyShader);

	        this.bindAndDraw(source);
	    },

	    copyToGame: function (source)
	    {
	        this.currentShader = null;

	        this.setShader(this.gameShader);

	        this.bindAndDraw(source);
	    },

	    bindAndDraw: function (source)
	    {
	        var gl = this.gl;
	        var renderer = this.renderer;

	        this.set1i('uMainSampler', 0);

	        if (this.customMainSampler)
	        {
	            this.setTexture2D(this.customMainSampler);
	        }
	        else
	        {
	            this.setTexture2D(source.texture);
	        }

	        var matrix = this._tempMatrix1.loadIdentity();

	        var x = this.targetBounds.x;
	        var y = this.targetBounds.y;

	        var xw = x + source.width;
	        var yh = y + source.height;

	        var x0 = matrix.getX(x, y);
	        var x1 = matrix.getX(x, yh);
	        var x2 = matrix.getX(xw, yh);
	        var x3 = matrix.getX(xw, y);

	        var y0 = matrix.getY(x, y);
	        var y1 = matrix.getY(x, yh);
	        var y2 = matrix.getY(xw, yh);
	        var y3 = matrix.getY(xw, y);

	        var white = 0xffffff;

	        this.batchVert(x0, y0, 0, 0, 0, 0, white);
	        this.batchVert(x1, y1, 0, 1, 0, 0, white);
	        this.batchVert(x2, y2, 1, 1, 0, 0, white);
	        this.batchVert(x0, y0, 0, 0, 0, 0, white);
	        this.batchVert(x2, y2, 1, 1, 0, 0, white);
	        this.batchVert(x3, y3, 1, 0, 0, 0, white);

	        renderer.restoreFramebuffer(false, true);

	        if (!renderer.currentFramebuffer)
	        {
	            gl.viewport(0, 0, renderer.width, renderer.height);
	        }

	        renderer.restoreStencilMask();

	        this.flush();

	        this.tempSprite = null;
	    },

	    onDraw: function (target)
	    {
	        this.drawToGame(target);
	    },

	    setUVs: function (uA, vA, uB, vB, uC, vC, uD, vD)
	    {
	        var vertexViewF32 = this.quadVertexViewF32;

	        vertexViewF32[2] = uA;
	        vertexViewF32[3] = vA;

	        vertexViewF32[9] = uB;
	        vertexViewF32[10] = vB;

	        vertexViewF32[16] = uC;
	        vertexViewF32[17] = vC;

	        vertexViewF32[23] = uA;
	        vertexViewF32[24] = vA;

	        vertexViewF32[30] = uC;
	        vertexViewF32[31] = vC;

	        vertexViewF32[37] = uD;
	        vertexViewF32[38] = vD;
	    },

	    setTargetUVs: function (source, target)
	    {
	        var diff = (target.height / source.height);

	        if (diff > 0.5)
	        {
	            diff = 0.5 - (diff - 0.5);
	        }
	        else
	        {
	            diff = 0.5 + (0.5 - diff);
	        }

	        this.setUVs(0, diff, 0, 1 + diff, 1, 1 + diff, 1, diff);
	    },

	    resetUVs: function ()
	    {
	        this.setUVs(0, 0, 0, 1, 1, 1, 1, 0);
	    },

	    destroy: function ()
	    {
	        this.renderer.deleteBuffer(this.quadVertexBuffer);

	        this.drawSpriteShader = null;
	        this.copyShader = null;
	        this.gameShader = null;
	        this.colorMatrixShader = null;

	        this.quadVertexData = null;
	        this.quadVertexBuffer = null;
	        this.quadVertexViewF32 = null;

	        this.fsTarget = null;
	        this.tempSprite = null;

	        MultiPipeline.prototype.destroy.call(this);

	        return this;
	    }

	});

	PreFXPipeline_1 = PreFXPipeline;
	return PreFXPipeline_1;
}

var AddBlendFrag;
var hasRequiredAddBlendFrag;

function requireAddBlendFrag () {
	if (hasRequiredAddBlendFrag) return AddBlendFrag;
	hasRequiredAddBlendFrag = 1;
	AddBlendFrag = [
	    '#define SHADER_NAME PHASER_ADD_BLEND_FS',
	    'precision mediump float;',
	    'uniform sampler2D uMainSampler1;',
	    'uniform sampler2D uMainSampler2;',
	    'uniform float uStrength;',
	    'varying vec2 outTexCoord;',
	    'void main ()',
	    '{',
	    '    vec4 frame1 = texture2D(uMainSampler1, outTexCoord);',
	    '    vec4 frame2 = texture2D(uMainSampler2, outTexCoord);',
	    '    gl_FragColor = frame1 + frame2 * uStrength;',
	    '}',
	].join('\n');
	return AddBlendFrag;
}

var CopyFrag;
var hasRequiredCopyFrag;

function requireCopyFrag () {
	if (hasRequiredCopyFrag) return CopyFrag;
	hasRequiredCopyFrag = 1;
	CopyFrag = [
	    '#define SHADER_NAME PHASER_COPY_FS',
	    'precision mediump float;',
	    'uniform sampler2D uMainSampler;',
	    'uniform float uBrightness;',
	    'varying vec2 outTexCoord;',
	    'void main ()',
	    '{',
	    '    gl_FragColor = texture2D(uMainSampler, outTexCoord) * uBrightness;',
	    '}',
	].join('\n');
	return CopyFrag;
}

var LightFrag;
var hasRequiredLightFrag;

function requireLightFrag () {
	if (hasRequiredLightFrag) return LightFrag;
	hasRequiredLightFrag = 1;
	LightFrag = [
	    '#define SHADER_NAME PHASER_LIGHT_FS',
	    'precision mediump float;',
	    'struct Light',
	    '{',
	    '    vec2 position;',
	    '    vec3 color;',
	    '    float intensity;',
	    '    float radius;',
	    '};',
	    'const int kMaxLights = %LIGHT_COUNT%;',
	    'uniform vec4 uCamera; ',
	    'uniform vec2 uResolution;',
	    'uniform sampler2D uMainSampler;',
	    'uniform sampler2D uNormSampler;',
	    'uniform vec3 uAmbientLightColor;',
	    'uniform Light uLights[kMaxLights];',
	    'uniform mat3 uInverseRotationMatrix;',
	    'uniform int uLightCount;',
	    'varying vec2 outTexCoord;',
	    'varying float outTexId;',
	    'varying float outTintEffect;',
	    'varying vec4 outTint;',
	    'void main ()',
	    '{',
	    '    vec3 finalColor = vec3(0.0, 0.0, 0.0);',
	    '    vec4 texel = vec4(outTint.bgr * outTint.a, outTint.a);',
	    '    vec4 texture = texture2D(uMainSampler, outTexCoord);',
	    '    vec4 color = texture * texel;',
	    '    if (outTintEffect == 1.0)',
	    '    {',
	    '        color.rgb = mix(texture.rgb, outTint.bgr * outTint.a, texture.a);',
	    '    }',
	    '    else if (outTintEffect == 2.0)',
	    '    {',
	    '        color = texel;',
	    '    }',
	    '    vec3 normalMap = texture2D(uNormSampler, outTexCoord).rgb;',
	    '    vec3 normal = normalize(uInverseRotationMatrix * vec3(normalMap * 2.0 - 1.0));',
	    '    vec2 res = vec2(min(uResolution.x, uResolution.y)) * uCamera.w;',
	    '    for (int index = 0; index < kMaxLights; ++index)',
	    '    {',
	    '        if (index < uLightCount)',
	    '        {',
	    '            Light light = uLights[index];',
	    '            vec3 lightDir = vec3((light.position.xy / res) - (gl_FragCoord.xy / res), 0.1);',
	    '            vec3 lightNormal = normalize(lightDir);',
	    '            float distToSurf = length(lightDir) * uCamera.w;',
	    '            float diffuseFactor = max(dot(normal, lightNormal), 0.0);',
	    '            float radius = (light.radius / res.x * uCamera.w) * uCamera.w;',
	    '            float attenuation = clamp(1.0 - distToSurf * distToSurf / (radius * radius), 0.0, 1.0);',
	    '            vec3 diffuse = light.color * diffuseFactor;',
	    '            finalColor += (attenuation * diffuse) * light.intensity;',
	    '        }',
	    '    }',
	    '    vec4 colorOutput = vec4(uAmbientLightColor + finalColor, 1.0);',
	    '    gl_FragColor = color * vec4(colorOutput.rgb * colorOutput.a, colorOutput.a);',
	    '}',
	].join('\n');
	return LightFrag;
}

var LinearBlendFrag;
var hasRequiredLinearBlendFrag;

function requireLinearBlendFrag () {
	if (hasRequiredLinearBlendFrag) return LinearBlendFrag;
	hasRequiredLinearBlendFrag = 1;
	LinearBlendFrag = [
	    '#define SHADER_NAME PHASER_LINEAR_BLEND_FS',
	    'precision mediump float;',
	    'uniform sampler2D uMainSampler1;',
	    'uniform sampler2D uMainSampler2;',
	    'uniform float uStrength;',
	    'varying vec2 outTexCoord;',
	    'void main ()',
	    '{',
	    '    vec4 frame1 = texture2D(uMainSampler1, outTexCoord);',
	    '    vec4 frame2 = texture2D(uMainSampler2, outTexCoord);',
	    '    gl_FragColor = mix(frame1, frame2 * uStrength, 0.5);',
	    '}',
	].join('\n');
	return LinearBlendFrag;
}

var MeshFrag;
var hasRequiredMeshFrag;

function requireMeshFrag () {
	if (hasRequiredMeshFrag) return MeshFrag;
	hasRequiredMeshFrag = 1;
	MeshFrag = [
	    '#define SHADER_NAME PHASER_MESH_FS',
	    'precision mediump float;',
	    'uniform vec3 uLightPosition;',
	    'uniform vec3 uLightAmbient;',
	    'uniform vec3 uLightDiffuse;',
	    'uniform vec3 uLightSpecular;',
	    'uniform vec3 uFogColor;',
	    'uniform float uFogNear;',
	    'uniform float uFogFar;',
	    'uniform vec3 uMaterialAmbient;',
	    'uniform vec3 uMaterialDiffuse;',
	    'uniform vec3 uMaterialSpecular;',
	    'uniform float uMaterialShine;',
	    'uniform vec3 uCameraPosition;',
	    'uniform sampler2D uTexture;',
	    'varying vec2 vTextureCoord;',
	    'varying vec3 vNormal;',
	    'varying vec3 vPosition;',
	    'void main (void)',
	    '{',
	    '    vec4 color = texture2D(uTexture, vTextureCoord);',
	    '    vec3 ambient = uLightAmbient * uMaterialAmbient;',
	    '    vec3 norm = normalize(vNormal);',
	    '    vec3 lightDir = normalize(uLightPosition - vPosition);',
	    '    float diff = max(dot(norm, lightDir), 0.0);',
	    '    vec3 diffuse = uLightDiffuse * (diff * uMaterialDiffuse);',
	    '    vec3 viewDir = normalize(uCameraPosition - vPosition);',
	    '    vec3 reflectDir = reflect(-lightDir, norm);',
	    '    float spec = pow(max(dot(viewDir, reflectDir), 0.0), uMaterialShine);',
	    '    vec3 specular = uLightSpecular * (spec * uMaterialSpecular);',
	    '    vec3 result = (ambient + diffuse + specular) * color.rgb;',
	    '    float depth = gl_FragCoord.z / gl_FragCoord.w;',
	    '    float fogFactor = smoothstep(uFogNear, uFogFar, depth);',
	    '    gl_FragColor.rgb = mix(result.rgb, uFogColor, fogFactor);',
	    '    gl_FragColor.a = color.a;',
	    '}',
	].join('\n');
	return MeshFrag;
}

var MeshVert;
var hasRequiredMeshVert;

function requireMeshVert () {
	if (hasRequiredMeshVert) return MeshVert;
	hasRequiredMeshVert = 1;
	MeshVert = [
	    '#define SHADER_NAME PHASER_MESH_VS',
	    'precision mediump float;',
	    'attribute vec3 aVertexPosition;',
	    'attribute vec3 aVertexNormal;',
	    'attribute vec2 aTextureCoord;',
	    'uniform mat4 uViewProjectionMatrix;',
	    'uniform mat4 uModelMatrix;',
	    'uniform mat4 uNormalMatrix;',
	    'varying vec2 vTextureCoord;',
	    'varying vec3 vNormal;',
	    'varying vec3 vPosition;',
	    'void main ()',
	    '{',
	    '    vTextureCoord = aTextureCoord;',
	    '    vPosition = vec3(uModelMatrix * vec4(aVertexPosition, 1.0));',
	    '    vNormal = vec3(uNormalMatrix * vec4(aVertexNormal, 1.0));',
	    '    gl_Position = uViewProjectionMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);',
	    '}',
	].join('\n');
	return MeshVert;
}

var MobileFrag;
var hasRequiredMobileFrag;

function requireMobileFrag () {
	if (hasRequiredMobileFrag) return MobileFrag;
	hasRequiredMobileFrag = 1;
	MobileFrag = [
	    '#define SHADER_NAME PHASER_MOBILE_FS',
	    '#ifdef GL_FRAGMENT_PRECISION_HIGH',
	    'precision highp float;',
	    '#else',
	    'precision mediump float;',
	    '#endif',
	    'uniform sampler2D uMainSampler;',
	    'varying vec2 outTexCoord;',
	    'varying float outTintEffect;',
	    'varying vec4 outTint;',
	    'void main ()',
	    '{',
	    '    vec4 texel = vec4(outTint.bgr * outTint.a, outTint.a);',
	    '    vec4 texture = texture2D(uMainSampler, outTexCoord);',
	    '    vec4 color = texture * texel;',
	    '    if (outTintEffect == 1.0)',
	    '    {',
	    '        color.rgb = mix(texture.rgb, outTint.bgr * outTint.a, texture.a);',
	    '    }',
	    '    else if (outTintEffect == 2.0)',
	    '    {',
	    '        color = texel;',
	    '    }',
	    '    gl_FragColor = color;',
	    '}',
	].join('\n');
	return MobileFrag;
}

var MobileVert;
var hasRequiredMobileVert;

function requireMobileVert () {
	if (hasRequiredMobileVert) return MobileVert;
	hasRequiredMobileVert = 1;
	MobileVert = [
	    '#define SHADER_NAME PHASER_MOBILE_VS',
	    'precision mediump float;',
	    'uniform mat4 uProjectionMatrix;',
	    'uniform vec2 uResolution;',
	    'attribute vec2 inPosition;',
	    'attribute vec2 inTexCoord;',
	    'attribute float inTexId;',
	    'attribute float inTintEffect;',
	    'attribute vec4 inTint;',
	    'varying vec2 outTexCoord;',
	    'varying float outTintEffect;',
	    'varying vec4 outTint;',
	    'void main ()',
	    '{',
	    '    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);',
	    '    outTexCoord = inTexCoord;',
	    '    outTint = inTint;',
	    '    outTintEffect = inTintEffect;',
	    '}',
	].join('\n');
	return MobileVert;
}

var PointLightFrag;
var hasRequiredPointLightFrag;

function requirePointLightFrag () {
	if (hasRequiredPointLightFrag) return PointLightFrag;
	hasRequiredPointLightFrag = 1;
	PointLightFrag = [
	    '#define SHADER_NAME PHASER_POINTLIGHT_FS',
	    'precision mediump float;',
	    'uniform vec2 uResolution;',
	    'uniform float uCameraZoom;',
	    'varying vec4 lightPosition;',
	    'varying vec4 lightColor;',
	    'varying float lightRadius;',
	    'varying float lightAttenuation;',
	    'void main ()',
	    '{',
	    '    vec2 center = (lightPosition.xy + 1.0) * (uResolution.xy * 0.5);',
	    '    float distToSurf = length(center - gl_FragCoord.xy);',
	    '    float radius = 1.0 - distToSurf / (lightRadius * uCameraZoom);',
	    '    float intensity = smoothstep(0.0, 1.0, radius * lightAttenuation);',
	    '    vec4 color = vec4(intensity, intensity, intensity, 0.0) * lightColor;',
	    '    gl_FragColor = vec4(color.rgb * lightColor.a, color.a);',
	    '}',
	].join('\n');
	return PointLightFrag;
}

var PointLightVert;
var hasRequiredPointLightVert;

function requirePointLightVert () {
	if (hasRequiredPointLightVert) return PointLightVert;
	hasRequiredPointLightVert = 1;
	PointLightVert = [
	    '#define SHADER_NAME PHASER_POINTLIGHT_VS',
	    'precision mediump float;',
	    'uniform mat4 uProjectionMatrix;',
	    'attribute vec2 inPosition;',
	    'attribute vec2 inLightPosition;',
	    'attribute vec4 inLightColor;',
	    'attribute float inLightRadius;',
	    'attribute float inLightAttenuation;',
	    'varying vec4 lightPosition;',
	    'varying vec4 lightColor;',
	    'varying float lightRadius;',
	    'varying float lightAttenuation;',
	    'void main ()',
	    '{',
	    '    lightColor = inLightColor;',
	    '    lightRadius = inLightRadius;',
	    '    lightAttenuation = inLightAttenuation;',
	    '    lightPosition = uProjectionMatrix * vec4(inLightPosition, 1.0, 1.0);',
	    '    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);',
	    '}',
	].join('\n');
	return PointLightVert;
}

var shaders;
var hasRequiredShaders;

function requireShaders () {
	if (hasRequiredShaders) return shaders;
	hasRequiredShaders = 1;
	shaders = {

	    AddBlendFrag: requireAddBlendFrag(),
	    BitmapMaskFrag: requireBitmapMaskFrag(),
	    BitmapMaskVert: requireBitmapMaskVert(),
	    ColorMatrixFrag: requireColorMatrixFrag(),
	    CopyFrag: requireCopyFrag(),
	    FXBarrelFrag: requireFXBarrelFrag(),
	    FXBloomFrag: requireFXBloomFrag(),
	    FXBlurHighFrag: requireFXBlurHighFrag(),
	    FXBlurLowFrag: requireFXBlurLowFrag(),
	    FXBlurMedFrag: requireFXBlurMedFrag(),
	    FXBokehFrag: requireFXBokehFrag(),
	    FXCircleFrag: requireFXCircleFrag(),
	    FXDisplacementFrag: requireFXDisplacementFrag(),
	    FXGlowFrag: requireFXGlowFrag(),
	    FXGradientFrag: requireFXGradientFrag(),
	    FXPixelateFrag: requireFXPixelateFrag(),
	    FXShadowFrag: requireFXShadowFrag(),
	    FXShineFrag: requireFXShineFrag(),
	    FXVignetteFrag: requireFXVignetteFrag(),
	    FXWipeFrag: requireFXWipeFrag(),
	    LightFrag: requireLightFrag(),
	    LinearBlendFrag: requireLinearBlendFrag(),
	    MeshFrag: requireMeshFrag(),
	    MeshVert: requireMeshVert(),
	    MobileFrag: requireMobileFrag(),
	    MobileVert: requireMobileVert(),
	    MultiFrag: requireMultiFrag(),
	    MultiVert: requireMultiVert(),
	    PointLightFrag: requirePointLightFrag(),
	    PointLightVert: requirePointLightVert(),
	    PostFXFrag: requirePostFXFrag(),
	    QuadVert: requireQuadVert(),
	    SingleFrag: requireSingleFrag(),
	    SingleVert: requireSingleVert()

	};
	return shaders;
}

var FXPipeline_1;
var hasRequiredFXPipeline;

function requireFXPipeline () {
	if (hasRequiredFXPipeline) return FXPipeline_1;
	hasRequiredFXPipeline = 1;
	var Class = requireClass();
	var FX = requireFx();
	var FX_CONST = require_const$b();
	var GetFastValue = requireGetFastValue();
	var PreFXPipeline = requirePreFXPipeline();
	var Shaders = requireShaders();
	var Utils = requireUtils$1();

	var FXPipeline = new Class({

	    Extends: PreFXPipeline,

	    initialize:

	    function FXPipeline (config)
	    {

	        config.shaders = [
	            Utils.setGlowQuality(Shaders.FXGlowFrag, config.game),
	            Shaders.FXShadowFrag,
	            Shaders.FXPixelateFrag,
	            Shaders.FXVignetteFrag,
	            Shaders.FXShineFrag,
	            Shaders.FXBlurLowFrag,
	            Shaders.FXBlurMedFrag,
	            Shaders.FXBlurHighFrag,
	            Shaders.FXGradientFrag,
	            Shaders.FXBloomFrag,
	            Shaders.ColorMatrixFrag,
	            Shaders.FXCircleFrag,
	            Shaders.FXBarrelFrag,
	            Shaders.FXDisplacementFrag,
	            Shaders.FXWipeFrag,
	            Shaders.FXBokehFrag
	        ];

	        PreFXPipeline.call(this, config);

	        var game = this.game;

	        this.glow = new FX.Glow(game);

	        this.shadow = new FX.Shadow(game);

	        this.pixelate = new FX.Pixelate(game);

	        this.vignette = new FX.Vignette(game);

	        this.shine = new FX.Shine(game);

	        this.gradient = new FX.Gradient(game);

	        this.circle = new FX.Circle(game);

	        this.barrel = new FX.Barrel(game);

	        this.wipe = new FX.Wipe(game);

	        this.bokeh = new FX.Bokeh(game);

	        var fxHandlers = [];

	        fxHandlers[FX_CONST.GLOW] = this.onGlow;
	        fxHandlers[FX_CONST.SHADOW] = this.onShadow;
	        fxHandlers[FX_CONST.PIXELATE] = this.onPixelate;
	        fxHandlers[FX_CONST.VIGNETTE] = this.onVignette;
	        fxHandlers[FX_CONST.SHINE] = this.onShine;
	        fxHandlers[FX_CONST.BLUR] = this.onBlur;
	        fxHandlers[FX_CONST.GRADIENT] = this.onGradient;
	        fxHandlers[FX_CONST.BLOOM] = this.onBloom;
	        fxHandlers[FX_CONST.COLOR_MATRIX] = this.onColorMatrix;
	        fxHandlers[FX_CONST.CIRCLE] = this.onCircle;
	        fxHandlers[FX_CONST.BARREL] = this.onBarrel;
	        fxHandlers[FX_CONST.DISPLACEMENT] = this.onDisplacement;
	        fxHandlers[FX_CONST.WIPE] = this.onWipe;
	        fxHandlers[FX_CONST.BOKEH] = this.onBokeh;

	        this.fxHandlers = fxHandlers;

	        this.source;

	        this.target;

	        this.swap;
	    },

	    onDraw: function (target1, target2, target3)
	    {
	        this.source = target1;
	        this.target = target2;
	        this.swap = target3;

	        var width = target1.width;
	        var height = target1.height;

	        var sprite = this.tempSprite;
	        var handlers = this.fxHandlers;

	        if (sprite && sprite.preFX)
	        {
	            var fx = sprite.preFX.list;

	            for (var i = 0; i < fx.length; i++)
	            {
	                var controller = fx[i];

	                if (controller.active)
	                {
	                    handlers[controller.type].call(this, controller, width, height);
	                }
	            }
	        }

	        this.drawToGame(this.source);
	    },

	    runDraw: function ()
	    {
	        var source = this.source;
	        var target = this.target;

	        this.copy(source, target);

	        this.source = target;
	        this.target = source;
	    },

	    onGlow: function (config, width, height)
	    {
	        var shader = this.shaders[FX_CONST.GLOW];

	        this.setShader(shader);

	        this.glow.onPreRender(config, shader, width, height);

	        this.runDraw();
	    },

	    onShadow: function (config)
	    {
	        var shader = this.shaders[FX_CONST.SHADOW];

	        this.setShader(shader);

	        this.shadow.onPreRender(config, shader);

	        this.runDraw();
	    },

	    onPixelate: function (config, width, height)
	    {
	        var shader = this.shaders[FX_CONST.PIXELATE];

	        this.setShader(shader);

	        this.pixelate.onPreRender(config, shader, width, height);

	        this.runDraw();
	    },

	    onVignette: function (config)
	    {
	        var shader = this.shaders[FX_CONST.VIGNETTE];

	        this.setShader(shader);

	        this.vignette.onPreRender(config, shader);

	        this.runDraw();
	    },

	    onShine: function (config, width, height)
	    {
	        var shader = this.shaders[FX_CONST.SHINE];

	        this.setShader(shader);

	        this.shine.onPreRender(config, shader, width, height);

	        this.runDraw();
	    },

	    onBlur: function (config, width, height)
	    {
	        var quality = GetFastValue(config, 'quality');

	        var shader = this.shaders[FX_CONST.BLUR + quality];

	        this.setShader(shader);

	        this.set1i('uMainSampler', 0);
	        this.set2f('resolution', width, height);
	        this.set1f('strength', GetFastValue(config, 'strength'));
	        this.set3fv('color', GetFastValue(config, 'glcolor'));

	        var x = GetFastValue(config, 'x');
	        var y = GetFastValue(config, 'y');
	        var steps = GetFastValue(config, 'steps');

	        for (var i = 0; i < steps; i++)
	        {
	            this.set2f('offset', x, 0);
	            this.runDraw();

	            this.set2f('offset', 0, y);
	            this.runDraw();
	        }
	    },

	    onGradient: function (config)
	    {
	        var shader = this.shaders[FX_CONST.GRADIENT];

	        this.setShader(shader);

	        this.gradient.onPreRender(config, shader);

	        this.runDraw();
	    },

	    onBloom: function (config, width, height)
	    {
	        var shader = this.shaders[FX_CONST.BLOOM];

	        this.copySprite(this.source, this.swap);

	        this.setShader(shader);

	        this.set1i('uMainSampler', 0);
	        this.set1f('strength', GetFastValue(config, 'blurStrength'));
	        this.set3fv('color', GetFastValue(config, 'glcolor'));

	        var x = (2 / width) * GetFastValue(config, 'offsetX');
	        var y = (2 / height) * GetFastValue(config, 'offsetY');
	        var steps = GetFastValue(config, 'steps');

	        for (var i = 0; i < steps; i++)
	        {
	            this.set2f('offset', x, 0);
	            this.runDraw();

	            this.set2f('offset', 0, y);
	            this.runDraw();
	        }

	        this.blendFrames(this.swap, this.source, this.target, GetFastValue(config, 'strength'));
	        this.copySprite(this.target, this.source);
	    },

	    onColorMatrix: function (config)
	    {
	        this.setShader(this.colorMatrixShader);

	        this.set1fv('uColorMatrix', config.getData());
	        this.set1f('uAlpha', config.alpha);

	        this.runDraw();
	    },

	    onCircle: function (config, width, height)
	    {
	        var shader = this.shaders[FX_CONST.CIRCLE];

	        this.setShader(shader);

	        this.circle.onPreRender(config, shader, width, height);

	        this.runDraw();
	    },

	    onBarrel: function (config)
	    {
	        var shader = this.shaders[FX_CONST.BARREL];

	        this.setShader(shader);

	        this.barrel.onPreRender(config, shader);

	        this.runDraw();
	    },

	    onDisplacement: function (config)
	    {
	        this.setShader(this.shaders[FX_CONST.DISPLACEMENT]);

	        this.set1i('uDisplacementSampler', 1);
	        this.set2f('amount', config.x, config.y);

	        this.bindTexture(config.glTexture, 1);

	        this.runDraw();
	    },

	    onWipe: function (config)
	    {
	        var shader = this.shaders[FX_CONST.WIPE];

	        this.setShader(shader);

	        this.wipe.onPreRender(config, shader);

	        this.runDraw();
	    },

	    onBokeh: function (config, width, height)
	    {
	        var shader = this.shaders[FX_CONST.BOKEH];

	        this.setShader(shader);

	        this.bokeh.onPreRender(config, shader, width, height);

	        this.runDraw();
	    },

	    destroy: function ()
	    {
	        this.glow.destroy();
	        this.shadow.destroy();
	        this.pixelate.destroy();
	        this.vignette.destroy();
	        this.shine.destroy();
	        this.gradient.destroy();
	        this.circle.destroy();
	        this.barrel.destroy();
	        this.wipe.destroy();
	        this.bokeh.destroy();

	        this.fxHandlers = null;
	        this.source = null;
	        this.target = null;
	        this.swap = null;

	        PreFXPipeline.prototype.destroy.call(this);

	        return this;
	    }
	});

	FXPipeline_1 = FXPipeline;
	return FXPipeline_1;
}

var LightPipeline_1;
var hasRequiredLightPipeline;

function requireLightPipeline () {
	if (hasRequiredLightPipeline) return LightPipeline_1;
	hasRequiredLightPipeline = 1;
	var Class = requireClass();
	var GetFastValue = requireGetFastValue();
	var LightShaderSourceFS = requireLightFrag();
	var MultiPipeline = requireMultiPipeline();
	var TransformMatrix = requireTransformMatrix();
	var Vec2 = requireVector2();
	var WebGLPipeline = requireWebGLPipeline();

	var LightPipeline = new Class({

	    Extends: MultiPipeline,

	    initialize:

	    function LightPipeline (config)
	    {
	        var fragShader = GetFastValue(config, 'fragShader', LightShaderSourceFS);

	        config.fragShader = fragShader.replace('%LIGHT_COUNT%', config.game.renderer.config.maxLights);

	        MultiPipeline.call(this, config);

	        this.inverseRotationMatrix = new Float32Array([
	            1, 0, 0,
	            0, 1, 0,
	            0, 0, 1
	        ]);

	        this.currentNormalMap;

	        this.lightsActive = true;

	        this.tempVec2 = new Vec2();

	        this._tempMatrix = new TransformMatrix();

	        this._tempMatrix2 = new TransformMatrix();
	    },

	    boot: function ()
	    {
	        WebGLPipeline.prototype.boot.call(this);
	    },

	    onRender: function (scene, camera)
	    {
	        var lightManager = scene.sys.lights;

	        this.lightsActive = false;

	        if (!lightManager || !lightManager.active)
	        {
	            return;
	        }

	        var lights = lightManager.getLights(camera);
	        var lightsCount = lights.length;

	        this.lightsActive = true;

	        var i;
	        var renderer = this.renderer;
	        var height = renderer.height;
	        var cameraMatrix = camera.matrix;
	        var tempVec2 = this.tempVec2;

	        this.set1i('uMainSampler', 0);
	        this.set1i('uNormSampler', 1);
	        this.set2f('uResolution', this.width / 2, this.height / 2);
	        this.set4f('uCamera', camera.x, camera.y, camera.rotation, camera.zoom);
	        this.set3f('uAmbientLightColor', lightManager.ambientColor.r, lightManager.ambientColor.g, lightManager.ambientColor.b);
	        this.set1i('uLightCount', lightsCount);

	        for (i = 0; i < lightsCount; i++)
	        {
	            var light = lights[i].light;
	            var color = light.color;

	            var lightName = 'uLights[' + i + '].';

	            cameraMatrix.transformPoint(light.x, light.y, tempVec2);

	            this.set2f(lightName + 'position', tempVec2.x - (camera.scrollX * light.scrollFactorX * camera.zoom), height - (tempVec2.y - (camera.scrollY * light.scrollFactorY) * camera.zoom));
	            this.set3f(lightName + 'color', color.r, color.g, color.b);
	            this.set1f(lightName + 'intensity', light.intensity);
	            this.set1f(lightName + 'radius', light.radius);
	        }

	        this.currentNormalMapRotation = null;
	    },

	    setNormalMapRotation: function (rotation)
	    {
	        if (rotation !== this.currentNormalMapRotation || this.vertexCount === 0)
	        {
	            if (this.vertexCount > 0)
	            {
	                this.flush();
	            }

	            var inverseRotationMatrix = this.inverseRotationMatrix;

	            if (rotation)
	            {
	                var rot = -rotation;
	                var c = Math.cos(rot);
	                var s = Math.sin(rot);

	                inverseRotationMatrix[1] = s;
	                inverseRotationMatrix[3] = -s;
	                inverseRotationMatrix[0] = inverseRotationMatrix[4] = c;
	            }
	            else
	            {
	                inverseRotationMatrix[0] = inverseRotationMatrix[4] = 1;
	                inverseRotationMatrix[1] = inverseRotationMatrix[3] = 0;
	            }

	            this.setMatrix3fv('uInverseRotationMatrix', false, inverseRotationMatrix);

	            this.currentNormalMapRotation = rotation;
	        }
	    },

	    setTexture2D: function (texture, gameObject)
	    {
	        var renderer = this.renderer;

	        if (texture === undefined) { texture = renderer.whiteTexture; }

	        var normalMap = this.getNormalMap(gameObject);

	        if (this.isNewNormalMap(texture, normalMap))
	        {
	            this.flush();

	            this.createBatch(texture);

	            this.addTextureToBatch(normalMap);

	            this.currentNormalMap = normalMap;
	        }

	        var rotation = 0;

	        if (gameObject && gameObject.parentContainer)
	        {
	            var matrix = gameObject.getWorldTransformMatrix(this._tempMatrix, this._tempMatrix2);

	            rotation = matrix.rotationNormalized;
	        }
	        else if (gameObject)
	        {
	            rotation = gameObject.rotation;
	        }

	        if (this.currentBatch === null)
	        {
	            this.createBatch(texture);

	            this.addTextureToBatch(normalMap);
	        }

	        this.setNormalMapRotation(rotation);

	        return 0;
	    },

	    setGameObject: function (gameObject, frame)
	    {
	        if (frame === undefined) { frame = gameObject.frame; }

	        var texture = frame.glTexture;
	        var normalMap = this.getNormalMap(gameObject);

	        if (this.isNewNormalMap(texture, normalMap))
	        {
	            this.flush();

	            this.createBatch(texture);

	            this.addTextureToBatch(normalMap);

	            this.currentNormalMap = normalMap;
	        }

	        if (gameObject.parentContainer)
	        {
	            var matrix = gameObject.getWorldTransformMatrix(this._tempMatrix, this._tempMatrix2);

	            this.setNormalMapRotation(matrix.rotationNormalized);
	        }
	        else
	        {
	            this.setNormalMapRotation(gameObject.rotation);
	        }

	        if (this.currentBatch === null)
	        {
	            this.createBatch(texture);

	            this.addTextureToBatch(normalMap);
	        }

	        return 0;
	    },

	    isNewNormalMap: function (texture, normalMap)
	    {
	        return (this.currentTexture !== texture || this.currentNormalMap !== normalMap);
	    },

	    getNormalMap: function (gameObject)
	    {
	        var normalMap;

	        if (!gameObject)
	        {
	            return this.renderer.normalTexture;
	        }
	        else if (gameObject.displayTexture)
	        {
	            normalMap = gameObject.displayTexture.dataSource[gameObject.displayFrame.sourceIndex];
	        }
	        else if (gameObject.texture)
	        {
	            normalMap = gameObject.texture.dataSource[gameObject.frame.sourceIndex];
	        }
	        else if (gameObject.tileset)
	        {
	            if (Array.isArray(gameObject.tileset))
	            {
	                normalMap = gameObject.tileset[0].image.dataSource[0];
	            }
	            else
	            {
	                normalMap = gameObject.tileset.image.dataSource[0];
	            }
	        }

	        if (!normalMap)
	        {
	            return this.renderer.normalTexture;
	        }

	        return normalMap.glTexture;
	    },

	    batchSprite: function (gameObject, camera, parentTransformMatrix)
	    {
	        if (this.lightsActive)
	        {
	            MultiPipeline.prototype.batchSprite.call(this, gameObject, camera, parentTransformMatrix);
	        }
	    },

	    batchTexture: function (
	        gameObject,
	        texture,
	        textureWidth, textureHeight,
	        srcX, srcY,
	        srcWidth, srcHeight,
	        scaleX, scaleY,
	        rotation,
	        flipX, flipY,
	        scrollFactorX, scrollFactorY,
	        displayOriginX, displayOriginY,
	        frameX, frameY, frameWidth, frameHeight,
	        tintTL, tintTR, tintBL, tintBR, tintEffect,
	        uOffset, vOffset,
	        camera,
	        parentTransformMatrix,
	        skipFlip,
	        textureUnit)
	    {
	        if (this.lightsActive)
	        {
	            MultiPipeline.prototype.batchTexture.call(
	                this,
	                gameObject,
	                texture,
	                textureWidth, textureHeight,
	                srcX, srcY,
	                srcWidth, srcHeight,
	                scaleX, scaleY,
	                rotation,
	                flipX, flipY,
	                scrollFactorX, scrollFactorY,
	                displayOriginX, displayOriginY,
	                frameX, frameY, frameWidth, frameHeight,
	                tintTL, tintTR, tintBL, tintBR, tintEffect,
	                uOffset, vOffset,
	                camera,
	                parentTransformMatrix,
	                skipFlip,
	                textureUnit
	            );
	        }
	    },

	    batchTextureFrame: function (
	        frame,
	        x, y,
	        tint, alpha,
	        transformMatrix,
	        parentTransformMatrix
	    )
	    {
	        if (this.lightsActive)
	        {
	            MultiPipeline.prototype.batchTextureFrame.call(
	                this,
	                frame,
	                x, y,
	                tint, alpha,
	                transformMatrix,
	                parentTransformMatrix
	            );
	        }
	    }

	});

	LightPipeline_1 = LightPipeline;
	return LightPipeline_1;
}

var MobilePipeline_1;
var hasRequiredMobilePipeline;

function requireMobilePipeline () {
	if (hasRequiredMobilePipeline) return MobilePipeline_1;
	hasRequiredMobilePipeline = 1;
	var Class = requireClass();
	var GetFastValue = requireGetFastValue();
	var MultiPipeline = requireMultiPipeline();
	var ShaderSourceFS = requireSingleFrag();
	var ShaderSourceVS = requireSingleVert();
	var WEBGL_CONST = require_const$8();
	var WebGLPipeline = requireWebGLPipeline();

	var MobilePipeline = new Class({

	    Extends: MultiPipeline,

	    initialize:

	    function MobilePipeline (config)
	    {
	        config.fragShader = GetFastValue(config, 'fragShader', ShaderSourceFS);
	        config.vertShader = GetFastValue(config, 'vertShader', ShaderSourceVS);
	        config.attributes = GetFastValue(config, 'attributes', [
	            {
	                name: 'inPosition',
	                size: 2
	            },
	            {
	                name: 'inTexCoord',
	                size: 2
	            },
	            {
	                name: 'inTexId'
	            },
	            {
	                name: 'inTintEffect'
	            },
	            {
	                name: 'inTint',
	                size: 4,
	                type: WEBGL_CONST.UNSIGNED_BYTE,
	                normalized: true
	            }
	        ]);
	        config.forceZero = true;
	        config.resizeUniform = 'uResolution';

	        MultiPipeline.call(this, config);
	    },

	    boot: function ()
	    {
	        WebGLPipeline.prototype.boot.call(this);

	        var renderer = this.renderer;

	        this.set1i('uMainSampler', 0);
	        this.set2f('uResolution', renderer.width, renderer.height);
	    }

	});

	MobilePipeline_1 = MobilePipeline;
	return MobilePipeline_1;
}

var PointLightPipeline_1;
var hasRequiredPointLightPipeline;

function requirePointLightPipeline () {
	if (hasRequiredPointLightPipeline) return PointLightPipeline_1;
	hasRequiredPointLightPipeline = 1;
	var Class = requireClass();
	var GetFastValue = requireGetFastValue();
	var PointLightShaderSourceFS = requirePointLightFrag();
	var PointLightShaderSourceVS = requirePointLightVert();
	var WebGLPipeline = requireWebGLPipeline();

	var PointLightPipeline = new Class({

	    Extends: WebGLPipeline,

	    initialize:

	    function PointLightPipeline (config)
	    {
	        config.vertShader = GetFastValue(config, 'vertShader', PointLightShaderSourceVS);
	        config.fragShader = GetFastValue(config, 'fragShader', PointLightShaderSourceFS);
	        config.attributes = GetFastValue(config, 'attributes', [
	            {
	                name: 'inPosition',
	                size: 2
	            },
	            {
	                name: 'inLightPosition',
	                size: 2
	            },
	            {
	                name: 'inLightRadius'
	            },
	            {
	                name: 'inLightAttenuation'
	            },
	            {
	                name: 'inLightColor',
	                size: 4
	            }
	        ]);

	        WebGLPipeline.call(this, config);
	    },

	    onRender: function (scene, camera)
	    {
	        this.set2f('uResolution', this.width, this.height);
	        this.set1f('uCameraZoom', camera.zoom);
	    },

	    batchPointLight: function (light, camera, x0, y0, x1, y1, x2, y2, x3, y3, lightX, lightY)
	    {
	        var color = light.color;
	        var intensity = light.intensity;
	        var radius = light.radius;
	        var attenuation = light.attenuation;

	        var r = color.r * intensity;
	        var g = color.g * intensity;
	        var b = color.b * intensity;
	        var a = camera.alpha * light.alpha;

	        if (this.shouldFlush(6))
	        {
	            this.flush();
	        }

	        if (!this.currentBatch)
	        {
	            this.setTexture2D();
	        }

	        this.batchLightVert(x0, y0, lightX, lightY, radius, attenuation, r, g, b, a);
	        this.batchLightVert(x1, y1, lightX, lightY, radius, attenuation, r, g, b, a);
	        this.batchLightVert(x2, y2, lightX, lightY, radius, attenuation, r, g, b, a);
	        this.batchLightVert(x0, y0, lightX, lightY, radius, attenuation, r, g, b, a);
	        this.batchLightVert(x2, y2, lightX, lightY, radius, attenuation, r, g, b, a);
	        this.batchLightVert(x3, y3, lightX, lightY, radius, attenuation, r, g, b, a);

	        this.currentBatch.count = (this.vertexCount - this.currentBatch.start);
	    },

	    batchLightVert: function (x, y, lightX, lightY, radius, attenuation, r, g, b, a)
	    {
	        var vertexViewF32 = this.vertexViewF32;

	        var vertexOffset = (this.vertexCount * this.currentShader.vertexComponentCount) - 1;

	        vertexViewF32[++vertexOffset] = x;
	        vertexViewF32[++vertexOffset] = y;
	        vertexViewF32[++vertexOffset] = lightX;
	        vertexViewF32[++vertexOffset] = lightY;
	        vertexViewF32[++vertexOffset] = radius;
	        vertexViewF32[++vertexOffset] = attenuation;
	        vertexViewF32[++vertexOffset] = r;
	        vertexViewF32[++vertexOffset] = g;
	        vertexViewF32[++vertexOffset] = b;
	        vertexViewF32[++vertexOffset] = a;

	        this.vertexCount++;
	    }

	});

	PointLightPipeline_1 = PointLightPipeline;
	return PointLightPipeline_1;
}

var RopePipeline_1;
var hasRequiredRopePipeline;

function requireRopePipeline () {
	if (hasRequiredRopePipeline) return RopePipeline_1;
	hasRequiredRopePipeline = 1;
	var Class = requireClass();
	var GetFastValue = requireGetFastValue();
	var MultiPipeline = requireMultiPipeline();

	var RopePipeline = new Class({

	    Extends: MultiPipeline,

	    initialize:

	    function RopePipeline (config)
	    {

	        config.topology = 5;
	        config.batchSize = GetFastValue(config, 'batchSize', 256);

	        MultiPipeline.call(this, config);
	    }
	});

	RopePipeline_1 = RopePipeline;
	return RopePipeline_1;
}

var SinglePipeline_1;
var hasRequiredSinglePipeline;

function requireSinglePipeline () {
	if (hasRequiredSinglePipeline) return SinglePipeline_1;
	hasRequiredSinglePipeline = 1;
	var Class = requireClass();
	var GetFastValue = requireGetFastValue();
	var MultiPipeline = requireMultiPipeline();
	var ShaderSourceFS = requireSingleFrag();
	var ShaderSourceVS = requireSingleVert();
	var WebGLPipeline = requireWebGLPipeline();

	var SinglePipeline = new Class({

	    Extends: MultiPipeline,

	    initialize:

	    function SinglePipeline (config)
	    {
	        config.fragShader = GetFastValue(config, 'fragShader', ShaderSourceFS),
	        config.vertShader = GetFastValue(config, 'vertShader', ShaderSourceVS),
	        config.forceZero = true;

	        MultiPipeline.call(this, config);
	    },

	    boot: function ()
	    {
	        WebGLPipeline.prototype.boot.call(this);

	        var renderer = this.renderer;

	        this.set1i('uMainSampler', 0);
	        this.set2f('uResolution', renderer.width, renderer.height);
	    }

	});

	SinglePipeline_1 = SinglePipeline;
	return SinglePipeline_1;
}

var UtilityPipeline_1;
var hasRequiredUtilityPipeline;

function requireUtilityPipeline () {
	if (hasRequiredUtilityPipeline) return UtilityPipeline_1;
	hasRequiredUtilityPipeline = 1;
	var AddBlendFS = requireAddBlendFrag();
	var BlendModes = requireBlendModes();
	var Class = requireClass();
	var ColorMatrix = requireColorMatrix$1();
	var ColorMatrixFS = requireColorMatrixFrag();
	var CopyFS = requireCopyFrag();
	var GetFastValue = requireGetFastValue();
	var LinearBlendFS = requireLinearBlendFrag();
	var QuadVS = requireQuadVert();
	var WebGLPipeline = requireWebGLPipeline();

	var UtilityPipeline = new Class({

	    Extends: WebGLPipeline,

	    initialize:

	    function UtilityPipeline (config)
	    {
	        config.renderTarget = GetFastValue(config, 'renderTarget', [
	            {
	                scale: 1,
	                autoResize: true
	            },
	            {
	                scale: 1,
	                autoResize: true
	            },
	            {
	                scale: 0.5,
	                autoResize: true
	            },
	            {
	                scale: 0.5,
	                autoResize: true
	            }
	        ]);

	        config.vertShader = GetFastValue(config, 'vertShader', QuadVS);

	        config.shaders = GetFastValue(config, 'shaders', [
	            {
	                name: 'Copy',
	                fragShader: CopyFS
	            },
	            {
	                name: 'AddBlend',
	                fragShader: AddBlendFS
	            },
	            {
	                name: 'LinearBlend',
	                fragShader: LinearBlendFS
	            },
	            {
	                name: 'ColorMatrix',
	                fragShader: ColorMatrixFS
	            }
	        ]);

	        config.attributes = GetFastValue(config, 'attributes', [
	            {
	                name: 'inPosition',
	                size: 2
	            },
	            {
	                name: 'inTexCoord',
	                size: 2
	            }
	        ]);

	        config.vertices = [
	            -1, -1, 0, 0,
	            -1, 1, 0, 1,
	            1, 1, 1, 1,
	            -1, -1, 0, 0,
	            1, 1, 1, 1,
	            1, -1, 1, 0
	        ];

	        config.batchSize = 1;

	        WebGLPipeline.call(this, config);

	        this.colorMatrix = new ColorMatrix();

	        this.copyShader;

	        this.addShader;

	        this.linearShader;

	        this.colorMatrixShader;

	        this.fullFrame1;

	        this.fullFrame2;

	        this.halfFrame1;

	        this.halfFrame2;
	    },

	    boot: function ()
	    {
	        WebGLPipeline.prototype.boot.call(this);

	        var shaders = this.shaders;
	        var targets = this.renderTargets;

	        this.copyShader = shaders[0];
	        this.addShader = shaders[1];
	        this.linearShader = shaders[2];
	        this.colorMatrixShader = shaders[3];

	        this.fullFrame1 = targets[0];
	        this.fullFrame2 = targets[1];
	        this.halfFrame1 = targets[2];
	        this.halfFrame2 = targets[3];
	    },

	    copyFrame: function (source, target, brightness, clear, clearAlpha)
	    {
	        if (brightness === undefined) { brightness = 1; }
	        if (clear === undefined) { clear = true; }
	        if (clearAlpha === undefined) { clearAlpha = true; }

	        var gl = this.gl;

	        this.setShader(this.copyShader);

	        this.set1i('uMainSampler', 0);
	        this.set1f('uBrightness', brightness);

	        gl.activeTexture(gl.TEXTURE0);
	        gl.bindTexture(gl.TEXTURE_2D, source.texture.webGLTexture);

	        if (target)
	        {
	            gl.viewport(0, 0, target.width, target.height);
	            gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer.webGLFramebuffer);
	            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target.texture.webGLTexture, 0);
	        }
	        else
	        {
	            gl.viewport(0, 0, source.width, source.height);
	        }

	        if (clear)
	        {
	            if (clearAlpha)
	            {
	                gl.clearColor(0, 0, 0, 0);
	            }
	            else
	            {
	                gl.clearColor(0, 0, 0, 1);
	            }

	            gl.clear(gl.COLOR_BUFFER_BIT);
	        }

	        gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.STATIC_DRAW);
	        gl.drawArrays(gl.TRIANGLES, 0, 6);

	        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
	        gl.bindTexture(gl.TEXTURE_2D, null);
	    },

	    blitFrame: function (source, target, brightness, clear, clearAlpha, eraseMode, flipY)
	    {
	        if (brightness === undefined) { brightness = 1; }
	        if (clear === undefined) { clear = true; }
	        if (clearAlpha === undefined) { clearAlpha = true; }
	        if (eraseMode === undefined) { eraseMode = false; }
	        if (flipY === undefined) { flipY = false; }

	        var gl = this.gl;

	        this.setShader(this.copyShader);

	        this.set1i('uMainSampler', 0);
	        this.set1f('uBrightness', brightness);

	        gl.activeTexture(gl.TEXTURE0);
	        gl.bindTexture(gl.TEXTURE_2D, source.texture.webGLTexture);

	        if (source.height > target.height)
	        {
	            gl.viewport(0, 0, source.width, source.height);

	            this.setTargetUVs(source, target);
	        }
	        else
	        {
	            var diff = target.height - source.height;

	            gl.viewport(0, diff, source.width, source.height);
	        }

	        gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer.webGLFramebuffer);
	        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target.texture.webGLTexture, 0);

	        if (clear)
	        {
	            if (clearAlpha)
	            {
	                gl.clearColor(0, 0, 0, 0);
	            }
	            else
	            {
	                gl.clearColor(0, 0, 0, 1);
	            }

	            gl.clear(gl.COLOR_BUFFER_BIT);
	        }

	        if (eraseMode)
	        {
	            var blendMode = this.renderer.currentBlendMode;

	            this.renderer.setBlendMode(BlendModes.ERASE);
	        }

	        if (flipY)
	        {
	            this.flipY();
	        }

	        gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.STATIC_DRAW);
	        gl.drawArrays(gl.TRIANGLES, 0, 6);

	        if (eraseMode)
	        {
	            this.renderer.setBlendMode(blendMode);
	        }

	        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
	        gl.bindTexture(gl.TEXTURE_2D, null);

	        this.resetUVs();
	    },

	    copyFrameRect: function (source, target, x, y, width, height, clear, clearAlpha)
	    {
	        if (clear === undefined) { clear = true; }
	        if (clearAlpha === undefined) { clearAlpha = true; }

	        var gl = this.gl;

	        gl.bindFramebuffer(gl.FRAMEBUFFER, source.framebuffer.webGLFramebuffer);
	        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, source.texture.webGLTexture, 0);

	        if (clear)
	        {
	            if (clearAlpha)
	            {
	                gl.clearColor(0, 0, 0, 0);
	            }
	            else
	            {
	                gl.clearColor(0, 0, 0, 1);
	            }

	            gl.clear(gl.COLOR_BUFFER_BIT);
	        }

	        gl.activeTexture(gl.TEXTURE0);
	        gl.bindTexture(gl.TEXTURE_2D, target.texture.webGLTexture);

	        gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, x, y, width, height);

	        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
	        gl.bindTexture(gl.TEXTURE_2D, null);
	    },

	    copyToGame: function (source)
	    {
	        var gl = this.gl;

	        this.setShader(this.copyShader);

	        this.set1i('uMainSampler', 0);
	        this.set1f('uBrightness', 1);

	        this.renderer.popFramebuffer();

	        gl.activeTexture(gl.TEXTURE0);
	        gl.bindTexture(gl.TEXTURE_2D, source.texture.webGLTexture);

	        gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.STATIC_DRAW);
	        gl.drawArrays(gl.TRIANGLES, 0, 6);
	    },

	    drawFrame: function (source, target, clearAlpha, colorMatrix)
	    {
	        if (clearAlpha === undefined) { clearAlpha = true; }
	        if (colorMatrix === undefined) { colorMatrix = this.colorMatrix; }

	        var gl = this.gl;

	        this.setShader(this.colorMatrixShader);

	        this.set1i('uMainSampler', 0);
	        this.set1fv('uColorMatrix', colorMatrix.getData());
	        this.set1f('uAlpha', colorMatrix.alpha);

	        gl.activeTexture(gl.TEXTURE0);
	        gl.bindTexture(gl.TEXTURE_2D, source.texture.webGLTexture);

	        if (target)
	        {
	            gl.viewport(0, 0, target.width, target.height);
	            gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer.webGLFramebuffer);
	            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target.texture.webGLTexture, 0);
	        }
	        else
	        {
	            gl.viewport(0, 0, source.width, source.height);
	        }

	        if (clearAlpha)
	        {
	            gl.clearColor(0, 0, 0, 0);
	        }
	        else
	        {
	            gl.clearColor(0, 0, 0, 1);
	        }

	        gl.clear(gl.COLOR_BUFFER_BIT);

	        gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.STATIC_DRAW);
	        gl.drawArrays(gl.TRIANGLES, 0, 6);

	        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
	        gl.bindTexture(gl.TEXTURE_2D, null);
	    },

	    blendFrames: function (source1, source2, target, strength, clearAlpha, blendShader)
	    {
	        if (strength === undefined) { strength = 1; }
	        if (clearAlpha === undefined) { clearAlpha = true; }
	        if (blendShader === undefined) { blendShader = this.linearShader; }

	        var gl = this.gl;

	        this.setShader(blendShader);

	        this.set1i('uMainSampler1', 0);
	        this.set1i('uMainSampler2', 1);
	        this.set1f('uStrength', strength);

	        gl.activeTexture(gl.TEXTURE0);
	        gl.bindTexture(gl.TEXTURE_2D, source1.texture.webGLTexture);

	        gl.activeTexture(gl.TEXTURE1);
	        gl.bindTexture(gl.TEXTURE_2D, source2.texture.webGLTexture);

	        if (target)
	        {
	            gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer.webGLFramebuffer);
	            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target.texture.webGLTexture, 0);
	            gl.viewport(0, 0, target.width, target.height);
	        }
	        else
	        {
	            gl.viewport(0, 0, source1.width, source1.height);
	        }

	        if (clearAlpha)
	        {
	            gl.clearColor(0, 0, 0, 0);
	        }
	        else
	        {
	            gl.clearColor(0, 0, 0, 1);
	        }

	        gl.clear(gl.COLOR_BUFFER_BIT);

	        gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.STATIC_DRAW);
	        gl.drawArrays(gl.TRIANGLES, 0, 6);

	        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
	        gl.bindTexture(gl.TEXTURE_2D, null);
	    },

	    blendFramesAdditive: function (source1, source2, target, strength, clearAlpha)
	    {
	        this.blendFrames(source1, source2, target, strength, clearAlpha, this.addShader);
	    },

	    clearFrame: function (target, clearAlpha)
	    {
	        if (clearAlpha === undefined) { clearAlpha = true; }

	        var gl = this.gl;

	        gl.viewport(0, 0, target.width, target.height);

	        gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer.webGLFramebuffer);

	        if (clearAlpha)
	        {
	            gl.clearColor(0, 0, 0, 0);
	        }
	        else
	        {
	            gl.clearColor(0, 0, 0, 1);
	        }

	        gl.clear(gl.COLOR_BUFFER_BIT);

	        var fbo = this.renderer.currentFramebuffer;

	        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo.webGLFramebuffer);
	    },

	    setUVs: function (uA, vA, uB, vB, uC, vC, uD, vD)
	    {
	        var vertexViewF32 = this.vertexViewF32;

	        vertexViewF32[2] = uA;
	        vertexViewF32[3] = vA;
	        vertexViewF32[6] = uB;
	        vertexViewF32[7] = vB;
	        vertexViewF32[10] = uC;
	        vertexViewF32[11] = vC;
	        vertexViewF32[14] = uA;
	        vertexViewF32[15] = vA;
	        vertexViewF32[18] = uC;
	        vertexViewF32[19] = vC;
	        vertexViewF32[22] = uD;
	        vertexViewF32[23] = vD;
	    },

	    setTargetUVs: function (source, target)
	    {
	        var diff = (target.height / source.height);

	        if (diff > 0.5)
	        {
	            diff = 0.5 - (diff - 0.5);
	        }
	        else
	        {
	            diff = 0.5 + (0.5 - diff);
	        }

	        this.setUVs(0, diff, 0, 1 + diff, 1, 1 + diff, 1, diff);
	    },

	    flipX: function ()
	    {
	        this.setUVs(1, 0, 1, 1, 0, 1, 0, 0);
	    },

	    flipY: function ()
	    {
	        this.setUVs(0, 1, 0, 0, 1, 0, 1, 1);
	    },

	    resetUVs: function ()
	    {
	        this.setUVs(0, 0, 0, 1, 1, 1, 1, 0);
	    }

	});

	UtilityPipeline_1 = UtilityPipeline;
	return UtilityPipeline_1;
}

var PipelineManager_1;
var hasRequiredPipelineManager;

function requirePipelineManager () {
	if (hasRequiredPipelineManager) return PipelineManager_1;
	hasRequiredPipelineManager = 1;
	var Class = requireClass();
	var CONST = require_const$9();
	var CustomMap = require_Map();
	var Device = requireDevice();
	var GetFastValue = requireGetFastValue();
	var RenderTarget = requireRenderTarget();
	var SnapCeil = requireSnapCeil();

	var BitmapMaskPipeline = requireBitmapMaskPipeline();
	var FX = requireFx();
	var FX_CONST = require_const$b();
	var FXPipeline = requireFXPipeline();
	var LightPipeline = requireLightPipeline();
	var MobilePipeline = requireMobilePipeline();
	var MultiPipeline = requireMultiPipeline();
	var PointLightPipeline = requirePointLightPipeline();
	var RopePipeline = requireRopePipeline();
	var SinglePipeline = requireSinglePipeline();
	var UtilityPipeline = requireUtilityPipeline();
	var ArrayEach = requireEach();
	var ArrayRemove = requireRemove();

	var PipelineManager = new Class({

	    initialize:

	    function PipelineManager (renderer)
	    {

	        this.game = renderer.game;

	        this.renderer = renderer;

	        this.classes = new CustomMap([
	            [ CONST.UTILITY_PIPELINE, UtilityPipeline ],
	            [ CONST.MULTI_PIPELINE, MultiPipeline ],
	            [ CONST.BITMAPMASK_PIPELINE, BitmapMaskPipeline ],
	            [ CONST.SINGLE_PIPELINE, SinglePipeline ],
	            [ CONST.ROPE_PIPELINE, RopePipeline ],
	            [ CONST.LIGHT_PIPELINE, LightPipeline ],
	            [ CONST.POINTLIGHT_PIPELINE, PointLightPipeline ],
	            [ CONST.MOBILE_PIPELINE, MobilePipeline ]
	        ]);

	        this.postPipelineClasses = new CustomMap();

	        this.pipelines = new CustomMap();

	        this.postPipelineInstances = [];

	        this.default = null;

	        this.current = null;

	        this.previous = null;

	        this.MULTI_PIPELINE = null;

	        this.BITMAPMASK_PIPELINE = null;

	        this.UTILITY_PIPELINE = null;

	        this.MOBILE_PIPELINE = null;

	        this.FX_PIPELINE = null;

	        this.fullFrame1;

	        this.fullFrame2;

	        this.halfFrame1;

	        this.halfFrame2;

	        this.renderTargets = [];

	        this.maxDimension = 0;

	        this.frameInc = 32;

	        this.targetIndex = 0;
	    },

	    boot: function (pipelineConfig, defaultPipeline, autoMobilePipeline)
	    {

	        var renderer = this.renderer;
	        var targets = this.renderTargets;

	        this.frameInc = Math.floor(GetFastValue(pipelineConfig, 'frameInc', 32));

	        var renderWidth = renderer.width;
	        var renderHeight = renderer.height;

	        var disablePreFX = this.game.config.disablePreFX;
	        var disablePostFX = this.game.config.disablePostFX;

	        if (!disablePostFX)
	        {
	            this.postPipelineClasses.setAll([
	                [ String(FX_CONST.BARREL), FX.Barrel ],
	                [ String(FX_CONST.BLOOM), FX.Bloom ],
	                [ String(FX_CONST.BLUR), FX.Blur ],
	                [ String(FX_CONST.BOKEH), FX.Bokeh ],
	                [ String(FX_CONST.CIRCLE), FX.Circle ],
	                [ String(FX_CONST.COLOR_MATRIX), FX.ColorMatrix ],
	                [ String(FX_CONST.DISPLACEMENT), FX.Displacement ],
	                [ String(FX_CONST.GLOW), FX.Glow ],
	                [ String(FX_CONST.GRADIENT), FX.Gradient ],
	                [ String(FX_CONST.PIXELATE), FX.Pixelate ],
	                [ String(FX_CONST.SHADOW), FX.Shadow ],
	                [ String(FX_CONST.SHINE), FX.Shine ],
	                [ String(FX_CONST.VIGNETTE), FX.Vignette ],
	                [ String(FX_CONST.WIPE), FX.Wipe ]
	            ]);
	        }

	        if (!disablePreFX)
	        {
	            this.classes.set(CONST.FX_PIPELINE, FXPipeline);

	            var minDimension = Math.min(renderWidth, renderHeight);

	            var qty = Math.ceil(minDimension / this.frameInc);

	            for (var i = 1; i < qty; i++)
	            {
	                var targetWidth = i * this.frameInc;

	                targets.push(new RenderTarget(renderer, targetWidth, targetWidth));

	                targets.push(new RenderTarget(renderer, targetWidth, targetWidth));

	                targets.push(new RenderTarget(renderer, targetWidth, targetWidth));

	                this.maxDimension = targetWidth;
	            }

	            targets.push(new RenderTarget(renderer, renderWidth, renderHeight, 1, 0, true, true));
	            targets.push(new RenderTarget(renderer, renderWidth, renderHeight, 1, 0, true, true));
	            targets.push(new RenderTarget(renderer, renderWidth, renderHeight, 1, 0, true, true));
	        }

	        var instance;
	        var pipelineName;

	        var _this = this;
	        var game = this.game;

	        this.classes.each(function (pipelineName, pipeline)
	        {
	            instance = _this.add(pipelineName, new pipeline({ game: game }));

	            if (pipelineName === CONST.UTILITY_PIPELINE)
	            {
	                _this.UTILITY_PIPELINE = instance;

	                _this.fullFrame1 = instance.fullFrame1;
	                _this.fullFrame2 = instance.fullFrame2;
	                _this.halfFrame1 = instance.halfFrame1;
	                _this.halfFrame2 = instance.halfFrame2;
	            }
	        });

	        this.MULTI_PIPELINE = this.get(CONST.MULTI_PIPELINE);
	        this.BITMAPMASK_PIPELINE = this.get(CONST.BITMAPMASK_PIPELINE);
	        this.MOBILE_PIPELINE = this.get(CONST.MOBILE_PIPELINE);

	        if (!disablePreFX)
	        {
	            this.FX_PIPELINE = this.get(CONST.FX_PIPELINE);
	        }

	        if (pipelineConfig)
	        {
	            for (pipelineName in pipelineConfig)
	            {
	                var pipelineClass = pipelineConfig[pipelineName];

	                instance = new pipelineClass(game);

	                instance.name = pipelineName;

	                if (instance.isPostFX)
	                {
	                    this.postPipelineClasses.set(pipelineName, pipelineClass);
	                }
	                else if (!this.has(pipelineName))
	                {
	                    this.classes.set(pipelineName, pipelineClass);

	                    this.add(pipelineName, instance);
	                }
	            }
	        }

	        this.default = this.get(defaultPipeline);

	        if (autoMobilePipeline && !Device.os.desktop)
	        {
	            this.default = this.MOBILE_PIPELINE;
	        }
	    },

	    setDefaultPipeline: function (pipeline)
	    {
	        var instance = this.get(pipeline);

	        if (instance)
	        {
	            this.default = instance;
	        }

	        return instance;
	    },

	    add: function (name, pipeline)
	    {
	        if (pipeline.isPostFX)
	        {
	            console.warn(name + ' is a Post Pipeline. Use `addPostPipeline` instead');

	            return;
	        }

	        var pipelines = this.pipelines;
	        var renderer = this.renderer;

	        if (!pipelines.has(name))
	        {
	            pipeline.name = name;
	            pipeline.manager = this;

	            pipelines.set(name, pipeline);
	        }
	        else
	        {
	            console.warn('Pipeline exists: ' + name);
	        }

	        if (!pipeline.hasBooted)
	        {
	            pipeline.boot();
	        }

	        if (renderer.width !== 0 && renderer.height !== 0 && !pipeline.isPreFX)
	        {
	            pipeline.resize(renderer.width, renderer.height);
	        }

	        return pipeline;
	    },

	    addPostPipeline: function (name, pipeline)
	    {
	        if (!this.postPipelineClasses.has(name))
	        {
	            this.postPipelineClasses.set(name, pipeline);
	        }
	    },

	    flush: function ()
	    {
	        if (this.current)
	        {
	            this.current.flush();
	        }
	    },

	    has: function (pipeline)
	    {
	        var pipelines = this.pipelines;

	        if (typeof pipeline === 'string')
	        {
	            return pipelines.has(pipeline);
	        }
	        else if (pipelines.contains(pipeline))
	        {
	            return true;
	        }

	        return false;
	    },

	    get: function (pipeline)
	    {
	        var pipelines = this.pipelines;

	        if (typeof pipeline === 'string')
	        {
	            return pipelines.get(pipeline);
	        }
	        else if (pipelines.contains(pipeline))
	        {
	            return pipeline;
	        }
	    },

	    getPostPipeline: function (pipeline, gameObject, config)
	    {
	        var pipelineClasses = this.postPipelineClasses;

	        var instance;
	        var pipelineName = '';
	        var pipetype = typeof pipeline;

	        if (pipetype === 'string' || pipetype === 'number')
	        {
	            instance = pipelineClasses.get(pipeline);
	            pipelineName = pipeline;
	        }
	        else if (pipetype === 'function')
	        {

	            if (pipelineClasses.contains(pipeline))
	            {
	                instance = pipeline;
	            }

	            pipelineName = pipeline.name;
	        }
	        else if (pipetype === 'object')
	        {

	            instance = pipelineClasses.get(pipeline.name);

	            pipelineName = pipeline.name;
	        }

	        if (instance)
	        {
	            var newPipeline = new instance(this.game, config);

	            newPipeline.name = pipelineName;

	            if (gameObject)
	            {
	                newPipeline.gameObject = gameObject;
	            }

	            this.postPipelineInstances.push(newPipeline);

	            return newPipeline;
	        }
	    },

	    removePostPipeline: function (pipeline)
	    {
	        ArrayRemove(this.postPipelineInstances, pipeline);
	    },

	    remove: function (name, removeClass, removePostPipelineClass)
	    {
	        if (removeClass === undefined) { removeClass = true; }
	        if (removePostPipelineClass === undefined) { removePostPipelineClass = true; }

	        this.pipelines.delete(name);

	        if (removeClass)
	        {
	            this.classes.delete(name);
	        }

	        if (removePostPipelineClass)
	        {
	            this.postPipelineClasses.delete(name);
	        }
	    },

	    set: function (pipeline, gameObject, currentShader)
	    {
	        if (pipeline.isPostFX)
	        {
	            return;
	        }

	        if (!this.isCurrent(pipeline, currentShader))
	        {
	            this.flush();

	            if (this.current)
	            {
	                this.current.unbind();
	            }

	            this.current = pipeline;

	            pipeline.bind(currentShader);
	        }

	        pipeline.updateProjectionMatrix();

	        pipeline.onBind(gameObject);

	        return pipeline;
	    },

	    preBatch: function (gameObject)
	    {
	        if (gameObject.hasPostPipeline)
	        {
	            this.flush();

	            var pipelines = gameObject.postPipelines;

	            for (var i = pipelines.length - 1; i >= 0; i--)
	            {
	                var pipeline = pipelines[i];

	                if (pipeline.active)
	                {
	                    pipeline.preBatch(gameObject);
	                }
	            }
	        }
	    },

	    postBatch: function (gameObject)
	    {
	        if (gameObject.hasPostPipeline)
	        {
	            this.flush();

	            var pipelines = gameObject.postPipelines;

	            for (var i = 0; i < pipelines.length; i++)
	            {
	                var pipeline = pipelines[i];

	                if (pipeline.active)
	                {
	                    pipeline.postBatch(gameObject);
	                }
	            }
	        }
	    },

	    preBatchCamera: function (camera)
	    {
	        if (camera.hasPostPipeline)
	        {
	            this.flush();

	            var pipelines = camera.postPipelines;

	            for (var i = pipelines.length - 1; i >= 0; i--)
	            {
	                var pipeline = pipelines[i];

	                if (pipeline.active)
	                {
	                    pipeline.preBatch(camera);
	                }
	            }
	        }
	    },

	    postBatchCamera: function (camera)
	    {
	        if (camera.hasPostPipeline)
	        {
	            this.flush();

	            var pipelines = camera.postPipelines;

	            for (var i = 0; i < pipelines.length; i++)
	            {
	                var pipeline = pipelines[i];

	                if (pipeline.active)
	                {
	                    pipeline.postBatch(camera);
	                }
	            }
	        }
	    },

	    isCurrent: function (pipeline, currentShader)
	    {
	        var renderer = this.renderer;
	        var current = this.current;

	        if (current && !currentShader)
	        {
	            currentShader = current.currentShader;
	        }

	        return !(current !== pipeline || currentShader.program !== renderer.currentProgram);
	    },

	    copyFrame: function (source, target, brightness, clear, clearAlpha)
	    {
	        this.setUtility(this.UTILITY_PIPELINE.copyShader).copyFrame(source, target, brightness, clear, clearAlpha);

	        return this;
	    },

	    copyToGame: function (source)
	    {
	        this.setUtility(this.UTILITY_PIPELINE.copyShader).copyToGame(source);

	        return this;
	    },

	    drawFrame: function (source, target, clearAlpha, colorMatrix)
	    {
	        this.setUtility(this.UTILITY_PIPELINE.colorMatrixShader).drawFrame(source, target, clearAlpha, colorMatrix);

	        return this;
	    },

	    blendFrames: function (source1, source2, target, strength, clearAlpha)
	    {
	        this.setUtility(this.UTILITY_PIPELINE.linearShader).blendFrames(source1, source2, target, strength, clearAlpha);

	        return this;
	    },

	    blendFramesAdditive: function (source1, source2, target, strength, clearAlpha)
	    {
	        this.setUtility(this.UTILITY_PIPELINE.addShader).blendFramesAdditive(source1, source2, target, strength, clearAlpha);

	        return this;
	    },

	    clearFrame: function (target, clearAlpha)
	    {
	        this.UTILITY_PIPELINE.clearFrame(target, clearAlpha);

	        return this;
	    },

	    blitFrame: function (source, target, brightness, clear, clearAlpha, eraseMode)
	    {
	        this.setUtility(this.UTILITY_PIPELINE.copyShader).blitFrame(source, target, brightness, clear, clearAlpha, eraseMode);

	        return this;
	    },

	    copyFrameRect: function (source, target, x, y, width, height, clear, clearAlpha)
	    {
	        this.UTILITY_PIPELINE.copyFrameRect(source, target, x, y, width, height, clear, clearAlpha);

	        return this;
	    },

	    forceZero: function ()
	    {
	        return (this.current && this.current.forceZero);
	    },

	    setMulti: function ()
	    {
	        return this.set(this.MULTI_PIPELINE);
	    },

	    setUtility: function (currentShader)
	    {
	        return this.UTILITY_PIPELINE.bind(currentShader);
	    },

	    setFX: function ()
	    {
	        return this.set(this.FX_PIPELINE);
	    },

	    restoreContext: function ()
	    {
	        this.rebind();
	        this.pipelines.each(function (_, pipeline)
	        {
	            pipeline.restoreContext();
	        });
	        ArrayEach(this.postPipelineInstances, function (pipeline)
	        {
	            pipeline.restoreContext();
	        });
	    },

	    rebind: function (pipeline)
	    {
	        if (pipeline === undefined && this.previous)
	        {
	            pipeline = this.previous;
	        }

	        var renderer = this.renderer;
	        var gl = renderer.gl;

	        gl.disable(gl.DEPTH_TEST);
	        gl.disable(gl.CULL_FACE);

	        if (renderer.hasActiveStencilMask())
	        {
	            gl.clear(gl.DEPTH_BUFFER_BIT);
	        }
	        else
	        {

	            gl.disable(gl.STENCIL_TEST);
	            gl.clear(gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
	        }

	        gl.viewport(0, 0, renderer.width, renderer.height);

	        renderer.currentProgram = null;

	        renderer.setBlendMode(0, true);

	        var vao = renderer.vaoExtension;

	        if (vao)
	        {
	            vao.bindVertexArrayOES(null);
	        }

	        var entries = this.pipelines.entries;

	        for (var key in entries)
	        {
	            entries[key].glReset = true;
	        }

	        if (pipeline)
	        {
	            this.current = pipeline;

	            pipeline.rebind();
	        }
	    },

	    clear: function ()
	    {
	        var renderer = this.renderer;

	        this.flush();

	        if (this.current)
	        {
	            this.current.unbind();
	            this.previous = this.current;
	            this.current = null;
	        }
	        else
	        {
	            this.previous = null;
	        }

	        renderer.currentProgram = null;

	        renderer.setBlendMode(0, true);

	        var vao = renderer.vaoExtension;

	        if (vao)
	        {
	            vao.bindVertexArrayOES(null);
	        }
	    },

	    getRenderTarget: function (size)
	    {
	        var targets = this.renderTargets;

	        var offset = 3;

	        if (size > this.maxDimension)
	        {
	            this.targetIndex = targets.length - offset;

	            return targets[this.targetIndex];
	        }
	        else
	        {
	            var index = (SnapCeil(size, this.frameInc, 0, true) - 1) * offset;

	            this.targetIndex = index;

	            return targets[index];
	        }
	    },

	    getSwapRenderTarget: function ()
	    {
	        return this.renderTargets[this.targetIndex + 1];
	    },

	    getAltSwapRenderTarget: function ()
	    {
	        return this.renderTargets[this.targetIndex + 2];
	    },

	    destroy: function ()
	    {
	        this.flush();

	        this.classes.clear();
	        this.postPipelineClasses.clear();
	        this.pipelines.clear();

	        this.renderer = null;
	        this.game = null;
	        this.classes = null;
	        this.postPipelineClasses = null;
	        this.pipelines = null;
	        this.default = null;
	        this.current = null;
	        this.previous = null;
	    }

	});

	PipelineManager_1 = PipelineManager;
	return PipelineManager_1;
}

var WebGLSnapshot_1;
var hasRequiredWebGLSnapshot;

function requireWebGLSnapshot () {
	if (hasRequiredWebGLSnapshot) return WebGLSnapshot_1;
	hasRequiredWebGLSnapshot = 1;
	var CanvasPool = requireCanvasPool();
	var Color = requireColor$1();
	var GetFastValue = requireGetFastValue();

	var WebGLSnapshot = function (sourceContext, config)
	{
	    var gl = sourceContext;

	    var callback = GetFastValue(config, 'callback');
	    var type = GetFastValue(config, 'type', 'image/png');
	    var encoderOptions = GetFastValue(config, 'encoder', 0.92);
	    var x = Math.abs(Math.round(GetFastValue(config, 'x', 0)));
	    var y = Math.abs(Math.round(GetFastValue(config, 'y', 0)));

	    var getPixel = GetFastValue(config, 'getPixel', false);

	    var isFramebuffer = GetFastValue(config, 'isFramebuffer', false);

	    var bufferWidth = (isFramebuffer) ? GetFastValue(config, 'bufferWidth', 1) : gl.drawingBufferWidth;
	    var bufferHeight = (isFramebuffer) ? GetFastValue(config, 'bufferHeight', 1) : gl.drawingBufferHeight;

	    if (getPixel)
	    {
	        var pixel = new Uint8Array(4);

	        var destY = (isFramebuffer) ? y : bufferHeight - y;

	        gl.readPixels(x, destY, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);

	        callback.call(null, new Color(pixel[0], pixel[1], pixel[2], pixel[3]));
	    }
	    else
	    {
	        var width = Math.floor(GetFastValue(config, 'width', bufferWidth));
	        var height = Math.floor(GetFastValue(config, 'height', bufferHeight));

	        var total = width * height * 4;

	        var pixels = new Uint8Array(total);

	        gl.readPixels(x, bufferHeight - y - height, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);

	        var canvas = CanvasPool.createWebGL(this, width, height);
	        var ctx = canvas.getContext('2d', { willReadFrequently: true });

	        var imageData = ctx.getImageData(0, 0, width, height);

	        var data = imageData.data;

	        for (var py = 0; py < height; py++)
	        {
	            for (var px = 0; px < width; px++)
	            {
	                var sourceIndex = ((height - py - 1) * width + px) * 4;

	                var destIndex = (isFramebuffer) ? total - ((py * width + (width - px)) * 4) : (py * width + px) * 4;

	                data[destIndex + 0] = pixels[sourceIndex + 0];
	                data[destIndex + 1] = pixels[sourceIndex + 1];
	                data[destIndex + 2] = pixels[sourceIndex + 2];
	                data[destIndex + 3] = pixels[sourceIndex + 3];
	            }
	        }

	        ctx.putImageData(imageData, 0, 0);

	        var image = new Image();

	        image.onerror = function ()
	        {
	            callback.call(null);

	            CanvasPool.remove(canvas);
	        };

	        image.onload = function ()
	        {
	            callback.call(null, image);

	            CanvasPool.remove(canvas);
	        };

	        image.src = canvas.toDataURL(type, encoderOptions);
	    }
	};

	WebGLSnapshot_1 = WebGLSnapshot;
	return WebGLSnapshot_1;
}

var WebGLBufferWrapper_1;
var hasRequiredWebGLBufferWrapper;

function requireWebGLBufferWrapper () {
	if (hasRequiredWebGLBufferWrapper) return WebGLBufferWrapper_1;
	hasRequiredWebGLBufferWrapper = 1;
	var Class = requireClass();

	var WebGLBufferWrapper = new Class({

	    initialize:

	    function WebGLBufferWrapper (gl, initialDataOrSize, bufferType, bufferUsage)
	    {

	        this.webGLBuffer = null;

	        this.gl = gl;

	        this.initialDataOrSize = initialDataOrSize;

	        this.bufferType = bufferType;

	        this.bufferUsage = bufferUsage;

	        this.createResource();
	    },

	    createResource: function ()
	    {
	        if (this.initialDataOrSize === null)
	        {
	            return;
	        }

	        var gl = this.gl;

	        if (gl.isContextLost())
	        {

	            return;
	        }

	        var bufferType = this.bufferType;
	        var webGLBuffer = gl.createBuffer();

	        this.webGLBuffer = webGLBuffer;

	        gl.bindBuffer(bufferType, this.webGLBuffer);
	        gl.bufferData(bufferType, this.initialDataOrSize, this.bufferUsage);
	        gl.bindBuffer(bufferType, null);
	    },

	    destroy: function ()
	    {
	        var gl = this.gl;
	        if (!gl.isContextLost())
	        {
	            gl.deleteBuffer(this.webGLBuffer);
	        }
	        this.webGLBuffer = null;
	        this.initialDataOrSize = null;
	        this.gl = null;
	    }
	});

	WebGLBufferWrapper_1 = WebGLBufferWrapper;
	return WebGLBufferWrapper_1;
}

var WebGLProgramWrapper_1;
var hasRequiredWebGLProgramWrapper;

function requireWebGLProgramWrapper () {
	if (hasRequiredWebGLProgramWrapper) return WebGLProgramWrapper_1;
	hasRequiredWebGLProgramWrapper = 1;
	var Class = requireClass();

	var WebGLProgramWrapper = new Class({

	    initialize:

	    function WebGLProgramWrapper (gl, vertexSource, fragmentSource)
	    {

	        this.webGLProgram = null;

	        this.gl = gl;

	        this.vertexSource = vertexSource;

	        this.fragmentSource = fragmentSource;

	        this.createResource();
	    },

	    createResource: function ()
	    {
	        var gl = this.gl;

	        if (gl.isContextLost())
	        {

	            return;
	        }

	        var program = gl.createProgram();

	        var vs = gl.createShader(gl.VERTEX_SHADER);
	        var fs = gl.createShader(gl.FRAGMENT_SHADER);

	        gl.shaderSource(vs, this.vertexSource);
	        gl.shaderSource(fs, this.fragmentSource);

	        gl.compileShader(vs);
	        gl.compileShader(fs);

	        var failed = 'Shader failed:\n';

	        if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS))
	        {
	            throw new Error('Vertex ' + failed + gl.getShaderInfoLog(vs));
	        }

	        if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS))
	        {
	            throw new Error('Fragment ' + failed + gl.getShaderInfoLog(fs));
	        }

	        gl.attachShader(program, vs);
	        gl.attachShader(program, fs);

	        gl.linkProgram(program);

	        if (!gl.getProgramParameter(program, gl.LINK_STATUS))
	        {
	            throw new Error('Link ' + failed + gl.getProgramInfoLog(program));
	        }

	        gl.useProgram(program);

	        this.webGLProgram = program;
	    },

	    destroy: function ()
	    {
	        if (!this.webGLProgram)
	        {
	            return;
	        }

	        if (!this.gl.isContextLost())
	        {
	            this.gl.deleteProgram(this.webGLProgram);
	        }

	        this.webGLProgram = null;
	        this.gl = null;
	    }
	});

	WebGLProgramWrapper_1 = WebGLProgramWrapper;
	return WebGLProgramWrapper_1;
}

var WebGLTextureWrapper_1;
var hasRequiredWebGLTextureWrapper;

function requireWebGLTextureWrapper () {
	if (hasRequiredWebGLTextureWrapper) return WebGLTextureWrapper_1;
	hasRequiredWebGLTextureWrapper = 1;
	var Class = requireClass();
	var IsSizePowerOfTwo = requireIsSizePowerOfTwo();

	var WebGLTextureWrapper = new Class({

	    initialize:

	    function WebGLTextureWrapper (gl, mipLevel, minFilter, magFilter, wrapT, wrapS, format, pixels, width, height, pma, forceSize, flipY)
	    {

	        this.webGLTexture = null;

	        this.isRenderTexture = false;

	        this.gl = gl;

	        this.mipLevel = mipLevel;

	        this.minFilter = minFilter;

	        this.magFilter = magFilter;

	        this.wrapT = wrapT;

	        this.wrapS = wrapS;

	        this.format = format;

	        this.pixels = pixels;

	        this.width = width;

	        this.height = height;

	        this.pma = (pma === undefined || pma === null) ? true : pma;

	        this.forceSize = !!forceSize;

	        this.flipY = !!flipY;

	        this.__SPECTOR_Metadata = {};

	        this.createResource();
	    },

	    createResource: function ()
	    {
	        var gl = this.gl;

	        if (gl.isContextLost())
	        {

	            return;
	        }

	        if (this.pixels instanceof WebGLTextureWrapper)
	        {

	            this.webGLTexture = this.pixels.webGLTexture;
	            return;
	        }

	        var texture = gl.createTexture();

	        texture.__SPECTOR_Metadata = this.__SPECTOR_Metadata;

	        this.webGLTexture = texture;

	        this._processTexture();
	    },

	    update: function (source, width, height, flipY, wrapS, wrapT, minFilter, magFilter, format)
	    {
	        if (width === 0 || height === 0)
	        {
	            return;
	        }

	        this.pixels = source;
	        this.width = width;
	        this.height = height;
	        this.flipY = flipY;
	        this.wrapS = wrapS;
	        this.wrapT = wrapT;
	        this.minFilter = minFilter;
	        this.magFilter = magFilter;
	        this.format = format;

	        var gl = this.gl;

	        if (gl.isContextLost())
	        {

	            return;
	        }

	        this._processTexture();
	    },

	    _processTexture: function ()
	    {
	        var gl = this.gl;

	        gl.activeTexture(gl.TEXTURE0);

	        var currentTexture = gl.getParameter(gl.TEXTURE_BINDING_2D);

	        gl.bindTexture(gl.TEXTURE_2D, this.webGLTexture);

	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this.minFilter);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, this.magFilter);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, this.wrapS);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, this.wrapT);

	        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.pma);
	        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, this.flipY);

	        var pixels = this.pixels;
	        var mipLevel = this.mipLevel;
	        var width = this.width;
	        var height = this.height;
	        var format = this.format;

	        var generateMipmap = false;

	        if (pixels === null || pixels === undefined)
	        {
	            gl.texImage2D(gl.TEXTURE_2D, mipLevel, format, width, height, 0, format, gl.UNSIGNED_BYTE, null);

	            generateMipmap = IsSizePowerOfTwo(width, height);
	        }
	        else if (pixels.compressed)
	        {
	            width = pixels.width;
	            height = pixels.height;
	            generateMipmap = pixels.generateMipmap;

	            for (var i = 0; i < pixels.mipmaps.length; i++)
	            {
	                gl.compressedTexImage2D(gl.TEXTURE_2D, i, pixels.internalFormat, pixels.mipmaps[i].width, pixels.mipmaps[i].height, 0, pixels.mipmaps[i].data);
	            }
	        }
	        else if (pixels instanceof Uint8Array)
	        {
	            gl.texImage2D(gl.TEXTURE_2D, mipLevel, format, width, height, 0, format, gl.UNSIGNED_BYTE, pixels);

	            generateMipmap = IsSizePowerOfTwo(width, height);
	        }
	        else
	        {
	            if (!this.forceSize)
	            {
	                width = pixels.width;
	                height = pixels.height;
	            }

	            gl.texImage2D(gl.TEXTURE_2D, mipLevel, format, format, gl.UNSIGNED_BYTE, pixels);

	            generateMipmap = IsSizePowerOfTwo(width, height);
	        }

	        if (generateMipmap)
	        {
	            gl.generateMipmap(gl.TEXTURE_2D);
	        }

	        if (currentTexture)
	        {
	            gl.bindTexture(gl.TEXTURE_2D, currentTexture);
	        }
	        else
	        {
	            gl.bindTexture(gl.TEXTURE_2D, null);
	        }
	    },

	    spectorMetadata: {

	        get: function ()
	        {
	            return this.__SPECTOR_Metadata;
	        },

	        set: function (value)
	        {

	            this.__SPECTOR_Metadata = value;

	            if (!this.gl.isContextLost())
	            {

	                this.webGLTexture.__SPECTOR_Metadata = value;
	            }
	        }
	    },

	    destroy: function ()
	    {
	        if (this.webGLTexture === null)
	        {
	            return;
	        }

	        if (!this.gl.isContextLost())
	        {
	            if (!(this.pixels instanceof WebGLTextureWrapper))
	            {

	                this.gl.deleteTexture(this.webGLTexture);
	            }
	        }

	        this.pixels = null;
	        this.webGLTexture = null;
	        this.gl = null;
	    }
	});

	WebGLTextureWrapper_1 = WebGLTextureWrapper;
	return WebGLTextureWrapper_1;
}

var WebGLFramebufferWrapper_1;
var hasRequiredWebGLFramebufferWrapper;

function requireWebGLFramebufferWrapper () {
	if (hasRequiredWebGLFramebufferWrapper) return WebGLFramebufferWrapper_1;
	hasRequiredWebGLFramebufferWrapper = 1;
	var Class = requireClass();

	var errors = {
	    36054: 'Incomplete Attachment',
	    36055: 'Missing Attachment',
	    36057: 'Incomplete Dimensions',
	    36061: 'Framebuffer Unsupported'
	};

	var WebGLFramebufferWrapper = new Class({

	    initialize:

	    function WebGLFramebufferWrapper (gl, width, height, renderTexture, addDepthStencilBuffer)
	    {

	        this.webGLFramebuffer = null;

	        this.gl = gl;

	        this.width = width;

	        this.height = height;

	        this.renderTexture = renderTexture;

	        this.addDepthStencilBuffer = !!addDepthStencilBuffer;

	        this.createResource();
	    },

	    createResource: function ()
	    {
	        var gl = this.gl;

	        if (gl.isContextLost())
	        {

	            return;
	        }

	        var renderTexture = this.renderTexture;
	        var complete = 0;
	        var framebuffer = gl.createFramebuffer();

	        this.webGLFramebuffer = framebuffer;
	        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);

	        renderTexture.isRenderTexture = true;
	        renderTexture.isAlphaPremultiplied = false;

	        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, renderTexture.webGLTexture, 0);

	        complete = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

	        if (complete !== gl.FRAMEBUFFER_COMPLETE)
	        {
	            throw new Error('Framebuffer status: ' + (errors[complete] || complete));
	        }

	        if (this.addDepthStencilBuffer)
	        {
	            var depthStencilBuffer = gl.createRenderbuffer();

	            gl.bindRenderbuffer(gl.RENDERBUFFER, depthStencilBuffer);
	            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, this.width, this.height);
	            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, depthStencilBuffer);
	        }

	        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
	    },

	    destroy: function ()
	    {
	        if (this.webGLFramebuffer === null)
	        {
	            return;
	        }

	        var gl = this.gl;

	        if (!gl.isContextLost())
	        {
	            gl.bindFramebuffer(gl.FRAMEBUFFER, this.webGLFramebuffer);

	            var colorAttachment = gl.getFramebufferAttachmentParameter(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME);

	            if (colorAttachment !== null)
	            {
	                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0);

	                gl.deleteTexture(colorAttachment);
	            }

	            var depthStencilAttachment = gl.getFramebufferAttachmentParameter(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME);

	            if (depthStencilAttachment !== null)
	            {
	                gl.deleteRenderbuffer(depthStencilAttachment);
	            }

	            gl.bindFramebuffer(gl.FRAMEBUFFER, null);

	            gl.deleteFramebuffer(this.webGLFramebuffer);
	        }

	        this.renderTexture = null;
	        this.webGLFramebuffer = null;
	        this.gl = null;
	    }
	});

	WebGLFramebufferWrapper_1 = WebGLFramebufferWrapper;
	return WebGLFramebufferWrapper_1;
}

var WebGLAttribLocationWrapper_1;
var hasRequiredWebGLAttribLocationWrapper;

function requireWebGLAttribLocationWrapper () {
	if (hasRequiredWebGLAttribLocationWrapper) return WebGLAttribLocationWrapper_1;
	hasRequiredWebGLAttribLocationWrapper = 1;
	var Class = requireClass();

	var WebGLAttribLocationWrapper = new Class({

	    initialize:

	    function WebGLAttribLocationWrapper (gl, program, name)
	    {

	        this.webGLAttribLocation = -1;

	        this.gl = gl;

	        this.program = program;

	        this.name = name;

	        this.createResource();
	    },

	    createResource: function ()
	    {
	        if (this.program.webGLProgram === null)
	        {
	            this.webGLAttribLocation = -1;
	            return;
	        }

	        var gl = this.gl;

	        if (gl.isContextLost())
	        {

	            return;
	        }

	        this.webGLAttribLocation = gl.getAttribLocation(this.program.webGLProgram, this.name);
	    },

	    destroy: function ()
	    {
	        this.gl = null;
	        this.program = null;
	        this.name = null;
	        this.webGLAttribLocation = -1;
	    }
	});

	WebGLAttribLocationWrapper_1 = WebGLAttribLocationWrapper;
	return WebGLAttribLocationWrapper_1;
}

var WebGLUniformLocationWrapper_1;
var hasRequiredWebGLUniformLocationWrapper;

function requireWebGLUniformLocationWrapper () {
	if (hasRequiredWebGLUniformLocationWrapper) return WebGLUniformLocationWrapper_1;
	hasRequiredWebGLUniformLocationWrapper = 1;
	var Class = requireClass();

	var WebGLUniformLocationWrapper = new Class({

	    initialize:

	    function WebGLUniformLocationWrapper (gl, program, name)
	    {

	        this.webGLUniformLocation = null;

	        this.gl = gl;

	        this.program = program;

	        this.name = name;

	        this.createResource();
	    },

	    createResource: function ()
	    {
	        if (this.program.webGLProgram === null)
	        {
	            this.webGLUniformLocation = null;
	            return;
	        }

	        var gl = this.gl;

	        if (gl.isContextLost())
	        {

	            return;
	        }

	        this.webGLUniformLocation = gl.getUniformLocation(this.program.webGLProgram, this.name);
	    },

	    destroy: function ()
	    {
	        this.gl = null;
	        this.program = null;
	        this.name = null;
	        this.webGLUniformLocation = null;
	    }
	});

	WebGLUniformLocationWrapper_1 = WebGLUniformLocationWrapper;
	return WebGLUniformLocationWrapper_1;
}

var WebGLRenderer_1;
var hasRequiredWebGLRenderer;

function requireWebGLRenderer () {
	if (hasRequiredWebGLRenderer) return WebGLRenderer_1;
	hasRequiredWebGLRenderer = 1;
	var ArrayEach = requireEach();
	var ArrayRemove = requireRemove();
	var CameraEvents = requireEvents$f();
	var Class = requireClass();
	var CONST = require_const$f();
	var EventEmitter = requireEventemitter3();
	var Events = requireEvents$d();
	var IsSizePowerOfTwo = requireIsSizePowerOfTwo();
	var Matrix4 = requireMatrix4();
	var NOOP = requireNOOP();
	var PipelineManager = requirePipelineManager();
	var RenderTarget = requireRenderTarget();
	var ScaleEvents = requireEvents$e();
	var TextureEvents = requireEvents$c();
	var Utils = requireUtils$1();
	var WebGLSnapshot = requireWebGLSnapshot();
	var WebGLBufferWrapper = requireWebGLBufferWrapper();
	var WebGLProgramWrapper = requireWebGLProgramWrapper();
	var WebGLTextureWrapper = requireWebGLTextureWrapper();
	var WebGLFramebufferWrapper = requireWebGLFramebufferWrapper();
	var WebGLAttribLocationWrapper = requireWebGLAttribLocationWrapper();
	var WebGLUniformLocationWrapper = requireWebGLUniformLocationWrapper();

	var WebGLRenderer = new Class({

	    Extends: EventEmitter,

	    initialize:

	    function WebGLRenderer (game)
	    {
	        EventEmitter.call(this);

	        var gameConfig = game.config;

	        var contextCreationConfig = {
	            alpha: gameConfig.transparent,
	            desynchronized: gameConfig.desynchronized,
	            depth: true,
	            antialias: gameConfig.antialiasGL,
	            premultipliedAlpha: gameConfig.premultipliedAlpha,
	            stencil: true,
	            failIfMajorPerformanceCaveat: gameConfig.failIfMajorPerformanceCaveat,
	            powerPreference: gameConfig.powerPreference,
	            preserveDrawingBuffer: gameConfig.preserveDrawingBuffer,
	            willReadFrequently: false
	        };

	        this.config = {
	            clearBeforeRender: gameConfig.clearBeforeRender,
	            antialias: gameConfig.antialias,
	            backgroundColor: gameConfig.backgroundColor,
	            contextCreation: contextCreationConfig,
	            roundPixels: gameConfig.roundPixels,
	            maxTextures: gameConfig.maxTextures,
	            maxTextureSize: gameConfig.maxTextureSize,
	            batchSize: gameConfig.batchSize,
	            maxLights: gameConfig.maxLights,
	            mipmapFilter: gameConfig.mipmapFilter
	        };

	        this.game = game;

	        this.type = CONST.WEBGL;

	        this.pipelines = null;

	        this.width = 0;

	        this.height = 0;

	        this.canvas = game.canvas;

	        this.blendModes = [];

	        this.contextLost = false;

	        this.snapshotState = {
	            x: 0,
	            y: 0,
	            width: 1,
	            height: 1,
	            getPixel: false,
	            callback: null,
	            type: 'image/png',
	            encoder: 0.92,
	            isFramebuffer: false,
	            bufferWidth: 0,
	            bufferHeight: 0
	        };

	        this.maxTextures = 0;

	        this.textureIndexes;

	        this.glBufferWrappers = [];

	        this.glProgramWrappers = [];

	        this.glTextureWrappers = [];

	        this.glFramebufferWrappers = [];

	        this.glAttribLocationWrappers = [];

	        this.glUniformLocationWrappers = [];

	        this.currentFramebuffer = null;

	        this.fboStack = [];

	        this.currentProgram = null;

	        this.currentBlendMode = Infinity;

	        this.currentScissorEnabled = false;

	        this.currentScissor = null;

	        this.scissorStack = [];

	        this.contextLostHandler = NOOP;

	        this.contextRestoredHandler = NOOP;

	        this.previousContextLostHandler = NOOP;

	        this.previousContextRestoredHandler = NOOP;

	        this.gl = null;

	        this.supportedExtensions = null;

	        this.instancedArraysExtension = null;

	        this.vaoExtension = null;

	        this.extensions = {};

	        this.glFormats;

	        this.compression;

	        this.drawingBufferHeight = 0;

	        this.blankTexture = null;

	        this.normalTexture = null;

	        this.whiteTexture = null;

	        this.maskCount = 0;

	        this.maskStack = [];

	        this.currentMask = { mask: null, camera: null };

	        this.currentCameraMask = { mask: null, camera: null };

	        this.glFuncMap = null;

	        this.currentType = '';

	        this.newType = false;

	        this.nextTypeMatch = false;

	        this.finalType = false;

	        this.mipmapFilter = null;

	        this.defaultScissor = [ 0, 0, 0, 0 ];

	        this.isBooted = false;

	        this.renderTarget = null;

	        this.projectionMatrix;

	        this.projectionWidth = 0;

	        this.projectionHeight = 0;

	        this.maskSource = null;

	        this.maskTarget = null;

	        this.spector = null;

	        this._debugCapture = false;

	        this.init(this.config);
	    },

	    init: function (config)
	    {
	        var gl;
	        var game = this.game;
	        var canvas = this.canvas;
	        var clearColor = config.backgroundColor;

	        if (game.config.context)
	        {
	            gl = game.config.context;
	        }
	        else
	        {
	            gl = canvas.getContext('webgl', config.contextCreation) || canvas.getContext('experimental-webgl', config.contextCreation);
	        }

	        if (!gl || gl.isContextLost())
	        {
	            this.contextLost = true;

	            throw new Error('WebGL unsupported');
	        }

	        this.gl = gl;

	        this.setExtensions();

	        this.setContextHandlers();

	        game.context = gl;

	        for (var i = 0; i <= 27; i++)
	        {
	            this.blendModes.push({ func: [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ], equation: gl.FUNC_ADD });
	        }

	        this.blendModes[1].func = [ gl.ONE, gl.DST_ALPHA ];

	        this.blendModes[2].func = [ gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA ];

	        this.blendModes[3].func = [ gl.ONE, gl.ONE_MINUS_SRC_COLOR ];

	        this.blendModes[17] = { func: [ gl.ZERO, gl.ONE_MINUS_SRC_ALPHA ], equation: gl.FUNC_REVERSE_SUBTRACT };

	        this.glFormats = [ gl.BYTE, gl.SHORT, gl.UNSIGNED_BYTE, gl.UNSIGNED_SHORT, gl.FLOAT ];

	        this.glFuncMap = {

	            mat2: { func: gl.uniformMatrix2fv, length: 1, matrix: true },
	            mat3: { func: gl.uniformMatrix3fv, length: 1, matrix: true },
	            mat4: { func: gl.uniformMatrix4fv, length: 1, matrix: true },

	            '1f': { func: gl.uniform1f, length: 1 },
	            '1fv': { func: gl.uniform1fv, length: 1 },
	            '1i': { func: gl.uniform1i, length: 1 },
	            '1iv': { func: gl.uniform1iv, length: 1 },

	            '2f': { func: gl.uniform2f, length: 2 },
	            '2fv': { func: gl.uniform2fv, length: 1 },
	            '2i': { func: gl.uniform2i, length: 2 },
	            '2iv': { func: gl.uniform2iv, length: 1 },

	            '3f': { func: gl.uniform3f, length: 3 },
	            '3fv': { func: gl.uniform3fv, length: 1 },
	            '3i': { func: gl.uniform3i, length: 3 },
	            '3iv': { func: gl.uniform3iv, length: 1 },

	            '4f': { func: gl.uniform4f, length: 4 },
	            '4fv': { func: gl.uniform4fv, length: 1 },
	            '4i': { func: gl.uniform4i, length: 4 },
	            '4iv': { func: gl.uniform4iv, length: 1 }

	        };

	        if (!config.maxTextures || config.maxTextures === -1)
	        {
	            config.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
	        }

	        if (!config.maxTextureSize)
	        {
	            config.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
	        }

	        this.compression = this.getCompressedTextures();

	        gl.disable(gl.DEPTH_TEST);
	        gl.disable(gl.CULL_FACE);

	        gl.enable(gl.BLEND);

	        gl.clearColor(clearColor.redGL, clearColor.greenGL, clearColor.blueGL, clearColor.alphaGL);
	        gl.clear(gl.COLOR_BUFFER_BIT);

	        var validMipMaps = [ 'NEAREST', 'LINEAR', 'NEAREST_MIPMAP_NEAREST', 'LINEAR_MIPMAP_NEAREST', 'NEAREST_MIPMAP_LINEAR', 'LINEAR_MIPMAP_LINEAR' ];

	        if (validMipMaps.indexOf(config.mipmapFilter) !== -1)
	        {
	            this.mipmapFilter = gl[config.mipmapFilter];
	        }

	        this.maxTextures = Utils.checkShaderMax(gl, config.maxTextures);

	        this.textureIndexes = [];

	        this.createTemporaryTextures();

	        this.pipelines = new PipelineManager(this);

	        this.setBlendMode(CONST.BlendModes.NORMAL);

	        this.projectionMatrix = new Matrix4().identity();

	        game.textures.once(TextureEvents.READY, this.boot, this);

	        return this;
	    },

	    boot: function ()
	    {
	        var game = this.game;
	        var pipelineManager = this.pipelines;

	        var baseSize = game.scale.baseSize;

	        var width = baseSize.width;
	        var height = baseSize.height;

	        this.width = width;
	        this.height = height;

	        this.isBooted = true;

	        this.renderTarget = new RenderTarget(this, width, height, 1, 0, true, true);

	        this.maskTarget = new RenderTarget(this, width, height, 1, 0, true, true);
	        this.maskSource = new RenderTarget(this, width, height, 1, 0, true, true);

	        var config = game.config;

	        pipelineManager.boot(config.pipeline, config.defaultPipeline, config.autoMobilePipeline);

	        this.blankTexture = game.textures.getFrame('__DEFAULT').glTexture;
	        this.normalTexture = game.textures.getFrame('__NORMAL').glTexture;
	        this.whiteTexture = game.textures.getFrame('__WHITE').glTexture;

	        var gl = this.gl;

	        gl.bindFramebuffer(gl.FRAMEBUFFER, null);

	        gl.enable(gl.SCISSOR_TEST);

	        game.scale.on(ScaleEvents.RESIZE, this.onResize, this);

	        this.resize(width, height);
	    },

	    setExtensions: function ()
	    {
	        var gl = this.gl;

	        var exts = gl.getSupportedExtensions();

	        this.supportedExtensions = exts;

	        var angleString = 'ANGLE_instanced_arrays';

	        this.instancedArraysExtension = (exts.indexOf(angleString) > -1) ? gl.getExtension(angleString) : null;

	        var vaoString = 'OES_vertex_array_object';

	        this.vaoExtension = (exts.indexOf(vaoString) > -1) ? gl.getExtension(vaoString) : null;
	    },

	    setContextHandlers: function (contextLost, contextRestored)
	    {
	        if (this.previousContextLostHandler)
	        {
	            this.canvas.removeEventListener('webglcontextlost', this.previousContextLostHandler, false);
	        }
	        if (this.previousContextRestoredHandler)
	        {
	            this.canvas.removeEventListener('webglcontextlost', this.previousContextRestoredHandler, false);
	        }

	        if (typeof contextLost === 'function')
	        {
	            this.contextLostHandler = contextLost.bind(this);
	        }
	        else
	        {
	            this.contextLostHandler = this.dispatchContextLost.bind(this);
	        }

	        if (typeof contextRestored === 'function')
	        {
	            this.contextRestoredHandler = contextRestored.bind(this);
	        }
	        else
	        {
	            this.contextRestoredHandler = this.dispatchContextRestored.bind(this);
	        }

	        this.canvas.addEventListener('webglcontextlost', this.contextLostHandler, false);
	        this.canvas.addEventListener('webglcontextrestored', this.contextRestoredHandler, false);

	        this.previousContextLostHandler = this.contextLostHandler;
	        this.previousContextRestoredHandler = this.contextRestoredHandler;
	    },

	    dispatchContextLost: function (event)
	    {
	        this.contextLost = true;

	        if (console)
	        {
	            console.warn('WebGL Context lost. Renderer disabled');
	        }

	        this.emit(Events.LOSE_WEBGL, this);

	        event.preventDefault();
	    },

	    dispatchContextRestored: function (event)
	    {
	        var gl = this.gl;

	        if (gl.isContextLost())
	        {
	            if (console)
	            {
	                console.log('WebGL Context restored, but context is still lost');
	            }

	            return;
	        }

	        this.currentProgram = null;
	        this.currentFramebuffer = null;
	        this.setBlendMode(CONST.BlendModes.NORMAL);

	        gl.disable(gl.BLEND);
	        gl.disable(gl.DEPTH_TEST);
	        gl.enable(gl.CULL_FACE);

	        this.compression = this.getCompressedTextures();

	        var wrapperCreateResource = function (wrapper)
	        {
	            wrapper.createResource();
	        };

	        ArrayEach(this.glTextureWrappers, wrapperCreateResource);
	        ArrayEach(this.glBufferWrappers, wrapperCreateResource);
	        ArrayEach(this.glFramebufferWrappers, wrapperCreateResource);
	        ArrayEach(this.glProgramWrappers, wrapperCreateResource);
	        ArrayEach(this.glAttribLocationWrappers, wrapperCreateResource);
	        ArrayEach(this.glUniformLocationWrappers, wrapperCreateResource);

	        this.createTemporaryTextures();

	        this.pipelines.restoreContext();

	        this.resize(this.game.scale.baseSize.width, this.game.scale.baseSize.height);

	        this.setExtensions();

	        this.contextLost = false;

	        if (console)
	        {
	            console.warn('WebGL Context restored. Renderer running again.');
	        }

	        this.emit(Events.RESTORE_WEBGL, this);

	        event.preventDefault();
	    },

	    createTemporaryTextures: function ()
	    {
	        var gl = this.gl;

	        for (var index = 0; index < this.maxTextures; index++)
	        {
	            var tempTexture = gl.createTexture();

	            gl.activeTexture(gl.TEXTURE0 + index);

	            gl.bindTexture(gl.TEXTURE_2D, tempTexture);

	            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([ 0, 0, 255, 255 ]));

	            this.textureIndexes.push(index);
	        }
	    },

	    captureFrame: function (quickCapture, fullCapture)
	    {
	    },

	    captureNextFrame: function ()
	    {
	    },

	    getFps: function ()
	    {
	    },

	    log: function ()
	    {
	    },

	    startCapture: function (commandCount, quickCapture, fullCapture)
	    {
	    },

	    stopCapture: function ()
	    {
	    },

	    onCapture: function (capture)
	    {
	    },

	    onResize: function (gameSize, baseSize)
	    {

	        if (baseSize.width !== this.width || baseSize.height !== this.height)
	        {
	            this.resize(baseSize.width, baseSize.height);
	        }
	    },

	    beginCapture: function (width, height)
	    {
	        if (width === undefined) { width = this.width; }
	        if (height === undefined) { height = this.height; }

	        this.renderTarget.bind(true, width, height);

	        this.setProjectionMatrix(width, height);
	    },

	    endCapture: function ()
	    {
	        this.renderTarget.unbind(true);

	        this.resetProjectionMatrix();

	        return this.renderTarget;
	    },

	    resize: function (width, height)
	    {
	        var gl = this.gl;

	        this.width = width;
	        this.height = height;

	        this.setProjectionMatrix(width, height);

	        gl.viewport(0, 0, width, height);

	        this.drawingBufferHeight = gl.drawingBufferHeight;

	        gl.scissor(0, (gl.drawingBufferHeight - height), width, height);

	        this.defaultScissor[2] = width;
	        this.defaultScissor[3] = height;

	        this.emit(Events.RESIZE, width, height);

	        return this;
	    },

	    getCompressedTextures: function ()
	    {
	        var extString = 'WEBGL_compressed_texture_';
	        var wkExtString = 'WEBKIT_' + extString;
	        var extEXTString = 'EXT_texture_compression_';

	        var hasExt = function (gl, format)
	        {
	            var results = gl.getExtension(extString + format) || gl.getExtension(wkExtString + format) || gl.getExtension(extEXTString + format);

	            if (results)
	            {
	                var glEnums = {};

	                for (var key in results)
	                {
	                    glEnums[results[key]] = key;
	                }

	                return glEnums;
	            }
	        };

	        var gl = this.gl;

	        return {
	            ETC: hasExt(gl, 'etc'),
	            ETC1: hasExt(gl, 'etc1'),
	            ATC: hasExt(gl, 'atc'),
	            ASTC: hasExt(gl, 'astc'),
	            BPTC: hasExt(gl, 'bptc'),
	            RGTC: hasExt(gl, 'rgtc'),
	            PVRTC: hasExt(gl, 'pvrtc'),
	            S3TC: hasExt(gl, 's3tc'),
	            S3TCSRGB: hasExt(gl, 's3tc_srgb'),
	            IMG: true
	        };
	    },

	    getCompressedTextureName: function (baseFormat, format)
	    {
	        var supportedFormats = this.compression[baseFormat.toUpperCase()];

	        if (format in supportedFormats)
	        {
	            return supportedFormats[format];
	        }
	    },

	    supportsCompressedTexture: function (baseFormat, format)
	    {
	        var supportedFormats = this.compression[baseFormat.toUpperCase()];

	        if (supportedFormats)
	        {
	            if (format)
	            {
	                return format in supportedFormats;
	            }
	            else
	            {
	                return true;
	            }
	        }

	        return false;
	    },

	    getAspectRatio: function ()
	    {
	        return this.width / this.height;
	    },

	    setProjectionMatrix: function (width, height)
	    {
	        if (width !== this.projectionWidth || height !== this.projectionHeight)
	        {
	            this.projectionWidth = width;
	            this.projectionHeight = height;

	            this.projectionMatrix.ortho(0, width, height, 0, -1000, 1000);
	        }

	        return this;
	    },

	    resetProjectionMatrix: function ()
	    {
	        return this.setProjectionMatrix(this.width, this.height);
	    },

	    hasExtension: function (extensionName)
	    {
	        return this.supportedExtensions ? this.supportedExtensions.indexOf(extensionName) : false;
	    },

	    getExtension: function (extensionName)
	    {
	        if (!this.hasExtension(extensionName)) { return null; }

	        if (!(extensionName in this.extensions))
	        {
	            this.extensions[extensionName] = this.gl.getExtension(extensionName);
	        }

	        return this.extensions[extensionName];
	    },

	    flush: function ()
	    {
	        this.pipelines.flush();
	    },

	    pushScissor: function (x, y, width, height, drawingBufferHeight)
	    {
	        if (drawingBufferHeight === undefined) { drawingBufferHeight = this.drawingBufferHeight; }

	        var scissorStack = this.scissorStack;

	        var scissor = [ x, y, width, height ];

	        scissorStack.push(scissor);

	        this.setScissor(x, y, width, height, drawingBufferHeight);

	        this.currentScissor = scissor;

	        return scissor;
	    },

	    setScissor: function (x, y, width, height, drawingBufferHeight)
	    {
	        if (drawingBufferHeight === undefined) { drawingBufferHeight = this.drawingBufferHeight; }

	        var gl = this.gl;

	        var current = this.currentScissor;

	        var setScissor = (width > 0 && height > 0);

	        if (current && setScissor)
	        {
	            var cx = current[0];
	            var cy = current[1];
	            var cw = current[2];
	            var ch = current[3];

	            setScissor = (cx !== x || cy !== y || cw !== width || ch !== height);
	        }

	        if (setScissor)
	        {
	            this.flush();

	            gl.scissor(x, (drawingBufferHeight - y - height), width, height);
	        }
	    },

	    resetScissor: function ()
	    {
	        var gl = this.gl;

	        gl.enable(gl.SCISSOR_TEST);

	        var current = this.currentScissor;

	        if (current)
	        {
	            var x = current[0];
	            var y = current[1];
	            var width = current[2];
	            var height = current[3];

	            if (width > 0 && height > 0)
	            {
	                gl.scissor(x, (this.drawingBufferHeight - y - height), width, height);
	            }
	        }
	    },

	    popScissor: function ()
	    {
	        var scissorStack = this.scissorStack;

	        scissorStack.pop();

	        var scissor = scissorStack[scissorStack.length - 1];

	        if (scissor)
	        {
	            this.setScissor(scissor[0], scissor[1], scissor[2], scissor[3]);
	        }

	        this.currentScissor = scissor;
	    },

	    hasActiveStencilMask: function ()
	    {
	        var mask = this.currentMask.mask;
	        var camMask = this.currentCameraMask.mask;

	        return ((mask && mask.isStencil) || (camMask && camMask.isStencil));
	    },

	    resetViewport: function ()
	    {
	        var gl = this.gl;

	        gl.viewport(0, 0, this.width, this.height);

	        this.drawingBufferHeight = gl.drawingBufferHeight;
	    },

	    setBlendMode: function (blendModeId, force)
	    {
	        if (force === undefined) { force = false; }

	        var gl = this.gl;
	        var blendMode = this.blendModes[blendModeId];

	        if (force || (blendModeId !== CONST.BlendModes.SKIP_CHECK && this.currentBlendMode !== blendModeId))
	        {
	            this.flush();

	            gl.enable(gl.BLEND);
	            gl.blendEquation(blendMode.equation);

	            if (blendMode.func.length > 2)
	            {
	                gl.blendFuncSeparate(blendMode.func[0], blendMode.func[1], blendMode.func[2], blendMode.func[3]);
	            }
	            else
	            {
	                gl.blendFunc(blendMode.func[0], blendMode.func[1]);
	            }

	            this.currentBlendMode = blendModeId;

	            return true;
	        }

	        return false;
	    },

	    addBlendMode: function (func, equation)
	    {
	        var index = this.blendModes.push({ func: func, equation: equation });

	        return index - 1;
	    },

	    updateBlendMode: function (index, func, equation)
	    {
	        if (this.blendModes[index])
	        {
	            this.blendModes[index].func = func;

	            if (equation)
	            {
	                this.blendModes[index].equation = equation;
	            }
	        }

	        return this;
	    },

	    removeBlendMode: function (index)
	    {
	        if (index > 17 && this.blendModes[index])
	        {
	            this.blendModes.splice(index, 1);
	        }

	        return this;
	    },

	    pushFramebuffer: function (framebuffer, updateScissor, setViewport, texture, clear)
	    {
	        if (framebuffer === this.currentFramebuffer)
	        {
	            return this;
	        }

	        this.fboStack.push(framebuffer);

	        return this.setFramebuffer(framebuffer, updateScissor, setViewport, texture, clear);
	    },

	    setFramebuffer: function (framebuffer, updateScissor, setViewport, texture, clear)
	    {
	        if (updateScissor === undefined) { updateScissor = false; }
	        if (setViewport === undefined) { setViewport = true; }
	        if (texture === undefined) { texture = null; }
	        if (clear === undefined) { clear = false; }

	        if (framebuffer === this.currentFramebuffer)
	        {
	            return this;
	        }

	        var gl = this.gl;

	        var width = this.width;
	        var height = this.height;

	        if (framebuffer && framebuffer.renderTexture && setViewport)
	        {
	            width = framebuffer.renderTexture.width;
	            height = framebuffer.renderTexture.height;
	        }
	        else
	        {
	            this.flush();
	        }

	        if (framebuffer)
	        {
	            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer.webGLFramebuffer);
	        }
	        else
	        {
	            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
	        }

	        if (setViewport)
	        {
	            gl.viewport(0, 0, width, height);
	        }

	        if (texture)
	        {
	            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture.webGLTexture, 0);
	        }

	        if (clear)
	        {
	            gl.clearColor(0, 0, 0, 0);
	            gl.clear(gl.COLOR_BUFFER_BIT);
	        }

	        if (updateScissor)
	        {
	            if (framebuffer)
	            {
	                this.drawingBufferHeight = height;

	                this.pushScissor(0, 0, width, height);
	            }
	            else
	            {
	                this.drawingBufferHeight = this.height;

	                this.popScissor();
	            }
	        }

	        this.currentFramebuffer = framebuffer;

	        return this;
	    },

	    popFramebuffer: function (updateScissor, setViewport)
	    {
	        if (updateScissor === undefined) { updateScissor = false; }
	        if (setViewport === undefined) { setViewport = true; }

	        var fboStack = this.fboStack;

	        fboStack.pop();

	        var framebuffer = fboStack[fboStack.length - 1];

	        if (!framebuffer)
	        {
	            framebuffer = null;
	        }

	        this.setFramebuffer(framebuffer, updateScissor, setViewport);

	        return framebuffer;
	    },

	    restoreFramebuffer: function (updateScissor, setViewport)
	    {
	        if (updateScissor === undefined) { updateScissor = false; }
	        if (setViewport === undefined) { setViewport = true; }

	        var fboStack = this.fboStack;

	        var framebuffer = fboStack[fboStack.length - 1];

	        if (!framebuffer)
	        {
	            framebuffer = null;
	        }

	        this.currentFramebuffer = null;

	        this.setFramebuffer(framebuffer, updateScissor, setViewport);
	    },

	    setProgram: function (program)
	    {
	        if (program !== this.currentProgram)
	        {
	            this.flush();

	            this.gl.useProgram(program.webGLProgram);

	            this.currentProgram = program;

	            return true;
	        }

	        return false;
	    },

	    resetProgram: function ()
	    {
	        this.gl.useProgram(this.currentProgram.webGLProgramWrapper);

	        return this;
	    },

	    createTextureFromSource: function (source, width, height, scaleMode, forceClamp)
	    {
	        if (forceClamp === undefined) { forceClamp = false; }

	        var gl = this.gl;
	        var minFilter = gl.NEAREST;
	        var magFilter = gl.NEAREST;
	        var wrap = gl.CLAMP_TO_EDGE;
	        var texture = null;

	        width = source ? source.width : width;
	        height = source ? source.height : height;

	        var pow = IsSizePowerOfTwo(width, height);

	        if (pow && !forceClamp)
	        {
	            wrap = gl.REPEAT;
	        }

	        if (scaleMode === CONST.ScaleModes.LINEAR && this.config.antialias)
	        {
	            var isCompressed = source && source.compressed;
	            var isMip = (!isCompressed && pow) || (isCompressed && source.mipmaps.length > 1);

	            minFilter = (this.mipmapFilter && isMip) ? this.mipmapFilter : gl.LINEAR;
	            magFilter = gl.LINEAR;
	        }

	        if (!source && typeof width === 'number' && typeof height === 'number')
	        {
	            texture = this.createTexture2D(0, minFilter, magFilter, wrap, wrap, gl.RGBA, null, width, height);
	        }
	        else
	        {
	            texture = this.createTexture2D(0, minFilter, magFilter, wrap, wrap, gl.RGBA, source);
	        }

	        return texture;
	    },

	    createTexture2D: function (mipLevel, minFilter, magFilter, wrapT, wrapS, format, pixels, width, height, pma, forceSize, flipY)
	    {
	        if (typeof width !== 'number') { width = pixels ? pixels.width : 1; }
	        if (typeof height !== 'number') { height = pixels ? pixels.height : 1; }

	        var texture = new WebGLTextureWrapper(this.gl, mipLevel, minFilter, magFilter, wrapT, wrapS, format, pixels, width, height, pma, forceSize, flipY);

	        this.glTextureWrappers.push(texture);

	        return texture;
	    },

	    createFramebuffer: function (width, height, renderTexture, addDepthStencilBuffer)
	    {
	        this.currentFramebuffer = null;
	        var framebuffer = new WebGLFramebufferWrapper(this.gl, width, height, renderTexture, addDepthStencilBuffer);

	        this.glFramebufferWrappers.push(framebuffer);

	        return framebuffer;
	    },

	    beginBitmapMask: function (bitmapMask, camera)
	    {
	        var gl = this.gl;

	        if (gl)
	        {
	            this.flush();

	            this.maskTarget.bind(true);

	            if (this.currentCameraMask.mask !== bitmapMask)
	            {
	                this.currentMask.mask = bitmapMask;
	                this.currentMask.camera = camera;
	            }
	        }
	    },

	    drawBitmapMask: function (bitmapMask, camera, bitmapMaskPipeline)
	    {

	        this.flush();

	        this.maskSource.bind();

	        this.setBlendMode(0, true);

	        bitmapMask.renderWebGL(this, bitmapMask, camera);

	        this.maskSource.unbind(true);
	        this.maskTarget.unbind();

	        var gl = this.gl;
	        var prev = this.getCurrentStencilMask();

	        if (prev)
	        {
	            gl.enable(gl.STENCIL_TEST);

	            prev.mask.applyStencil(this, prev.camera, true);
	        }
	        else
	        {
	            this.currentMask.mask = null;
	        }

	        this.pipelines.set(bitmapMaskPipeline);

	        gl.activeTexture(gl.TEXTURE0);
	        gl.bindTexture(gl.TEXTURE_2D, this.maskTarget.texture.webGLTexture);

	        gl.activeTexture(gl.TEXTURE1);
	        gl.bindTexture(gl.TEXTURE_2D, this.maskSource.texture.webGLTexture);
	    },

	    createProgram: function (vertexShader, fragmentShader)
	    {
	        var wrapper = new WebGLProgramWrapper(this.gl, vertexShader, fragmentShader);
	        this.glProgramWrappers.push(wrapper);
	        return wrapper;
	    },

	    createVertexBuffer: function (initialDataOrSize, bufferUsage)
	    {
	        var gl = this.gl;
	        var vertexBuffer = new WebGLBufferWrapper(gl, initialDataOrSize, gl.ARRAY_BUFFER, bufferUsage);
	        this.glBufferWrappers.push(vertexBuffer);
	        return vertexBuffer;
	    },

	    createAttribLocation: function (program, name)
	    {
	        var attrib = new WebGLAttribLocationWrapper(this.gl, program, name);
	        this.glAttribLocationWrappers.push(attrib);
	        return attrib;
	    },

	    createUniformLocation: function (program, name)
	    {
	        var uniform = new WebGLUniformLocationWrapper(this.gl, program, name);
	        this.glUniformLocationWrappers.push(uniform);
	        return uniform;
	    },

	    createIndexBuffer: function (initialDataOrSize, bufferUsage)
	    {
	        var gl = this.gl;
	        var indexBuffer = new WebGLBufferWrapper(gl, initialDataOrSize, gl.ELEMENT_ARRAY_BUFFER, bufferUsage);
	        this.glBufferWrappers.push(indexBuffer);
	        return indexBuffer;
	    },

	    deleteTexture: function (texture)
	    {
	        if (!texture)
	        {
	            return;
	        }
	        ArrayRemove(this.glTextureWrappers, texture);
	        texture.destroy();
	        return this;
	    },

	    deleteFramebuffer: function (framebuffer)
	    {
	        if (!framebuffer)
	        {
	            return this;
	        }
	        ArrayRemove(this.fboStack, framebuffer);
	        ArrayRemove(this.glFramebufferWrappers, framebuffer);
	        framebuffer.destroy();
	        return this;
	    },

	    deleteProgram: function (program)
	    {
	        if (program)
	        {
	            ArrayRemove(this.glProgramWrappers, program);
	            program.destroy();
	        }

	        return this;
	    },

	    deleteAttribLocation: function (attrib)
	    {
	        if (attrib)
	        {
	            ArrayRemove(this.glAttribLocationWrappers, attrib);
	            attrib.destroy();
	        }

	        return this;
	    },

	    deleteUniformLocation: function (uniform)
	    {
	        if (uniform)
	        {
	            ArrayRemove(this.glUniformLocationWrappers, uniform);
	            uniform.destroy();
	        }

	        return this;
	    },

	    deleteBuffer: function (buffer)
	    {
	        if (!buffer) { return this; }
	        ArrayRemove(this.glBufferWrappers, buffer);
	        buffer.destroy();
	        return this;
	    },

	    preRenderCamera: function (camera)
	    {
	        var cx = camera.x;
	        var cy = camera.y;
	        var cw = camera.width;
	        var ch = camera.height;

	        var color = camera.backgroundColor;

	        camera.emit(CameraEvents.PRE_RENDER, camera);

	        this.pipelines.preBatchCamera(camera);

	        this.pushScissor(cx, cy, cw, ch);

	        if (camera.mask)
	        {
	            this.currentCameraMask.mask = camera.mask;
	            this.currentCameraMask.camera = camera._maskCamera;

	            camera.mask.preRenderWebGL(this, camera, camera._maskCamera);
	        }

	        if (color.alphaGL > 0)
	        {
	            var pipeline = this.pipelines.setMulti();

	            pipeline.drawFillRect(
	                cx, cy, cw, ch,
	                Utils.getTintFromFloats(color.blueGL, color.greenGL, color.redGL, 1),
	                color.alphaGL
	            );
	        }
	    },

	    getCurrentStencilMask: function ()
	    {
	        var prev = null;
	        var stack = this.maskStack;
	        var cameraMask = this.currentCameraMask;

	        if (stack.length > 0)
	        {
	            prev = stack[stack.length - 1];
	        }
	        else if (cameraMask.mask && cameraMask.mask.isStencil)
	        {
	            prev = cameraMask;
	        }

	        return prev;
	    },

	    postRenderCamera: function (camera)
	    {
	        var flashEffect = camera.flashEffect;
	        var fadeEffect = camera.fadeEffect;

	        if (flashEffect.isRunning || (fadeEffect.isRunning || fadeEffect.isComplete))
	        {
	            var pipeline = this.pipelines.setMulti();

	            flashEffect.postRenderWebGL(pipeline, Utils.getTintFromFloats);
	            fadeEffect.postRenderWebGL(pipeline, Utils.getTintFromFloats);
	        }

	        camera.dirty = false;

	        this.popScissor();

	        if (camera.mask)
	        {
	            this.currentCameraMask.mask = null;

	            camera.mask.postRenderWebGL(this, camera._maskCamera);
	        }

	        this.pipelines.postBatchCamera(camera);

	        camera.emit(CameraEvents.POST_RENDER, camera);
	    },

	    preRender: function ()
	    {
	        if (this.contextLost) { return; }

	        var gl = this.gl;

	        gl.bindFramebuffer(gl.FRAMEBUFFER, null);

	        this.emit(Events.PRE_RENDER_CLEAR);

	        if (this.config.clearBeforeRender)
	        {
	            var clearColor = this.config.backgroundColor;

	            gl.clearColor(clearColor.redGL, clearColor.greenGL, clearColor.blueGL, clearColor.alphaGL);

	            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
	        }

	        gl.enable(gl.SCISSOR_TEST);

	        this.currentScissor = this.defaultScissor;

	        this.scissorStack.length = 0;
	        this.scissorStack.push(this.currentScissor);

	        if (this.game.scene.customViewports)
	        {
	            gl.scissor(0, (this.drawingBufferHeight - this.height), this.width, this.height);
	        }

	        this.currentMask.mask = null;
	        this.currentCameraMask.mask = null;
	        this.maskStack.length = 0;

	        this.emit(Events.PRE_RENDER);
	    },

	    render: function (scene, children, camera)
	    {
	        if (this.contextLost) { return; }

	        var childCount = children.length;

	        this.emit(Events.RENDER, scene, camera);

	        this.preRenderCamera(camera);

	        if (childCount === 0)
	        {
	            this.setBlendMode(CONST.BlendModes.NORMAL);

	            this.postRenderCamera(camera);

	            return;
	        }

	        this.currentType = '';

	        var current = this.currentMask;

	        for (var i = 0; i < childCount; i++)
	        {
	            this.finalType = (i === childCount - 1);

	            var child = children[i];

	            var mask = child.mask;

	            current = this.currentMask;

	            if (current.mask && current.mask !== mask)
	            {

	                current.mask.postRenderWebGL(this, current.camera);
	            }

	            if (mask && current.mask !== mask)
	            {
	                mask.preRenderWebGL(this, child, camera);
	            }

	            if (child.blendMode !== this.currentBlendMode)
	            {
	                this.setBlendMode(child.blendMode);
	            }

	            var type = child.type;

	            if (type !== this.currentType)
	            {
	                this.newType = true;
	                this.currentType = type;
	            }

	            if (!this.finalType)
	            {
	                this.nextTypeMatch = (children[i + 1].type === this.currentType);
	            }
	            else
	            {
	                this.nextTypeMatch = false;
	            }

	            child.renderWebGL(this, child, camera);

	            this.newType = false;
	        }

	        current = this.currentMask;

	        if (current.mask)
	        {

	            current.mask.postRenderWebGL(this, current.camera);
	        }

	        this.setBlendMode(CONST.BlendModes.NORMAL);

	        this.postRenderCamera(camera);
	    },

	    postRender: function ()
	    {
	        if (this.contextLost) { return; }

	        this.flush();

	        this.emit(Events.POST_RENDER);

	        var state = this.snapshotState;

	        if (state.callback)
	        {
	            WebGLSnapshot(this.gl, state);

	            state.callback = null;
	        }
	    },

	    clearStencilMask: function ()
	    {
	        this.gl.disable(this.gl.STENCIL_TEST);
	    },

	    restoreStencilMask: function ()
	    {
	        var gl = this.gl;

	        var current = this.getCurrentStencilMask();

	        if (current)
	        {
	            var mask = current.mask;

	            gl.enable(gl.STENCIL_TEST);

	            if (mask.invertAlpha)
	            {
	                gl.stencilFunc(gl.NOTEQUAL, mask.level, 0xff);
	            }
	            else
	            {
	                gl.stencilFunc(gl.EQUAL, mask.level, 0xff);
	            }
	        }
	    },

	    snapshot: function (callback, type, encoderOptions)
	    {
	        return this.snapshotArea(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight, callback, type, encoderOptions);
	    },

	    snapshotArea: function (x, y, width, height, callback, type, encoderOptions)
	    {
	        var state = this.snapshotState;

	        state.callback = callback;
	        state.type = type;
	        state.encoder = encoderOptions;
	        state.getPixel = false;
	        state.x = x;
	        state.y = y;
	        state.width = width;
	        state.height = height;

	        return this;
	    },

	    snapshotPixel: function (x, y, callback)
	    {
	        this.snapshotArea(x, y, 1, 1, callback);

	        this.snapshotState.getPixel = true;

	        return this;
	    },

	    snapshotFramebuffer: function (framebuffer, bufferWidth, bufferHeight, callback, getPixel, x, y, width, height, type, encoderOptions)
	    {
	        if (getPixel === undefined) { getPixel = false; }
	        if (x === undefined) { x = 0; }
	        if (y === undefined) { y = 0; }
	        if (width === undefined) { width = bufferWidth; }
	        if (height === undefined) { height = bufferHeight; }

	        if (type === 'pixel')
	        {
	            getPixel = true;
	            type = 'image/png';
	        }

	        var currentFramebuffer = this.currentFramebuffer;

	        this.snapshotArea(x, y, width, height, callback, type, encoderOptions);

	        var state = this.snapshotState;

	        state.getPixel = getPixel;

	        state.isFramebuffer = true;
	        state.bufferWidth = bufferWidth;
	        state.bufferHeight = bufferHeight;

	        state.width = Math.min(state.width, bufferWidth);
	        state.height = Math.min(state.height, bufferHeight);

	        this.setFramebuffer(framebuffer);

	        WebGLSnapshot(this.gl, state);

	        this.setFramebuffer(currentFramebuffer);

	        state.callback = null;
	        state.isFramebuffer = false;

	        return this;
	    },

	    canvasToTexture: function (srcCanvas, dstTexture, noRepeat, flipY)
	    {
	        if (noRepeat === undefined) { noRepeat = false; }
	        if (flipY === undefined) { flipY = false; }

	        var gl = this.gl;
	        var minFilter = gl.NEAREST;
	        var magFilter = gl.NEAREST;

	        var width = srcCanvas.width;
	        var height = srcCanvas.height;

	        var wrapping = gl.CLAMP_TO_EDGE;

	        var pow = IsSizePowerOfTwo(width, height);

	        if (!noRepeat && pow)
	        {
	            wrapping = gl.REPEAT;
	        }

	        if (this.config.antialias)
	        {
	            minFilter = (pow && this.mipmapFilter) ? this.mipmapFilter : gl.LINEAR;
	            magFilter = gl.LINEAR;
	        }

	        if (!dstTexture)
	        {
	            return this.createTexture2D(0, minFilter, magFilter, wrapping, wrapping, gl.RGBA, srcCanvas, width, height, true, false, flipY);
	        }
	        else
	        {
	            dstTexture.update(srcCanvas, width, height, flipY, wrapping, wrapping, minFilter, magFilter, dstTexture.format);

	            return dstTexture;
	        }
	    },

	    createCanvasTexture: function (srcCanvas, noRepeat, flipY)
	    {
	        if (noRepeat === undefined) { noRepeat = false; }
	        if (flipY === undefined) { flipY = false; }

	        return this.canvasToTexture(srcCanvas, null, noRepeat, flipY);
	    },

	    updateCanvasTexture: function (srcCanvas, dstTexture, flipY, noRepeat)
	    {
	        if (flipY === undefined) { flipY = false; }
	        if (noRepeat === undefined) { noRepeat = false; }

	        return this.canvasToTexture(srcCanvas, dstTexture, noRepeat, flipY);
	    },

	    videoToTexture: function (srcVideo, dstTexture, noRepeat, flipY)
	    {
	        if (noRepeat === undefined) { noRepeat = false; }
	        if (flipY === undefined) { flipY = false; }

	        var gl = this.gl;
	        var minFilter = gl.NEAREST;
	        var magFilter = gl.NEAREST;

	        var width = srcVideo.videoWidth;
	        var height = srcVideo.videoHeight;

	        var wrapping = gl.CLAMP_TO_EDGE;

	        var pow = IsSizePowerOfTwo(width, height);

	        if (!noRepeat && pow)
	        {
	            wrapping = gl.REPEAT;
	        }

	        if (this.config.antialias)
	        {
	            minFilter = (pow && this.mipmapFilter) ? this.mipmapFilter : gl.LINEAR;
	            magFilter = gl.LINEAR;
	        }

	        if (!dstTexture)
	        {
	            return this.createTexture2D(0, minFilter, magFilter, wrapping, wrapping, gl.RGBA, srcVideo, width, height, true, true, flipY);
	        }
	        else
	        {
	            dstTexture.update(srcVideo, width, height, flipY, wrapping, wrapping, minFilter, magFilter, dstTexture.format);

	            return dstTexture;
	        }
	    },

	    createVideoTexture: function (srcVideo, noRepeat, flipY)
	    {
	        if (noRepeat === undefined) { noRepeat = false; }
	        if (flipY === undefined) { flipY = false; }

	        return this.videoToTexture(srcVideo, null, noRepeat, flipY);
	    },

	    updateVideoTexture: function (srcVideo, dstTexture, flipY, noRepeat)
	    {
	        if (flipY === undefined) { flipY = false; }
	        if (noRepeat === undefined) { noRepeat = false; }

	        return this.videoToTexture(srcVideo, dstTexture, noRepeat, flipY);
	    },

	    createUint8ArrayTexture: function (data, width, height)
	    {
	        var gl = this.gl;
	        var minFilter = gl.NEAREST;
	        var magFilter = gl.NEAREST;
	        var wrap = gl.CLAMP_TO_EDGE;

	        var pow = IsSizePowerOfTwo(width, height);

	        if (pow)
	        {
	            wrap = gl.REPEAT;
	        }

	        return this.createTexture2D(0, minFilter, magFilter, wrap, wrap, gl.RGBA, data, width, height);
	    },

	    setTextureFilter: function (texture, filter)
	    {
	        var gl = this.gl;

	        var glFilter = (filter === 0) ? gl.LINEAR : gl.NEAREST;

	        gl.activeTexture(gl.TEXTURE0);

	        var currentTexture = gl.getParameter(gl.TEXTURE_BINDING_2D);

	        gl.bindTexture(gl.TEXTURE_2D, texture.webGLTexture);

	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, glFilter);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, glFilter);

	        texture.minFilter = glFilter;
	        texture.magFilter = glFilter;

	        if (currentTexture)
	        {
	            gl.bindTexture(gl.TEXTURE_2D, currentTexture);
	        }

	        return this;
	    },

	    getMaxTextureSize: function ()
	    {
	        return this.config.maxTextureSize;
	    },

	    destroy: function ()
	    {
	        this.canvas.removeEventListener('webglcontextlost', this.contextLostHandler, false);

	        this.canvas.removeEventListener('webglcontextrestored', this.contextRestoredHandler, false);

	        var wrapperDestroy = function (wrapper)
	        {
	            wrapper.destroy();
	        };
	        ArrayEach(this.glAttribLocationWrappers, wrapperDestroy);
	        ArrayEach(this.glBufferWrappers, wrapperDestroy);
	        ArrayEach(this.glFramebufferWrappers, wrapperDestroy);
	        ArrayEach(this.glProgramWrappers, wrapperDestroy);
	        ArrayEach(this.glTextureWrappers, wrapperDestroy);
	        ArrayEach(this.glUniformLocationWrappers, wrapperDestroy);

	        this.maskTarget.destroy();
	        this.maskSource.destroy();

	        this.pipelines.destroy();

	        this.removeAllListeners();

	        this.fboStack = [];
	        this.maskStack = [];
	        this.extensions = {};
	        this.textureIndexes = [];

	        this.gl = null;
	        this.game = null;
	        this.canvas = null;
	        this.contextLost = true;
	        this.currentMask = null;
	        this.currentCameraMask = null;
	    }

	});

	WebGLRenderer_1 = WebGLRenderer;
	return WebGLRenderer_1;
}

var CreateRenderer_1;
var hasRequiredCreateRenderer;

function requireCreateRenderer () {
	if (hasRequiredCreateRenderer) return CreateRenderer_1;
	hasRequiredCreateRenderer = 1;
	var CanvasInterpolation = requireCanvasInterpolation();
	var CanvasPool = requireCanvasPool();
	var CONST = require_const$f();
	var Features = requireFeatures();

	var CreateRenderer = function (game)
	{
	    var config = game.config;

	    if ((config.customEnvironment || config.canvas) && config.renderType === CONST.AUTO)
	    {
	        throw new Error('Must set explicit renderType in custom environment');
	    }

	    if (!config.customEnvironment && !config.canvas && config.renderType !== CONST.HEADLESS)
	    {
	        if (config.renderType === CONST.AUTO)
	        {
	            config.renderType = Features.webGL ? CONST.WEBGL : CONST.CANVAS;
	        }

	        if (config.renderType === CONST.WEBGL)
	        {
	            if (!Features.webGL) { throw new Error('Cannot create WebGL context, aborting.'); }
	        }
	        else if (config.renderType === CONST.CANVAS)
	        {
	            if (!Features.canvas) { throw new Error('Cannot create Canvas context, aborting.'); }
	        }
	        else
	        {
	            throw new Error('Unknown value for renderer type: ' + config.renderType);
	        }
	    }

	    if (!config.antialias)
	    {
	        CanvasPool.disableSmoothing();
	    }

	    var baseSize = game.scale.baseSize;

	    var width = baseSize.width;
	    var height = baseSize.height;

	    if (config.canvas)
	    {
	        game.canvas = config.canvas;

	        game.canvas.width = width;
	        game.canvas.height = height;
	    }
	    else
	    {
	        game.canvas = CanvasPool.create(game, width, height, config.renderType);
	    }

	    if (config.canvasStyle)
	    {
	        game.canvas.style = config.canvasStyle;
	    }

	    if (!config.antialias)
	    {
	        CanvasInterpolation.setCrisp(game.canvas);
	    }

	    if (config.renderType === CONST.HEADLESS)
	    {

	        return;
	    }

	    var CanvasRenderer;
	    var WebGLRenderer;

	    if (typeof WEBGL_RENDERER && typeof CANVAS_RENDERER)
	    {
	        CanvasRenderer = requireCanvasRenderer();
	        WebGLRenderer = requireWebGLRenderer();

	        if (config.renderType === CONST.WEBGL)
	        {
	            game.renderer = new WebGLRenderer(game);
	        }
	        else
	        {
	            game.renderer = new CanvasRenderer(game);
	            game.context = game.renderer.gameContext;
	        }
	    }

	    if (typeof WEBGL_RENDERER && !typeof CANVAS_RENDERER)
	    {
	        WebGLRenderer = requireWebGLRenderer();

	        config.renderType = CONST.WEBGL;

	        game.renderer = new WebGLRenderer(game);
	    }

	    if (!typeof WEBGL_RENDERER && typeof CANVAS_RENDERER)
	    {
	        CanvasRenderer = requireCanvasRenderer();

	        config.renderType = CONST.CANVAS;

	        game.renderer = new CanvasRenderer(game);

	        game.context = game.renderer.gameContext;
	    }
	};

	CreateRenderer_1 = CreateRenderer;
	return CreateRenderer_1;
}

var RequestAnimationFrame_1;
var hasRequiredRequestAnimationFrame;

function requireRequestAnimationFrame () {
	if (hasRequiredRequestAnimationFrame) return RequestAnimationFrame_1;
	hasRequiredRequestAnimationFrame = 1;
	var Class = requireClass();
	var NOOP = requireNOOP();

	var RequestAnimationFrame = new Class({

	    initialize:

	    function RequestAnimationFrame ()
	    {

	        this.isRunning = false;

	        this.callback = NOOP;

	        this.isSetTimeOut = false;

	        this.timeOutID = null;

	        this.delay = 0;

	        var _this = this;

	        this.step = function step (time)
	        {
	            _this.callback(time);

	            if (_this.isRunning)
	            {
	                _this.timeOutID = window.requestAnimationFrame(step);
	            }
	        };

	        this.stepTimeout = function stepTimeout ()
	        {
	            if (_this.isRunning)
	            {

	                _this.timeOutID = window.setTimeout(stepTimeout, _this.delay);
	            }

	            _this.callback(window.performance.now());
	        };
	    },

	    start: function (callback, forceSetTimeOut, delay)
	    {
	        if (this.isRunning)
	        {
	            return;
	        }

	        this.callback = callback;

	        this.isSetTimeOut = forceSetTimeOut;

	        this.delay = delay;

	        this.isRunning = true;

	        this.timeOutID = (forceSetTimeOut) ? window.setTimeout(this.stepTimeout, 0) : window.requestAnimationFrame(this.step);
	    },

	    stop: function ()
	    {
	        this.isRunning = false;

	        if (this.isSetTimeOut)
	        {
	            clearTimeout(this.timeOutID);
	        }
	        else
	        {
	            window.cancelAnimationFrame(this.timeOutID);
	        }
	    },

	    destroy: function ()
	    {
	        this.stop();

	        this.callback = NOOP;
	    }

	});

	RequestAnimationFrame_1 = RequestAnimationFrame;
	return RequestAnimationFrame_1;
}

var TimeStep_1;
var hasRequiredTimeStep;

function requireTimeStep () {
	if (hasRequiredTimeStep) return TimeStep_1;
	hasRequiredTimeStep = 1;
	var Class = requireClass();
	requireGetValue();
	var NOOP = requireNOOP();
	requireRequestAnimationFrame();

	var TimeStep = new Class({
	  initialize: function TimeStep(game, config) {
	    this.game = game;
	    this.rafId = null;
	    this.started = false;
	    this.running = false;
	    this.callback = NOOP;
	    this.lastTime = 0;
	  },

	  start: function(callback) {
	    if (this.started) return this;
	    this.started = true;
	    this.running = true;
	    this.callback = callback;
	    this.lastTime = performance.now();
	    this.rafId = requestAnimationFrame(this.tick.bind(this));
	  },

	  tick: function(timestamp) {
	    var delta = timestamp - this.lastTime;
	    this.callback(timestamp, delta);
	    this.lastTime = timestamp;
	    this.rafId = requestAnimationFrame(this.tick.bind(this));
	  },

	  stop: function() {
	    if (this.running) {
	      cancelAnimationFrame(this.rafId);
	      this.running = false;
	    }
	  },

	  destroy: function() {
	    this.stop();
	  }
	});

	TimeStep_1 = TimeStep;
	return TimeStep_1;
}

var VisibilityHandler_1;
var hasRequiredVisibilityHandler;

function requireVisibilityHandler () {
	if (hasRequiredVisibilityHandler) return VisibilityHandler_1;
	hasRequiredVisibilityHandler = 1;
	var Events = requireEvents$h();

	var VisibilityHandler = function (game)
	{
	    var hiddenVar;
	    var eventEmitter = game.events;

	    if (document.hidden !== undefined)
	    {
	        hiddenVar = 'visibilitychange';
	    }
	    else
	    {
	        var vendors = [ 'webkit', 'moz', 'ms' ];

	        vendors.forEach(function (prefix)
	        {
	            if (document[prefix + 'Hidden'] !== undefined)
	            {
	                document.hidden = function ()
	                {
	                    return document[prefix + 'Hidden'];
	                };

	                hiddenVar = prefix + 'visibilitychange';
	            }

	        });
	    }

	    var onChange = function (event)
	    {
	        if (document.hidden || event.type === 'pause')
	        {
	            eventEmitter.emit(Events.HIDDEN);
	        }
	        else
	        {
	            eventEmitter.emit(Events.VISIBLE);
	        }
	    };

	    if (hiddenVar)
	    {
	        document.addEventListener(hiddenVar, onChange, false);
	    }

	    window.onblur = function ()
	    {
	        eventEmitter.emit(Events.BLUR);
	    };

	    window.onfocus = function ()
	    {
	        eventEmitter.emit(Events.FOCUS);
	    };

	    if (window.focus && game.config.autoFocus)
	    {
	        window.focus();
	    }
	};

	VisibilityHandler_1 = VisibilityHandler;
	return VisibilityHandler_1;
}

var core;
var hasRequiredCore;

function requireCore () {
	if (hasRequiredCore) return core;
	hasRequiredCore = 1;
	core = {

	    Config: requireConfig(),
	    CreateRenderer: requireCreateRenderer(),
	    Events: requireEvents$h(),
	    TimeStep: requireTimeStep(),
	    VisibilityHandler: requireVisibilityHandler()

	};
	return core;
}

var Arne16;
var hasRequiredArne16;

function requireArne16 () {
	if (hasRequiredArne16) return Arne16;
	hasRequiredArne16 = 1;
	Arne16 = {
	    0: '#000',
	    1: '#9D9D9D',
	    2: '#FFF',
	    3: '#BE2633',
	    4: '#E06F8B',
	    5: '#493C2B',
	    6: '#A46422',
	    7: '#EB8931',
	    8: '#F7E26B',
	    9: '#2F484E',
	    A: '#44891A',
	    B: '#A3CE27',
	    C: '#1B2632',
	    D: '#005784',
	    E: '#31A2F2',
	    F: '#B2DCEF'
	};
	return Arne16;
}

var GenerateTexture_1;
var hasRequiredGenerateTexture;

function requireGenerateTexture () {
	if (hasRequiredGenerateTexture) return GenerateTexture_1;
	hasRequiredGenerateTexture = 1;
	var Arne16 = requireArne16();
	var CanvasPool = requireCanvasPool();
	var GetValue = requireGetValue();

	var GenerateTexture = function (config)
	{
	    var data = GetValue(config, 'data', []);
	    var canvas = GetValue(config, 'canvas', null);
	    var palette = GetValue(config, 'palette', Arne16);
	    var pixelWidth = GetValue(config, 'pixelWidth', 1);
	    var pixelHeight = GetValue(config, 'pixelHeight', pixelWidth);
	    var resizeCanvas = GetValue(config, 'resizeCanvas', true);
	    var clearCanvas = GetValue(config, 'clearCanvas', true);
	    var preRender = GetValue(config, 'preRender', null);
	    var postRender = GetValue(config, 'postRender', null);

	    var width = Math.floor(Math.abs(data[0].length * pixelWidth));
	    var height = Math.floor(Math.abs(data.length * pixelHeight));

	    if (!canvas)
	    {
	        canvas = CanvasPool.create2D(this, width, height);
	        resizeCanvas = false;
	        clearCanvas = false;
	    }

	    if (resizeCanvas)
	    {
	        canvas.width = width;
	        canvas.height = height;
	    }

	    var ctx = canvas.getContext('2d', { willReadFrequently: true });

	    if (clearCanvas)
	    {
	        ctx.clearRect(0, 0, width, height);
	    }

	    if (preRender)
	    {
	        preRender(canvas, ctx);
	    }

	    for (var y = 0; y < data.length; y++)
	    {
	        var row = data[y];

	        for (var x = 0; x < row.length; x++)
	        {
	            var d = row[x];

	            if (d !== '.' && d !== ' ')
	            {
	                ctx.fillStyle = palette[d];
	                ctx.fillRect(x * pixelWidth, y * pixelHeight, pixelWidth, pixelHeight);
	            }
	        }
	    }

	    if (postRender)
	    {
	        postRender(canvas, ctx);
	    }

	    return canvas;
	};

	GenerateTexture_1 = GenerateTexture;
	return GenerateTexture_1;
}

var C64;
var hasRequiredC64;

function requireC64 () {
	if (hasRequiredC64) return C64;
	hasRequiredC64 = 1;
	C64 = {
	    0: '#000',
	    1: '#fff',
	    2: '#8b4131',
	    3: '#7bbdc5',
	    4: '#8b41ac',
	    5: '#6aac41',
	    6: '#3931a4',
	    7: '#d5de73',
	    8: '#945a20',
	    9: '#5a4100',
	    A: '#bd736a',
	    B: '#525252',
	    C: '#838383',
	    D: '#acee8b',
	    E: '#7b73de',
	    F: '#acacac'
	};
	return C64;
}

var CGA;
var hasRequiredCGA;

function requireCGA () {
	if (hasRequiredCGA) return CGA;
	hasRequiredCGA = 1;
	CGA = {
	    0: '#000',
	    1: '#2234d1',
	    2: '#0c7e45',
	    3: '#44aacc',
	    4: '#8a3622',
	    5: '#5c2e78',
	    6: '#aa5c3d',
	    7: '#b5b5b5',
	    8: '#5e606e',
	    9: '#4c81fb',
	    A: '#6cd947',
	    B: '#7be2f9',
	    C: '#eb8a60',
	    D: '#e23d69',
	    E: '#ffd93f',
	    F: '#fff'
	};
	return CGA;
}

var JMP;
var hasRequiredJMP;

function requireJMP () {
	if (hasRequiredJMP) return JMP;
	hasRequiredJMP = 1;
	JMP = {
	    0: '#000',
	    1: '#191028',
	    2: '#46af45',
	    3: '#a1d685',
	    4: '#453e78',
	    5: '#7664fe',
	    6: '#833129',
	    7: '#9ec2e8',
	    8: '#dc534b',
	    9: '#e18d79',
	    A: '#d6b97b',
	    B: '#e9d8a1',
	    C: '#216c4b',
	    D: '#d365c8',
	    E: '#afaab9',
	    F: '#f5f4eb'
	};
	return JMP;
}

var MSX;
var hasRequiredMSX;

function requireMSX () {
	if (hasRequiredMSX) return MSX;
	hasRequiredMSX = 1;
	MSX = {
	    0: '#000',
	    1: '#191028',
	    2: '#46af45',
	    3: '#a1d685',
	    4: '#453e78',
	    5: '#7664fe',
	    6: '#833129',
	    7: '#9ec2e8',
	    8: '#dc534b',
	    9: '#e18d79',
	    A: '#d6b97b',
	    B: '#e9d8a1',
	    C: '#216c4b',
	    D: '#d365c8',
	    E: '#afaab9',
	    F: '#fff'
	};
	return MSX;
}

var palettes;
var hasRequiredPalettes;

function requirePalettes () {
	if (hasRequiredPalettes) return palettes;
	hasRequiredPalettes = 1;
	palettes = {

	    ARNE16: requireArne16(),
	    C64: requireC64(),
	    CGA: requireCGA(),
	    JMP: requireJMP(),
	    MSX: requireMSX()

	};
	return palettes;
}

var create;
var hasRequiredCreate;

function requireCreate () {
	if (hasRequiredCreate) return create;
	hasRequiredCreate = 1;
	create = {

	    GenerateTexture: requireGenerateTexture(),
	    Palettes: requirePalettes()

	};
	return create;
}

var FromPoints_1;
var hasRequiredFromPoints;

function requireFromPoints () {
	if (hasRequiredFromPoints) return FromPoints_1;
	hasRequiredFromPoints = 1;
	var Rectangle = requireRectangle$2();
	var MATH_CONST = require_const$c();

	var FromPoints = function (points, out)
	{
	    if (out === undefined) { out = new Rectangle(); }

	    if (points.length === 0)
	    {
	        return out;
	    }

	    var minX = Number.MAX_VALUE;
	    var minY = Number.MAX_VALUE;

	    var maxX = MATH_CONST.MIN_SAFE_INTEGER;
	    var maxY = MATH_CONST.MIN_SAFE_INTEGER;

	    var p;
	    var px;
	    var py;

	    for (var i = 0; i < points.length; i++)
	    {
	        p = points[i];

	        if (Array.isArray(p))
	        {
	            px = p[0];
	            py = p[1];
	        }
	        else
	        {
	            px = p.x;
	            py = p.y;
	        }

	        minX = Math.min(minX, px);
	        minY = Math.min(minY, py);

	        maxX = Math.max(maxX, px);
	        maxY = Math.max(maxY, py);
	    }

	    out.x = minX;
	    out.y = minY;
	    out.width = maxX - minX;
	    out.height = maxY - minY;

	    return out;
	};

	FromPoints_1 = FromPoints;
	return FromPoints_1;
}

var Curve_1$1;
var hasRequiredCurve$1;

function requireCurve$1 () {
	if (hasRequiredCurve$1) return Curve_1$1;
	hasRequiredCurve$1 = 1;
	var Class = requireClass();
	var FromPoints = requireFromPoints();
	var Rectangle = requireRectangle$2();
	var Vector2 = requireVector2();

	var Curve = new Class({

	    initialize:

	    function Curve (type)
	    {

	        this.type = type;

	        this.defaultDivisions = 5;

	        this.arcLengthDivisions = 100;

	        this.cacheArcLengths = [];

	        this.needsUpdate = true;

	        this.active = true;

	        this._tmpVec2A = new Vector2();

	        this._tmpVec2B = new Vector2();
	    },

	    draw: function (graphics, pointsTotal)
	    {
	        if (pointsTotal === undefined) { pointsTotal = 32; }

	        return graphics.strokePoints(this.getPoints(pointsTotal));
	    },

	    getBounds: function (out, accuracy)
	    {
	        if (!out) { out = new Rectangle(); }
	        if (accuracy === undefined) { accuracy = 16; }

	        var len = this.getLength();

	        if (accuracy > len)
	        {
	            accuracy = len / 2;
	        }

	        var spaced = Math.max(1, Math.round(len / accuracy));

	        return FromPoints(this.getSpacedPoints(spaced), out);
	    },

	    getDistancePoints: function (distance)
	    {
	        var len = this.getLength();

	        var spaced = Math.max(1, len / distance);

	        return this.getSpacedPoints(spaced);
	    },

	    getEndPoint: function (out)
	    {
	        if (out === undefined) { out = new Vector2(); }

	        return this.getPointAt(1, out);
	    },

	    getLength: function ()
	    {
	        var lengths = this.getLengths();

	        return lengths[lengths.length - 1];
	    },

	    getLengths: function (divisions)
	    {
	        if (divisions === undefined) { divisions = this.arcLengthDivisions; }

	        if ((this.cacheArcLengths.length === divisions + 1) && !this.needsUpdate)
	        {
	            return this.cacheArcLengths;
	        }

	        this.needsUpdate = false;

	        var cache = [];
	        var current;
	        var last = this.getPoint(0, this._tmpVec2A);
	        var sum = 0;

	        cache.push(0);

	        for (var p = 1; p <= divisions; p++)
	        {
	            current = this.getPoint(p / divisions, this._tmpVec2B);

	            sum += current.distance(last);

	            cache.push(sum);

	            last.copy(current);
	        }

	        this.cacheArcLengths = cache;

	        return cache; 
	    },

	    getPointAt: function (u, out)
	    {
	        var t = this.getUtoTmapping(u);

	        return this.getPoint(t, out);
	    },

	    getPoints: function (divisions, stepRate, out)
	    {
	        if (out === undefined) { out = []; }

	        if (!divisions)
	        {
	            if (!stepRate)
	            {
	                divisions = this.defaultDivisions;
	            }
	            else
	            {
	                divisions = this.getLength() / stepRate;
	            }
	        }

	        for (var d = 0; d <= divisions; d++)
	        {
	            out.push(this.getPoint(d / divisions));
	        }

	        return out;
	    },

	    getRandomPoint: function (out)
	    {
	        if (out === undefined) { out = new Vector2(); }

	        return this.getPoint(Math.random(), out);
	    },

	    getSpacedPoints: function (divisions, stepRate, out)
	    {
	        if (out === undefined) { out = []; }

	        if (!divisions)
	        {
	            if (!stepRate)
	            {
	                divisions = this.defaultDivisions;
	            }
	            else
	            {
	                divisions = this.getLength() / stepRate;
	            }
	        }

	        for (var d = 0; d <= divisions; d++)
	        {
	            var t = this.getUtoTmapping(d / divisions, null, divisions);

	            out.push(this.getPoint(t));
	        }

	        return out;
	    },

	    getStartPoint: function (out)
	    {
	        if (out === undefined) { out = new Vector2(); }

	        return this.getPointAt(0, out);
	    },

	    getTangent: function (t, out)
	    {
	        if (out === undefined) { out = new Vector2(); }

	        var delta = 0.0001;
	        var t1 = t - delta;
	        var t2 = t + delta;

	        if (t1 < 0)
	        {
	            t1 = 0;
	        }

	        if (t2 > 1)
	        {
	            t2 = 1;
	        }

	        this.getPoint(t1, this._tmpVec2A);
	        this.getPoint(t2, out);

	        return out.subtract(this._tmpVec2A).normalize();
	    },

	    getTangentAt: function (u, out)
	    {
	        var t = this.getUtoTmapping(u);

	        return this.getTangent(t, out);
	    },

	    getTFromDistance: function (distance, divisions)
	    {
	        if (distance <= 0)
	        {
	            return 0;
	        }

	        return this.getUtoTmapping(0, distance, divisions);
	    },

	    getUtoTmapping: function (u, distance, divisions)
	    {
	        var arcLengths = this.getLengths(divisions);

	        var i = 0;
	        var il = arcLengths.length;

	        var targetArcLength; 

	        if (distance)
	        {

	            targetArcLength = Math.min(distance, arcLengths[il - 1]);
	        }
	        else
	        {
	            targetArcLength = u * arcLengths[il - 1];
	        }

	        var low = 0;
	        var high = il - 1;
	        var comparison;

	        while (low <= high)
	        {
	            i = Math.floor(low + (high - low) / 2); 

	            comparison = arcLengths[i] - targetArcLength;

	            if (comparison < 0)
	            {
	                low = i + 1;
	            }
	            else if (comparison > 0)
	            {
	                high = i - 1;
	            }
	            else
	            {
	                high = i;
	                break;
	            }
	        }

	        i = high;

	        if (arcLengths[i] === targetArcLength)
	        {
	            return i / (il - 1);
	        }

	        var lengthBefore = arcLengths[i];
	        var lengthAfter = arcLengths[i + 1];

	        var segmentLength = lengthAfter - lengthBefore;

	        var segmentFraction = (targetArcLength - lengthBefore) / segmentLength;

	        return (i + segmentFraction) / (il - 1);
	    },

	    updateArcLengths: function ()
	    {
	        this.needsUpdate = true;

	        this.getLengths();
	    }

	});

	Curve_1$1 = Curve;
	return Curve_1$1;
}

var CubicBezierCurve_1;
var hasRequiredCubicBezierCurve;

function requireCubicBezierCurve () {
	if (hasRequiredCubicBezierCurve) return CubicBezierCurve_1;
	hasRequiredCubicBezierCurve = 1;
	var Class = requireClass();
	var CubicBezier = requireCubicBezierInterpolation();
	var Curve = requireCurve$1();
	var Vector2 = requireVector2();

	var CubicBezierCurve = new Class({

	    Extends: Curve,

	    initialize:

	    function CubicBezierCurve (p0, p1, p2, p3)
	    {
	        Curve.call(this, 'CubicBezierCurve');

	        if (Array.isArray(p0))
	        {
	            p3 = new Vector2(p0[6], p0[7]);
	            p2 = new Vector2(p0[4], p0[5]);
	            p1 = new Vector2(p0[2], p0[3]);
	            p0 = new Vector2(p0[0], p0[1]);
	        }

	        this.p0 = p0;

	        this.p1 = p1;

	        this.p2 = p2;

	        this.p3 = p3;
	    },

	    getStartPoint: function (out)
	    {
	        if (out === undefined) { out = new Vector2(); }

	        return out.copy(this.p0);
	    },

	    getResolution: function (divisions)
	    {
	        return divisions;
	    },

	    getPoint: function (t, out)
	    {
	        if (out === undefined) { out = new Vector2(); }

	        var p0 = this.p0;
	        var p1 = this.p1;
	        var p2 = this.p2;
	        var p3 = this.p3;

	        return out.set(CubicBezier(t, p0.x, p1.x, p2.x, p3.x), CubicBezier(t, p0.y, p1.y, p2.y, p3.y));
	    },

	    draw: function (graphics, pointsTotal)
	    {
	        if (pointsTotal === undefined) { pointsTotal = 32; }

	        var points = this.getPoints(pointsTotal);

	        graphics.beginPath();
	        graphics.moveTo(this.p0.x, this.p0.y);

	        for (var i = 1; i < points.length; i++)
	        {
	            graphics.lineTo(points[i].x, points[i].y);
	        }

	        graphics.strokePath();

	        return graphics;
	    },

	    toJSON: function ()
	    {
	        return {
	            type: this.type,
	            points: [
	                this.p0.x, this.p0.y,
	                this.p1.x, this.p1.y,
	                this.p2.x, this.p2.y,
	                this.p3.x, this.p3.y
	            ]
	        };
	    }

	});

	CubicBezierCurve.fromJSON = function (data)
	{
	    var points = data.points;

	    var p0 = new Vector2(points[0], points[1]);
	    var p1 = new Vector2(points[2], points[3]);
	    var p2 = new Vector2(points[4], points[5]);
	    var p3 = new Vector2(points[6], points[7]);

	    return new CubicBezierCurve(p0, p1, p2, p3);
	};

	CubicBezierCurve_1 = CubicBezierCurve;
	return CubicBezierCurve_1;
}

var EllipseCurve_1;
var hasRequiredEllipseCurve;

function requireEllipseCurve () {
	if (hasRequiredEllipseCurve) return EllipseCurve_1;
	hasRequiredEllipseCurve = 1;
	var Class = requireClass();
	var Curve = requireCurve$1();
	var DegToRad = requireDegToRad();
	var GetValue = requireGetValue();
	var RadToDeg = requireRadToDeg();
	var Vector2 = requireVector2();

	var EllipseCurve = new Class({

	    Extends: Curve,

	    initialize:

	    function EllipseCurve (x, y, xRadius, yRadius, startAngle, endAngle, clockwise, rotation)
	    {
	        if (typeof x === 'object')
	        {
	            var config = x;

	            x = GetValue(config, 'x', 0);
	            y = GetValue(config, 'y', 0);
	            xRadius = GetValue(config, 'xRadius', 0);
	            yRadius = GetValue(config, 'yRadius', xRadius);
	            startAngle = GetValue(config, 'startAngle', 0);
	            endAngle = GetValue(config, 'endAngle', 360);
	            clockwise = GetValue(config, 'clockwise', false);
	            rotation = GetValue(config, 'rotation', 0);
	        }
	        else
	        {
	            if (yRadius === undefined) { yRadius = xRadius; }
	            if (startAngle === undefined) { startAngle = 0; }
	            if (endAngle === undefined) { endAngle = 360; }
	            if (clockwise === undefined) { clockwise = false; }
	            if (rotation === undefined) { rotation = 0; }
	        }

	        Curve.call(this, 'EllipseCurve');

	        this.p0 = new Vector2(x, y);

	        this._xRadius = xRadius;

	        this._yRadius = yRadius;

	        this._startAngle = DegToRad(startAngle);

	        this._endAngle = DegToRad(endAngle);

	        this._clockwise = clockwise;

	        this._rotation = DegToRad(rotation);
	    },

	    getStartPoint: function (out)
	    {
	        if (out === undefined) { out = new Vector2(); }

	        return this.getPoint(0, out);
	    },

	    getResolution: function (divisions)
	    {
	        return divisions * 2;
	    },

	    getPoint: function (t, out)
	    {
	        if (out === undefined) { out = new Vector2(); }

	        var twoPi = Math.PI * 2;
	        var deltaAngle = this._endAngle - this._startAngle;
	        var samePoints = Math.abs(deltaAngle) < Number.EPSILON;

	        while (deltaAngle < 0)
	        {
	            deltaAngle += twoPi;
	        }

	        while (deltaAngle > twoPi)
	        {
	            deltaAngle -= twoPi;
	        }

	        if (deltaAngle < Number.EPSILON)
	        {
	            if (samePoints)
	            {
	                deltaAngle = 0;
	            }
	            else
	            {
	                deltaAngle = twoPi;
	            }
	        }

	        if (this._clockwise && !samePoints)
	        {
	            if (deltaAngle === twoPi)
	            {
	                deltaAngle = - twoPi;
	            }
	            else
	            {
	                deltaAngle = deltaAngle - twoPi;
	            }
	        }

	        var angle = this._startAngle + t * deltaAngle;
	        var x = this.p0.x + this._xRadius * Math.cos(angle);
	        var y = this.p0.y + this._yRadius * Math.sin(angle);

	        if (this._rotation !== 0)
	        {
	            var cos = Math.cos(this._rotation);
	            var sin = Math.sin(this._rotation);

	            var tx = x - this.p0.x;
	            var ty = y - this.p0.y;

	            x = tx * cos - ty * sin + this.p0.x;
	            y = tx * sin + ty * cos + this.p0.y;
	        }

	        return out.set(x, y);
	    },

	    setXRadius: function (value)
	    {
	        this.xRadius = value;

	        return this;
	    },

	    setYRadius: function (value)
	    {
	        this.yRadius = value;

	        return this;
	    },

	    setWidth: function (value)
	    {
	        this.xRadius = value / 2;

	        return this;
	    },

	    setHeight: function (value)
	    {
	        this.yRadius = value / 2;

	        return this;
	    },

	    setStartAngle: function (value)
	    {
	        this.startAngle = value;

	        return this;
	    },

	    setEndAngle: function (value)
	    {
	        this.endAngle = value;

	        return this;
	    },

	    setClockwise: function (value)
	    {
	        this.clockwise = value;

	        return this;
	    },

	    setRotation: function (value)
	    {
	        this.rotation = value;

	        return this;
	    },

	    x: {

	        get: function ()
	        {
	            return this.p0.x;
	        },

	        set: function (value)
	        {
	            this.p0.x = value;
	        }

	    },

	    y: {

	        get: function ()
	        {
	            return this.p0.y;
	        },

	        set: function (value)
	        {
	            this.p0.y = value;
	        }

	    },

	    xRadius: {

	        get: function ()
	        {
	            return this._xRadius;
	        },

	        set: function (value)
	        {
	            this._xRadius = value;
	        }

	    },

	    yRadius: {

	        get: function ()
	        {
	            return this._yRadius;
	        },

	        set: function (value)
	        {
	            this._yRadius = value;
	        }

	    },

	    startAngle: {

	        get: function ()
	        {
	            return RadToDeg(this._startAngle);
	        },

	        set: function (value)
	        {
	            this._startAngle = DegToRad(value);
	        }

	    },

	    endAngle: {

	        get: function ()
	        {
	            return RadToDeg(this._endAngle);
	        },

	        set: function (value)
	        {
	            this._endAngle = DegToRad(value);
	        }

	    },

	    clockwise: {

	        get: function ()
	        {
	            return this._clockwise;
	        },

	        set: function (value)
	        {
	            this._clockwise = value;
	        }

	    },

	    angle: {

	        get: function ()
	        {
	            return RadToDeg(this._rotation);
	        },

	        set: function (value)
	        {
	            this._rotation = DegToRad(value);
	        }

	    },

	    rotation: {

	        get: function ()
	        {
	            return this._rotation;
	        },

	        set: function (value)
	        {
	            this._rotation = value;
	        }

	    },

	    toJSON: function ()
	    {
	        return {
	            type: this.type,
	            x: this.p0.x,
	            y: this.p0.y,
	            xRadius: this._xRadius,
	            yRadius: this._yRadius,
	            startAngle: RadToDeg(this._startAngle),
	            endAngle: RadToDeg(this._endAngle),
	            clockwise: this._clockwise,
	            rotation: RadToDeg(this._rotation)
	        };
	    }

	});

	EllipseCurve.fromJSON = function (data)
	{
	    return new EllipseCurve(data);
	};

	EllipseCurve_1 = EllipseCurve;
	return EllipseCurve_1;
}

var LineCurve_1;
var hasRequiredLineCurve;

function requireLineCurve () {
	if (hasRequiredLineCurve) return LineCurve_1;
	hasRequiredLineCurve = 1;
	var Class = requireClass();
	var Curve = requireCurve$1();
	var FromPoints = requireFromPoints();
	var Rectangle = requireRectangle$2();
	var Vector2 = requireVector2();

	var LineCurve = new Class({

	    Extends: Curve,

	    initialize:

	    function LineCurve (p0, p1)
	    {
	        Curve.call(this, 'LineCurve');

	        if (Array.isArray(p0))
	        {
	            p1 = new Vector2(p0[2], p0[3]);
	            p0 = new Vector2(p0[0], p0[1]);
	        }

	        this.p0 = p0;

	        this.p1 = p1;

	        this.arcLengthDivisions = 1;
	    },

	    getBounds: function (out)
	    {
	        if (out === undefined) { out = new Rectangle(); }

	        return FromPoints([ this.p0, this.p1 ], out);
	    },

	    getStartPoint: function (out)
	    {
	        if (out === undefined) { out = new Vector2(); }

	        return out.copy(this.p0);
	    },

	    getResolution: function (divisions)
	    {
	        if (divisions === undefined) { divisions = 1; }

	        return divisions;
	    },

	    getPoint: function (t, out)
	    {
	        if (out === undefined) { out = new Vector2(); }

	        if (t === 1)
	        {
	            return out.copy(this.p1);
	        }

	        out.copy(this.p1).subtract(this.p0).scale(t).add(this.p0);

	        return out;
	    },

	    getPointAt: function (u, out)
	    {
	        return this.getPoint(u, out);
	    },

	    getTangent: function (t, out)
	    {
	        if (out === undefined) { out = new Vector2(); }

	        out.copy(this.p1).subtract(this.p0).normalize();

	        return out;
	    },

	    getUtoTmapping: function (u, distance, divisions)
	    {
	        var t;

	        if (distance)
	        {
	            var arcLengths = this.getLengths(divisions);
	            var lineLength = arcLengths[arcLengths.length - 1];

	            var targetLineLength = Math.min(distance, lineLength);

	            t = targetLineLength / lineLength;
	        }
	        else
	        {
	            t = u;
	        }

	        return t;
	    },

	    draw: function (graphics)
	    {
	        graphics.lineBetween(this.p0.x, this.p0.y, this.p1.x, this.p1.y);

	        return graphics;
	    },

	    toJSON: function ()
	    {
	        return {
	            type: this.type,
	            points: [
	                this.p0.x, this.p0.y,
	                this.p1.x, this.p1.y
	            ]
	        };
	    }

	});

	LineCurve.fromJSON = function (data)
	{
	    var points = data.points;

	    var p0 = new Vector2(points[0], points[1]);
	    var p1 = new Vector2(points[2], points[3]);

	    return new LineCurve(p0, p1);
	};

	LineCurve_1 = LineCurve;
	return LineCurve_1;
}

var MoveTo_1;
var hasRequiredMoveTo;

function requireMoveTo () {
	if (hasRequiredMoveTo) return MoveTo_1;
	hasRequiredMoveTo = 1;
	var Class = requireClass();
	var Vector2 = requireVector2();

	var MoveTo = new Class({

	    initialize:

	    function MoveTo (x, y)
	    {

	        this.active = false;

	        this.p0 = new Vector2(x, y);
	    },

	    getPoint: function (t, out)
	    {
	        if (out === undefined) { out = new Vector2(); }

	        return out.copy(this.p0);
	    },

	    getPointAt: function (u, out)
	    {
	        return this.getPoint(u, out);
	    },

	    getResolution: function ()
	    {
	        return 1;
	    },

	    getLength: function ()
	    {
	        return 0;
	    },

	    toJSON: function ()
	    {
	        return {
	            type: 'MoveTo',
	            points: [
	                this.p0.x, this.p0.y
	            ]
	        };
	    }

	});

	MoveTo_1 = MoveTo;
	return MoveTo_1;
}

var QuadraticBezierCurve;
var hasRequiredQuadraticBezierCurve;

function requireQuadraticBezierCurve () {
	if (hasRequiredQuadraticBezierCurve) return QuadraticBezierCurve;
	hasRequiredQuadraticBezierCurve = 1;
	var Class = requireClass();
	var Curve = requireCurve$1();
	var QuadraticBezierInterpolation = requireQuadraticBezierInterpolation();
	var Vector2 = requireVector2();

	var QuadraticBezier = new Class({

	    Extends: Curve,

	    initialize:

	    function QuadraticBezier (p0, p1, p2)
	    {
	        Curve.call(this, 'QuadraticBezierCurve');

	        if (Array.isArray(p0))
	        {
	            p2 = new Vector2(p0[4], p0[5]);
	            p1 = new Vector2(p0[2], p0[3]);
	            p0 = new Vector2(p0[0], p0[1]);
	        }

	        this.p0 = p0;

	        this.p1 = p1;

	        this.p2 = p2;
	    },

	    getStartPoint: function (out)
	    {
	        if (out === undefined) { out = new Vector2(); }

	        return out.copy(this.p0);
	    },

	    getResolution: function (divisions)
	    {
	        return divisions;
	    },

	    getPoint: function (t, out)
	    {
	        if (out === undefined) { out = new Vector2(); }

	        var p0 = this.p0;
	        var p1 = this.p1;
	        var p2 = this.p2;

	        return out.set(
	            QuadraticBezierInterpolation(t, p0.x, p1.x, p2.x),
	            QuadraticBezierInterpolation(t, p0.y, p1.y, p2.y)
	        );
	    },

	    draw: function (graphics, pointsTotal)
	    {
	        if (pointsTotal === undefined) { pointsTotal = 32; }

	        var points = this.getPoints(pointsTotal);

	        graphics.beginPath();
	        graphics.moveTo(this.p0.x, this.p0.y);

	        for (var i = 1; i < points.length; i++)
	        {
	            graphics.lineTo(points[i].x, points[i].y);
	        }

	        graphics.strokePath();

	        return graphics;
	    },

	    toJSON: function ()
	    {
	        return {
	            type: this.type,
	            points: [
	                this.p0.x, this.p0.y,
	                this.p1.x, this.p1.y,
	                this.p2.x, this.p2.y
	            ]
	        };
	    }

	});

	QuadraticBezier.fromJSON = function (data)
	{
	    var points = data.points;

	    var p0 = new Vector2(points[0], points[1]);
	    var p1 = new Vector2(points[2], points[3]);
	    var p2 = new Vector2(points[4], points[5]);

	    return new QuadraticBezier(p0, p1, p2);
	};

	QuadraticBezierCurve = QuadraticBezier;
	return QuadraticBezierCurve;
}

var SplineCurve_1;
var hasRequiredSplineCurve;

function requireSplineCurve () {
	if (hasRequiredSplineCurve) return SplineCurve_1;
	hasRequiredSplineCurve = 1;
	var CatmullRom = requireCatmullRom();
	var Class = requireClass();
	var Curve = requireCurve$1();
	var Vector2 = requireVector2();

	var SplineCurve = new Class({

	    Extends: Curve,

	    initialize:

	    function SplineCurve (points)
	    {
	        if (points === undefined) { points = []; }

	        Curve.call(this, 'SplineCurve');

	        this.points = [];

	        this.addPoints(points);
	    },

	    addPoints: function (points)
	    {
	        for (var i = 0; i < points.length; i++)
	        {
	            var p = new Vector2();

	            if (typeof points[i] === 'number')
	            {
	                p.x = points[i];
	                p.y = points[i + 1];
	                i++;
	            }
	            else if (Array.isArray(points[i]))
	            {

	                p.x = points[i][0];
	                p.y = points[i][1];
	            }
	            else
	            {
	                p.x = points[i].x;
	                p.y = points[i].y;
	            }

	            this.points.push(p);
	        }

	        return this;
	    },

	    addPoint: function (x, y)
	    {
	        var vec = new Vector2(x, y);

	        this.points.push(vec);

	        return vec;
	    },

	    getStartPoint: function (out)
	    {
	        if (out === undefined) { out = new Vector2(); }

	        return out.copy(this.points[0]);
	    },

	    getResolution: function (divisions)
	    {
	        return divisions * this.points.length;
	    },

	    getPoint: function (t, out)
	    {
	        if (out === undefined) { out = new Vector2(); }

	        var points = this.points;

	        var point = (points.length - 1) * t;

	        var intPoint = Math.floor(point);

	        var weight = point - intPoint;

	        var p0 = points[(intPoint === 0) ? intPoint : intPoint - 1];
	        var p1 = points[intPoint];
	        var p2 = points[(intPoint > points.length - 2) ? points.length - 1 : intPoint + 1];
	        var p3 = points[(intPoint > points.length - 3) ? points.length - 1 : intPoint + 2];

	        return out.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));
	    },

	    toJSON: function ()
	    {
	        var points = [];

	        for (var i = 0; i < this.points.length; i++)
	        {
	            points.push(this.points[i].x);
	            points.push(this.points[i].y);
	        }

	        return {
	            type: this.type,
	            points: points
	        };
	    }

	});

	SplineCurve.fromJSON = function (data)
	{
	    return new SplineCurve(data.points);
	};

	SplineCurve_1 = SplineCurve;
	return SplineCurve_1;
}

var Path_1;
var hasRequiredPath;

function requirePath () {
	if (hasRequiredPath) return Path_1;
	hasRequiredPath = 1;
	var Class = requireClass();
	var CubicBezierCurve = requireCubicBezierCurve();
	var EllipseCurve = requireEllipseCurve();
	var GameObjectFactory = requireGameObjectFactory();
	var LineCurve = requireLineCurve();
	var MovePathTo = requireMoveTo();
	var QuadraticBezierCurve = requireQuadraticBezierCurve();
	var Rectangle = requireRectangle$2();
	var SplineCurve = requireSplineCurve();
	var Vector2 = requireVector2();
	var MATH_CONST = require_const$c();

	var Path = new Class({

	    initialize:

	    function Path (x, y)
	    {
	        if (x === undefined) { x = 0; }
	        if (y === undefined) { y = 0; }

	        this.name = '';

	        this.defaultDivisions = 12;

	        this.curves = [];

	        this.cacheLengths = [];

	        this.autoClose = false;

	        this.startPoint = new Vector2();

	        this._tmpVec2A = new Vector2();

	        this._tmpVec2B = new Vector2();

	        if (typeof x === 'object')
	        {
	            this.fromJSON(x);
	        }
	        else
	        {
	            this.startPoint.set(x, y);
	        }
	    },

	    add: function (curve)
	    {
	        this.curves.push(curve);

	        return this;
	    },

	    circleTo: function (radius, clockwise, rotation)
	    {
	        if (clockwise === undefined) { clockwise = false; }

	        return this.ellipseTo(radius, radius, 0, 360, clockwise, rotation);
	    },

	    closePath: function ()
	    {

	        var startPoint = this.curves[0].getPoint(0);
	        var endPoint = this.curves[this.curves.length - 1].getPoint(1);

	        if (!startPoint.equals(endPoint))
	        {

	            this.curves.push(new LineCurve(endPoint, startPoint));
	        }

	        return this;
	    },

	    cubicBezierTo: function (x, y, control1X, control1Y, control2X, control2Y)
	    {
	        var p0 = this.getEndPoint();
	        var p1;
	        var p2;
	        var p3;

	        if (x instanceof Vector2)
	        {
	            p1 = x;
	            p2 = y;
	            p3 = control1X;
	        }
	        else
	        {
	            p1 = new Vector2(control1X, control1Y);
	            p2 = new Vector2(control2X, control2Y);
	            p3 = new Vector2(x, y);
	        }

	        return this.add(new CubicBezierCurve(p0, p1, p2, p3));
	    },

	    quadraticBezierTo: function (x, y, controlX, controlY)
	    {
	        var p0 = this.getEndPoint();
	        var p1;
	        var p2;

	        if (x instanceof Vector2)
	        {
	            p1 = x;
	            p2 = y;
	        }
	        else
	        {
	            p1 = new Vector2(controlX, controlY);
	            p2 = new Vector2(x, y);
	        }

	        return this.add(new QuadraticBezierCurve(p0, p1, p2));
	    },

	    draw: function (graphics, pointsTotal)
	    {
	        for (var i = 0; i < this.curves.length; i++)
	        {
	            var curve = this.curves[i];

	            if (!curve.active)
	            {
	                continue;
	            }

	            curve.draw(graphics, pointsTotal);
	        }

	        return graphics;
	    },

	    ellipseTo: function (xRadius, yRadius, startAngle, endAngle, clockwise, rotation)
	    {
	        var ellipse = new EllipseCurve(0, 0, xRadius, yRadius, startAngle, endAngle, clockwise, rotation);

	        var end = this.getEndPoint(this._tmpVec2A);

	        var start = ellipse.getStartPoint(this._tmpVec2B);

	        end.subtract(start);

	        ellipse.x = end.x;
	        ellipse.y = end.y;

	        return this.add(ellipse);
	    },

	    fromJSON: function (data)
	    {

	        this.curves = [];
	        this.cacheLengths = [];

	        this.startPoint.set(data.x, data.y);

	        this.autoClose = data.autoClose;

	        for (var i = 0; i < data.curves.length; i++)
	        {
	            var curve = data.curves[i];

	            switch (curve.type)
	            {
	                case 'LineCurve':
	                    this.add(LineCurve.fromJSON(curve));
	                    break;

	                case 'EllipseCurve':
	                    this.add(EllipseCurve.fromJSON(curve));
	                    break;

	                case 'SplineCurve':
	                    this.add(SplineCurve.fromJSON(curve));
	                    break;

	                case 'CubicBezierCurve':
	                    this.add(CubicBezierCurve.fromJSON(curve));
	                    break;

	                case 'QuadraticBezierCurve':
	                    this.add(QuadraticBezierCurve.fromJSON(curve));
	                    break;
	            }
	        }

	        return this;
	    },

	    getBounds: function (out, accuracy)
	    {
	        if (out === undefined) { out = new Rectangle(); }
	        if (accuracy === undefined) { accuracy = 16; }

	        out.x = Number.MAX_VALUE;
	        out.y = Number.MAX_VALUE;

	        var bounds = new Rectangle();
	        var maxRight = MATH_CONST.MIN_SAFE_INTEGER;
	        var maxBottom = MATH_CONST.MIN_SAFE_INTEGER;

	        for (var i = 0; i < this.curves.length; i++)
	        {
	            var curve = this.curves[i];

	            if (!curve.active)
	            {
	                continue;
	            }

	            curve.getBounds(bounds, accuracy);

	            out.x = Math.min(out.x, bounds.x);
	            out.y = Math.min(out.y, bounds.y);

	            maxRight = Math.max(maxRight, bounds.right);
	            maxBottom = Math.max(maxBottom, bounds.bottom);
	        }

	        out.right = maxRight;
	        out.bottom = maxBottom;

	        return out;
	    },

	    getCurveLengths: function ()
	    {

	        if (this.cacheLengths.length === this.curves.length)
	        {
	            return this.cacheLengths;
	        }

	        var lengths = [];
	        var sums = 0;

	        for (var i = 0; i < this.curves.length; i++)
	        {
	            sums += this.curves[i].getLength();

	            lengths.push(sums);
	        }

	        this.cacheLengths = lengths;

	        return lengths;
	    },

	    getCurveAt: function (t)
	    {
	        var d = t * this.getLength();
	        var curveLengths = this.getCurveLengths();
	        var i = 0;

	        while (i < curveLengths.length)
	        {
	            if (curveLengths[i] >= d)
	            {
	                return this.curves[i];
	            }

	            i++;
	        }

	        return null;
	    },

	    getEndPoint: function (out)
	    {
	        if (out === undefined) { out = new Vector2(); }

	        if (this.curves.length > 0)
	        {
	            this.curves[this.curves.length - 1].getPoint(1, out);
	        }
	        else
	        {
	            out.copy(this.startPoint);
	        }

	        return out;
	    },

	    getLength: function ()
	    {
	        var lens = this.getCurveLengths();

	        return lens[lens.length - 1];
	    },

	    getPoint: function (t, out)
	    {
	        if (out === undefined) { out = new Vector2(); }

	        var d = t * this.getLength();
	        var curveLengths = this.getCurveLengths();
	        var i = 0;

	        while (i < curveLengths.length)
	        {
	            if (curveLengths[i] >= d)
	            {
	                var diff = curveLengths[i] - d;
	                var curve = this.curves[i];

	                var segmentLength = curve.getLength();
	                var u = (segmentLength === 0) ? 0 : 1 - diff / segmentLength;

	                return curve.getPointAt(u, out);
	            }

	            i++;
	        }

	        return null;
	    },

	    getPoints: function (divisions, stepRate)
	    {

	        if (!divisions && !stepRate)
	        {
	            divisions = this.defaultDivisions;
	        }

	        var points = [];
	        var last;

	        for (var i = 0; i < this.curves.length; i++)
	        {
	            var curve = this.curves[i];

	            if (!curve.active)
	            {
	                continue;
	            }

	            var resolution = curve.getResolution(divisions);

	            var pts = curve.getPoints(resolution, stepRate);

	            for (var j = 0; j < pts.length; j++)
	            {
	                var point = pts[j];

	                if (last && last.equals(point))
	                {

	                    continue;
	                }

	                points.push(point);

	                last = point;
	            }
	        }

	        if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0]))
	        {
	            points.push(points[0]);
	        }

	        return points;
	    },

	    getRandomPoint: function (out)
	    {
	        if (out === undefined) { out = new Vector2(); }

	        return this.getPoint(Math.random(), out);
	    },

	    getSpacedPoints: function (divisions)
	    {
	        if (divisions === undefined) { divisions = 40; }

	        var points = [];

	        for (var i = 0; i <= divisions; i++)
	        {
	            points.push(this.getPoint(i / divisions));
	        }

	        if (this.autoClose)
	        {
	            points.push(points[0]);
	        }

	        return points;
	    },

	    getStartPoint: function (out)
	    {
	        if (out === undefined) { out = new Vector2(); }

	        return out.copy(this.startPoint);
	    },

	    getTangent: function (t, out)
	    {
	        if (out === undefined) { out = new Vector2(); }

	        var d = t * this.getLength();
	        var curveLengths = this.getCurveLengths();
	        var i = 0;

	        while (i < curveLengths.length)
	        {
	            if (curveLengths[i] >= d)
	            {
	                var diff = curveLengths[i] - d;
	                var curve = this.curves[i];

	                var segmentLength = curve.getLength();
	                var u = (segmentLength === 0) ? 0 : 1 - diff / segmentLength;

	                return curve.getTangentAt(u, out);
	            }

	            i++;
	        }

	        return null;
	    },

	    lineTo: function (x, y)
	    {
	        if (x instanceof Vector2)
	        {
	            this._tmpVec2B.copy(x);
	        }
	        else if (typeof x === 'object')
	        {
	            this._tmpVec2B.setFromObject(x);
	        }
	        else
	        {
	            this._tmpVec2B.set(x, y);
	        }

	        var end = this.getEndPoint(this._tmpVec2A);

	        return this.add(new LineCurve([ end.x, end.y, this._tmpVec2B.x, this._tmpVec2B.y ]));
	    },

	    splineTo: function (points)
	    {
	        points.unshift(this.getEndPoint());

	        return this.add(new SplineCurve(points));
	    },

	    moveTo: function (x, y)
	    {
	        if (x instanceof Vector2)
	        {
	            return this.add(new MovePathTo(x.x, x.y));
	        }
	        else
	        {
	            return this.add(new MovePathTo(x, y));
	        }
	    },

	    toJSON: function ()
	    {
	        var out = [];

	        for (var i = 0; i < this.curves.length; i++)
	        {
	            out.push(this.curves[i].toJSON());
	        }

	        return {
	            type: 'Path',
	            x: this.startPoint.x,
	            y: this.startPoint.y,
	            autoClose: this.autoClose,
	            curves: out
	        };
	    },

	    updateArcLengths: function ()
	    {
	        this.cacheLengths = [];

	        this.getCurveLengths();
	    },

	    destroy: function ()
	    {
	        this.curves.length = 0;
	        this.cacheLengths.length = 0;
	        this.startPoint = undefined;
	    }

	});

	GameObjectFactory.register('path', function (x, y)
	{
	    return new Path(x, y);
	});

	Path_1 = Path;
	return Path_1;
}

var curves;
var hasRequiredCurves;

function requireCurves () {
	if (hasRequiredCurves) return curves;
	hasRequiredCurves = 1;
	curves = {
	    Path: requirePath(),
	    MoveTo: requireMoveTo(),

	    CubicBezier: requireCubicBezierCurve(),
	    Curve: requireCurve$1(),
	    Ellipse: requireEllipseCurve(),
	    Line: requireLineCurve(),
	    QuadraticBezier: requireQuadraticBezierCurve(),
	    Spline: requireSplineCurve()
	};
	return curves;
}

var DataManagerPlugin_1;
var hasRequiredDataManagerPlugin;

function requireDataManagerPlugin () {
	if (hasRequiredDataManagerPlugin) return DataManagerPlugin_1;
	hasRequiredDataManagerPlugin = 1;
	var Class = requireClass();
	var DataManager = requireDataManager();
	var PluginCache = requirePluginCache();
	var SceneEvents = requireEvents$l();

	var DataManagerPlugin = new Class({

	    Extends: DataManager,

	    initialize:

	    function DataManagerPlugin (scene)
	    {
	        DataManager.call(this, scene, scene.sys.events);

	        this.scene = scene;

	        this.systems = scene.sys;

	        scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
	        scene.sys.events.on(SceneEvents.START, this.start, this);
	    },

	    boot: function ()
	    {
	        this.events = this.systems.events;

	        this.events.once(SceneEvents.DESTROY, this.destroy, this);
	    },

	    start: function ()
	    {
	        this.events.once(SceneEvents.SHUTDOWN, this.shutdown, this);
	    },

	    shutdown: function ()
	    {
	        this.systems.events.off(SceneEvents.SHUTDOWN, this.shutdown, this);
	    },

	    destroy: function ()
	    {
	        DataManager.prototype.destroy.call(this);

	        this.events.off(SceneEvents.START, this.start, this);

	        this.scene = null;
	        this.systems = null;
	    }

	});

	PluginCache.register('DataManagerPlugin', DataManagerPlugin, 'data');

	DataManagerPlugin_1 = DataManagerPlugin;
	return DataManagerPlugin_1;
}

var data;
var hasRequiredData;

function requireData () {
	if (hasRequiredData) return data;
	hasRequiredData = 1;
	data = {

	    DataManager: requireDataManager(),
	    DataManagerPlugin: requireDataManagerPlugin(),
	    Events: requireEvents$k()

	};
	return data;
}

var _in;
var hasRequired_in;

function require_in () {
	if (hasRequired_in) return _in;
	hasRequired_in = 1;
	_in = {

	    BottomCenter: requireBottomCenter(),
	    BottomLeft: requireBottomLeft(),
	    BottomRight: requireBottomRight(),
	    Center: requireCenter(),
	    LeftCenter: requireLeftCenter(),
	    QuickSet: requireQuickSet(),
	    RightCenter: requireRightCenter(),
	    TopCenter: requireTopCenter(),
	    TopLeft: requireTopLeft(),
	    TopRight: requireTopRight()

	};
	return _in;
}

var to;
var hasRequiredTo;

function requireTo () {
	if (hasRequiredTo) return to;
	hasRequiredTo = 1;
	to = {

	    BottomCenter: requireBottomCenter$1(),
	    BottomLeft: requireBottomLeft$1(),
	    BottomRight: requireBottomRight$1(),
	    LeftBottom: requireLeftBottom(),
	    LeftCenter: requireLeftCenter$1(),
	    LeftTop: requireLeftTop(),
	    QuickSet: requireQuickSet$1(),
	    RightBottom: requireRightBottom(),
	    RightCenter: requireRightCenter$1(),
	    RightTop: requireRightTop(),
	    TopCenter: requireTopCenter$1(),
	    TopLeft: requireTopLeft$1(),
	    TopRight: requireTopRight$1()

	};
	return to;
}

var align;
var hasRequiredAlign;

function requireAlign () {
	if (hasRequiredAlign) return align;
	hasRequiredAlign = 1;
	var CONST = require_const$e();
	var Extend = requireExtend$1();

	var Align = {

	    In: require_in(),
	    To: requireTo()

	};

	Align = Extend(false, Align, CONST);

	align = Align;
	return align;
}

var BaseShader_1;
var hasRequiredBaseShader;

function requireBaseShader () {
	if (hasRequiredBaseShader) return BaseShader_1;
	hasRequiredBaseShader = 1;
	var Class = requireClass();

	var BaseShader = new Class({

	    initialize:

	    function BaseShader (key, fragmentSrc, vertexSrc, uniforms)
	    {
	        if (!fragmentSrc || fragmentSrc === '')
	        {
	            fragmentSrc = [
	                'precision mediump float;',

	                'uniform vec2 resolution;',

	                'varying vec2 fragCoord;',

	                'void main () {',
	                '    vec2 uv = fragCoord / resolution.xy;',
	                '    gl_FragColor = vec4(uv.xyx, 1.0);',
	                '}'
	            ].join('\n');
	        }

	        if (!vertexSrc || vertexSrc === '')
	        {
	            vertexSrc = [
	                'precision mediump float;',

	                'uniform mat4 uProjectionMatrix;',
	                'uniform mat4 uViewMatrix;',
	                'uniform vec2 uResolution;',

	                'attribute vec2 inPosition;',

	                'varying vec2 fragCoord;',
	                'varying vec2 outTexCoord;',

	                'void main () {',
	                '   gl_Position = uProjectionMatrix * uViewMatrix * vec4(inPosition, 1.0, 1.0);',
	                '   fragCoord = vec2(inPosition.x, uResolution.y - inPosition.y);',
	                '   outTexCoord = vec2(inPosition.x / uResolution.x, fragCoord.y / uResolution.y);',
	                '}'
	            ].join('\n');
	        }

	        if (uniforms === undefined) { uniforms = null; }

	        this.key = key;

	        this.fragmentSrc = fragmentSrc;

	        this.vertexSrc = vertexSrc;

	        this.uniforms = uniforms;
	    }

	});

	BaseShader_1 = BaseShader;
	return BaseShader_1;
}

var GetBounds_1$2;
var hasRequiredGetBounds$2;

function requireGetBounds$2 () {
	if (hasRequiredGetBounds$2) return GetBounds_1$2;
	hasRequiredGetBounds$2 = 1;
	var GetBottom = requireGetBottom();
	var GetLeft = requireGetLeft();
	var GetRight = requireGetRight();
	var GetTop = requireGetTop();
	var Rectangle = requireRectangle$2();

	var GetBounds = function (gameObject, output)
	{
	    if (output === undefined) { output = new Rectangle(); }

	    var left = GetLeft(gameObject);
	    var top = GetTop(gameObject);

	    output.x = left;
	    output.y = top;
	    output.width = GetRight(gameObject) - left;
	    output.height = GetBottom(gameObject) - top;

	    return output;
	};

	GetBounds_1$2 = GetBounds;
	return GetBounds_1$2;
}

var GetOffsetX_1;
var hasRequiredGetOffsetX;

function requireGetOffsetX () {
	if (hasRequiredGetOffsetX) return GetOffsetX_1;
	hasRequiredGetOffsetX = 1;
	var GetOffsetX = function (gameObject)
	{
	    return gameObject.width * gameObject.originX;
	};

	GetOffsetX_1 = GetOffsetX;
	return GetOffsetX_1;
}

var GetOffsetY_1;
var hasRequiredGetOffsetY;

function requireGetOffsetY () {
	if (hasRequiredGetOffsetY) return GetOffsetY_1;
	hasRequiredGetOffsetY = 1;
	var GetOffsetY = function (gameObject)
	{
	    return gameObject.height * gameObject.originY;
	};

	GetOffsetY_1 = GetOffsetY;
	return GetOffsetY_1;
}

var bounds;
var hasRequiredBounds;

function requireBounds () {
	if (hasRequiredBounds) return bounds;
	hasRequiredBounds = 1;
	bounds = {

	    CenterOn: requireCenterOn$3(),
	    GetBottom: requireGetBottom(),
	    GetBounds: requireGetBounds$2(),
	    GetCenterX: requireGetCenterX(),
	    GetCenterY: requireGetCenterY(),
	    GetLeft: requireGetLeft(),
	    GetOffsetX: requireGetOffsetX(),
	    GetOffsetY: requireGetOffsetY(),
	    GetRight: requireGetRight(),
	    GetTop: requireGetTop(),
	    SetBottom: requireSetBottom(),
	    SetCenterX: requireSetCenterX(),
	    SetCenterY: requireSetCenterY(),
	    SetLeft: requireSetLeft(),
	    SetRight: requireSetRight(),
	    SetTop: requireSetTop()

	};
	return bounds;
}

var TouchAction_1;
var hasRequiredTouchAction;

function requireTouchAction () {
	if (hasRequiredTouchAction) return TouchAction_1;
	hasRequiredTouchAction = 1;
	var TouchAction = function (canvas, value)
	{
	    if (value === undefined) { value = 'none'; }

	    canvas.style['msTouchAction'] = value;
	    canvas.style['ms-touch-action'] = value;
	    canvas.style['touch-action'] = value;

	    return canvas;
	};

	TouchAction_1 = TouchAction;
	return TouchAction_1;
}

var UserSelect_1;
var hasRequiredUserSelect;

function requireUserSelect () {
	if (hasRequiredUserSelect) return UserSelect_1;
	hasRequiredUserSelect = 1;
	var UserSelect = function (canvas, value)
	{
	    if (value === undefined) { value = 'none'; }

	    var vendors = [
	        '-webkit-',
	        '-khtml-',
	        '-moz-',
	        '-ms-',
	        ''
	    ];

	    vendors.forEach(function (vendor)
	    {
	        canvas.style[vendor + 'user-select'] = value;
	    });

	    canvas.style['-webkit-touch-callout'] = value;
	    canvas.style['-webkit-tap-highlight-color'] = 'rgba(0, 0, 0, 0)';

	    return canvas;
	};

	UserSelect_1 = UserSelect;
	return UserSelect_1;
}

var canvas$1;
var hasRequiredCanvas$2;

function requireCanvas$2 () {
	if (hasRequiredCanvas$2) return canvas$1;
	hasRequiredCanvas$2 = 1;
	canvas$1 = {

	    CanvasInterpolation: requireCanvasInterpolation(),
	    CanvasPool: requireCanvasPool(),
	    Smoothing: requireSmoothing(),
	    TouchAction: requireTouchAction(),
	    UserSelect: requireUserSelect()

	};
	return canvas$1;
}

var ColorSpectrum_1;
var hasRequiredColorSpectrum;

function requireColorSpectrum () {
	if (hasRequiredColorSpectrum) return ColorSpectrum_1;
	hasRequiredColorSpectrum = 1;
	var GetColor = requireGetColor();

	var ColorSpectrum = function (limit)
	{
	    if (limit === undefined) { limit = 1024; }

	    var colors = [];

	    var range = 255;

	    var i;
	    var r = 255;
	    var g = 0;
	    var b = 0;

	    for (i = 0; i <= range; i++)
	    {
	        colors.push({ r: r, g: i, b: b, color: GetColor(r, i, b) });
	    }

	    g = 255;

	    for (i = range; i >= 0; i--)
	    {
	        colors.push({ r: i, g: g, b: b, color: GetColor(i, g, b) });
	    }

	    r = 0;

	    for (i = 0; i <= range; i++, g--)
	    {
	        colors.push({ r: r, g: g, b: i, color: GetColor(r, g, i) });
	    }

	    g = 0;
	    b = 255;

	    for (i = 0; i <= range; i++, b--, r++)
	    {
	        colors.push({ r: r, g: g, b: b, color: GetColor(r, g, b) });
	    }

	    if (limit === 1024)
	    {
	        return colors;
	    }
	    else
	    {
	        var out = [];

	        var t = 0;
	        var inc = 1024 / limit;

	        for (i = 0; i < limit; i++)
	        {
	            out.push(colors[Math.floor(t)]);

	            t += inc;
	        }

	        return out;
	    }
	};

	ColorSpectrum_1 = ColorSpectrum;
	return ColorSpectrum_1;
}

var ColorToRGBA_1;
var hasRequiredColorToRGBA;

function requireColorToRGBA () {
	if (hasRequiredColorToRGBA) return ColorToRGBA_1;
	hasRequiredColorToRGBA = 1;
	var ColorToRGBA = function (color)
	{
	    var output = {
	        r: color >> 16 & 0xFF,
	        g: color >> 8 & 0xFF,
	        b: color & 0xFF,
	        a: 255
	    };

	    if (color > 16777215)
	    {
	        output.a = color >>> 24;
	    }

	    return output;
	};

	ColorToRGBA_1 = ColorToRGBA;
	return ColorToRGBA_1;
}

var ComponentToHex_1;
var hasRequiredComponentToHex;

function requireComponentToHex () {
	if (hasRequiredComponentToHex) return ComponentToHex_1;
	hasRequiredComponentToHex = 1;
	var ComponentToHex = function (color)
	{
	    var hex = color.toString(16);

	    return (hex.length === 1) ? '0' + hex : hex;
	};

	ComponentToHex_1 = ComponentToHex;
	return ComponentToHex_1;
}

var HueToComponent_1;
var hasRequiredHueToComponent;

function requireHueToComponent () {
	if (hasRequiredHueToComponent) return HueToComponent_1;
	hasRequiredHueToComponent = 1;
	var HueToComponent = function (p, q, t)
	{
	    if (t < 0)
	    {
	        t += 1;
	    }

	    if (t > 1)
	    {
	        t -= 1;
	    }

	    if (t < 1 / 6)
	    {
	        return p + (q - p) * 6 * t;
	    }

	    if (t < 1 / 2)
	    {
	        return q;
	    }

	    if (t < 2 / 3)
	    {
	        return p + (q - p) * (2 / 3 - t) * 6;
	    }

	    return p;
	};

	HueToComponent_1 = HueToComponent;
	return HueToComponent_1;
}

var HSLToColor_1;
var hasRequiredHSLToColor;

function requireHSLToColor () {
	if (hasRequiredHSLToColor) return HSLToColor_1;
	hasRequiredHSLToColor = 1;
	var Color = requireColor$1();
	var HueToComponent = requireHueToComponent();

	var HSLToColor = function (h, s, l)
	{

	    var r = l;
	    var g = l;
	    var b = l;

	    if (s !== 0)
	    {
	        var q = (l < 0.5) ? l * (1 + s) : l + s - l * s;
	        var p = 2 * l - q;

	        r = HueToComponent(p, q, h + 1 / 3);
	        g = HueToComponent(p, q, h);
	        b = HueToComponent(p, q, h - 1 / 3);
	    }

	    var color = new Color();

	    return color.setGLTo(r, g, b, 1);
	};

	HSLToColor_1 = HSLToColor;
	return HSLToColor_1;
}

var HSVColorWheel_1;
var hasRequiredHSVColorWheel;

function requireHSVColorWheel () {
	if (hasRequiredHSVColorWheel) return HSVColorWheel_1;
	hasRequiredHSVColorWheel = 1;
	var HSVToRGB = requireHSVToRGB();

	var HSVColorWheel = function (s, v)
	{
	    if (s === undefined) { s = 1; }
	    if (v === undefined) { v = 1; }

	    var colors = [];

	    for (var c = 0; c <= 359; c++)
	    {
	        colors.push(HSVToRGB(c / 359, s, v));
	    }

	    return colors;
	};

	HSVColorWheel_1 = HSVColorWheel;
	return HSVColorWheel_1;
}

var Interpolate;
var hasRequiredInterpolate$1;

function requireInterpolate$1 () {
	if (hasRequiredInterpolate$1) return Interpolate;
	hasRequiredInterpolate$1 = 1;
	var Linear = requireLinear();
	var GetColor = requireGetColor();

	var RGBWithRGB = function (r1, g1, b1, r2, g2, b2, length, index)
	{
	    if (length === undefined) { length = 100; }
	    if (index === undefined) { index = 0; }

	    var t = index / length;
	    var r = Linear(r1, r2, t);
	    var g = Linear(g1, g2, t);
	    var b = Linear(b1, b2, t);

	    return {
	        r: r,
	        g: g,
	        b: b,
	        a: 255,
	        color: GetColor(r, g, b)
	    };
	};

	var ColorWithColor = function (color1, color2, length, index)
	{
	    if (length === undefined) { length = 100; }
	    if (index === undefined) { index = 0; }

	    return RGBWithRGB(color1.r, color1.g, color1.b, color2.r, color2.g, color2.b, length, index);
	};

	var ColorWithRGB = function (color, r, g, b, length, index)
	{
	    if (length === undefined) { length = 100; }
	    if (index === undefined) { index = 0; }

	    return RGBWithRGB(color.r, color.g, color.b, r, g, b, length, index);
	};

	Interpolate = {

	    RGBWithRGB: RGBWithRGB,
	    ColorWithRGB: ColorWithRGB,
	    ColorWithColor: ColorWithColor

	};
	return Interpolate;
}

var RandomRGB_1;
var hasRequiredRandomRGB;

function requireRandomRGB () {
	if (hasRequiredRandomRGB) return RandomRGB_1;
	hasRequiredRandomRGB = 1;
	var Between = requireBetween$1();
	var Color = requireColor$1();

	var RandomRGB = function (min, max)
	{
	    if (min === undefined) { min = 0; }
	    if (max === undefined) { max = 255; }

	    return new Color(Between(min, max), Between(min, max), Between(min, max));
	};

	RandomRGB_1 = RandomRGB;
	return RandomRGB_1;
}

var RGBToString_1;
var hasRequiredRGBToString;

function requireRGBToString () {
	if (hasRequiredRGBToString) return RGBToString_1;
	hasRequiredRGBToString = 1;
	var ComponentToHex = requireComponentToHex();

	var RGBToString = function (r, g, b, a, prefix)
	{
	    if (a === undefined) { a = 255; }
	    if (prefix === undefined) { prefix = '#'; }

	    if (prefix === '#')
	    {
	        return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1, 7);
	    }
	    else
	    {
	        return '0x' + ComponentToHex(a) + ComponentToHex(r) + ComponentToHex(g) + ComponentToHex(b);
	    }
	};

	RGBToString_1 = RGBToString;
	return RGBToString_1;
}

var color;
var hasRequiredColor;

function requireColor () {
	if (hasRequiredColor) return color;
	hasRequiredColor = 1;
	var Color = requireColor$1();

	Color.ColorSpectrum = requireColorSpectrum();
	Color.ColorToRGBA = requireColorToRGBA();
	Color.ComponentToHex = requireComponentToHex();
	Color.GetColor = requireGetColor();
	Color.GetColor32 = requireGetColor32();
	Color.HexStringToColor = requireHexStringToColor();
	Color.HSLToColor = requireHSLToColor();
	Color.HSVColorWheel = requireHSVColorWheel();
	Color.HSVToRGB = requireHSVToRGB();
	Color.HueToComponent = requireHueToComponent();
	Color.IntegerToColor = requireIntegerToColor();
	Color.IntegerToRGB = requireIntegerToRGB();
	Color.Interpolate = requireInterpolate$1();
	Color.ObjectToColor = requireObjectToColor();
	Color.RandomRGB = requireRandomRGB();
	Color.RGBStringToColor = requireRGBStringToColor();
	Color.RGBToHSV = requireRGBToHSV();
	Color.RGBToString = requireRGBToString();
	Color.ValueToColor = requireValueToColor();

	color = Color;
	return color;
}

var mask;
var hasRequiredMask;

function requireMask () {
	if (hasRequiredMask) return mask;
	hasRequiredMask = 1;
	mask = {

	    BitmapMask: requireBitmapMask(),
	    GeometryMask: requireGeometryMask()

	};
	return mask;
}

var RGB_1;
var hasRequiredRGB;

function requireRGB () {
	if (hasRequiredRGB) return RGB_1;
	hasRequiredRGB = 1;
	var Class = requireClass();
	var NOOP = requireNOOP();

	var RGB = new Class({

	    initialize:

	    function RGB (red, green, blue)
	    {

	        this._rgb = [ 0, 0, 0 ];

	        this.onChangeCallback = NOOP;

	        this.dirty = false;

	        this.set(red, green, blue);
	    },

	    set: function (red, green, blue)
	    {
	        if (red === undefined) { red = 0; }
	        if (green === undefined) { green = 0; }
	        if (blue === undefined) { blue = 0; }

	        this._rgb = [ red, green, blue ];

	        this.onChange();

	        return this;
	    },

	    equals: function (red, green, blue)
	    {
	        var rgb = this._rgb;

	        return (rgb[0] === red && rgb[1] === green && rgb[2] === blue);
	    },

	    onChange: function ()
	    {
	        this.dirty = true;

	        var rgb = this._rgb;

	        this.onChangeCallback.call(this, rgb[0], rgb[1], rgb[2]);
	    },

	    r: {

	        get: function ()
	        {
	            return this._rgb[0];
	        },

	        set: function (value)
	        {
	            this._rgb[0] = value;
	            this.onChange();
	        }

	    },

	    g: {

	        get: function ()
	        {
	            return this._rgb[1];
	        },

	        set: function (value)
	        {
	            this._rgb[1] = value;
	            this.onChange();
	        }

	    },

	    b: {

	        get: function ()
	        {
	            return this._rgb[2];
	        },

	        set: function (value)
	        {
	            this._rgb[2] = value;
	            this.onChange();
	        }

	    },

	    destroy: function ()
	    {
	        this.onChangeCallback = null;
	    }

	});

	RGB_1 = RGB;
	return RGB_1;
}

var display;
var hasRequiredDisplay;

function requireDisplay () {
	if (hasRequiredDisplay) return display;
	hasRequiredDisplay = 1;
	display = {

	    Align: requireAlign(),
	    BaseShader: requireBaseShader(),
	    Bounds: requireBounds(),
	    Canvas: requireCanvas$2(),
	    Color: requireColor(),
	    ColorMatrix: requireColorMatrix$1(),
	    Masks: requireMask(),
	    RGB: requireRGB()

	};
	return display;
}

var AddToDOM_1;
var hasRequiredAddToDOM;

function requireAddToDOM () {
	if (hasRequiredAddToDOM) return AddToDOM_1;
	hasRequiredAddToDOM = 1;
	var AddToDOM = function (element, parent)
	{
	    var target;

	    if (parent)
	    {
	        if (typeof parent === 'string')
	        {

	            target = document.getElementById(parent);
	        }
	        else if (typeof parent === 'object' && parent.nodeType === 1)
	        {

	            target = parent;
	        }
	    }
	    else if (element.parentElement || parent === null)
	    {
	        return element;
	    }

	    if (!target)
	    {
	        target = document.body;
	    }

	    target.appendChild(element);

	    return element;
	};

	AddToDOM_1 = AddToDOM;
	return AddToDOM_1;
}

var DOMContentLoaded_1;
var hasRequiredDOMContentLoaded;

function requireDOMContentLoaded () {
	if (hasRequiredDOMContentLoaded) return DOMContentLoaded_1;
	hasRequiredDOMContentLoaded = 1;
	var OS = requireOS();

	var DOMContentLoaded = function (callback)
	{
	    if (document.readyState === 'complete' || document.readyState === 'interactive')
	    {
	        callback();

	        return;
	    }

	    var check = function ()
	    {
	        document.removeEventListener('deviceready', check, true);
	        document.removeEventListener('DOMContentLoaded', check, true);
	        window.removeEventListener('load', check, true);

	        callback();
	    };

	    if (!document.body)
	    {
	        window.setTimeout(check, 20);
	    }
	    else if (OS.cordova)
	    {

	        document.addEventListener('deviceready', check, false);
	    }
	    else
	    {
	        document.addEventListener('DOMContentLoaded', check, true);
	        window.addEventListener('load', check, true);
	    }
	};

	DOMContentLoaded_1 = DOMContentLoaded;
	return DOMContentLoaded_1;
}

var GetInnerHeight_1;
var hasRequiredGetInnerHeight;

function requireGetInnerHeight () {
	if (hasRequiredGetInnerHeight) return GetInnerHeight_1;
	hasRequiredGetInnerHeight = 1;
	var GetInnerHeight = function (iOS)
	{

	    if (!iOS)
	    {
	        return window.innerHeight;
	    }

	    var axis = Math.abs(window.orientation);

	    var size = { w: 0, h: 0 };

	    var ruler = document.createElement('div');

	    ruler.setAttribute('style', 'position: fixed; height: 100vh; width: 0; top: 0');

	    document.documentElement.appendChild(ruler);

	    size.w = (axis === 90) ? ruler.offsetHeight : window.innerWidth;
	    size.h = (axis === 90) ? window.innerWidth : ruler.offsetHeight;

	    document.documentElement.removeChild(ruler);

	    ruler = null;

	    if (Math.abs(window.orientation) !== 90)
	    {
	        return size.h;
	    }
	    else
	    {
	        return size.w;
	    }
	};

	GetInnerHeight_1 = GetInnerHeight;
	return GetInnerHeight_1;
}

var CENTER_CONST;
var hasRequiredCENTER_CONST;

function requireCENTER_CONST () {
	if (hasRequiredCENTER_CONST) return CENTER_CONST;
	hasRequiredCENTER_CONST = 1;
	CENTER_CONST = {

	    NO_CENTER: 0,

	    CENTER_BOTH: 1,

	    CENTER_HORIZONTALLY: 2,

	    CENTER_VERTICALLY: 3

	};
	return CENTER_CONST;
}

var ORIENTATION_CONST$1;
var hasRequiredORIENTATION_CONST$1;

function requireORIENTATION_CONST$1 () {
	if (hasRequiredORIENTATION_CONST$1) return ORIENTATION_CONST$1;
	hasRequiredORIENTATION_CONST$1 = 1;
	ORIENTATION_CONST$1 = {

	    LANDSCAPE: 'landscape-primary',

	    LANDSCAPE_SECONDARY: 'landscape-secondary',

	    PORTRAIT: 'portrait-primary',

	    PORTRAIT_SECONDARY: 'portrait-secondary'

	};
	return ORIENTATION_CONST$1;
}

var SCALE_MODE_CONST;
var hasRequiredSCALE_MODE_CONST;

function requireSCALE_MODE_CONST () {
	if (hasRequiredSCALE_MODE_CONST) return SCALE_MODE_CONST;
	hasRequiredSCALE_MODE_CONST = 1;
	SCALE_MODE_CONST = {

	    NONE: 0,

	    WIDTH_CONTROLS_HEIGHT: 1,

	    HEIGHT_CONTROLS_WIDTH: 2,

	    FIT: 3,

	    ENVELOP: 4,

	    RESIZE: 5,

	    EXPAND: 6

	};
	return SCALE_MODE_CONST;
}

var ZOOM_CONST;
var hasRequiredZOOM_CONST;

function requireZOOM_CONST () {
	if (hasRequiredZOOM_CONST) return ZOOM_CONST;
	hasRequiredZOOM_CONST = 1;
	ZOOM_CONST = {

	    NO_ZOOM: 1,

	    ZOOM_2X: 2,

	    ZOOM_4X: 4,

	    MAX_ZOOM: -1

	};
	return ZOOM_CONST;
}

var _const$7;
var hasRequired_const$7;

function require_const$7 () {
	if (hasRequired_const$7) return _const$7;
	hasRequired_const$7 = 1;
	var CONST = {

	    CENTER: requireCENTER_CONST(),
	    ORIENTATION: requireORIENTATION_CONST$1(),
	    SCALE_MODE: requireSCALE_MODE_CONST(),
	    ZOOM: requireZOOM_CONST()

	};

	_const$7 = CONST;
	return _const$7;
}

var GetScreenOrientation_1;
var hasRequiredGetScreenOrientation;

function requireGetScreenOrientation () {
	if (hasRequiredGetScreenOrientation) return GetScreenOrientation_1;
	hasRequiredGetScreenOrientation = 1;
	var CONST = require_const$7();

	var GetScreenOrientation = function (width, height)
	{
	    var screen = window.screen;
	    var orientation = (screen) ? screen.orientation || screen.mozOrientation || screen.msOrientation : false;

	    if (orientation && typeof orientation.type === 'string')
	    {

	        return orientation.type;
	    }
	    else if (typeof orientation === 'string')
	    {

	        return orientation;
	    }

	    if (typeof window.orientation === 'number')
	    {

	        return (window.orientation === 0 || window.orientation === 180) ? CONST.ORIENTATION.PORTRAIT : CONST.ORIENTATION.LANDSCAPE;
	    }
	    else if (window.matchMedia)
	    {
	        if (window.matchMedia('(orientation: portrait)').matches)
	        {
	            return CONST.ORIENTATION.PORTRAIT;
	        }
	        else if (window.matchMedia('(orientation: landscape)').matches)
	        {
	            return CONST.ORIENTATION.LANDSCAPE;
	        }
	    }
	    else
	    {
	        return (height > width) ? CONST.ORIENTATION.PORTRAIT : CONST.ORIENTATION.LANDSCAPE;
	    }
	};

	GetScreenOrientation_1 = GetScreenOrientation;
	return GetScreenOrientation_1;
}

var GetTarget_1;
var hasRequiredGetTarget;

function requireGetTarget () {
	if (hasRequiredGetTarget) return GetTarget_1;
	hasRequiredGetTarget = 1;
	var GetTarget = function (element)
	{
	    var target;

	    if (element !== '')
	    {
	        if (typeof element === 'string')
	        {

	            target = document.getElementById(element);
	        }
	        else if (element && element.nodeType === 1)
	        {

	            target = element;
	        }
	    }

	    if (!target)
	    {

	        target = document.body;
	    }

	    return target;
	};

	GetTarget_1 = GetTarget;
	return GetTarget_1;
}

var ParseXML_1;
var hasRequiredParseXML;

function requireParseXML () {
	if (hasRequiredParseXML) return ParseXML_1;
	hasRequiredParseXML = 1;
	var ParseXML = function (data)
	{
	    var xml = '';

	    try
	    {
	        if (window['DOMParser'])
	        {
	            var domparser = new DOMParser();
	            xml = domparser.parseFromString(data, 'text/xml');
	        }
	        else
	        {
	            xml = new ActiveXObject('Microsoft.XMLDOM');
	            xml.loadXML(data);
	        }
	    }
	    catch (e)
	    {
	        xml = null;
	    }

	    if (!xml || !xml.documentElement || xml.getElementsByTagName('parsererror').length)
	    {
	        return null;
	    }
	    else
	    {
	        return xml;
	    }
	};

	ParseXML_1 = ParseXML;
	return ParseXML_1;
}

var RemoveFromDOM_1;
var hasRequiredRemoveFromDOM;

function requireRemoveFromDOM () {
	if (hasRequiredRemoveFromDOM) return RemoveFromDOM_1;
	hasRequiredRemoveFromDOM = 1;
	var RemoveFromDOM = function (element)
	{
	    if (element.parentNode)
	    {
	        element.parentNode.removeChild(element);
	    }
	};

	RemoveFromDOM_1 = RemoveFromDOM;
	return RemoveFromDOM_1;
}

var dom;
var hasRequiredDom;

function requireDom () {
	if (hasRequiredDom) return dom;
	hasRequiredDom = 1;
	var Dom = {

	    AddToDOM: requireAddToDOM(),
	    DOMContentLoaded: requireDOMContentLoaded(),
	    GetInnerHeight: requireGetInnerHeight(),
	    GetScreenOrientation: requireGetScreenOrientation(),
	    GetTarget: requireGetTarget(),
	    ParseXML: requireParseXML(),
	    RemoveFromDOM: requireRemoveFromDOM(),
	    RequestAnimationFrame: requireRequestAnimationFrame()

	};

	dom = Dom;
	return dom;
}

var EventEmitter_1;
var hasRequiredEventEmitter;

function requireEventEmitter () {
	if (hasRequiredEventEmitter) return EventEmitter_1;
	hasRequiredEventEmitter = 1;
	var Class = requireClass();
	var EE = requireEventemitter3();
	var PluginCache = requirePluginCache();

	var EventEmitter = new Class({

	    Extends: EE,

	    initialize:

	    function EventEmitter ()
	    {
	        EE.call(this);
	    },

	    shutdown: function ()
	    {
	        this.removeAllListeners();
	    },

	    destroy: function ()
	    {
	        this.removeAllListeners();
	    }

	});

	PluginCache.register('EventEmitter', EventEmitter, 'events');

	EventEmitter_1 = EventEmitter;
	return EventEmitter_1;
}

var events$a;
var hasRequiredEvents$a;

function requireEvents$a () {
	if (hasRequiredEvents$a) return events$a;
	hasRequiredEvents$a = 1;
	events$a = { EventEmitter: requireEventEmitter() };
	return events$a;
}

var CreateDOMContainer_1;
var hasRequiredCreateDOMContainer;

function requireCreateDOMContainer () {
	if (hasRequiredCreateDOMContainer) return CreateDOMContainer_1;
	hasRequiredCreateDOMContainer = 1;
	var AddToDOM = requireAddToDOM();

	var CreateDOMContainer = function (game)
	{
	    var config = game.config;

	    if (!config.parent || !config.domCreateContainer)
	    {
	        return;
	    }

	    var div = document.createElement('div');

	    div.style.cssText = [
	        'display: block;',
	        'width: ' + game.scale.width + 'px;',
	        'height: ' + game.scale.height + 'px;',
	        'padding: 0; margin: 0;',
	        'position: absolute;',
	        'overflow: hidden;',
	        'pointer-events: ' + config.domPointerEvents + ';',
	        'transform: scale(1);',
	        'transform-origin: left top;'
	    ].join(' ');

	    game.domContainer = div;

	    AddToDOM(div, config.parent);
	};

	CreateDOMContainer_1 = CreateDOMContainer;
	return CreateDOMContainer_1;
}

var _const$6;
var hasRequired_const$6;

function require_const$6 () {
	if (hasRequired_const$6) return _const$6;
	hasRequired_const$6 = 1;
	var INPUT_CONST = {

	    MOUSE_DOWN: 0,

	    MOUSE_MOVE: 1,

	    MOUSE_UP: 2,

	    TOUCH_START: 3,

	    TOUCH_MOVE: 4,

	    TOUCH_END: 5,

	    POINTER_LOCK_CHANGE: 6,

	    TOUCH_CANCEL: 7,

	    MOUSE_WHEEL: 8

	};

	_const$6 = INPUT_CONST;
	return _const$6;
}

var BOOT_EVENT;
var hasRequiredBOOT_EVENT;

function requireBOOT_EVENT () {
	if (hasRequiredBOOT_EVENT) return BOOT_EVENT;
	hasRequiredBOOT_EVENT = 1;
	BOOT_EVENT = 'boot';
	return BOOT_EVENT;
}

var DESTROY_EVENT$1;
var hasRequiredDESTROY_EVENT$1;

function requireDESTROY_EVENT$1 () {
	if (hasRequiredDESTROY_EVENT$1) return DESTROY_EVENT$1;
	hasRequiredDESTROY_EVENT$1 = 1;
	DESTROY_EVENT$1 = 'destroy';
	return DESTROY_EVENT$1;
}

var DRAG_END_EVENT;
var hasRequiredDRAG_END_EVENT;

function requireDRAG_END_EVENT () {
	if (hasRequiredDRAG_END_EVENT) return DRAG_END_EVENT;
	hasRequiredDRAG_END_EVENT = 1;
	DRAG_END_EVENT = 'dragend';
	return DRAG_END_EVENT;
}

var DRAG_ENTER_EVENT;
var hasRequiredDRAG_ENTER_EVENT;

function requireDRAG_ENTER_EVENT () {
	if (hasRequiredDRAG_ENTER_EVENT) return DRAG_ENTER_EVENT;
	hasRequiredDRAG_ENTER_EVENT = 1;
	DRAG_ENTER_EVENT = 'dragenter';
	return DRAG_ENTER_EVENT;
}

var DRAG_EVENT;
var hasRequiredDRAG_EVENT;

function requireDRAG_EVENT () {
	if (hasRequiredDRAG_EVENT) return DRAG_EVENT;
	hasRequiredDRAG_EVENT = 1;
	DRAG_EVENT = 'drag';
	return DRAG_EVENT;
}

var DRAG_LEAVE_EVENT;
var hasRequiredDRAG_LEAVE_EVENT;

function requireDRAG_LEAVE_EVENT () {
	if (hasRequiredDRAG_LEAVE_EVENT) return DRAG_LEAVE_EVENT;
	hasRequiredDRAG_LEAVE_EVENT = 1;
	DRAG_LEAVE_EVENT = 'dragleave';
	return DRAG_LEAVE_EVENT;
}

var DRAG_OVER_EVENT;
var hasRequiredDRAG_OVER_EVENT;

function requireDRAG_OVER_EVENT () {
	if (hasRequiredDRAG_OVER_EVENT) return DRAG_OVER_EVENT;
	hasRequiredDRAG_OVER_EVENT = 1;
	DRAG_OVER_EVENT = 'dragover';
	return DRAG_OVER_EVENT;
}

var DRAG_START_EVENT;
var hasRequiredDRAG_START_EVENT;

function requireDRAG_START_EVENT () {
	if (hasRequiredDRAG_START_EVENT) return DRAG_START_EVENT;
	hasRequiredDRAG_START_EVENT = 1;
	DRAG_START_EVENT = 'dragstart';
	return DRAG_START_EVENT;
}

var DROP_EVENT;
var hasRequiredDROP_EVENT;

function requireDROP_EVENT () {
	if (hasRequiredDROP_EVENT) return DROP_EVENT;
	hasRequiredDROP_EVENT = 1;
	DROP_EVENT = 'drop';
	return DROP_EVENT;
}

var GAME_OUT_EVENT;
var hasRequiredGAME_OUT_EVENT;

function requireGAME_OUT_EVENT () {
	if (hasRequiredGAME_OUT_EVENT) return GAME_OUT_EVENT;
	hasRequiredGAME_OUT_EVENT = 1;
	GAME_OUT_EVENT = 'gameout';
	return GAME_OUT_EVENT;
}

var GAME_OVER_EVENT;
var hasRequiredGAME_OVER_EVENT;

function requireGAME_OVER_EVENT () {
	if (hasRequiredGAME_OVER_EVENT) return GAME_OVER_EVENT;
	hasRequiredGAME_OVER_EVENT = 1;
	GAME_OVER_EVENT = 'gameover';
	return GAME_OVER_EVENT;
}

var GAMEOBJECT_DOWN_EVENT;
var hasRequiredGAMEOBJECT_DOWN_EVENT;

function requireGAMEOBJECT_DOWN_EVENT () {
	if (hasRequiredGAMEOBJECT_DOWN_EVENT) return GAMEOBJECT_DOWN_EVENT;
	hasRequiredGAMEOBJECT_DOWN_EVENT = 1;
	GAMEOBJECT_DOWN_EVENT = 'gameobjectdown';
	return GAMEOBJECT_DOWN_EVENT;
}

var GAMEOBJECT_DRAG_END_EVENT;
var hasRequiredGAMEOBJECT_DRAG_END_EVENT;

function requireGAMEOBJECT_DRAG_END_EVENT () {
	if (hasRequiredGAMEOBJECT_DRAG_END_EVENT) return GAMEOBJECT_DRAG_END_EVENT;
	hasRequiredGAMEOBJECT_DRAG_END_EVENT = 1;
	GAMEOBJECT_DRAG_END_EVENT = 'dragend';
	return GAMEOBJECT_DRAG_END_EVENT;
}

var GAMEOBJECT_DRAG_ENTER_EVENT;
var hasRequiredGAMEOBJECT_DRAG_ENTER_EVENT;

function requireGAMEOBJECT_DRAG_ENTER_EVENT () {
	if (hasRequiredGAMEOBJECT_DRAG_ENTER_EVENT) return GAMEOBJECT_DRAG_ENTER_EVENT;
	hasRequiredGAMEOBJECT_DRAG_ENTER_EVENT = 1;
	GAMEOBJECT_DRAG_ENTER_EVENT = 'dragenter';
	return GAMEOBJECT_DRAG_ENTER_EVENT;
}

var GAMEOBJECT_DRAG_EVENT;
var hasRequiredGAMEOBJECT_DRAG_EVENT;

function requireGAMEOBJECT_DRAG_EVENT () {
	if (hasRequiredGAMEOBJECT_DRAG_EVENT) return GAMEOBJECT_DRAG_EVENT;
	hasRequiredGAMEOBJECT_DRAG_EVENT = 1;
	GAMEOBJECT_DRAG_EVENT = 'drag';
	return GAMEOBJECT_DRAG_EVENT;
}

var GAMEOBJECT_DRAG_LEAVE_EVENT;
var hasRequiredGAMEOBJECT_DRAG_LEAVE_EVENT;

function requireGAMEOBJECT_DRAG_LEAVE_EVENT () {
	if (hasRequiredGAMEOBJECT_DRAG_LEAVE_EVENT) return GAMEOBJECT_DRAG_LEAVE_EVENT;
	hasRequiredGAMEOBJECT_DRAG_LEAVE_EVENT = 1;
	GAMEOBJECT_DRAG_LEAVE_EVENT = 'dragleave';
	return GAMEOBJECT_DRAG_LEAVE_EVENT;
}

var GAMEOBJECT_DRAG_OVER_EVENT;
var hasRequiredGAMEOBJECT_DRAG_OVER_EVENT;

function requireGAMEOBJECT_DRAG_OVER_EVENT () {
	if (hasRequiredGAMEOBJECT_DRAG_OVER_EVENT) return GAMEOBJECT_DRAG_OVER_EVENT;
	hasRequiredGAMEOBJECT_DRAG_OVER_EVENT = 1;
	GAMEOBJECT_DRAG_OVER_EVENT = 'dragover';
	return GAMEOBJECT_DRAG_OVER_EVENT;
}

var GAMEOBJECT_DRAG_START_EVENT;
var hasRequiredGAMEOBJECT_DRAG_START_EVENT;

function requireGAMEOBJECT_DRAG_START_EVENT () {
	if (hasRequiredGAMEOBJECT_DRAG_START_EVENT) return GAMEOBJECT_DRAG_START_EVENT;
	hasRequiredGAMEOBJECT_DRAG_START_EVENT = 1;
	GAMEOBJECT_DRAG_START_EVENT = 'dragstart';
	return GAMEOBJECT_DRAG_START_EVENT;
}

var GAMEOBJECT_DROP_EVENT;
var hasRequiredGAMEOBJECT_DROP_EVENT;

function requireGAMEOBJECT_DROP_EVENT () {
	if (hasRequiredGAMEOBJECT_DROP_EVENT) return GAMEOBJECT_DROP_EVENT;
	hasRequiredGAMEOBJECT_DROP_EVENT = 1;
	GAMEOBJECT_DROP_EVENT = 'drop';
	return GAMEOBJECT_DROP_EVENT;
}

var GAMEOBJECT_MOVE_EVENT;
var hasRequiredGAMEOBJECT_MOVE_EVENT;

function requireGAMEOBJECT_MOVE_EVENT () {
	if (hasRequiredGAMEOBJECT_MOVE_EVENT) return GAMEOBJECT_MOVE_EVENT;
	hasRequiredGAMEOBJECT_MOVE_EVENT = 1;
	GAMEOBJECT_MOVE_EVENT = 'gameobjectmove';
	return GAMEOBJECT_MOVE_EVENT;
}

var GAMEOBJECT_OUT_EVENT;
var hasRequiredGAMEOBJECT_OUT_EVENT;

function requireGAMEOBJECT_OUT_EVENT () {
	if (hasRequiredGAMEOBJECT_OUT_EVENT) return GAMEOBJECT_OUT_EVENT;
	hasRequiredGAMEOBJECT_OUT_EVENT = 1;
	GAMEOBJECT_OUT_EVENT = 'gameobjectout';
	return GAMEOBJECT_OUT_EVENT;
}

var GAMEOBJECT_OVER_EVENT;
var hasRequiredGAMEOBJECT_OVER_EVENT;

function requireGAMEOBJECT_OVER_EVENT () {
	if (hasRequiredGAMEOBJECT_OVER_EVENT) return GAMEOBJECT_OVER_EVENT;
	hasRequiredGAMEOBJECT_OVER_EVENT = 1;
	GAMEOBJECT_OVER_EVENT = 'gameobjectover';
	return GAMEOBJECT_OVER_EVENT;
}

var GAMEOBJECT_POINTER_DOWN_EVENT;
var hasRequiredGAMEOBJECT_POINTER_DOWN_EVENT;

function requireGAMEOBJECT_POINTER_DOWN_EVENT () {
	if (hasRequiredGAMEOBJECT_POINTER_DOWN_EVENT) return GAMEOBJECT_POINTER_DOWN_EVENT;
	hasRequiredGAMEOBJECT_POINTER_DOWN_EVENT = 1;
	GAMEOBJECT_POINTER_DOWN_EVENT = 'pointerdown';
	return GAMEOBJECT_POINTER_DOWN_EVENT;
}

var GAMEOBJECT_POINTER_MOVE_EVENT;
var hasRequiredGAMEOBJECT_POINTER_MOVE_EVENT;

function requireGAMEOBJECT_POINTER_MOVE_EVENT () {
	if (hasRequiredGAMEOBJECT_POINTER_MOVE_EVENT) return GAMEOBJECT_POINTER_MOVE_EVENT;
	hasRequiredGAMEOBJECT_POINTER_MOVE_EVENT = 1;
	GAMEOBJECT_POINTER_MOVE_EVENT = 'pointermove';
	return GAMEOBJECT_POINTER_MOVE_EVENT;
}

var GAMEOBJECT_POINTER_OUT_EVENT;
var hasRequiredGAMEOBJECT_POINTER_OUT_EVENT;

function requireGAMEOBJECT_POINTER_OUT_EVENT () {
	if (hasRequiredGAMEOBJECT_POINTER_OUT_EVENT) return GAMEOBJECT_POINTER_OUT_EVENT;
	hasRequiredGAMEOBJECT_POINTER_OUT_EVENT = 1;
	GAMEOBJECT_POINTER_OUT_EVENT = 'pointerout';
	return GAMEOBJECT_POINTER_OUT_EVENT;
}

var GAMEOBJECT_POINTER_OVER_EVENT;
var hasRequiredGAMEOBJECT_POINTER_OVER_EVENT;

function requireGAMEOBJECT_POINTER_OVER_EVENT () {
	if (hasRequiredGAMEOBJECT_POINTER_OVER_EVENT) return GAMEOBJECT_POINTER_OVER_EVENT;
	hasRequiredGAMEOBJECT_POINTER_OVER_EVENT = 1;
	GAMEOBJECT_POINTER_OVER_EVENT = 'pointerover';
	return GAMEOBJECT_POINTER_OVER_EVENT;
}

var GAMEOBJECT_POINTER_UP_EVENT;
var hasRequiredGAMEOBJECT_POINTER_UP_EVENT;

function requireGAMEOBJECT_POINTER_UP_EVENT () {
	if (hasRequiredGAMEOBJECT_POINTER_UP_EVENT) return GAMEOBJECT_POINTER_UP_EVENT;
	hasRequiredGAMEOBJECT_POINTER_UP_EVENT = 1;
	GAMEOBJECT_POINTER_UP_EVENT = 'pointerup';
	return GAMEOBJECT_POINTER_UP_EVENT;
}

var GAMEOBJECT_POINTER_WHEEL_EVENT;
var hasRequiredGAMEOBJECT_POINTER_WHEEL_EVENT;

function requireGAMEOBJECT_POINTER_WHEEL_EVENT () {
	if (hasRequiredGAMEOBJECT_POINTER_WHEEL_EVENT) return GAMEOBJECT_POINTER_WHEEL_EVENT;
	hasRequiredGAMEOBJECT_POINTER_WHEEL_EVENT = 1;
	GAMEOBJECT_POINTER_WHEEL_EVENT = 'wheel';
	return GAMEOBJECT_POINTER_WHEEL_EVENT;
}

var GAMEOBJECT_UP_EVENT;
var hasRequiredGAMEOBJECT_UP_EVENT;

function requireGAMEOBJECT_UP_EVENT () {
	if (hasRequiredGAMEOBJECT_UP_EVENT) return GAMEOBJECT_UP_EVENT;
	hasRequiredGAMEOBJECT_UP_EVENT = 1;
	GAMEOBJECT_UP_EVENT = 'gameobjectup';
	return GAMEOBJECT_UP_EVENT;
}

var GAMEOBJECT_WHEEL_EVENT;
var hasRequiredGAMEOBJECT_WHEEL_EVENT;

function requireGAMEOBJECT_WHEEL_EVENT () {
	if (hasRequiredGAMEOBJECT_WHEEL_EVENT) return GAMEOBJECT_WHEEL_EVENT;
	hasRequiredGAMEOBJECT_WHEEL_EVENT = 1;
	GAMEOBJECT_WHEEL_EVENT = 'gameobjectwheel';
	return GAMEOBJECT_WHEEL_EVENT;
}

var MANAGER_BOOT_EVENT;
var hasRequiredMANAGER_BOOT_EVENT;

function requireMANAGER_BOOT_EVENT () {
	if (hasRequiredMANAGER_BOOT_EVENT) return MANAGER_BOOT_EVENT;
	hasRequiredMANAGER_BOOT_EVENT = 1;
	MANAGER_BOOT_EVENT = 'boot';
	return MANAGER_BOOT_EVENT;
}

var MANAGER_PROCESS_EVENT;
var hasRequiredMANAGER_PROCESS_EVENT;

function requireMANAGER_PROCESS_EVENT () {
	if (hasRequiredMANAGER_PROCESS_EVENT) return MANAGER_PROCESS_EVENT;
	hasRequiredMANAGER_PROCESS_EVENT = 1;
	MANAGER_PROCESS_EVENT = 'process';
	return MANAGER_PROCESS_EVENT;
}

var MANAGER_UPDATE_EVENT;
var hasRequiredMANAGER_UPDATE_EVENT;

function requireMANAGER_UPDATE_EVENT () {
	if (hasRequiredMANAGER_UPDATE_EVENT) return MANAGER_UPDATE_EVENT;
	hasRequiredMANAGER_UPDATE_EVENT = 1;
	MANAGER_UPDATE_EVENT = 'update';
	return MANAGER_UPDATE_EVENT;
}

var POINTER_DOWN_EVENT;
var hasRequiredPOINTER_DOWN_EVENT;

function requirePOINTER_DOWN_EVENT () {
	if (hasRequiredPOINTER_DOWN_EVENT) return POINTER_DOWN_EVENT;
	hasRequiredPOINTER_DOWN_EVENT = 1;
	POINTER_DOWN_EVENT = 'pointerdown';
	return POINTER_DOWN_EVENT;
}

var POINTER_DOWN_OUTSIDE_EVENT;
var hasRequiredPOINTER_DOWN_OUTSIDE_EVENT;

function requirePOINTER_DOWN_OUTSIDE_EVENT () {
	if (hasRequiredPOINTER_DOWN_OUTSIDE_EVENT) return POINTER_DOWN_OUTSIDE_EVENT;
	hasRequiredPOINTER_DOWN_OUTSIDE_EVENT = 1;
	POINTER_DOWN_OUTSIDE_EVENT = 'pointerdownoutside';
	return POINTER_DOWN_OUTSIDE_EVENT;
}

var POINTER_MOVE_EVENT;
var hasRequiredPOINTER_MOVE_EVENT;

function requirePOINTER_MOVE_EVENT () {
	if (hasRequiredPOINTER_MOVE_EVENT) return POINTER_MOVE_EVENT;
	hasRequiredPOINTER_MOVE_EVENT = 1;
	POINTER_MOVE_EVENT = 'pointermove';
	return POINTER_MOVE_EVENT;
}

var POINTER_OUT_EVENT;
var hasRequiredPOINTER_OUT_EVENT;

function requirePOINTER_OUT_EVENT () {
	if (hasRequiredPOINTER_OUT_EVENT) return POINTER_OUT_EVENT;
	hasRequiredPOINTER_OUT_EVENT = 1;
	POINTER_OUT_EVENT = 'pointerout';
	return POINTER_OUT_EVENT;
}

var POINTER_OVER_EVENT;
var hasRequiredPOINTER_OVER_EVENT;

function requirePOINTER_OVER_EVENT () {
	if (hasRequiredPOINTER_OVER_EVENT) return POINTER_OVER_EVENT;
	hasRequiredPOINTER_OVER_EVENT = 1;
	POINTER_OVER_EVENT = 'pointerover';
	return POINTER_OVER_EVENT;
}

var POINTER_UP_EVENT;
var hasRequiredPOINTER_UP_EVENT;

function requirePOINTER_UP_EVENT () {
	if (hasRequiredPOINTER_UP_EVENT) return POINTER_UP_EVENT;
	hasRequiredPOINTER_UP_EVENT = 1;
	POINTER_UP_EVENT = 'pointerup';
	return POINTER_UP_EVENT;
}

var POINTER_UP_OUTSIDE_EVENT;
var hasRequiredPOINTER_UP_OUTSIDE_EVENT;

function requirePOINTER_UP_OUTSIDE_EVENT () {
	if (hasRequiredPOINTER_UP_OUTSIDE_EVENT) return POINTER_UP_OUTSIDE_EVENT;
	hasRequiredPOINTER_UP_OUTSIDE_EVENT = 1;
	POINTER_UP_OUTSIDE_EVENT = 'pointerupoutside';
	return POINTER_UP_OUTSIDE_EVENT;
}

var POINTER_WHEEL_EVENT;
var hasRequiredPOINTER_WHEEL_EVENT;

function requirePOINTER_WHEEL_EVENT () {
	if (hasRequiredPOINTER_WHEEL_EVENT) return POINTER_WHEEL_EVENT;
	hasRequiredPOINTER_WHEEL_EVENT = 1;
	POINTER_WHEEL_EVENT = 'wheel';
	return POINTER_WHEEL_EVENT;
}

var POINTERLOCK_CHANGE_EVENT;
var hasRequiredPOINTERLOCK_CHANGE_EVENT;

function requirePOINTERLOCK_CHANGE_EVENT () {
	if (hasRequiredPOINTERLOCK_CHANGE_EVENT) return POINTERLOCK_CHANGE_EVENT;
	hasRequiredPOINTERLOCK_CHANGE_EVENT = 1;
	POINTERLOCK_CHANGE_EVENT = 'pointerlockchange';
	return POINTERLOCK_CHANGE_EVENT;
}

var PRE_UPDATE_EVENT;
var hasRequiredPRE_UPDATE_EVENT;

function requirePRE_UPDATE_EVENT () {
	if (hasRequiredPRE_UPDATE_EVENT) return PRE_UPDATE_EVENT;
	hasRequiredPRE_UPDATE_EVENT = 1;
	PRE_UPDATE_EVENT = 'preupdate';
	return PRE_UPDATE_EVENT;
}

var SHUTDOWN_EVENT;
var hasRequiredSHUTDOWN_EVENT;

function requireSHUTDOWN_EVENT () {
	if (hasRequiredSHUTDOWN_EVENT) return SHUTDOWN_EVENT;
	hasRequiredSHUTDOWN_EVENT = 1;
	SHUTDOWN_EVENT = 'shutdown';
	return SHUTDOWN_EVENT;
}

var START_EVENT$2;
var hasRequiredSTART_EVENT$2;

function requireSTART_EVENT$2 () {
	if (hasRequiredSTART_EVENT$2) return START_EVENT$2;
	hasRequiredSTART_EVENT$2 = 1;
	START_EVENT$2 = 'start';
	return START_EVENT$2;
}

var UPDATE_EVENT;
var hasRequiredUPDATE_EVENT;

function requireUPDATE_EVENT () {
	if (hasRequiredUPDATE_EVENT) return UPDATE_EVENT;
	hasRequiredUPDATE_EVENT = 1;
	UPDATE_EVENT = 'update';
	return UPDATE_EVENT;
}

var events$9;
var hasRequiredEvents$9;

function requireEvents$9 () {
	if (hasRequiredEvents$9) return events$9;
	hasRequiredEvents$9 = 1;
	events$9 = {

	    BOOT: requireBOOT_EVENT(),
	    DESTROY: requireDESTROY_EVENT$1(),
	    DRAG_END: requireDRAG_END_EVENT(),
	    DRAG_ENTER: requireDRAG_ENTER_EVENT(),
	    DRAG: requireDRAG_EVENT(),
	    DRAG_LEAVE: requireDRAG_LEAVE_EVENT(),
	    DRAG_OVER: requireDRAG_OVER_EVENT(),
	    DRAG_START: requireDRAG_START_EVENT(),
	    DROP: requireDROP_EVENT(),
	    GAME_OUT: requireGAME_OUT_EVENT(),
	    GAME_OVER: requireGAME_OVER_EVENT(),
	    GAMEOBJECT_DOWN: requireGAMEOBJECT_DOWN_EVENT(),
	    GAMEOBJECT_DRAG_END: requireGAMEOBJECT_DRAG_END_EVENT(),
	    GAMEOBJECT_DRAG_ENTER: requireGAMEOBJECT_DRAG_ENTER_EVENT(),
	    GAMEOBJECT_DRAG: requireGAMEOBJECT_DRAG_EVENT(),
	    GAMEOBJECT_DRAG_LEAVE: requireGAMEOBJECT_DRAG_LEAVE_EVENT(),
	    GAMEOBJECT_DRAG_OVER: requireGAMEOBJECT_DRAG_OVER_EVENT(),
	    GAMEOBJECT_DRAG_START: requireGAMEOBJECT_DRAG_START_EVENT(),
	    GAMEOBJECT_DROP: requireGAMEOBJECT_DROP_EVENT(),
	    GAMEOBJECT_MOVE: requireGAMEOBJECT_MOVE_EVENT(),
	    GAMEOBJECT_OUT: requireGAMEOBJECT_OUT_EVENT(),
	    GAMEOBJECT_OVER: requireGAMEOBJECT_OVER_EVENT(),
	    GAMEOBJECT_POINTER_DOWN: requireGAMEOBJECT_POINTER_DOWN_EVENT(),
	    GAMEOBJECT_POINTER_MOVE: requireGAMEOBJECT_POINTER_MOVE_EVENT(),
	    GAMEOBJECT_POINTER_OUT: requireGAMEOBJECT_POINTER_OUT_EVENT(),
	    GAMEOBJECT_POINTER_OVER: requireGAMEOBJECT_POINTER_OVER_EVENT(),
	    GAMEOBJECT_POINTER_UP: requireGAMEOBJECT_POINTER_UP_EVENT(),
	    GAMEOBJECT_POINTER_WHEEL: requireGAMEOBJECT_POINTER_WHEEL_EVENT(),
	    GAMEOBJECT_UP: requireGAMEOBJECT_UP_EVENT(),
	    GAMEOBJECT_WHEEL: requireGAMEOBJECT_WHEEL_EVENT(),
	    MANAGER_BOOT: requireMANAGER_BOOT_EVENT(),
	    MANAGER_PROCESS: requireMANAGER_PROCESS_EVENT(),
	    MANAGER_UPDATE: requireMANAGER_UPDATE_EVENT(),
	    POINTER_DOWN: requirePOINTER_DOWN_EVENT(),
	    POINTER_DOWN_OUTSIDE: requirePOINTER_DOWN_OUTSIDE_EVENT(),
	    POINTER_MOVE: requirePOINTER_MOVE_EVENT(),
	    POINTER_OUT: requirePOINTER_OUT_EVENT(),
	    POINTER_OVER: requirePOINTER_OVER_EVENT(),
	    POINTER_UP: requirePOINTER_UP_EVENT(),
	    POINTER_UP_OUTSIDE: requirePOINTER_UP_OUTSIDE_EVENT(),
	    POINTER_WHEEL: requirePOINTER_WHEEL_EVENT(),
	    POINTERLOCK_CHANGE: requirePOINTERLOCK_CHANGE_EVENT(),
	    PRE_UPDATE: requirePRE_UPDATE_EVENT(),
	    SHUTDOWN: requireSHUTDOWN_EVENT(),
	    START: requireSTART_EVENT$2(),
	    UPDATE: requireUPDATE_EVENT()

	};
	return events$9;
}

var KeyCodes_1;
var hasRequiredKeyCodes;

function requireKeyCodes () {
	if (hasRequiredKeyCodes) return KeyCodes_1;
	hasRequiredKeyCodes = 1;
	var KeyCodes = {

	    BACKSPACE: 8,

	    TAB: 9,

	    ENTER: 13,

	    SHIFT: 16,

	    CTRL: 17,

	    ALT: 18,

	    PAUSE: 19,

	    CAPS_LOCK: 20,

	    ESC: 27,

	    SPACE: 32,

	    PAGE_UP: 33,

	    PAGE_DOWN: 34,

	    END: 35,

	    HOME: 36,

	    LEFT: 37,

	    UP: 38,

	    RIGHT: 39,

	    DOWN: 40,

	    PRINT_SCREEN: 42,

	    INSERT: 45,

	    DELETE: 46,

	    ZERO: 48,

	    ONE: 49,

	    TWO: 50,

	    THREE: 51,

	    FOUR: 52,

	    FIVE: 53,

	    SIX: 54,

	    SEVEN: 55,

	    EIGHT: 56,

	    NINE: 57,

	    NUMPAD_ZERO: 96,

	    NUMPAD_ONE: 97,

	    NUMPAD_TWO: 98,

	    NUMPAD_THREE: 99,

	    NUMPAD_FOUR: 100,

	    NUMPAD_FIVE: 101,

	    NUMPAD_SIX: 102,

	    NUMPAD_SEVEN: 103,

	    NUMPAD_EIGHT: 104,

	    NUMPAD_NINE: 105,

	    NUMPAD_ADD: 107,

	    NUMPAD_SUBTRACT: 109,

	    A: 65,

	    B: 66,

	    C: 67,

	    D: 68,

	    E: 69,

	    F: 70,

	    G: 71,

	    H: 72,

	    I: 73,

	    J: 74,

	    K: 75,

	    L: 76,

	    M: 77,

	    N: 78,

	    O: 79,

	    P: 80,

	    Q: 81,

	    R: 82,

	    S: 83,

	    T: 84,

	    U: 85,

	    V: 86,

	    W: 87,

	    X: 88,

	    Y: 89,

	    Z: 90,

	    F1: 112,

	    F2: 113,

	    F3: 114,

	    F4: 115,

	    F5: 116,

	    F6: 117,

	    F7: 118,

	    F8: 119,

	    F9: 120,

	    F10: 121,

	    F11: 122,

	    F12: 123,

	    SEMICOLON: 186,

	    PLUS: 187,

	    COMMA: 188,

	    MINUS: 189,

	    PERIOD: 190,

	    FORWARD_SLASH: 191,

	    BACK_SLASH: 220,

	    QUOTES: 222,

	    BACKTICK: 192,

	    OPEN_BRACKET: 219,

	    CLOSED_BRACKET: 221,

	    SEMICOLON_FIREFOX: 59,

	    COLON: 58,

	    COMMA_FIREFOX_WINDOWS: 60,

	    COMMA_FIREFOX: 62,

	    BRACKET_RIGHT_FIREFOX: 174,

	    BRACKET_LEFT_FIREFOX: 175
	};

	KeyCodes_1 = KeyCodes;
	return KeyCodes_1;
}

var KeyboardManager_1;
var hasRequiredKeyboardManager;

function requireKeyboardManager () {
	if (hasRequiredKeyboardManager) return KeyboardManager_1;
	hasRequiredKeyboardManager = 1;
	var ArrayRemove = requireRemove();
	var Class = requireClass();
	var GameEvents = requireEvents$h();
	var InputEvents = requireEvents$9();
	var KeyCodes = requireKeyCodes();
	var NOOP = requireNOOP();

	var KeyboardManager = new Class({

	    initialize:

	    function KeyboardManager (inputManager)
	    {

	        this.manager = inputManager;

	        this.queue = [];

	        this.preventDefault = true;

	        this.captures = [];

	        this.enabled = false;

	        this.target;

	        this.onKeyDown = NOOP;

	        this.onKeyUp = NOOP;

	        inputManager.events.once(InputEvents.MANAGER_BOOT, this.boot, this);
	    },

	    boot: function ()
	    {
	        var config = this.manager.config;

	        this.enabled = config.inputKeyboard;
	        this.target = config.inputKeyboardEventTarget;

	        this.addCapture(config.inputKeyboardCapture);

	        if (!this.target && window)
	        {
	            this.target = window;
	        }

	        if (this.enabled && this.target)
	        {
	            this.startListeners();
	        }

	        this.manager.game.events.on(GameEvents.POST_STEP, this.postUpdate, this);
	    },

	    startListeners: function ()
	    {
	        var _this = this;

	        this.onKeyDown = function (event)
	        {
	            if (event.defaultPrevented || !_this.enabled || !_this.manager)
	            {

	                return;
	            }

	            _this.queue.push(event);

	            _this.manager.events.emit(InputEvents.MANAGER_PROCESS);

	            var modified = (event.altKey || event.ctrlKey || event.shiftKey || event.metaKey);

	            if (_this.preventDefault && !modified && _this.captures.indexOf(event.keyCode) > -1)
	            {
	                event.preventDefault();
	            }
	        };

	        this.onKeyUp = function (event)
	        {
	            if (event.defaultPrevented || !_this.enabled || !_this.manager)
	            {

	                return;
	            }

	            _this.queue.push(event);

	            _this.manager.events.emit(InputEvents.MANAGER_PROCESS);

	            var modified = (event.altKey || event.ctrlKey || event.shiftKey || event.metaKey);

	            if (_this.preventDefault && !modified && _this.captures.indexOf(event.keyCode) > -1)
	            {
	                event.preventDefault();
	            }
	        };

	        var target = this.target;

	        if (target)
	        {
	            target.addEventListener('keydown', this.onKeyDown, false);
	            target.addEventListener('keyup', this.onKeyUp, false);

	            this.enabled = true;
	        }
	    },

	    stopListeners: function ()
	    {
	        var target = this.target;

	        target.removeEventListener('keydown', this.onKeyDown, false);
	        target.removeEventListener('keyup', this.onKeyUp, false);

	        this.enabled = false;
	    },

	    postUpdate: function ()
	    {
	        this.queue = [];
	    },

	    addCapture: function (keycode)
	    {
	        if (typeof keycode === 'string')
	        {
	            keycode = keycode.split(',');
	        }

	        if (!Array.isArray(keycode))
	        {
	            keycode = [ keycode ];
	        }

	        var captures = this.captures;

	        for (var i = 0; i < keycode.length; i++)
	        {
	            var code = keycode[i];

	            if (typeof code === 'string')
	            {
	                code = KeyCodes[code.trim().toUpperCase()];
	            }

	            if (captures.indexOf(code) === -1)
	            {
	                captures.push(code);
	            }
	        }

	        this.preventDefault = captures.length > 0;
	    },

	    removeCapture: function (keycode)
	    {
	        if (typeof keycode === 'string')
	        {
	            keycode = keycode.split(',');
	        }

	        if (!Array.isArray(keycode))
	        {
	            keycode = [ keycode ];
	        }

	        var captures = this.captures;

	        for (var i = 0; i < keycode.length; i++)
	        {
	            var code = keycode[i];

	            if (typeof code === 'string')
	            {
	                code = KeyCodes[code.toUpperCase()];
	            }

	            ArrayRemove(captures, code);
	        }

	        this.preventDefault = captures.length > 0;
	    },

	    clearCaptures: function ()
	    {
	        this.captures = [];

	        this.preventDefault = false;
	    },

	    destroy: function ()
	    {
	        this.stopListeners();

	        this.clearCaptures();

	        this.queue = [];

	        this.manager.game.events.off(GameEvents.POST_RENDER, this.postUpdate, this);

	        this.target = null;
	        this.enabled = false;
	        this.manager = null;
	    }

	});

	KeyboardManager_1 = KeyboardManager;
	return KeyboardManager_1;
}

var MouseManager_1;
var hasRequiredMouseManager;

function requireMouseManager () {
	if (hasRequiredMouseManager) return MouseManager_1;
	hasRequiredMouseManager = 1;
	var Class = requireClass();
	var Features = requireFeatures();
	var InputEvents = requireEvents$9();
	var NOOP = requireNOOP();

	var MouseManager = new Class({

	    initialize:

	    function MouseManager (inputManager)
	    {

	        this.manager = inputManager;

	        this.preventDefaultDown = true;

	        this.preventDefaultUp = true;

	        this.preventDefaultMove = true;

	        this.preventDefaultWheel = false;

	        this.enabled = false;

	        this.target;

	        this.locked = false;

	        this.onMouseMove = NOOP;

	        this.onMouseDown = NOOP;

	        this.onMouseUp = NOOP;

	        this.onMouseDownWindow = NOOP;

	        this.onMouseUpWindow = NOOP;

	        this.onMouseOver = NOOP;

	        this.onMouseOut = NOOP;

	        this.onMouseWheel = NOOP;

	        this.pointerLockChange = NOOP;

	        this.isTop = true;

	        inputManager.events.once(InputEvents.MANAGER_BOOT, this.boot, this);
	    },

	    boot: function ()
	    {
	        var config = this.manager.config;

	        this.enabled = config.inputMouse;
	        this.target = config.inputMouseEventTarget;
	        this.passive = config.inputMousePassive;

	        this.preventDefaultDown = config.inputMousePreventDefaultDown;
	        this.preventDefaultUp = config.inputMousePreventDefaultUp;
	        this.preventDefaultMove = config.inputMousePreventDefaultMove;
	        this.preventDefaultWheel = config.inputMousePreventDefaultWheel;

	        if (!this.target)
	        {
	            this.target = this.manager.game.canvas;
	        }
	        else if (typeof this.target === 'string')
	        {
	            this.target = document.getElementById(this.target);
	        }

	        if (config.disableContextMenu)
	        {
	            this.disableContextMenu();
	        }

	        if (this.enabled && this.target)
	        {
	            this.startListeners();
	        }
	    },

	    disableContextMenu: function ()
	    {
	        this.target.addEventListener('contextmenu', function (event)
	        {
	            event.preventDefault();
	            return false;
	        });

	        return this;
	    },

	    requestPointerLock: function ()
	    {
	        if (Features.pointerLock)
	        {
	            var element = this.target;

	            element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;

	            element.requestPointerLock();
	        }
	    },

	    releasePointerLock: function ()
	    {
	        if (Features.pointerLock)
	        {
	            document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock;
	            document.exitPointerLock();
	        }
	    },

	    startListeners: function ()
	    {
	        var target = this.target;

	        if (!target)
	        {
	            return;
	        }

	        var _this = this;
	        var manager = this.manager;
	        var canvas = manager.canvas;
	        var autoFocus = (window && window.focus && manager.game.config.autoFocus);

	        this.onMouseMove = function (event)
	        {
	            if (!event.defaultPrevented && _this.enabled && manager && manager.enabled)
	            {
	                manager.onMouseMove(event);

	                if (_this.preventDefaultMove)
	                {
	                    event.preventDefault();
	                }
	            }
	        };

	        this.onMouseDown = function (event)
	        {
	            if (autoFocus)
	            {
	                window.focus();
	            }

	            if (!event.defaultPrevented && _this.enabled && manager && manager.enabled)
	            {
	                manager.onMouseDown(event);

	                if (_this.preventDefaultDown && event.target === canvas)
	                {
	                    event.preventDefault();
	                }
	            }
	        };

	        this.onMouseDownWindow = function (event)
	        {
	            if (event.sourceCapabilities && event.sourceCapabilities.firesTouchEvents)
	            {
	                return;
	            }

	            if (!event.defaultPrevented && _this.enabled && manager && manager.enabled && event.target !== canvas)
	            {

	                manager.onMouseDown(event);
	            }
	        };

	        this.onMouseUp = function (event)
	        {
	            if (!event.defaultPrevented && _this.enabled && manager && manager.enabled)
	            {
	                manager.onMouseUp(event);

	                if (_this.preventDefaultUp && event.target === canvas)
	                {
	                    event.preventDefault();
	                }
	            }
	        };

	        this.onMouseUpWindow = function (event)
	        {
	            if (event.sourceCapabilities && event.sourceCapabilities.firesTouchEvents)
	            {
	                return;
	            }

	            if (!event.defaultPrevented && _this.enabled && manager && manager.enabled && event.target !== canvas)
	            {

	                manager.onMouseUp(event);
	            }
	        };

	        this.onMouseOver = function (event)
	        {
	            if (!event.defaultPrevented && _this.enabled && manager && manager.enabled)
	            {
	                manager.setCanvasOver(event);
	            }
	        };

	        this.onMouseOut = function (event)
	        {
	            if (!event.defaultPrevented && _this.enabled && manager && manager.enabled)
	            {
	                manager.setCanvasOut(event);
	            }
	        };

	        this.onMouseWheel = function (event)
	        {
	            if (!event.defaultPrevented && _this.enabled && manager && manager.enabled)
	            {
	                manager.onMouseWheel(event);
	            }

	            if (_this.preventDefaultWheel && event.target === canvas)
	            {
	                event.preventDefault();
	            }
	        };

	        var passive = { passive: true };

	        target.addEventListener('mousemove', this.onMouseMove);
	        target.addEventListener('mousedown', this.onMouseDown);
	        target.addEventListener('mouseup', this.onMouseUp);
	        target.addEventListener('mouseover', this.onMouseOver, passive);
	        target.addEventListener('mouseout', this.onMouseOut, passive);

	        if (this.preventDefaultWheel)
	        {
	            target.addEventListener('wheel', this.onMouseWheel, { passive: false });
	        }
	        else
	        {
	            target.addEventListener('wheel', this.onMouseWheel, passive);
	        }

	        if (window && manager.game.config.inputWindowEvents)
	        {
	            try
	            {
	                window.top.addEventListener('mousedown', this.onMouseDownWindow, passive);
	                window.top.addEventListener('mouseup', this.onMouseUpWindow, passive);
	            }
	            catch (exception)
	            {
	                window.addEventListener('mousedown', this.onMouseDownWindow, passive);
	                window.addEventListener('mouseup', this.onMouseUpWindow, passive);

	                this.isTop = false;
	            }
	        }

	        if (Features.pointerLock)
	        {
	            this.pointerLockChange = function (event)
	            {
	                var element = _this.target;

	                _this.locked = (document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element) ? true : false;

	                manager.onPointerLockChange(event);
	            };

	            document.addEventListener('pointerlockchange', this.pointerLockChange, true);
	            document.addEventListener('mozpointerlockchange', this.pointerLockChange, true);
	            document.addEventListener('webkitpointerlockchange', this.pointerLockChange, true);
	        }

	        this.enabled = true;
	    },

	    stopListeners: function ()
	    {
	        var target = this.target;

	        target.removeEventListener('mousemove', this.onMouseMove);
	        target.removeEventListener('mousedown', this.onMouseDown);
	        target.removeEventListener('mouseup', this.onMouseUp);
	        target.removeEventListener('mouseover', this.onMouseOver);
	        target.removeEventListener('mouseout', this.onMouseOut);

	        if (window)
	        {
	            target = (this.isTop) ? window.top : window;

	            target.removeEventListener('mousedown', this.onMouseDownWindow);
	            target.removeEventListener('mouseup', this.onMouseUpWindow);
	        }

	        if (Features.pointerLock)
	        {
	            document.removeEventListener('pointerlockchange', this.pointerLockChange, true);
	            document.removeEventListener('mozpointerlockchange', this.pointerLockChange, true);
	            document.removeEventListener('webkitpointerlockchange', this.pointerLockChange, true);
	        }
	    },

	    destroy: function ()
	    {
	        this.stopListeners();

	        this.target = null;
	        this.enabled = false;
	        this.manager = null;
	    }

	});

	MouseManager_1 = MouseManager;
	return MouseManager_1;
}

var Pointer_1;
var hasRequiredPointer;

function requirePointer () {
	if (hasRequiredPointer) return Pointer_1;
	hasRequiredPointer = 1;
	var Angle = requireBetween();
	var Class = requireClass();
	var Distance = requireDistanceBetween();
	var FuzzyEqual = requireEqual();
	var SmoothStepInterpolation = requireSmoothStepInterpolation();
	var Vector2 = requireVector2();
	var OS = requireOS();

	var Pointer = new Class({

	    initialize:

	    function Pointer (manager, id)
	    {

	        this.manager = manager;

	        this.id = id;

	        this.event;

	        this.downElement;

	        this.upElement;

	        this.camera = null;

	        this.button = 0;

	        this.buttons = 0;

	        this.position = new Vector2();

	        this.prevPosition = new Vector2();

	        this.midPoint = new Vector2(-1, -1);

	        this.velocity = new Vector2();

	        this.angle = 0;

	        this.distance = 0;

	        this.smoothFactor = 0;

	        this.motionFactor = 0.2;

	        this.worldX = 0;

	        this.worldY = 0;

	        this.moveTime = 0;

	        this.downX = 0;

	        this.downY = 0;

	        this.downTime = 0;

	        this.upX = 0;

	        this.upY = 0;

	        this.upTime = 0;

	        this.primaryDown = false;

	        this.isDown = false;

	        this.wasTouch = false;

	        this.wasCanceled = false;

	        this.movementX = 0;

	        this.movementY = 0;

	        this.identifier = 0;

	        this.pointerId = null;

	        this.active = (id === 0) ? true : false;

	        this.locked = false;

	        this.deltaX = 0;

	        this.deltaY = 0;

	        this.deltaZ = 0;
	    },

	    updateWorldPoint: function (camera)
	    {

	        var temp = camera.getWorldPoint(this.x, this.y);

	        this.worldX = temp.x;
	        this.worldY = temp.y;

	        return this;
	    },

	    positionToCamera: function (camera, output)
	    {
	        return camera.getWorldPoint(this.x, this.y, output);
	    },

	    updateMotion: function ()
	    {
	        var cx = this.position.x;
	        var cy = this.position.y;

	        var mx = this.midPoint.x;
	        var my = this.midPoint.y;

	        if (cx === mx && cy === my)
	        {

	            return;
	        }

	        var vx = SmoothStepInterpolation(this.motionFactor, mx, cx);
	        var vy = SmoothStepInterpolation(this.motionFactor, my, cy);

	        if (FuzzyEqual(vx, cx, 0.1))
	        {
	            vx = cx;
	        }

	        if (FuzzyEqual(vy, cy, 0.1))
	        {
	            vy = cy;
	        }

	        this.midPoint.set(vx, vy);

	        var dx = cx - vx;
	        var dy = cy - vy;

	        this.velocity.set(dx, dy);

	        this.angle = Angle(vx, vy, cx, cy);

	        this.distance = Math.sqrt(dx * dx + dy * dy);
	    },

	    up: function (event)
	    {
	        if ('buttons' in event)
	        {
	            this.buttons = event.buttons;
	        }

	        this.event = event;

	        this.button = event.button;

	        this.upElement = event.target;

	        this.manager.transformPointer(this, event.pageX, event.pageY, false);

	        if (event.button === 0)
	        {
	            this.primaryDown = false;
	            this.upX = this.x;
	            this.upY = this.y;
	        }

	        if (this.buttons === 0)
	        {

	            this.isDown = false;

	            this.upTime = event.timeStamp;

	            this.wasTouch = false;
	        }
	    },

	    down: function (event)
	    {
	        if ('buttons' in event)
	        {
	            this.buttons = event.buttons;
	        }

	        this.event = event;

	        this.button = event.button;

	        this.downElement = event.target;

	        this.manager.transformPointer(this, event.pageX, event.pageY, false);

	        if (event.button === 0)
	        {
	            this.primaryDown = true;
	            this.downX = this.x;
	            this.downY = this.y;
	        }

	        if (OS.macOS && event.ctrlKey)
	        {

	            this.buttons = 2;
	            this.primaryDown = false;
	        }

	        if (!this.isDown)
	        {
	            this.isDown = true;

	            this.downTime = event.timeStamp;
	        }

	        this.wasTouch = false;
	    },

	    move: function (event)
	    {
	        if ('buttons' in event)
	        {
	            this.buttons = event.buttons;
	        }

	        this.event = event;

	        this.manager.transformPointer(this, event.pageX, event.pageY, true);

	        if (this.locked)
	        {

	            this.movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
	            this.movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
	        }

	        this.moveTime = event.timeStamp;

	        this.wasTouch = false;
	    },

	    wheel: function (event)
	    {
	        if ('buttons' in event)
	        {
	            this.buttons = event.buttons;
	        }

	        this.event = event;

	        this.manager.transformPointer(this, event.pageX, event.pageY, false);

	        this.deltaX = event.deltaX;
	        this.deltaY = event.deltaY;
	        this.deltaZ = event.deltaZ;

	        this.wasTouch = false;
	    },

	    touchstart: function (touch, event)
	    {
	        if (touch['pointerId'])
	        {
	            this.pointerId = touch.pointerId;
	        }

	        this.identifier = touch.identifier;
	        this.target = touch.target;
	        this.active = true;

	        this.buttons = 1;

	        this.event = event;

	        this.downElement = touch.target;

	        this.manager.transformPointer(this, touch.pageX, touch.pageY, false);

	        this.primaryDown = true;
	        this.downX = this.x;
	        this.downY = this.y;
	        this.downTime = event.timeStamp;

	        this.isDown = true;

	        this.wasTouch = true;
	        this.wasCanceled = false;

	        this.updateMotion();
	    },

	    touchmove: function (touch, event)
	    {
	        this.event = event;

	        this.manager.transformPointer(this, touch.pageX, touch.pageY, true);

	        this.moveTime = event.timeStamp;

	        this.wasTouch = true;

	        this.updateMotion();
	    },

	    touchend: function (touch, event)
	    {
	        this.buttons = 0;

	        this.event = event;

	        this.upElement = touch.target;

	        this.manager.transformPointer(this, touch.pageX, touch.pageY, false);

	        this.primaryDown = false;
	        this.upX = this.x;
	        this.upY = this.y;
	        this.upTime = event.timeStamp;

	        this.isDown = false;

	        this.wasTouch = true;
	        this.wasCanceled = false;

	        this.active = false;

	        this.updateMotion();
	    },

	    touchcancel: function (touch, event)
	    {
	        this.buttons = 0;

	        this.event = event;

	        this.upElement = touch.target;

	        this.manager.transformPointer(this, touch.pageX, touch.pageY, false);

	        this.primaryDown = false;
	        this.upX = this.x;
	        this.upY = this.y;
	        this.upTime = event.timeStamp;

	        this.isDown = false;

	        this.wasTouch = true;
	        this.wasCanceled = true;

	        this.active = false;
	    },

	    noButtonDown: function ()
	    {
	        return (this.buttons === 0);
	    },

	    leftButtonDown: function ()
	    {
	        return (this.buttons & 1) ? true : false;
	    },

	    rightButtonDown: function ()
	    {
	        return (this.buttons & 2) ? true : false;
	    },

	    middleButtonDown: function ()
	    {
	        return (this.buttons & 4) ? true : false;
	    },

	    backButtonDown: function ()
	    {
	        return (this.buttons & 8) ? true : false;
	    },

	    forwardButtonDown: function ()
	    {
	        return (this.buttons & 16) ? true : false;
	    },

	    leftButtonReleased: function ()
	    {
	        return this.buttons === 0 ? (this.button === 0 && !this.isDown) : this.button === 0;
	    },

	    rightButtonReleased: function ()
	    {
	        return this.buttons === 0 ? (this.button === 2 && !this.isDown) : this.button === 2;
	    },

	    middleButtonReleased: function ()
	    {
	        return this.buttons === 0 ? (this.button === 1 && !this.isDown) : this.button === 1;
	    },

	    backButtonReleased: function ()
	    {
	        return this.buttons === 0 ? (this.button === 3 && !this.isDown) : this.button === 3;
	    },

	    forwardButtonReleased: function ()
	    {
	        return this.buttons === 0 ? (this.button === 4 && !this.isDown) : this.button === 4;
	    },

	    getDistance: function ()
	    {
	        if (this.isDown)
	        {
	            return Distance(this.downX, this.downY, this.x, this.y);
	        }
	        else
	        {
	            return Distance(this.downX, this.downY, this.upX, this.upY);
	        }
	    },

	    getDistanceX: function ()
	    {
	        if (this.isDown)
	        {
	            return Math.abs(this.downX - this.x);
	        }
	        else
	        {
	            return Math.abs(this.downX - this.upX);
	        }
	    },

	    getDistanceY: function ()
	    {
	        if (this.isDown)
	        {
	            return Math.abs(this.downY - this.y);
	        }
	        else
	        {
	            return Math.abs(this.downY - this.upY);
	        }
	    },

	    getDuration: function ()
	    {
	        if (this.isDown)
	        {
	            return (this.manager.time - this.downTime);
	        }
	        else
	        {
	            return (this.upTime - this.downTime);
	        }
	    },

	    getAngle: function ()
	    {
	        if (this.isDown)
	        {
	            return Angle(this.downX, this.downY, this.x, this.y);
	        }
	        else
	        {
	            return Angle(this.downX, this.downY, this.upX, this.upY);
	        }
	    },

	    getInterpolatedPosition: function (steps, out)
	    {
	        if (steps === undefined) { steps = 10; }
	        if (out === undefined) { out = []; }

	        var prevX = this.prevPosition.x;
	        var prevY = this.prevPosition.y;

	        var curX = this.position.x;
	        var curY = this.position.y;

	        for (var i = 0; i < steps; i++)
	        {
	            var t = (1 / steps) * i;

	            out[i] = { x: SmoothStepInterpolation(t, prevX, curX), y: SmoothStepInterpolation(t, prevY, curY) };
	        }

	        return out;
	    },

	    reset: function ()
	    {
	        this.event = null;
	        this.downElement = null;
	        this.upElement = null;

	        this.button = 0;
	        this.buttons = 0;

	        this.position.set(0, 0);
	        this.prevPosition.set(0, 0);
	        this.midPoint.set(-1, -1);
	        this.velocity.set(0, 0);
	        this.angle = 0;
	        this.distance = 0;
	        this.worldX = 0;
	        this.worldY = 0;
	        this.downX = 0;
	        this.downY = 0;
	        this.upX = 0;
	        this.upY = 0;
	        this.moveTime = 0;
	        this.upTime = 0;
	        this.downTime = 0;
	        this.primaryDown = false;
	        this.isDown = false;
	        this.wasTouch = false;
	        this.wasCanceled = false;
	        this.movementX = 0;
	        this.movementY = 0;
	        this.identifier = 0;
	        this.pointerId = null;
	        this.deltaX = 0;
	        this.deltaY = 0;
	        this.deltaZ = 0;

	        this.active = (this.id === 0) ? true : false;
	    },

	    destroy: function ()
	    {
	        this.camera = null;
	        this.manager = null;
	        this.position = null;
	    },

	    x: {

	        get: function ()
	        {
	            return this.position.x;
	        },

	        set: function (value)
	        {
	            this.position.x = value;
	        }

	    },

	    y: {

	        get: function ()
	        {
	            return this.position.y;
	        },

	        set: function (value)
	        {
	            this.position.y = value;
	        }

	    },

	    time: {

	        get: function ()
	        {
	            return (this.event) ? this.event.timeStamp : 0;
	        }

	    }

	});

	Pointer_1 = Pointer;
	return Pointer_1;
}

var TouchManager_1;
var hasRequiredTouchManager;

function requireTouchManager () {
	if (hasRequiredTouchManager) return TouchManager_1;
	hasRequiredTouchManager = 1;
	var Class = requireClass();
	var InputEvents = requireEvents$9();
	var NOOP = requireNOOP();

	var TouchManager = new Class({

	    initialize:

	    function TouchManager (inputManager)
	    {

	        this.manager = inputManager;

	        this.capture = true;

	        this.enabled = false;

	        this.target;

	        this.onTouchStart = NOOP;

	        this.onTouchStartWindow = NOOP;

	        this.onTouchMove = NOOP;

	        this.onTouchEnd = NOOP;

	        this.onTouchEndWindow = NOOP;

	        this.onTouchCancel = NOOP;

	        this.onTouchCancelWindow = NOOP;

	        this.isTop = true;

	        inputManager.events.once(InputEvents.MANAGER_BOOT, this.boot, this);
	    },

	    boot: function ()
	    {
	        var config = this.manager.config;

	        this.enabled = config.inputTouch;
	        this.target = config.inputTouchEventTarget;
	        this.capture = config.inputTouchCapture;

	        if (!this.target)
	        {
	            this.target = this.manager.game.canvas;
	        }
	        else if (typeof this.target === 'string')
	        {
	            this.target = document.getElementById(this.target);
	        }

	        if (config.disableContextMenu)
	        {
	            this.disableContextMenu();
	        }

	        if (this.enabled && this.target)
	        {
	            this.startListeners();
	        }
	    },

	    disableContextMenu: function ()
	    {
	        this.target.addEventListener('contextmenu', function (event)
	        {
	            event.preventDefault();
	            return false;
	        });

	        return this;
	    },

	    startListeners: function ()
	    {
	        var target = this.target;

	        if (!target)
	        {
	            return;
	        }

	        var _this = this;
	        var manager = this.manager;
	        var canvas = manager.canvas;
	        var autoFocus = (window && window.focus && manager.game.config.autoFocus);

	        this.onTouchMove = function (event)
	        {
	            if (!event.defaultPrevented && _this.enabled && manager && manager.enabled)
	            {
	                manager.onTouchMove(event);

	                if (_this.capture && event.cancelable)
	                {
	                    event.preventDefault();
	                }
	            }
	        };

	        this.onTouchStart = function (event)
	        {
	            if (autoFocus)
	            {
	                window.focus();
	            }

	            if (!event.defaultPrevented && _this.enabled && manager && manager.enabled)
	            {
	                manager.onTouchStart(event);

	                if (_this.capture && event.cancelable && event.target === canvas)
	                {
	                    event.preventDefault();
	                }
	            }
	        };

	        this.onTouchStartWindow = function (event)
	        {
	            if (!event.defaultPrevented && _this.enabled && manager && manager.enabled && event.target !== canvas)
	            {

	                manager.onTouchStart(event);
	            }
	        };

	        this.onTouchEnd = function (event)
	        {
	            if (!event.defaultPrevented && _this.enabled && manager && manager.enabled)
	            {
	                manager.onTouchEnd(event);

	                if (_this.capture && event.cancelable && event.target === canvas)
	                {
	                    event.preventDefault();
	                }
	            }
	        };

	        this.onTouchEndWindow = function (event)
	        {
	            if (!event.defaultPrevented && _this.enabled && manager && manager.enabled && event.target !== canvas)
	            {

	                manager.onTouchEnd(event);
	            }
	        };

	        this.onTouchCancel = function (event)
	        {
	            if (!event.defaultPrevented && _this.enabled && manager && manager.enabled)
	            {
	                manager.onTouchCancel(event);

	                if (_this.capture)
	                {
	                    event.preventDefault();
	                }
	            }
	        };

	        this.onTouchCancelWindow = function (event)
	        {
	            if (!event.defaultPrevented && _this.enabled && manager && manager.enabled)
	            {
	                manager.onTouchCancel(event);
	            }
	        };

	        var capture = this.capture;
	        var passive = { passive: true };
	        var nonPassive = { passive: false };

	        target.addEventListener('touchstart', this.onTouchStart, (capture) ? nonPassive : passive);
	        target.addEventListener('touchmove', this.onTouchMove, (capture) ? nonPassive : passive);
	        target.addEventListener('touchend', this.onTouchEnd, (capture) ? nonPassive : passive);
	        target.addEventListener('touchcancel', this.onTouchCancel, (capture) ? nonPassive : passive);

	        if (window && manager.game.config.inputWindowEvents)
	        {
	            try
	            {
	                window.top.addEventListener('touchstart', this.onTouchStartWindow, nonPassive);
	                window.top.addEventListener('touchend', this.onTouchEndWindow, nonPassive);
	                window.top.addEventListener('touchcancel', this.onTouchCancelWindow, nonPassive);
	            }
	            catch (exception)
	            {
	                window.addEventListener('touchstart', this.onTouchStartWindow, nonPassive);
	                window.addEventListener('touchend', this.onTouchEndWindow, nonPassive);
	                window.addEventListener('touchcancel', this.onTouchCancelWindow, nonPassive);

	                this.isTop = false;
	            }
	        }

	        this.enabled = true;
	    },

	    stopListeners: function ()
	    {
	        var target = this.target;

	        target.removeEventListener('touchstart', this.onTouchStart);
	        target.removeEventListener('touchmove', this.onTouchMove);
	        target.removeEventListener('touchend', this.onTouchEnd);
	        target.removeEventListener('touchcancel', this.onTouchCancel);

	        if (window)
	        {
	            target = (this.isTop) ? window.top : window;

	            target.removeEventListener('touchstart', this.onTouchStartWindow);
	            target.removeEventListener('touchend', this.onTouchEndWindow);
	            target.removeEventListener('touchcancel', this.onTouchCancelWindow);
	        }
	    },

	    destroy: function ()
	    {
	        this.stopListeners();

	        this.target = null;
	        this.enabled = false;
	        this.manager = null;
	    }

	});

	TouchManager_1 = TouchManager;
	return TouchManager_1;
}

var InputManager_1;
var hasRequiredInputManager;

function requireInputManager () {
	if (hasRequiredInputManager) return InputManager_1;
	hasRequiredInputManager = 1;
	var Class = requireClass();
	var CONST = require_const$6();
	var EventEmitter = requireEventemitter3();
	var Events = requireEvents$9();
	var GameEvents = requireEvents$h();
	var Keyboard = requireKeyboardManager();
	var Mouse = requireMouseManager();
	var Pointer = requirePointer();
	var Touch = requireTouchManager();
	var TransformMatrix = requireTransformMatrix();
	var TransformXY = requireTransformXY();

	var InputManager = new Class({

	    initialize:

	    function InputManager (game, config)
	    {

	        this.game = game;

	        this.scaleManager;

	        this.canvas;

	        this.config = config;

	        this.enabled = true;

	        this.events = new EventEmitter();

	        this.isOver = true;

	        this.defaultCursor = '';

	        this.keyboard = (config.inputKeyboard) ? new Keyboard(this) : null;

	        this.mouse = (config.inputMouse) ? new Mouse(this) : null;

	        this.touch = (config.inputTouch) ? new Touch(this) : null;

	        this.pointers = [];

	        this.pointersTotal = config.inputActivePointers;

	        for (var i = 0; i <= this.pointersTotal; i++)
	        {
	            var pointer = new Pointer(this, i);

	            pointer.smoothFactor = config.inputSmoothFactor;

	            this.pointers.push(pointer);
	        }

	        this.mousePointer = (config.inputMouse) ? this.pointers[0] : null;

	        this.activePointer = this.pointers[0];

	        this.globalTopOnly = true;

	        this.time = 0;

	        this._tempPoint = { x: 0, y: 0 };

	        this._tempHitTest = [];

	        this._tempMatrix = new TransformMatrix();

	        this._tempMatrix2 = new TransformMatrix();

	        this._tempSkip = false;

	        this.mousePointerContainer = [ this.mousePointer ];

	        game.events.once(GameEvents.BOOT, this.boot, this);
	    },

	    boot: function ()
	    {
	        var game = this.game;
	        var events = game.events;

	        this.canvas = game.canvas;

	        this.scaleManager = game.scale;

	        this.events.emit(Events.MANAGER_BOOT);

	        events.on(GameEvents.PRE_RENDER, this.preRender, this);

	        events.once(GameEvents.DESTROY, this.destroy, this);
	    },

	    setCanvasOver: function (event)
	    {
	        this.isOver = true;

	        this.events.emit(Events.GAME_OVER, event);
	    },

	    setCanvasOut: function (event)
	    {
	        this.isOver = false;

	        this.events.emit(Events.GAME_OUT, event);
	    },

	    preRender: function ()
	    {
	        var time = this.game.loop.now;
	        var delta = this.game.loop.delta;
	        var scenes = this.game.scene.getScenes(true, true);

	        this.time = time;

	        this.events.emit(Events.MANAGER_UPDATE);

	        for (var i = 0; i < scenes.length; i++)
	        {
	            var scene = scenes[i];

	            if (scene.sys.input && scene.sys.input.updatePoll(time, delta) && this.globalTopOnly)
	            {

	                return;
	            }
	        }
	    },

	    setDefaultCursor: function (cursor)
	    {
	        this.defaultCursor = cursor;

	        if (this.canvas.style.cursor !== cursor)
	        {
	            this.canvas.style.cursor = cursor;
	        }
	    },

	    setCursor: function (interactiveObject)
	    {
	        if (interactiveObject.cursor)
	        {
	            this.canvas.style.cursor = interactiveObject.cursor;
	        }
	    },

	    resetCursor: function (interactiveObject, forceReset)
	    {
	        if ((forceReset || (interactiveObject && interactiveObject.cursor)) && this.canvas)
	        {
	            this.canvas.style.cursor = this.defaultCursor;
	        }
	    },

	    addPointer: function (quantity)
	    {
	        if (quantity === undefined) { quantity = 1; }

	        var output = [];

	        if (this.pointersTotal + quantity > 10)
	        {
	            quantity = 10 - this.pointersTotal;
	        }

	        for (var i = 0; i < quantity; i++)
	        {
	            var id = this.pointers.length;

	            var pointer = new Pointer(this, id);

	            pointer.smoothFactor = this.config.inputSmoothFactor;

	            this.pointers.push(pointer);

	            this.pointersTotal++;

	            output.push(pointer);
	        }

	        return output;
	    },

	    updateInputPlugins: function (type, pointers)
	    {
	        var scenes = this.game.scene.getScenes(false, true);

	        this._tempSkip = false;

	        for (var i = 0; i < scenes.length; i++)
	        {
	            var scene = scenes[i];

	            if (scene.sys.input)
	            {
	                var capture = scene.sys.input.update(type, pointers);

	                if ((capture && this.globalTopOnly) || this._tempSkip)
	                {

	                    return;
	                }
	            }
	        }
	    },

	    onTouchStart: function (event)
	    {
	        var pointers = this.pointers;
	        var changed = [];

	        for (var c = 0; c < event.changedTouches.length; c++)
	        {
	            var changedTouch = event.changedTouches[c];

	            for (var i = 1; i < pointers.length; i++)
	            {
	                var pointer = pointers[i];

	                if (!pointer.active)
	                {
	                    pointer.touchstart(changedTouch, event);

	                    this.activePointer = pointer;

	                    changed.push(pointer);

	                    break;
	                }
	            }
	        }

	        this.updateInputPlugins(CONST.TOUCH_START, changed);
	    },

	    onTouchMove: function (event)
	    {
	        var pointers = this.pointers;
	        var changed = [];

	        for (var c = 0; c < event.changedTouches.length; c++)
	        {
	            var changedTouch = event.changedTouches[c];

	            for (var i = 1; i < pointers.length; i++)
	            {
	                var pointer = pointers[i];

	                if (pointer.active && pointer.identifier === changedTouch.identifier)
	                {
	                    var element = document.elementFromPoint(changedTouch.clientX, changedTouch.clientY);
	                    var overCanvas = element === this.canvas;

	                    if (!this.isOver && overCanvas)
	                    {
	                        this.setCanvasOver(event);
	                    }
	                    else if (this.isOver && !overCanvas)
	                    {
	                        this.setCanvasOut(event);
	                    }

	                    if (this.isOver)
	                    {
	                        pointer.touchmove(changedTouch, event);

	                        this.activePointer = pointer;

	                        changed.push(pointer);
	                    }

	                    break;
	                }
	            }
	        }

	        this.updateInputPlugins(CONST.TOUCH_MOVE, changed);
	    },

	    onTouchEnd: function (event)
	    {
	        var pointers = this.pointers;
	        var changed = [];

	        for (var c = 0; c < event.changedTouches.length; c++)
	        {
	            var changedTouch = event.changedTouches[c];

	            for (var i = 1; i < pointers.length; i++)
	            {
	                var pointer = pointers[i];

	                if (pointer.active && pointer.identifier === changedTouch.identifier)
	                {
	                    pointer.touchend(changedTouch, event);

	                    changed.push(pointer);

	                    break;
	                }
	            }
	        }

	        this.updateInputPlugins(CONST.TOUCH_END, changed);
	    },

	    onTouchCancel: function (event)
	    {
	        var pointers = this.pointers;
	        var changed = [];

	        for (var c = 0; c < event.changedTouches.length; c++)
	        {
	            var changedTouch = event.changedTouches[c];

	            for (var i = 1; i < pointers.length; i++)
	            {
	                var pointer = pointers[i];

	                if (pointer.active && pointer.identifier === changedTouch.identifier)
	                {
	                    pointer.touchcancel(changedTouch, event);

	                    changed.push(pointer);

	                    break;
	                }
	            }
	        }

	        this.updateInputPlugins(CONST.TOUCH_CANCEL, changed);
	    },

	    onMouseDown: function (event)
	    {
	        var mousePointer = this.mousePointer;

	        mousePointer.down(event);

	        mousePointer.updateMotion();

	        this.activePointer = mousePointer;

	        this.updateInputPlugins(CONST.MOUSE_DOWN, this.mousePointerContainer);
	    },

	    onMouseMove: function (event)
	    {
	        var mousePointer = this.mousePointer;

	        mousePointer.move(event);

	        mousePointer.updateMotion();

	        this.activePointer = mousePointer;

	        this.updateInputPlugins(CONST.MOUSE_MOVE, this.mousePointerContainer);
	    },

	    onMouseUp: function (event)
	    {
	        var mousePointer = this.mousePointer;

	        mousePointer.up(event);

	        mousePointer.updateMotion();

	        this.activePointer = mousePointer;

	        this.updateInputPlugins(CONST.MOUSE_UP, this.mousePointerContainer);
	    },

	    onMouseWheel: function (event)
	    {
	        var mousePointer = this.mousePointer;

	        mousePointer.wheel(event);

	        this.activePointer = mousePointer;

	        this.updateInputPlugins(CONST.MOUSE_WHEEL, this.mousePointerContainer);
	    },

	    onPointerLockChange: function (event)
	    {
	        var isLocked = this.mouse.locked;

	        this.mousePointer.locked = isLocked;

	        this.events.emit(Events.POINTERLOCK_CHANGE, event, isLocked);
	    },

	    inputCandidate: function (gameObject, camera)
	    {
	        var input = gameObject.input;

	        if (!input || !input.enabled || !gameObject.willRender(camera))
	        {
	            return false;
	        }

	        var visible = true;
	        var parent = gameObject.parentContainer;

	        if (parent)
	        {
	            do
	            {
	                if (!parent.willRender(camera))
	                {
	                    visible = false;
	                    break;
	                }

	                parent = parent.parentContainer;

	            } while (parent);
	        }

	        return visible;
	    },

	    hitTest: function (pointer, gameObjects, camera, output)
	    {
	        if (output === undefined) { output = this._tempHitTest; }

	        var tempPoint = this._tempPoint;

	        var csx = camera.scrollX;
	        var csy = camera.scrollY;

	        output.length = 0;

	        var x = pointer.x;
	        var y = pointer.y;

	        camera.getWorldPoint(x, y, tempPoint);

	        pointer.worldX = tempPoint.x;
	        pointer.worldY = tempPoint.y;

	        var point = { x: 0, y: 0 };

	        var matrix = this._tempMatrix;
	        var parentMatrix = this._tempMatrix2;

	        for (var i = 0; i < gameObjects.length; i++)
	        {
	            var gameObject = gameObjects[i];

	            if (!this.inputCandidate(gameObject, camera))
	            {
	                continue;
	            }

	            var px = tempPoint.x + (csx * gameObject.scrollFactorX) - csx;
	            var py = tempPoint.y + (csy * gameObject.scrollFactorY) - csy;

	            if (gameObject.parentContainer)
	            {
	                gameObject.getWorldTransformMatrix(matrix, parentMatrix);

	                matrix.applyInverse(px, py, point);
	            }
	            else
	            {
	                TransformXY(px, py, gameObject.x, gameObject.y, gameObject.rotation, gameObject.scaleX, gameObject.scaleY, point);
	            }

	            if (this.pointWithinHitArea(gameObject, point.x, point.y))
	            {
	                output.push(gameObject);
	            }
	        }

	        return output;
	    },

	    pointWithinHitArea: function (gameObject, x, y)
	    {

	        x += gameObject.displayOriginX;
	        y += gameObject.displayOriginY;

	        var input = gameObject.input;

	        if (input && input.hitAreaCallback(input.hitArea, x, y, gameObject))
	        {
	            input.localX = x;
	            input.localY = y;

	            return true;
	        }
	        else
	        {
	            return false;
	        }
	    },

	    pointWithinInteractiveObject: function (object, x, y)
	    {
	        if (!object.hitArea)
	        {
	            return false;
	        }

	        x += object.gameObject.displayOriginX;
	        y += object.gameObject.displayOriginY;

	        object.localX = x;
	        object.localY = y;

	        return object.hitAreaCallback(object.hitArea, x, y, object);
	    },

	    transformPointer: function (pointer, pageX, pageY, wasMove)
	    {
	        var p0 = pointer.position;
	        var p1 = pointer.prevPosition;

	        p1.x = p0.x;
	        p1.y = p0.y;

	        var x = this.scaleManager.transformX(pageX);
	        var y = this.scaleManager.transformY(pageY);

	        var a = pointer.smoothFactor;

	        if (!wasMove || a === 0)
	        {

	            p0.x = x;
	            p0.y = y;
	        }
	        else
	        {

	            p0.x = x * a + p1.x * (1 - a);
	            p0.y = y * a + p1.y * (1 - a);
	        }
	    },

	    destroy: function ()
	    {
	        this.events.removeAllListeners();

	        this.game.events.off(GameEvents.PRE_RENDER);

	        if (this.keyboard)
	        {
	            this.keyboard.destroy();
	        }

	        if (this.mouse)
	        {
	            this.mouse.destroy();
	        }

	        if (this.touch)
	        {
	            this.touch.destroy();
	        }

	        for (var i = 0; i < this.pointers.length; i++)
	        {
	            this.pointers[i].destroy();
	        }

	        this.pointers = [];
	        this._tempHitTest = [];
	        this._tempMatrix.destroy();
	        this.canvas = null;
	        this.game = null;
	    }

	});

	InputManager_1 = InputManager;
	return InputManager_1;
}

var FileTypesManager_1;
var hasRequiredFileTypesManager;

function requireFileTypesManager () {
	if (hasRequiredFileTypesManager) return FileTypesManager_1;
	hasRequiredFileTypesManager = 1;
	var types = {};



	var FileTypesManager = {

	    
	    install: function (loader)
	    {
	        for (var key in types)
	        {
	            loader[key] = types[key];
	        }
	    },

	    
	    register: function (key, factoryFunction)
	    {
	        types[key] = factoryFunction;
	    },

	    
	    destroy: function ()
	    {
	        types = {};
	    }

	};

	FileTypesManager_1 = FileTypesManager;
	return FileTypesManager_1;
}

var GameObjectCreator_1;
var hasRequiredGameObjectCreator;

function requireGameObjectCreator () {
	if (hasRequiredGameObjectCreator) return GameObjectCreator_1;
	hasRequiredGameObjectCreator = 1;
	var Class = requireClass();
	var PluginCache = requirePluginCache();
	var SceneEvents = requireEvents$l();

	var GameObjectCreator = new Class({

	    initialize:

	    function GameObjectCreator (scene)
	    {

	        this.scene = scene;

	        this.systems = scene.sys;

	        this.events = scene.sys.events;

	        this.displayList;

	        this.updateList;

	        this.events.once(SceneEvents.BOOT, this.boot, this);
	        this.events.on(SceneEvents.START, this.start, this);
	    },

	    boot: function ()
	    {
	        this.displayList = this.systems.displayList;
	        this.updateList = this.systems.updateList;

	        this.events.once(SceneEvents.DESTROY, this.destroy, this);
	    },

	    start: function ()
	    {
	        this.events.once(SceneEvents.SHUTDOWN, this.shutdown, this);
	    },

	    shutdown: function ()
	    {
	        this.events.off(SceneEvents.SHUTDOWN, this.shutdown, this);
	    },

	    destroy: function ()
	    {
	        this.shutdown();

	        this.events.off(SceneEvents.START, this.start, this);

	        this.scene = null;
	        this.systems = null;
	        this.events = null;

	        this.displayList = null;
	        this.updateList = null;
	    }

	});

	GameObjectCreator.register = function (factoryType, factoryFunction)
	{
	    if (!GameObjectCreator.prototype.hasOwnProperty(factoryType))
	    {
	        GameObjectCreator.prototype[factoryType] = factoryFunction;
	    }
	};

	GameObjectCreator.remove = function (factoryType)
	{
	    if (GameObjectCreator.prototype.hasOwnProperty(factoryType))
	    {
	        delete GameObjectCreator.prototype[factoryType];
	    }
	};

	PluginCache.register('GameObjectCreator', GameObjectCreator, 'make');

	GameObjectCreator_1 = GameObjectCreator;
	return GameObjectCreator_1;
}

var PluginManager_1;
var hasRequiredPluginManager;

function requirePluginManager () {
	if (hasRequiredPluginManager) return PluginManager_1;
	hasRequiredPluginManager = 1;
	var Class = requireClass();
	var GameEvents = requireEvents$h();
	var EventEmitter = requireEventemitter3();
	var FileTypesManager = requireFileTypesManager();
	var GameObjectCreator = requireGameObjectCreator();
	var GameObjectFactory = requireGameObjectFactory();
	var GetFastValue = requireGetFastValue();
	var PluginCache = requirePluginCache();
	var Remove = requireRemove();
	var CONST = require_const$f();

	var PluginManager = new Class({

	    Extends: EventEmitter,

	    initialize:

	    function PluginManager (game)
	    {
	        EventEmitter.call(this);

	        this.game = game;

	        this.plugins = [];

	        this.scenePlugins = [];

	        this._pendingGlobal = [];

	        this._pendingScene = [];

	        if (game.isBooted || game.config.renderType === CONST.HEADLESS)
	        {
	            this.boot();
	        }
	        else
	        {
	            game.events.once(GameEvents.BOOT, this.boot, this);
	        }
	    },

	    boot: function ()
	    {
	        var i;
	        var entry;
	        var key;
	        var plugin;
	        var start;
	        var mapping;
	        var data;
	        var config = this.game.config;

	        var list = config.installGlobalPlugins;

	        list = list.concat(this._pendingGlobal);

	        for (i = 0; i < list.length; i++)
	        {
	            entry = list[i];

	            key = GetFastValue(entry, 'key', null);
	            plugin = GetFastValue(entry, 'plugin', null);
	            start = GetFastValue(entry, 'start', false);
	            mapping = GetFastValue(entry, 'mapping', null);
	            data = GetFastValue(entry, 'data', null);

	            if (key)
	            {
	                if (plugin)
	                {
	                    this.install(key, plugin, start, mapping, data);
	                }
	                else
	                {
	                    console.warn('Missing `plugin` for key: ' + key);
	                }

	            }
	        }

	        list = config.installScenePlugins;

	        list = list.concat(this._pendingScene);

	        for (i = 0; i < list.length; i++)
	        {
	            entry = list[i];

	            key = GetFastValue(entry, 'key', null);
	            plugin = GetFastValue(entry, 'plugin', null);
	            mapping = GetFastValue(entry, 'mapping', null);

	            if (key)
	            {
	                if (plugin)
	                {
	                    this.installScenePlugin(key, plugin, mapping);
	                }
	                else
	                {
	                    console.warn('Missing `plugin` for key: ' + key);
	                }
	            }
	        }

	        this._pendingGlobal = [];
	        this._pendingScene = [];

	        this.game.events.once(GameEvents.DESTROY, this.destroy, this);
	    },

	    addToScene: function (sys, globalPlugins, scenePlugins)
	    {
	        var i;
	        var pluginKey;
	        var pluginList;
	        var game = this.game;
	        var scene = sys.scene;
	        var map = sys.settings.map;
	        var isBooted = sys.settings.isBooted;

	        for (i = 0; i < globalPlugins.length; i++)
	        {
	            pluginKey = globalPlugins[i];

	            if (game[pluginKey])
	            {
	                sys[pluginKey] = game[pluginKey];

	                if (map.hasOwnProperty(pluginKey))
	                {
	                    scene[map[pluginKey]] = sys[pluginKey];
	                }
	            }
	            else if (pluginKey === 'game' && map.hasOwnProperty(pluginKey))
	            {
	                scene[map[pluginKey]] = game;
	            }
	        }

	        for (var s = 0; s < scenePlugins.length; s++)
	        {
	            pluginList = scenePlugins[s];

	            for (i = 0; i < pluginList.length; i++)
	            {
	                pluginKey = pluginList[i];

	                if (!PluginCache.hasCore(pluginKey))
	                {
	                    continue;
	                }

	                var source = PluginCache.getCore(pluginKey);

	                var mapKey = source.mapping;

	                var plugin = new source.plugin(scene, this, mapKey);

	                sys[mapKey] = plugin;

	                if (source.custom)
	                {
	                    scene[mapKey] = plugin;
	                }
	                else if (map.hasOwnProperty(mapKey))
	                {
	                    scene[map[mapKey]] = plugin;
	                }

	                if (isBooted)
	                {
	                    plugin.boot();
	                }
	            }
	        }

	        pluginList = this.plugins;

	        for (i = 0; i < pluginList.length; i++)
	        {
	            var entry = pluginList[i];

	            if (entry.mapping)
	            {
	                scene[entry.mapping] = entry.plugin;
	            }
	        }
	    },

	    getDefaultScenePlugins: function ()
	    {
	        var list = this.game.config.defaultPlugins;

	        list = list.concat(this.scenePlugins);

	        return list;
	    },

	    installScenePlugin: function (key, plugin, mapping, addToScene, fromLoader)
	    {
	        if (fromLoader === undefined) { fromLoader = false; }

	        if (typeof plugin !== 'function')
	        {
	            console.warn('Invalid Scene Plugin: ' + key);
	            return;
	        }

	        if (!PluginCache.hasCore(key))
	        {

	            PluginCache.register(key, plugin, mapping, true);
	        }

	        if (this.scenePlugins.indexOf(key) === -1)
	        {
	            this.scenePlugins.push(key);
	        }
	        else if (!fromLoader && PluginCache.hasCore(key))
	        {

	            console.warn('Scene Plugin key in use: ' + key);
	            return;
	        }

	        if (addToScene)
	        {
	            var instance = new plugin(addToScene, this, key);

	            addToScene.sys[key] = instance;

	            if (mapping && mapping !== '')
	            {
	                addToScene[mapping] = instance;
	            }

	            instance.boot();
	        }
	    },

	    install: function (key, plugin, start, mapping, data)
	    {
	        if (start === undefined) { start = false; }
	        if (mapping === undefined) { mapping = null; }
	        if (data === undefined) { data = null; }

	        if (typeof plugin !== 'function')
	        {
	            console.warn('Invalid Plugin: ' + key);
	            return null;
	        }

	        if (PluginCache.hasCustom(key))
	        {
	            console.warn('Plugin key in use: ' + key);
	            return null;
	        }

	        if (mapping !== null)
	        {
	            start = true;
	        }

	        if (!this.game.isBooted)
	        {
	            this._pendingGlobal.push({ key: key, plugin: plugin, start: start, mapping: mapping, data: data });
	        }
	        else
	        {

	            PluginCache.registerCustom(key, plugin, mapping, data);

	            if (start)
	            {
	                return this.start(key);
	            }
	        }

	        return null;
	    },

	    getIndex: function (key)
	    {
	        var list = this.plugins;

	        for (var i = 0; i < list.length; i++)
	        {
	            var entry = list[i];

	            if (entry.key === key)
	            {
	                return i;
	            }
	        }

	        return -1;
	    },

	    getEntry: function (key)
	    {
	        var idx = this.getIndex(key);

	        if (idx !== -1)
	        {
	            return this.plugins[idx];
	        }
	    },

	    isActive: function (key)
	    {
	        var entry = this.getEntry(key);

	        return (entry && entry.active);
	    },

	    start: function (key, runAs)
	    {
	        if (runAs === undefined) { runAs = key; }

	        var entry = this.getEntry(runAs);

	        if (entry && !entry.active)
	        {

	            entry.active = true;
	            entry.plugin.start();
	        }
	        else if (!entry)
	        {
	            entry = this.createEntry(key, runAs);
	        }

	        return (entry) ? entry.plugin : null;
	    },

	    createEntry: function (key, runAs)
	    {
	        var entry = PluginCache.getCustom(key);

	        if (entry)
	        {
	            var instance = new entry.plugin(this);

	            entry = {
	                key: runAs,
	                plugin: instance,
	                active: true,
	                mapping: entry.mapping,
	                data: entry.data
	            };

	            this.plugins.push(entry);

	            instance.init(entry.data);
	            instance.start();
	        }

	        return entry;
	    },

	    stop: function (key)
	    {
	        var entry = this.getEntry(key);

	        if (entry && entry.active)
	        {
	            entry.active = false;
	            entry.plugin.stop();
	        }

	        return this;
	    },

	    get: function (key, autoStart)
	    {
	        if (autoStart === undefined) { autoStart = true; }

	        var entry = this.getEntry(key);

	        if (entry)
	        {
	            return entry.plugin;
	        }
	        else
	        {
	            var plugin = this.getClass(key);

	            if (plugin && autoStart)
	            {
	                entry = this.createEntry(key, key);

	                return (entry) ? entry.plugin : null;
	            }
	            else if (plugin)
	            {
	                return plugin;
	            }
	        }

	        return null;
	    },

	    getClass: function (key)
	    {
	        return PluginCache.getCustomClass(key);
	    },

	    removeGlobalPlugin: function (key)
	    {
	        var entry = this.getEntry(key);

	        if (entry)
	        {
	            Remove(this.plugins, entry);
	        }

	        PluginCache.removeCustom(key);
	    },

	    removeScenePlugin: function (key)
	    {
	        Remove(this.scenePlugins, key);

	        PluginCache.remove(key);
	    },

	    registerGameObject: function (key, factoryCallback, creatorCallback)
	    {
	        if (factoryCallback)
	        {
	            GameObjectFactory.register(key, factoryCallback);
	        }

	        if (creatorCallback)
	        {
	            GameObjectCreator.register(key, creatorCallback);
	        }

	        return this;
	    },

	    removeGameObject: function (key, removeFromFactory, removeFromCreator)
	    {
	        if (removeFromFactory === undefined) { removeFromFactory = true; }
	        if (removeFromCreator === undefined) { removeFromCreator = true; }

	        if (removeFromFactory)
	        {
	            GameObjectFactory.remove(key);
	        }

	        if (removeFromCreator)
	        {
	            GameObjectCreator.remove(key);
	        }

	        return this;
	    },

	    registerFileType: function (key, callback, addToScene)
	    {
	        FileTypesManager.register(key, callback);

	        if (addToScene && addToScene.sys.load)
	        {
	            addToScene.sys.load[key] = callback;
	        }
	    },

	    destroy: function ()
	    {
	        for (var i = 0; i < this.plugins.length; i++)
	        {
	            this.plugins[i].plugin.destroy();
	        }

	        PluginCache.destroyCustomPlugins();

	        if (this.game.noReturn)
	        {
	            PluginCache.destroyCorePlugins();
	        }

	        this.game = null;
	        this.plugins = [];
	        this.scenePlugins = [];
	    }

	});

	PluginManager_1 = PluginManager;
	return PluginManager_1;
}

var Size_1$1;
var hasRequiredSize$1;

function requireSize$1 () {
	if (hasRequiredSize$1) return Size_1$1;
	hasRequiredSize$1 = 1;
	var Clamp = requireClamp();
	var Class = requireClass();
	var SnapFloor = requireSnapFloor();
	var Vector2 = requireVector2();

	var Size = new Class({

	    initialize:

	    function Size (width, height, aspectMode, parent)
	    {
	        if (width === undefined) { width = 0; }
	        if (height === undefined) { height = width; }
	        if (aspectMode === undefined) { aspectMode = 0; }
	        if (parent === undefined) { parent = null; }

	        this._width = width;

	        this._height = height;

	        this._parent = parent;

	        this.aspectMode = aspectMode;

	        this.aspectRatio = (height === 0) ? 1 : width / height;

	        this.minWidth = 0;

	        this.minHeight = 0;

	        this.maxWidth = Number.MAX_VALUE;

	        this.maxHeight = Number.MAX_VALUE;

	        this.snapTo = new Vector2();
	    },

	    setAspectMode: function (value)
	    {
	        if (value === undefined) { value = 0; }

	        this.aspectMode = value;

	        return this.setSize(this._width, this._height);
	    },

	    setSnap: function (snapWidth, snapHeight)
	    {
	        if (snapWidth === undefined) { snapWidth = 0; }
	        if (snapHeight === undefined) { snapHeight = snapWidth; }

	        this.snapTo.set(snapWidth, snapHeight);

	        return this.setSize(this._width, this._height);
	    },

	    setParent: function (parent)
	    {
	        this._parent = parent;

	        return this.setSize(this._width, this._height);
	    },

	    setMin: function (width, height)
	    {
	        if (width === undefined) { width = 0; }
	        if (height === undefined) { height = width; }

	        this.minWidth = Clamp(width, 0, this.maxWidth);
	        this.minHeight = Clamp(height, 0, this.maxHeight);

	        return this.setSize(this._width, this._height);
	    },

	    setMax: function (width, height)
	    {
	        if (width === undefined) { width = Number.MAX_VALUE; }
	        if (height === undefined) { height = width; }

	        this.maxWidth = Clamp(width, this.minWidth, Number.MAX_VALUE);
	        this.maxHeight = Clamp(height, this.minHeight, Number.MAX_VALUE);

	        return this.setSize(this._width, this._height);
	    },

	    setSize: function (width, height)
	    {
	        if (width === undefined) { width = 0; }
	        if (height === undefined) { height = width; }

	        switch (this.aspectMode)
	        {
	            case Size.NONE:
	                this._width = this.getNewWidth(SnapFloor(width, this.snapTo.x));
	                this._height = this.getNewHeight(SnapFloor(height, this.snapTo.y));
	                this.aspectRatio = (this._height === 0) ? 1 : this._width / this._height;
	                break;

	            case Size.WIDTH_CONTROLS_HEIGHT:
	                this._width = this.getNewWidth(SnapFloor(width, this.snapTo.x));
	                this._height = this.getNewHeight(this._width * (1 / this.aspectRatio), false);
	                break;

	            case Size.HEIGHT_CONTROLS_WIDTH:
	                this._height = this.getNewHeight(SnapFloor(height, this.snapTo.y));
	                this._width = this.getNewWidth(this._height * this.aspectRatio, false);
	                break;

	            case Size.FIT:
	                this.constrain(width, height, true);
	                break;

	            case Size.ENVELOP:
	                this.constrain(width, height, false);
	                break;
	        }

	        return this;
	    },

	    setAspectRatio: function (ratio)
	    {
	        this.aspectRatio = ratio;

	        return this.setSize(this._width, this._height);
	    },

	    resize: function (width, height)
	    {
	        this._width = this.getNewWidth(SnapFloor(width, this.snapTo.x));
	        this._height = this.getNewHeight(SnapFloor(height, this.snapTo.y));
	        this.aspectRatio = (this._height === 0) ? 1 : this._width / this._height;

	        return this;
	    },

	    getNewWidth: function (value, checkParent)
	    {
	        if (checkParent === undefined) { checkParent = true; }

	        value = Clamp(value, this.minWidth, this.maxWidth);

	        if (checkParent && this._parent && value > this._parent.width)
	        {
	            value = Math.max(this.minWidth, this._parent.width);
	        }

	        return value;
	    },

	    getNewHeight: function (value, checkParent)
	    {
	        if (checkParent === undefined) { checkParent = true; }

	        value = Clamp(value, this.minHeight, this.maxHeight);

	        if (checkParent && this._parent && value > this._parent.height)
	        {
	            value = Math.max(this.minHeight, this._parent.height);
	        }

	        return value;
	    },

	    constrain: function (width, height, fit)
	    {
	        if (width === undefined) { width = 0; }
	        if (height === undefined) { height = width; }
	        if (fit === undefined) { fit = true; }

	        width = this.getNewWidth(width);
	        height = this.getNewHeight(height);

	        var snap = this.snapTo;
	        var newRatio = (height === 0) ? 1 : width / height;

	        if ((fit && this.aspectRatio > newRatio) || (!fit && this.aspectRatio < newRatio))
	        {

	            width = SnapFloor(width, snap.x);

	            height = width / this.aspectRatio;

	            if (snap.y > 0)
	            {
	                height = SnapFloor(height, snap.y);

	                width = height * this.aspectRatio;
	            }
	        }
	        else if ((fit && this.aspectRatio < newRatio) || (!fit && this.aspectRatio > newRatio))
	        {

	            height = SnapFloor(height, snap.y);

	            width = height * this.aspectRatio;

	            if (snap.x > 0)
	            {
	                width = SnapFloor(width, snap.x);

	                height = width * (1 / this.aspectRatio);
	            }
	        }

	        this._width = width;
	        this._height = height;

	        return this;
	    },

	    fitTo: function (width, height)
	    {
	        return this.constrain(width, height, true);
	    },

	    envelop: function (width, height)
	    {
	        return this.constrain(width, height, false);
	    },

	    setWidth: function (value)
	    {
	        return this.setSize(value, this._height);
	    },

	    setHeight: function (value)
	    {
	        return this.setSize(this._width, value);
	    },

	    toString: function ()
	    {
	        return '[{ Size (width=' + this._width + ' height=' + this._height + ' aspectRatio=' + this.aspectRatio + ' aspectMode=' + this.aspectMode + ') }]';
	    },

	    setCSS: function (element)
	    {
	        if (element && element.style)
	        {
	            element.style.width = this._width + 'px';
	            element.style.height = this._height + 'px';
	        }
	    },

	    copy: function (destination)
	    {
	        destination.setAspectMode(this.aspectMode);

	        destination.aspectRatio = this.aspectRatio;

	        return destination.setSize(this.width, this.height);
	    },

	    destroy: function ()
	    {
	        this._parent = null;
	        this.snapTo = null;
	    },

	    width: {

	        get: function ()
	        {
	            return this._width;
	        },

	        set: function (value)
	        {
	            this.setSize(value, this._height);
	        }

	    },

	    height: {

	        get: function ()
	        {
	            return this._height;
	        },

	        set: function (value)
	        {
	            this.setSize(this._width, value);
	        }

	    }

	});

	Size.NONE = 0;

	Size.WIDTH_CONTROLS_HEIGHT = 1;

	Size.HEIGHT_CONTROLS_WIDTH = 2;

	Size.FIT = 3;

	Size.ENVELOP = 4;

	Size_1$1 = Size;
	return Size_1$1;
}

var ScaleManager_1;
var hasRequiredScaleManager;

function requireScaleManager () {
	if (hasRequiredScaleManager) return ScaleManager_1;
	hasRequiredScaleManager = 1;
	var CONST = require_const$7();
	var Class = requireClass();
	var Clamp = requireClamp();
	var EventEmitter = requireEventemitter3();
	var Events = requireEvents$e();
	var GameEvents = requireEvents$h();
	var GetInnerHeight = requireGetInnerHeight();
	var GetTarget = requireGetTarget();
	var GetScreenOrientation = requireGetScreenOrientation();
	var NOOP = requireNOOP();
	var Rectangle = requireRectangle$2();
	var Size = requireSize$1();
	var SnapFloor = requireSnapFloor();
	var Vector2 = requireVector2();
	var Camera = requireCamera();

	var ScaleManager = new Class({

	    Extends: EventEmitter,

	    initialize:

	    function ScaleManager (game)
	    {
	        EventEmitter.call(this);

	        this.game = game;

	        this.canvas;

	        this.canvasBounds = new Rectangle();

	        this.parent = null;

	        this.parentIsWindow = false;

	        this.parentSize = new Size();

	        this.gameSize = new Size();

	        this.baseSize = new Size();

	        this.displaySize = new Size();

	        this.scaleMode = CONST.SCALE_MODE.NONE;

	        this.zoom = 1;

	        this._resetZoom = false;

	        this.displayScale = new Vector2(1, 1);

	        this.autoRound = false;

	        this.autoCenter = CONST.CENTER.NO_CENTER;

	        this.orientation = CONST.ORIENTATION.LANDSCAPE;

	        this.fullscreen;

	        this.fullscreenTarget = null;

	        this._createdFullscreenTarget = false;

	        this.dirty = false;

	        this.resizeInterval = 500;

	        this._lastCheck = 0;

	        this._checkOrientation = false;

	        this.domlisteners = {

	            orientationChange: NOOP,
	            windowResize: NOOP,
	            fullScreenChange: NOOP,
	            fullScreenError: NOOP

	        };
	    },

	    preBoot: function ()
	    {

	        this.parseConfig(this.game.config);

	        this.game.events.once(GameEvents.BOOT, this.boot, this);
	    },

	    boot: function ()
	    {
	        var game = this.game;

	        this.canvas = game.canvas;

	        this.fullscreen = game.device.fullscreen;

	        var scaleMode = this.scaleMode;

	        if (scaleMode !== CONST.SCALE_MODE.RESIZE && scaleMode !== CONST.SCALE_MODE.EXPAND)
	        {
	            this.displaySize.setAspectMode(scaleMode);
	        }

	        if (scaleMode === CONST.SCALE_MODE.NONE)
	        {
	            this.resize(this.width, this.height);
	        }
	        else
	        {
	            this.getParentBounds();

	            if (this.parentSize.width > 0 && this.parentSize.height > 0)
	            {
	                this.displaySize.setParent(this.parentSize);
	            }

	            this.refresh();
	        }

	        game.events.on(GameEvents.PRE_STEP, this.step, this);
	        game.events.once(GameEvents.READY, this.refresh, this);
	        game.events.once(GameEvents.DESTROY, this.destroy, this);

	        this.startListeners();
	    },

	    parseConfig: function (config)
	    {

	        this.getParent(config);

	        this.getParentBounds();

	        var width = config.width;
	        var height = config.height;
	        var scaleMode = config.scaleMode;
	        var zoom = config.zoom;
	        var autoRound = config.autoRound;

	        if (typeof width === 'string')
	        {

	            if (width.substr(-1) !== '%')
	            {
	                width = parseInt(width, 10);
	            }
	            else
	            {

	                var parentWidth = this.parentSize.width;

	                if (parentWidth === 0)
	                {
	                    parentWidth = window.innerWidth;
	                }

	                var parentScaleX = parseInt(width, 10) / 100;

	                width = Math.floor(parentWidth * parentScaleX);
	            }

	        }

	        if (typeof height === 'string')
	        {

	            if (height.substr(-1) !== '%')
	            {
	                height = parseInt(height, 10);
	            }
	            else
	            {

	                var parentHeight = this.parentSize.height;

	                if (parentHeight === 0)
	                {
	                    parentHeight = window.innerHeight;
	                }

	                var parentScaleY = parseInt(height, 10) / 100;

	                height = Math.floor(parentHeight * parentScaleY);
	            }
	        }

	        this.scaleMode = scaleMode;

	        this.autoRound = autoRound;

	        this.autoCenter = config.autoCenter;

	        this.resizeInterval = config.resizeInterval;

	        if (autoRound)
	        {
	            width = Math.floor(width);
	            height = Math.floor(height);
	        }

	        this.gameSize.setSize(width, height);

	        if (zoom === CONST.ZOOM.MAX_ZOOM)
	        {
	            zoom = this.getMaxZoom();
	        }

	        this.zoom = zoom;

	        if (zoom !== 1)
	        {
	            this._resetZoom = true;
	        }

	        this.baseSize.setSize(width, height);

	        if (autoRound)
	        {
	            this.baseSize.width = Math.floor(this.baseSize.width);
	            this.baseSize.height = Math.floor(this.baseSize.height);
	        }

	        if (config.minWidth > 0)
	        {
	            this.displaySize.setMin(config.minWidth * zoom, config.minHeight * zoom);
	        }

	        if (config.maxWidth > 0)
	        {
	            this.displaySize.setMax(config.maxWidth * zoom, config.maxHeight * zoom);
	        }

	        this.displaySize.setSize(width, height);

	        if (config.snapWidth > 0 || config.snapHeight > 0)
	        {
	            this.displaySize.setSnap(config.snapWidth, config.snapHeight);
	        }

	        this.orientation = GetScreenOrientation(width, height);
	    },

	    getParent: function (config)
	    {
	        var parent = config.parent;

	        if (parent === null)
	        {

	            return;
	        }

	        this.parent = GetTarget(parent);
	        this.parentIsWindow = (this.parent === document.body);

	        if (config.expandParent && config.scaleMode !== CONST.SCALE_MODE.NONE)
	        {
	            var DOMRect = this.parent.getBoundingClientRect();

	            if (this.parentIsWindow || DOMRect.height === 0)
	            {
	                document.documentElement.style.height = '100%';
	                document.body.style.height = '100%';

	                DOMRect = this.parent.getBoundingClientRect();

	                if (!this.parentIsWindow && DOMRect.height === 0)
	                {
	                    this.parent.style.overflow = 'hidden';
	                    this.parent.style.width = '100%';
	                    this.parent.style.height = '100%';
	                }
	            }
	        }

	        if (config.fullscreenTarget && !this.fullscreenTarget)
	        {
	            this.fullscreenTarget = GetTarget(config.fullscreenTarget);
	        }
	    },

	    getParentBounds: function ()
	    {
	        if (!this.parent)
	        {
	            return false;
	        }

	        var parentSize = this.parentSize;

	        var DOMRect = this.parent.getBoundingClientRect();

	        if (this.parentIsWindow && this.game.device.os.iOS)
	        {
	            DOMRect.height = GetInnerHeight(true);
	        }

	        var newWidth = DOMRect.width;
	        var newHeight = DOMRect.height;

	        if (parentSize.width !== newWidth || parentSize.height !== newHeight)
	        {
	            parentSize.setSize(newWidth, newHeight);

	            return true;
	        }
	        else if (this.canvas)
	        {
	            var canvasBounds = this.canvasBounds;
	            var canvasRect = this.canvas.getBoundingClientRect();

	            if (canvasRect.x !== canvasBounds.x || canvasRect.y !== canvasBounds.y)
	            {
	                return true;
	            }
	        }

	        return false;
	    },

	    lockOrientation: function (orientation)
	    {
	        var lock = screen.lockOrientation || screen.mozLockOrientation || screen.msLockOrientation;

	        if (lock)
	        {
	            return lock.call(screen, orientation);
	        }

	        return false;
	    },

	    setParentSize: function (width, height)
	    {
	        this.parentSize.setSize(width, height);

	        return this.refresh();
	    },

	    setGameSize: function (width, height)
	    {
	        var autoRound = this.autoRound;

	        if (autoRound)
	        {
	            width = Math.floor(width);
	            height = Math.floor(height);
	        }

	        var previousWidth = this.width;
	        var previousHeight = this.height;

	        this.gameSize.resize(width, height);

	        this.baseSize.resize(width, height);

	        if (autoRound)
	        {
	            this.baseSize.width = Math.floor(this.baseSize.width);
	            this.baseSize.height = Math.floor(this.baseSize.height);
	        }

	        this.displaySize.setAspectRatio(width / height);

	        this.canvas.width = this.baseSize.width;
	        this.canvas.height = this.baseSize.height;

	        return this.refresh(previousWidth, previousHeight);
	    },

	    resize: function (width, height)
	    {
	        var zoom = this.zoom;
	        var autoRound = this.autoRound;

	        if (autoRound)
	        {
	            width = Math.floor(width);
	            height = Math.floor(height);
	        }

	        var previousWidth = this.width;
	        var previousHeight = this.height;

	        this.gameSize.resize(width, height);

	        this.baseSize.resize(width, height);

	        if (autoRound)
	        {
	            this.baseSize.width = Math.floor(this.baseSize.width);
	            this.baseSize.height = Math.floor(this.baseSize.height);
	        }

	        this.displaySize.setSize((width * zoom), (height * zoom));

	        this.canvas.width = this.baseSize.width;
	        this.canvas.height = this.baseSize.height;

	        var style = this.canvas.style;

	        var styleWidth = width * zoom;
	        var styleHeight = height * zoom;

	        if (autoRound)
	        {
	            styleWidth = Math.floor(styleWidth);
	            styleHeight = Math.floor(styleHeight);
	        }

	        if (styleWidth !== width || styleHeight !== height)
	        {
	            style.width = styleWidth + 'px';
	            style.height = styleHeight + 'px';
	        }

	        return this.refresh(previousWidth, previousHeight);
	    },

	    setZoom: function (value)
	    {
	        this.zoom = value;
	        this._resetZoom = true;

	        return this.refresh();
	    },

	    setMaxZoom: function ()
	    {
	        this.zoom = this.getMaxZoom();
	        this._resetZoom = true;

	        return this.refresh();
	    },

	    setSnap: function (snapWidth, snapHeight)
	    {
	        if (snapWidth === undefined) { snapWidth = 0; }
	        if (snapHeight === undefined) { snapHeight = snapWidth; }

	        this.displaySize.setSnap(snapWidth, snapHeight);

	        return this.refresh();
	    },

	    refresh: function (previousWidth, previousHeight)
	    {
	        if (previousWidth === undefined) { previousWidth = this.width; }
	        if (previousHeight === undefined) { previousHeight = this.height; }

	        this.updateScale();
	        this.updateBounds();
	        this.updateOrientation();

	        this.displayScale.set(this.baseSize.width / this.canvasBounds.width, this.baseSize.height / this.canvasBounds.height);

	        var domContainer = this.game.domContainer;

	        if (domContainer)
	        {
	            this.baseSize.setCSS(domContainer);

	            var canvasStyle = this.canvas.style;
	            var domStyle = domContainer.style;

	            domStyle.transform = 'scale(' + this.displaySize.width / this.baseSize.width + ',' + this.displaySize.height / this.baseSize.height + ')';

	            domStyle.marginLeft = canvasStyle.marginLeft;
	            domStyle.marginTop = canvasStyle.marginTop;
	        }

	        this.emit(Events.RESIZE, this.gameSize, this.baseSize, this.displaySize, previousWidth, previousHeight);

	        return this;
	    },

	    updateOrientation: function ()
	    {
	        if (this._checkOrientation)
	        {
	            this._checkOrientation = false;

	            var newOrientation = GetScreenOrientation(this.width, this.height);

	            if (newOrientation !== this.orientation)
	            {
	                this.orientation = newOrientation;

	                this.emit(Events.ORIENTATION_CHANGE, newOrientation);
	            }
	        }
	    },

	    updateScale: function ()
	    {
	        var style = this.canvas.style;

	        var width = this.gameSize.width;
	        var height = this.gameSize.height;

	        var styleWidth;
	        var styleHeight;

	        var zoom = this.zoom;
	        var autoRound = this.autoRound;

	        if (this.scaleMode === CONST.SCALE_MODE.NONE)
	        {

	            this.displaySize.setSize((width * zoom), (height * zoom));

	            styleWidth = this.displaySize.width;
	            styleHeight = this.displaySize.height;

	            if (autoRound)
	            {
	                styleWidth = Math.floor(styleWidth);
	                styleHeight = Math.floor(styleHeight);
	            }

	            if (this._resetZoom)
	            {
	                style.width = styleWidth + 'px';
	                style.height = styleHeight + 'px';

	                this._resetZoom = false;
	            }
	        }
	        else if (this.scaleMode === CONST.SCALE_MODE.RESIZE)
	        {

	            this.displaySize.setSize(this.parentSize.width, this.parentSize.height);

	            this.gameSize.setSize(this.displaySize.width, this.displaySize.height);

	            this.baseSize.setSize(this.displaySize.width, this.displaySize.height);

	            styleWidth = this.displaySize.width;
	            styleHeight = this.displaySize.height;

	            if (autoRound)
	            {
	                styleWidth = Math.floor(styleWidth);
	                styleHeight = Math.floor(styleHeight);
	            }

	            this.canvas.width = styleWidth;
	            this.canvas.height = styleHeight;
	        }
	        else if (this.scaleMode === CONST.SCALE_MODE.EXPAND)
	        {

	            var baseWidth = this.game.config.width;
	            var baseHeight = this.game.config.height;

	            var windowWidth = this.parentSize.width;
	            var windowHeight = this.parentSize.height;

	            var scaleX = windowWidth / baseWidth;
	            var scaleY = windowHeight / baseHeight;

	            var canvasWidth;
	            var canvasHeight;

	            if (scaleX < scaleY)
	            {
	                canvasWidth = baseWidth;
	                canvasHeight = (scaleX !== 0)? windowHeight / scaleX : baseHeight;
	            }
	            else
	            {
	                canvasWidth = (scaleY !== 0)? windowWidth / scaleY : baseWidth;
	                canvasHeight = baseHeight;
	            }

	            var clampedCanvasWidth = Clamp(canvasWidth, this.displaySize.minWidth, this.displaySize.maxWidth);
	            var clampedCanvasHeight = Clamp(canvasHeight, this.displaySize.minHeight, this.displaySize.maxHeight);

	            this.baseSize.setSize(clampedCanvasWidth, clampedCanvasHeight);

	            this.gameSize.setSize(clampedCanvasWidth, clampedCanvasHeight);

	            if (autoRound)
	            {
	                clampedCanvasWidth = Math.floor(clampedCanvasWidth);
	                clampedCanvasHeight = Math.floor(clampedCanvasHeight);
	            }

	            this.canvas.width = clampedCanvasWidth;
	            this.canvas.height = clampedCanvasHeight;

	            var clampedWindowWidth = windowWidth * (clampedCanvasWidth / canvasWidth);
	            var clampedWindowHeight = windowHeight * (clampedCanvasHeight / canvasHeight);
	            this.displaySize.setSize(clampedWindowWidth, clampedWindowHeight);

	            styleWidth = this.displaySize.width;
	            styleHeight = this.displaySize.height;

	            if (autoRound)
	            {
	                styleWidth = Math.floor(styleWidth);
	                styleHeight = Math.floor(styleHeight);
	            }

	            style.width = styleWidth + 'px';
	            style.height = styleHeight + 'px';

	        }
	        else
	        {

	            this.displaySize.setSize(this.parentSize.width, this.parentSize.height);

	            styleWidth = this.displaySize.width;
	            styleHeight = this.displaySize.height;

	            if (autoRound)
	            {
	                styleWidth = Math.floor(styleWidth);
	                styleHeight = Math.floor(styleHeight);
	            }

	            style.width = styleWidth + 'px';
	            style.height = styleHeight + 'px';
	        }

	        this.getParentBounds();

	        this.updateCenter();
	    },

	    getMaxZoom: function ()
	    {
	        var zoomH = SnapFloor(this.parentSize.width, this.gameSize.width, 0, true);
	        var zoomV = SnapFloor(this.parentSize.height, this.gameSize.height, 0, true);

	        return Math.max(Math.min(zoomH, zoomV), 1);
	    },

	    updateCenter: function ()
	    {
	        var autoCenter = this.autoCenter;

	        if (autoCenter === CONST.CENTER.NO_CENTER)
	        {
	            return;
	        }

	        var canvas = this.canvas;

	        var style = canvas.style;

	        var bounds = canvas.getBoundingClientRect();

	        var width = bounds.width;
	        var height = bounds.height;

	        var offsetX = Math.floor((this.parentSize.width - width) / 2);
	        var offsetY = Math.floor((this.parentSize.height - height) / 2);

	        if (autoCenter === CONST.CENTER.CENTER_HORIZONTALLY)
	        {
	            offsetY = 0;
	        }
	        else if (autoCenter === CONST.CENTER.CENTER_VERTICALLY)
	        {
	            offsetX = 0;
	        }

	        style.marginLeft = offsetX + 'px';
	        style.marginTop = offsetY + 'px';
	    },

	    updateBounds: function ()
	    {
	        var bounds = this.canvasBounds;
	        var clientRect = this.canvas.getBoundingClientRect();

	        bounds.x = clientRect.left + (window.pageXOffset || 0) - (document.documentElement.clientLeft || 0);
	        bounds.y = clientRect.top + (window.pageYOffset || 0) - (document.documentElement.clientTop || 0);
	        bounds.width = clientRect.width;
	        bounds.height = clientRect.height;
	    },

	    transformX: function (pageX)
	    {
	        return (pageX - this.canvasBounds.left) * this.displayScale.x;
	    },

	    transformY: function (pageY)
	    {
	        return (pageY - this.canvasBounds.top) * this.displayScale.y;
	    },

	    startFullscreen: function (fullscreenOptions)
	    {
	        if (fullscreenOptions === undefined) { fullscreenOptions = { navigationUI: 'hide' }; }

	        var fullscreen = this.fullscreen;

	        if (!fullscreen.available)
	        {
	            this.emit(Events.FULLSCREEN_UNSUPPORTED);

	            return;
	        }

	        if (!fullscreen.active)
	        {
	            var fsTarget = this.getFullscreenTarget();

	            if (fullscreen.keyboard)
	            {
	                fsTarget[fullscreen.request](Element.ALLOW_KEYBOARD_INPUT);
	            }
	            else
	            {
	                fsTarget[fullscreen.request](fullscreenOptions);
	            }
	        }
	    },

	    fullscreenSuccessHandler: function ()
	    {
	        this.getParentBounds();

	        this.refresh();

	        this.emit(Events.ENTER_FULLSCREEN);
	    },

	    fullscreenErrorHandler: function (error)
	    {
	        this.removeFullscreenTarget();

	        this.emit(Events.FULLSCREEN_FAILED, error);
	    },

	    getFullscreenTarget: function ()
	    {
	        if (!this.fullscreenTarget)
	        {
	            var fsTarget = document.createElement('div');

	            fsTarget.style.margin = '0';
	            fsTarget.style.padding = '0';
	            fsTarget.style.width = '100%';
	            fsTarget.style.height = '100%';

	            this.fullscreenTarget = fsTarget;

	            this._createdFullscreenTarget = true;
	        }

	        if (this._createdFullscreenTarget)
	        {
	            var canvasParent = this.canvas.parentNode;

	            canvasParent.insertBefore(this.fullscreenTarget, this.canvas);

	            this.fullscreenTarget.appendChild(this.canvas);
	        }

	        return this.fullscreenTarget;
	    },

	    removeFullscreenTarget: function ()
	    {
	        if (this._createdFullscreenTarget)
	        {
	            var fsTarget = this.fullscreenTarget;

	            if (fsTarget && fsTarget.parentNode)
	            {
	                var parent = fsTarget.parentNode;

	                parent.insertBefore(this.canvas, fsTarget);

	                parent.removeChild(fsTarget);
	            }
	        }
	    },

	    stopFullscreen: function ()
	    {
	        var fullscreen = this.fullscreen;

	        if (!fullscreen.available)
	        {
	            this.emit(Events.FULLSCREEN_UNSUPPORTED);

	            return false;
	        }

	        if (fullscreen.active)
	        {
	            document[fullscreen.cancel]();
	        }

	        this.removeFullscreenTarget();
	    },

	    leaveFullScreenSuccessHandler: function ()
	    {

	        this.getParentBounds();

	        this.emit(Events.LEAVE_FULLSCREEN);

	        this.refresh();
	    },

	    toggleFullscreen: function (fullscreenOptions)
	    {
	        if (this.fullscreen.active)
	        {
	            this.stopFullscreen();
	        }
	        else
	        {
	            this.startFullscreen(fullscreenOptions);
	        }
	    },

	    startListeners: function ()
	    {
	        var _this = this;
	        var listeners = this.domlisteners;

	        listeners.orientationChange = function ()
	        {
	            _this.updateBounds();

	            _this._checkOrientation = true;
	            _this.dirty = true;

	            _this.refresh();
	        };

	        listeners.windowResize = function ()
	        {
	            _this.updateBounds();

	            _this.dirty = true;
	        };

	        if (screen.orientation && screen.orientation.addEventListener)
	        {
	            screen.orientation.addEventListener('change', listeners.orientationChange, false);
	        }
	        else
	        {
	            window.addEventListener('orientationchange', listeners.orientationChange, false);
	        }

	        window.addEventListener('resize', listeners.windowResize, false);

	        if (this.fullscreen.available)
	        {
	            listeners.fullScreenChange = function (event)
	            {
	                return _this.onFullScreenChange(event);
	            };

	            listeners.fullScreenError = function (event)
	            {
	                return _this.onFullScreenError(event);
	            };

	            var vendors = [ 'webkit', 'moz', '' ];

	            vendors.forEach(function (prefix)
	            {
	                document.addEventListener(prefix + 'fullscreenchange', listeners.fullScreenChange, false);
	                document.addEventListener(prefix + 'fullscreenerror', listeners.fullScreenError, false);
	            });

	            document.addEventListener('MSFullscreenChange', listeners.fullScreenChange, false);
	            document.addEventListener('MSFullscreenError', listeners.fullScreenError, false);
	        }
	    },

	    onFullScreenChange: function ()
	    {
	        if (document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement || document.mozFullScreenElement)
	        {
	            this.fullscreenSuccessHandler();
	        }
	        else
	        {

	            this.stopFullscreen();
	            this.leaveFullScreenSuccessHandler();
	        }
	    },

	    onFullScreenError: function ()
	    {
	        this.removeFullscreenTarget();
	    },

	    getViewPort: function (camera, out)
	    {
	        if (!(camera instanceof Camera))
	        {
	            out = camera;
	            camera = undefined;
	        }

	        if (out === undefined)
	        {
	            out = new Rectangle();
	        }

	        var baseSize = this.baseSize;
	        var parentSize = this.parentSize;
	        var canvasBounds = this.canvasBounds;
	        var displayScale = this.displayScale;

	        var x = (canvasBounds.x >= 0) ? 0 : -(canvasBounds.x * displayScale.x);

	        var y = (canvasBounds.y >= 0) ? 0 : -(canvasBounds.y * displayScale.y);

	        var width;
	        if (parentSize.width >= canvasBounds.width)
	        {
	            width = baseSize.width;
	        }
	        else
	        {
	            width = baseSize.width - (canvasBounds.width - parentSize.width) * displayScale.x;
	        }

	        var height;
	        if (parentSize.height >= canvasBounds.height)
	        {
	            height = baseSize.height;
	        }
	        else
	        {
	            height = baseSize.height - (canvasBounds.height - parentSize.height) * displayScale.y;
	        }

	        out.setTo(x, y, width, height);

	        if (camera)
	        {
	            out.width /= camera.zoomX;
	            out.height /= camera.zoomY;
	            out.centerX = camera.centerX + camera.scrollX;
	            out.centerY = camera.centerY + camera.scrollY;
	        }

	        return out;
	    },

	    step: function (time, delta)
	    {
	        if (!this.parent)
	        {
	            return;
	        }

	        this._lastCheck += delta;

	        if (this.dirty || this._lastCheck > this.resizeInterval)
	        {

	            if (this.getParentBounds())
	            {
	                this.refresh();
	            }

	            this.dirty = false;
	            this._lastCheck = 0;
	        }
	    },

	    stopListeners: function ()
	    {
	        var listeners = this.domlisteners;

	        if (screen.orientation && screen.orientation.addEventListener)
	        {
	            screen.orientation.removeEventListener('change', listeners.orientationChange, false);
	        }
	        else
	        {
	            window.removeEventListener('orientationchange', listeners.orientationChange, false);
	        }

	        window.removeEventListener('resize', listeners.windowResize, false);

	        var vendors = [ 'webkit', 'moz', '' ];

	        vendors.forEach(function (prefix)
	        {
	            document.removeEventListener(prefix + 'fullscreenchange', listeners.fullScreenChange, false);
	            document.removeEventListener(prefix + 'fullscreenerror', listeners.fullScreenError, false);
	        });

	        document.removeEventListener('MSFullscreenChange', listeners.fullScreenChange, false);
	        document.removeEventListener('MSFullscreenError', listeners.fullScreenError, false);
	    },

	    destroy: function ()
	    {
	        this.removeAllListeners();

	        this.stopListeners();

	        this.game = null;
	        this.canvas = null;
	        this.canvasBounds = null;
	        this.parent = null;
	        this.fullscreenTarget = null;

	        this.parentSize.destroy();
	        this.gameSize.destroy();
	        this.baseSize.destroy();
	        this.displaySize.destroy();
	    },

	    isFullscreen: {

	        get: function ()
	        {
	            return this.fullscreen.active;
	        }

	    },

	    width: {

	        get: function ()
	        {
	            return this.gameSize.width;
	        }

	    },

	    height: {

	        get: function ()
	        {
	            return this.gameSize.height;
	        }

	    },

	    isPortrait: {

	        get: function ()
	        {
	            return (this.orientation === CONST.ORIENTATION.PORTRAIT);
	        }

	    },

	    isLandscape: {

	        get: function ()
	        {
	            return (this.orientation === CONST.ORIENTATION.LANDSCAPE);
	        }

	    },

	    isGamePortrait: {

	        get: function ()
	        {
	            return (this.height > this.width);
	        }

	    },

	    isGameLandscape: {

	        get: function ()
	        {
	            return (this.width > this.height);
	        }

	    }

	});

	ScaleManager_1 = ScaleManager;
	return ScaleManager_1;
}

var _const$5;
var hasRequired_const$5;

function require_const$5 () {
	if (hasRequired_const$5) return _const$5;
	hasRequired_const$5 = 1;
	var CONST = {

	    PENDING: 0,

	    INIT: 1,

	    START: 2,

	    LOADING: 3,

	    CREATING: 4,

	    RUNNING: 5,

	    PAUSED: 6,

	    SLEEPING: 7,

	    SHUTDOWN: 8,

	    DESTROYED: 9

	};

	_const$5 = CONST;
	return _const$5;
}

var ADD_EVENT;
var hasRequiredADD_EVENT;

function requireADD_EVENT () {
	if (hasRequiredADD_EVENT) return ADD_EVENT;
	hasRequiredADD_EVENT = 1;
	ADD_EVENT = 'addfile';
	return ADD_EVENT;
}

var COMPLETE_EVENT$3;
var hasRequiredCOMPLETE_EVENT$3;

function requireCOMPLETE_EVENT$3 () {
	if (hasRequiredCOMPLETE_EVENT$3) return COMPLETE_EVENT$3;
	hasRequiredCOMPLETE_EVENT$3 = 1;
	COMPLETE_EVENT$3 = 'complete';
	return COMPLETE_EVENT$3;
}

var FILE_COMPLETE_EVENT;
var hasRequiredFILE_COMPLETE_EVENT;

function requireFILE_COMPLETE_EVENT () {
	if (hasRequiredFILE_COMPLETE_EVENT) return FILE_COMPLETE_EVENT;
	hasRequiredFILE_COMPLETE_EVENT = 1;
	FILE_COMPLETE_EVENT = 'filecomplete';
	return FILE_COMPLETE_EVENT;
}

var FILE_KEY_COMPLETE_EVENT;
var hasRequiredFILE_KEY_COMPLETE_EVENT;

function requireFILE_KEY_COMPLETE_EVENT () {
	if (hasRequiredFILE_KEY_COMPLETE_EVENT) return FILE_KEY_COMPLETE_EVENT;
	hasRequiredFILE_KEY_COMPLETE_EVENT = 1;
	FILE_KEY_COMPLETE_EVENT = 'filecomplete-';
	return FILE_KEY_COMPLETE_EVENT;
}

var FILE_LOAD_ERROR_EVENT;
var hasRequiredFILE_LOAD_ERROR_EVENT;

function requireFILE_LOAD_ERROR_EVENT () {
	if (hasRequiredFILE_LOAD_ERROR_EVENT) return FILE_LOAD_ERROR_EVENT;
	hasRequiredFILE_LOAD_ERROR_EVENT = 1;
	FILE_LOAD_ERROR_EVENT = 'loaderror';
	return FILE_LOAD_ERROR_EVENT;
}

var FILE_LOAD_EVENT;
var hasRequiredFILE_LOAD_EVENT;

function requireFILE_LOAD_EVENT () {
	if (hasRequiredFILE_LOAD_EVENT) return FILE_LOAD_EVENT;
	hasRequiredFILE_LOAD_EVENT = 1;
	FILE_LOAD_EVENT = 'load';
	return FILE_LOAD_EVENT;
}

var FILE_PROGRESS_EVENT;
var hasRequiredFILE_PROGRESS_EVENT;

function requireFILE_PROGRESS_EVENT () {
	if (hasRequiredFILE_PROGRESS_EVENT) return FILE_PROGRESS_EVENT;
	hasRequiredFILE_PROGRESS_EVENT = 1;
	FILE_PROGRESS_EVENT = 'fileprogress';
	return FILE_PROGRESS_EVENT;
}

var POST_PROCESS_EVENT;
var hasRequiredPOST_PROCESS_EVENT;

function requirePOST_PROCESS_EVENT () {
	if (hasRequiredPOST_PROCESS_EVENT) return POST_PROCESS_EVENT;
	hasRequiredPOST_PROCESS_EVENT = 1;
	POST_PROCESS_EVENT = 'postprocess';
	return POST_PROCESS_EVENT;
}

var PROGRESS_EVENT;
var hasRequiredPROGRESS_EVENT;

function requirePROGRESS_EVENT () {
	if (hasRequiredPROGRESS_EVENT) return PROGRESS_EVENT;
	hasRequiredPROGRESS_EVENT = 1;
	PROGRESS_EVENT = 'progress';
	return PROGRESS_EVENT;
}

var START_EVENT$1;
var hasRequiredSTART_EVENT$1;

function requireSTART_EVENT$1 () {
	if (hasRequiredSTART_EVENT$1) return START_EVENT$1;
	hasRequiredSTART_EVENT$1 = 1;
	START_EVENT$1 = 'start';
	return START_EVENT$1;
}

var events$8;
var hasRequiredEvents$8;

function requireEvents$8 () {
	if (hasRequiredEvents$8) return events$8;
	hasRequiredEvents$8 = 1;
	events$8 = {

	    ADD: requireADD_EVENT(),
	    COMPLETE: requireCOMPLETE_EVENT$3(),
	    FILE_COMPLETE: requireFILE_COMPLETE_EVENT(),
	    FILE_KEY_COMPLETE: requireFILE_KEY_COMPLETE_EVENT(),
	    FILE_LOAD_ERROR: requireFILE_LOAD_ERROR_EVENT(),
	    FILE_LOAD: requireFILE_LOAD_EVENT(),
	    FILE_PROGRESS: requireFILE_PROGRESS_EVENT(),
	    POST_PROCESS: requirePOST_PROCESS_EVENT(),
	    PROGRESS: requirePROGRESS_EVENT(),
	    START: requireSTART_EVENT$1()

	};
	return events$8;
}

var GetPhysicsPlugins_1;
var hasRequiredGetPhysicsPlugins;

function requireGetPhysicsPlugins () {
	if (hasRequiredGetPhysicsPlugins) return GetPhysicsPlugins_1;
	hasRequiredGetPhysicsPlugins = 1;
	var GetFastValue = requireGetFastValue();
	var UppercaseFirst = requireUppercaseFirst();

	var GetPhysicsPlugins = function (sys)
	{
	    var defaultSystem = sys.game.config.defaultPhysicsSystem;
	    var sceneSystems = GetFastValue(sys.settings, 'physics', false);

	    if (!defaultSystem && !sceneSystems)
	    {

	        return;
	    }

	    var output = [];

	    if (defaultSystem)
	    {
	        output.push(UppercaseFirst(defaultSystem + 'Physics'));
	    }

	    if (sceneSystems)
	    {
	        for (var key in sceneSystems)
	        {
	            key = UppercaseFirst(key.concat('Physics'));

	            if (output.indexOf(key) === -1)
	            {
	                output.push(key);
	            }
	        }
	    }

	    return output;
	};

	GetPhysicsPlugins_1 = GetPhysicsPlugins;
	return GetPhysicsPlugins_1;
}

var GetScenePlugins_1;
var hasRequiredGetScenePlugins;

function requireGetScenePlugins () {
	if (hasRequiredGetScenePlugins) return GetScenePlugins_1;
	hasRequiredGetScenePlugins = 1;
	var GetFastValue = requireGetFastValue();

	var GetScenePlugins = function (sys)
	{
	    var defaultPlugins = sys.plugins.getDefaultScenePlugins();

	    var scenePlugins = GetFastValue(sys.settings, 'plugins', false);

	    if (Array.isArray(scenePlugins))
	    {
	        return scenePlugins;
	    }
	    else if (defaultPlugins)
	    {
	        return defaultPlugins;
	    }
	    else
	    {

	        return [];
	    }
	};

	GetScenePlugins_1 = GetScenePlugins;
	return GetScenePlugins_1;
}

var Clone_1$7;
var hasRequiredClone$7;

function requireClone$7 () {
	if (hasRequiredClone$7) return Clone_1$7;
	hasRequiredClone$7 = 1;
	var Clone = function (obj)
	{
	    var clone = {};

	    for (var key in obj)
	    {
	        if (Array.isArray(obj[key]))
	        {
	            clone[key] = obj[key].slice(0);
	        }
	        else
	        {
	            clone[key] = obj[key];
	        }
	    }

	    return clone;
	};

	Clone_1$7 = Clone;
	return Clone_1$7;
}

var Merge_1;
var hasRequiredMerge;

function requireMerge () {
	if (hasRequiredMerge) return Merge_1;
	hasRequiredMerge = 1;
	var Clone = requireClone$7();

	var Merge = function (obj1, obj2)
	{
	    var clone = Clone(obj1);

	    for (var key in obj2)
	    {
	        if (!clone.hasOwnProperty(key))
	        {
	            clone[key] = obj2[key];
	        }
	    }

	    return clone;
	};

	Merge_1 = Merge;
	return Merge_1;
}

var InjectionMap_1;
var hasRequiredInjectionMap;

function requireInjectionMap () {
	if (hasRequiredInjectionMap) return InjectionMap_1;
	hasRequiredInjectionMap = 1;
	var InjectionMap = {

	    game: 'game',
	    renderer: 'renderer',

	    anims: 'anims',
	    cache: 'cache',
	    plugins: 'plugins',
	    registry: 'registry',
	    scale: 'scale',
	    sound: 'sound',
	    textures: 'textures',

	    events: 'events',
	    cameras: 'cameras',
	    add: 'add',
	    make: 'make',
	    scenePlugin: 'scene',
	    displayList: 'children',
	    lights: 'lights',

	    data: 'data',
	    input: 'input',
	    load: 'load',
	    time: 'time',
	    tweens: 'tweens',

	    arcadePhysics: 'physics',
	    impactPhysics: 'impact',
	    matterPhysics: 'matter'

	};

	if (typeof PLUGIN_CAMERA3D)
	{
	    InjectionMap.cameras3d = 'cameras3d';
	}

	if (typeof PLUGIN_FBINSTANT)
	{
	    InjectionMap.facebook = 'facebook';
	}

	InjectionMap_1 = InjectionMap;
	return InjectionMap_1;
}

var Settings_1;
var hasRequiredSettings;

function requireSettings () {
	if (hasRequiredSettings) return Settings_1;
	hasRequiredSettings = 1;
	var CONST = require_const$5();
	var GetValue = requireGetValue();
	var Merge = requireMerge();
	var InjectionMap = requireInjectionMap();

	var Settings = {

	    create: function (config)
	    {
	        if (typeof config === 'string')
	        {
	            config = { key: config };
	        }
	        else if (config === undefined)
	        {

	            config = {};
	        }

	        return {

	            status: CONST.PENDING,

	            key: GetValue(config, 'key', ''),
	            active: GetValue(config, 'active', false),
	            visible: GetValue(config, 'visible', true),

	            isBooted: false,

	            isTransition: false,
	            transitionFrom: null,
	            transitionDuration: 0,
	            transitionAllowInput: true,

	            data: {},

	            pack: GetValue(config, 'pack', false),

	            cameras: GetValue(config, 'cameras', null),

	            map: GetValue(config, 'map', Merge(InjectionMap, GetValue(config, 'mapAdd', {}))),

	            physics: GetValue(config, 'physics', {}),

	            loader: GetValue(config, 'loader', {}),

	            plugins: GetValue(config, 'plugins', false),

	            input: GetValue(config, 'input', {})

	        };
	    }

	};

	Settings_1 = Settings;
	return Settings_1;
}

var Systems_1;
var hasRequiredSystems;

function requireSystems () {
	if (hasRequiredSystems) return Systems_1;
	hasRequiredSystems = 1;
	var Class = requireClass();
	var CONST = require_const$5();
	var DefaultPlugins = requireDefaultPlugins();
	var Events = requireEvents$l();
	var GetPhysicsPlugins = requireGetPhysicsPlugins();
	var GetScenePlugins = requireGetScenePlugins();
	var NOOP = requireNOOP();
	var Settings = requireSettings();

	var Systems = new Class({

	    initialize:

	    function Systems (scene, config)
	    {

	        this.scene = scene;

	        this.game;

	        this.renderer;

	        if (typeof PLUGIN_FBINSTANT)
	        {

	            this.facebook;
	        }

	        this.config = config;

	        this.settings = Settings.create(config);

	        this.canvas;

	        this.context;

	        this.anims;

	        this.cache;

	        this.plugins;

	        this.registry;

	        this.scale;

	        this.sound;

	        this.textures;

	        this.add;

	        this.cameras;

	        this.displayList;

	        this.events;

	        this.make;

	        this.scenePlugin;

	        this.updateList;

	        this.sceneUpdate = NOOP;
	    },

	    init: function (game)
	    {
	        this.settings.status = CONST.INIT;

	        this.sceneUpdate = NOOP;

	        this.game = game;
	        this.renderer = game.renderer;

	        this.canvas = game.canvas;
	        this.context = game.context;

	        var pluginManager = game.plugins;

	        this.plugins = pluginManager;

	        pluginManager.addToScene(this, DefaultPlugins.Global, [ DefaultPlugins.CoreScene, GetScenePlugins(this), GetPhysicsPlugins(this) ]);

	        this.events.emit(Events.BOOT, this);

	        this.settings.isBooted = true;
	    },

	    step: function (time, delta)
	    {
	        var events = this.events;

	        events.emit(Events.PRE_UPDATE, time, delta);

	        events.emit(Events.UPDATE, time, delta);

	        this.sceneUpdate.call(this.scene, time, delta);

	        events.emit(Events.POST_UPDATE, time, delta);
	    },

	    render: function (renderer)
	    {
	        var displayList = this.displayList;

	        displayList.depthSort();

	        this.events.emit(Events.PRE_RENDER, renderer);

	        this.cameras.render(renderer, displayList);

	        this.events.emit(Events.RENDER, renderer);
	    },

	    queueDepthSort: function ()
	    {
	        this.displayList.queueDepthSort();
	    },

	    depthSort: function ()
	    {
	        this.displayList.depthSort();
	    },

	    pause: function (data)
	    {
	        var settings = this.settings;
	        var status = this.getStatus();

	        if (status !== CONST.CREATING && status !== CONST.RUNNING)
	        {
	            console.warn('Cannot pause non-running Scene', settings.key);
	        }
	        else if (this.settings.active)
	        {
	            settings.status = CONST.PAUSED;

	            settings.active = false;

	            this.events.emit(Events.PAUSE, this, data);
	        }

	        return this;
	    },

	    resume: function (data)
	    {
	        var events = this.events;
	        var settings = this.settings;

	        if (!this.settings.active)
	        {
	            settings.status = CONST.RUNNING;

	            settings.active = true;

	            events.emit(Events.RESUME, this, data);
	        }

	        return this;
	    },

	    sleep: function (data)
	    {
	        var settings = this.settings;
	        var status = this.getStatus();

	        if (status !== CONST.CREATING && status !== CONST.RUNNING)
	        {
	            console.warn('Cannot sleep non-running Scene', settings.key);
	        }
	        else
	        {
	            settings.status = CONST.SLEEPING;

	            settings.active = false;
	            settings.visible = false;

	            this.events.emit(Events.SLEEP, this, data);
	        }

	        return this;
	    },

	    wake: function (data)
	    {
	        var events = this.events;
	        var settings = this.settings;

	        settings.status = CONST.RUNNING;

	        settings.active = true;
	        settings.visible = true;

	        events.emit(Events.WAKE, this, data);

	        if (settings.isTransition)
	        {
	            events.emit(Events.TRANSITION_WAKE, settings.transitionFrom, settings.transitionDuration);
	        }

	        return this;
	    },

	    getData: function ()
	    {
	        return this.settings.data;
	    },

	    getStatus: function ()
	    {
	        return this.settings.status;
	    },

	    canInput: function ()
	    {
	        var status = this.settings.status;

	        return (status > CONST.PENDING && status <= CONST.RUNNING);
	    },

	    isSleeping: function ()
	    {
	        return (this.settings.status === CONST.SLEEPING);
	    },

	    isActive: function ()
	    {
	        return (this.settings.status === CONST.RUNNING);
	    },

	    isPaused: function ()
	    {
	        return (this.settings.status === CONST.PAUSED);
	    },

	    isTransitioning: function ()
	    {
	        return (this.settings.isTransition || this.scenePlugin._target !== null);
	    },

	    isTransitionOut: function ()
	    {
	        return (this.scenePlugin._target !== null && this.scenePlugin._duration > 0);
	    },

	    isTransitionIn: function ()
	    {
	        return (this.settings.isTransition);
	    },

	    isVisible: function ()
	    {
	        return this.settings.visible;
	    },

	    setVisible: function (value)
	    {
	        this.settings.visible = value;

	        return this;
	    },

	    setActive: function (value, data)
	    {
	        if (value)
	        {
	            return this.resume(data);
	        }
	        else
	        {
	            return this.pause(data);
	        }
	    },

	    start: function (data)
	    {
	        var events = this.events;
	        var settings = this.settings;

	        if (data)
	        {
	            settings.data = data;
	        }

	        settings.status = CONST.START;

	        settings.active = true;
	        settings.visible = true;

	        events.emit(Events.START, this);

	        events.emit(Events.READY, this, data);
	    },

	    shutdown: function (data)
	    {
	        var events = this.events;
	        var settings = this.settings;

	        events.off(Events.TRANSITION_INIT);
	        events.off(Events.TRANSITION_START);
	        events.off(Events.TRANSITION_COMPLETE);
	        events.off(Events.TRANSITION_OUT);

	        settings.status = CONST.SHUTDOWN;

	        settings.active = false;
	        settings.visible = false;

	        events.emit(Events.SHUTDOWN, this, data);
	    },

	    destroy: function ()
	    {
	        var events = this.events;
	        var settings = this.settings;

	        settings.status = CONST.DESTROYED;

	        settings.active = false;
	        settings.visible = false;

	        events.emit(Events.DESTROY, this);

	        events.removeAllListeners();

	        var props = [ 'scene', 'game', 'anims', 'cache', 'plugins', 'registry', 'sound', 'textures', 'add', 'camera', 'displayList', 'events', 'make', 'scenePlugin', 'updateList' ];

	        for (var i = 0; i < props.length; i++)
	        {
	            this[props[i]] = null;
	        }
	    }

	});

	Systems_1 = Systems;
	return Systems_1;
}

var Scene_1;
var hasRequiredScene$1;

function requireScene$1 () {
	if (hasRequiredScene$1) return Scene_1;
	hasRequiredScene$1 = 1;
	var Class = requireClass();
	var Systems = requireSystems();

	var Scene = new Class({

	    initialize:

	    function Scene (config)
	    {

	        this.sys = new Systems(this, config);

	        this.game;

	        this.anims;

	        this.cache;

	        this.registry;

	        this.sound;

	        this.textures;

	        this.events;

	        this.cameras;

	        this.add;

	        this.make;

	        this.scene;

	        this.children;

	        this.lights;

	        this.data;

	        this.input;

	        this.load;

	        this.time;

	        this.tweens;

	        this.physics;

	        this.matter;

	        if (typeof PLUGIN_FBINSTANT)
	        {

	            this.facebook;
	        }

	        this.scale;

	        this.plugins;

	        this.renderer;
	    },

	    update: function ()
	    {
	    }

	});

	Scene_1 = Scene;
	return Scene_1;
}

var SceneManager_1;
var hasRequiredSceneManager;

function requireSceneManager () {
	if (hasRequiredSceneManager) return SceneManager_1;
	hasRequiredSceneManager = 1;
	var Class = requireClass();
	var CONST = require_const$5();
	var Events = requireEvents$l();
	var GameEvents = requireEvents$h();
	var GetValue = requireGetValue();
	var LoaderEvents = requireEvents$8();
	var NOOP = requireNOOP();
	var Scene = requireScene$1();
	var Systems = requireSystems();

	var SceneManager = new Class({

	    initialize:

	    function SceneManager (game, sceneConfig)
	    {

	        this.game = game;

	        this.keys = {};

	        this.scenes = [];

	        this._pending = [];

	        this._start = [];

	        this._queue = [];

	        this._data = {};

	        this.isProcessing = false;

	        this.isBooted = false;

	        this.customViewports = 0;

	        this.systemScene;

	        if (sceneConfig)
	        {
	            if (!Array.isArray(sceneConfig))
	            {
	                sceneConfig = [ sceneConfig ];
	            }

	            for (var i = 0; i < sceneConfig.length; i++)
	            {

	                this._pending.push({
	                    key: 'default',
	                    scene: sceneConfig[i],
	                    autoStart: (i === 0),
	                    data: {}
	                });
	            }
	        }

	        game.events.once(GameEvents.READY, this.bootQueue, this);
	    },

	    bootQueue: function ()
	    {
	        if (this.isBooted)
	        {
	            return;
	        }

	        this.systemScene = this.createSceneFromInstance('__SYSTEM', new Scene());

	        this.game.events.emit(GameEvents.SYSTEM_READY, this.systemScene, this);

	        var i;
	        var entry;
	        var key;
	        var sceneConfig;

	        for (i = 0; i < this._pending.length; i++)
	        {
	            entry = this._pending[i];

	            key = entry.key;
	            sceneConfig = entry.scene;

	            var newScene;

	            if (sceneConfig instanceof Scene)
	            {
	                newScene = this.createSceneFromInstance(key, sceneConfig);
	            }
	            else if (typeof sceneConfig === 'object')
	            {
	                newScene = this.createSceneFromObject(key, sceneConfig);
	            }
	            else if (typeof sceneConfig === 'function')
	            {
	                newScene = this.createSceneFromFunction(key, sceneConfig);
	            }

	            key = newScene.sys.settings.key;

	            this.keys[key] = newScene;

	            this.scenes.push(newScene);

	            if (this._data[key])
	            {
	                newScene.sys.settings.data = this._data[key].data;

	                if (this._data[key].autoStart)
	                {
	                    entry.autoStart = true;
	                }
	            }

	            if (entry.autoStart || newScene.sys.settings.active)
	            {
	                this._start.push(key);
	            }
	        }

	        this._pending.length = 0;

	        this._data = {};

	        this.isBooted = true;

	        for (i = 0; i < this._start.length; i++)
	        {
	            entry = this._start[i];

	            this.start(entry);
	        }

	        this._start.length = 0;
	    },

	    processQueue: function ()
	    {
	        var pendingLength = this._pending.length;
	        var queueLength = this._queue.length;

	        if (pendingLength === 0 && queueLength === 0)
	        {
	            return;
	        }

	        var i;
	        var entry;

	        if (pendingLength)
	        {
	            for (i = 0; i < pendingLength; i++)
	            {
	                entry = this._pending[i];

	                this.add(entry.key, entry.scene, entry.autoStart, entry.data);
	            }

	            for (i = 0; i < this._start.length; i++)
	            {
	                entry = this._start[i];

	                this.start(entry);
	            }

	            this._start.length = 0;
	            this._pending.length = 0;
	        }

	        for (i = 0; i < this._queue.length; i++)
	        {
	            entry = this._queue[i];

	            this[entry.op](entry.keyA, entry.keyB, entry.data);
	        }

	        this._queue.length = 0;
	    },

	    add: function (key, sceneConfig, autoStart, data)
	    {
	        if (autoStart === undefined) { autoStart = false; }
	        if (data === undefined) { data = {}; }

	        if (this.isProcessing || !this.isBooted)
	        {
	            this._pending.push({
	                key: key,
	                scene: sceneConfig,
	                autoStart: autoStart,
	                data: data
	            });

	            if (!this.isBooted)
	            {
	                this._data[key] = { data: data };
	            }

	            return null;
	        }

	        key = this.getKey(key, sceneConfig);

	        var newScene;

	        if (sceneConfig instanceof Scene)
	        {
	            newScene = this.createSceneFromInstance(key, sceneConfig);
	        }
	        else if (typeof sceneConfig === 'object')
	        {
	            sceneConfig.key = key;

	            newScene = this.createSceneFromObject(key, sceneConfig);
	        }
	        else if (typeof sceneConfig === 'function')
	        {
	            newScene = this.createSceneFromFunction(key, sceneConfig);
	        }

	        newScene.sys.settings.data = data;

	        key = newScene.sys.settings.key;

	        this.keys[key] = newScene;

	        this.scenes.push(newScene);

	        if (autoStart || newScene.sys.settings.active)
	        {
	            if (this._pending.length)
	            {
	                this._start.push(key);
	            }
	            else
	            {
	                this.start(key);
	            }
	        }

	        return newScene;
	    },

	    remove: function (key)
	    {
	        if (this.isProcessing)
	        {
	            return this.queueOp('remove', key);
	        }

	        var sceneToRemove = this.getScene(key);

	        if (!sceneToRemove || sceneToRemove.sys.isTransitioning())
	        {
	            return this;
	        }

	        var index = this.scenes.indexOf(sceneToRemove);
	        var sceneKey = sceneToRemove.sys.settings.key;

	        if (index > -1)
	        {
	            delete this.keys[sceneKey];
	            this.scenes.splice(index, 1);

	            if (this._start.indexOf(sceneKey) > -1)
	            {
	                index = this._start.indexOf(sceneKey);
	                this._start.splice(index, 1);
	            }

	            sceneToRemove.sys.destroy();
	        }

	        return this;
	    },

	    bootScene: function (scene)
	    {
	        var sys = scene.sys;
	        var settings = sys.settings;

	        sys.sceneUpdate = NOOP;

	        if (scene.init)
	        {
	            scene.init.call(scene, settings.data);

	            settings.status = CONST.INIT;

	            if (settings.isTransition)
	            {
	                sys.events.emit(Events.TRANSITION_INIT, settings.transitionFrom, settings.transitionDuration);
	            }
	        }

	        var loader;

	        if (sys.load)
	        {
	            loader = sys.load;

	            loader.reset();
	        }

	        if (loader && scene.preload)
	        {
	            scene.preload.call(scene);

	            settings.status = CONST.LOADING;

	            loader.once(LoaderEvents.COMPLETE, this.loadComplete, this);

	            loader.start();
	        }
	        else
	        {

	            this.create(scene);
	        }
	    },

	    loadComplete: function (loader)
	    {
	        this.create(loader.scene);
	    },

	    payloadComplete: function (loader)
	    {
	        this.bootScene(loader.scene);
	    },

	    update: function (time, delta)
	    {
	        this.processQueue();

	        this.isProcessing = true;

	        for (var i = this.scenes.length - 1; i >= 0; i--)
	        {
	            var sys = this.scenes[i].sys;

	            if (sys.settings.status > CONST.START && sys.settings.status <= CONST.RUNNING)
	            {
	                sys.step(time, delta);
	            }

	            if (sys.scenePlugin && sys.scenePlugin._target)
	            {
	                sys.scenePlugin.step(time, delta);
	            }
	        }
	    },

	    render: function (renderer)
	    {

	        for (var i = 0; i < this.scenes.length; i++)
	        {
	            var sys = this.scenes[i].sys;

	            if (sys.settings.visible && sys.settings.status >= CONST.LOADING && sys.settings.status < CONST.SLEEPING)
	            {
	                sys.render(renderer);
	            }
	        }

	        this.isProcessing = false;
	    },

	    create: function (scene)
	    {
	        var sys = scene.sys;
	        var settings = sys.settings;

	        if (scene.create)
	        {
	            settings.status = CONST.CREATING;

	            scene.create.call(scene, settings.data);

	            if (settings.status === CONST.DESTROYED)
	            {
	                return;
	            }
	        }

	        if (settings.isTransition)
	        {
	            sys.events.emit(Events.TRANSITION_START, settings.transitionFrom, settings.transitionDuration);
	        }

	        if (scene.update)
	        {
	            sys.sceneUpdate = scene.update;
	        }

	        settings.status = CONST.RUNNING;

	        sys.events.emit(Events.CREATE, scene);
	    },

	    createSceneFromFunction: function (key, scene)
	    {
	        var newScene = new scene();

	        if (newScene instanceof Scene)
	        {
	            var configKey = newScene.sys.settings.key;

	            if (configKey !== '')
	            {
	                key = configKey;
	            }

	            if (this.keys.hasOwnProperty(key))
	            {
	                throw new Error('Cannot add Scene with duplicate key: ' + key);
	            }

	            return this.createSceneFromInstance(key, newScene);
	        }
	        else
	        {
	            newScene.sys = new Systems(newScene);

	            newScene.sys.settings.key = key;

	            newScene.sys.init(this.game);

	            return newScene;
	        }
	    },

	    createSceneFromInstance: function (key, newScene)
	    {
	        var configKey = newScene.sys.settings.key;

	        if (configKey === '')
	        {
	            newScene.sys.settings.key = key;
	        }

	        newScene.sys.init(this.game);

	        return newScene;
	    },

	    createSceneFromObject: function (key, sceneConfig)
	    {
	        var newScene = new Scene(sceneConfig);

	        var configKey = newScene.sys.settings.key;

	        if (configKey !== '')
	        {
	            key = configKey;
	        }
	        else
	        {
	            newScene.sys.settings.key = key;
	        }

	        newScene.sys.init(this.game);

	        var defaults = [ 'init', 'preload', 'create', 'update', 'render' ];

	        for (var i = 0; i < defaults.length; i++)
	        {
	            var sceneCallback = GetValue(sceneConfig, defaults[i], null);

	            if (sceneCallback)
	            {
	                newScene[defaults[i]] = sceneCallback;
	            }
	        }

	        if (sceneConfig.hasOwnProperty('extend'))
	        {
	            for (var propertyKey in sceneConfig.extend)
	            {
	                if (!sceneConfig.extend.hasOwnProperty(propertyKey))
	                {
	                    continue;
	                }

	                var value = sceneConfig.extend[propertyKey];

	                if (propertyKey === 'data' && newScene.hasOwnProperty('data') && typeof value === 'object')
	                {

	                    newScene.data.merge(value);
	                }
	                else if (propertyKey !== 'sys')
	                {
	                    newScene[propertyKey] = value;
	                }
	            }
	        }

	        return newScene;
	    },

	    getKey: function (key, sceneConfig)
	    {
	        if (!key) { key = 'default'; }

	        if (typeof sceneConfig === 'function')
	        {
	            return key;
	        }
	        else if (sceneConfig instanceof Scene)
	        {
	            key = sceneConfig.sys.settings.key;
	        }
	        else if (typeof sceneConfig === 'object' && sceneConfig.hasOwnProperty('key'))
	        {
	            key = sceneConfig.key;
	        }

	        if (this.keys.hasOwnProperty(key))
	        {
	            throw new Error('Cannot add Scene with duplicate key: ' + key);
	        }
	        else
	        {
	            return key;
	        }
	    },

	    getScenes: function (isActive, inReverse)
	    {
	        if (isActive === undefined) { isActive = true; }
	        if (inReverse === undefined) { inReverse = false; }

	        var out = [];
	        var scenes = this.scenes;

	        for (var i = 0; i < scenes.length; i++)
	        {
	            var scene = scenes[i];

	            if (scene && (!isActive || (isActive && scene.sys.isActive())))
	            {
	                out.push(scene);
	            }
	        }

	        return (inReverse) ? out.reverse() : out;
	    },

	    getScene: function (key)
	    {
	        if (typeof key === 'string')
	        {
	            if (this.keys[key])
	            {
	                return this.keys[key];
	            }
	        }
	        else
	        {
	            for (var i = 0; i < this.scenes.length; i++)
	            {
	                if (key === this.scenes[i])
	                {
	                    return key;
	                }
	            }
	        }

	        return null;
	    },

	    isActive: function (key)
	    {
	        var scene = this.getScene(key);

	        if (scene)
	        {
	            return scene.sys.isActive();
	        }

	        return null;
	    },

	    isPaused: function (key)
	    {
	        var scene = this.getScene(key);

	        if (scene)
	        {
	            return scene.sys.isPaused();
	        }

	        return null;
	    },

	    isVisible: function (key)
	    {
	        var scene = this.getScene(key);

	        if (scene)
	        {
	            return scene.sys.isVisible();
	        }

	        return null;
	    },

	    isSleeping: function (key)
	    {
	        var scene = this.getScene(key);

	        if (scene)
	        {
	            return scene.sys.isSleeping();
	        }

	        return null;
	    },

	    pause: function (key, data)
	    {
	        var scene = this.getScene(key);

	        if (scene)
	        {
	            scene.sys.pause(data);
	        }

	        return this;
	    },

	    resume: function (key, data)
	    {
	        var scene = this.getScene(key);

	        if (scene)
	        {
	            scene.sys.resume(data);
	        }

	        return this;
	    },

	    sleep: function (key, data)
	    {
	        var scene = this.getScene(key);

	        if (scene && !scene.sys.isTransitioning())
	        {
	            scene.sys.sleep(data);
	        }

	        return this;
	    },

	    wake: function (key, data)
	    {
	        var scene = this.getScene(key);

	        if (scene)
	        {
	            scene.sys.wake(data);
	        }

	        return this;
	    },

	    run: function (key, data)
	    {
	        var scene = this.getScene(key);

	        if (!scene)
	        {
	            for (var i = 0; i < this._pending.length; i++)
	            {
	                if (this._pending[i].key === key)
	                {
	                    this.queueOp('start', key, data);
	                    break;
	                }
	            }
	            return this;
	        }

	        if (scene.sys.isSleeping())
	        {

	            scene.sys.wake(data);
	        }
	        else if (scene.sys.isPaused())
	        {

	            scene.sys.resume(data);
	        }
	        else
	        {

	            this.start(key, data);
	        }
	    },

	    start: function (key, data)
	    {

	        if (!this.isBooted)
	        {
	            this._data[key] = {
	                autoStart: true,
	                data: data
	            };

	            return this;
	        }

	        var scene = this.getScene(key);

	        if (!scene)
	        {
	            console.warn('Scene key not found: ' + key);
	            return this;
	        }

	        var sys = scene.sys;
	        var status = sys.settings.status;

	        if (status >= CONST.START && status <= CONST.CREATING)
	        {
	            return this;
	        }

	        else if (status >= CONST.RUNNING && status <= CONST.SLEEPING)
	        {
	            sys.shutdown();

	            sys.sceneUpdate = NOOP;

	            sys.start(data);
	        }

	        else
	        {
	            sys.sceneUpdate = NOOP;

	            sys.start(data);

	            var loader;

	            if (sys.load)
	            {
	                loader = sys.load;
	            }

	            if (loader && sys.settings.hasOwnProperty('pack'))
	            {
	                loader.reset();

	                if (loader.addPack({ payload: sys.settings.pack }))
	                {
	                    sys.settings.status = CONST.LOADING;

	                    loader.once(LoaderEvents.COMPLETE, this.payloadComplete, this);

	                    loader.start();

	                    return this;
	                }
	            }
	        }

	        this.bootScene(scene);

	        return this;
	    },

	    stop: function (key, data)
	    {
	        var scene = this.getScene(key);

	        if (scene && !scene.sys.isTransitioning() && scene.sys.settings.status !== CONST.SHUTDOWN)
	        {
	            var loader = scene.sys.load;

	            if (loader)
	            {
	                loader.off(LoaderEvents.COMPLETE, this.loadComplete, this);
	                loader.off(LoaderEvents.COMPLETE, this.payloadComplete, this);
	            }

	            scene.sys.shutdown(data);
	        }

	        return this;
	    },

	    switch: function (from, to, data)
	    {
	        var sceneA = this.getScene(from);
	        var sceneB = this.getScene(to);

	        if (sceneA && sceneB && sceneA !== sceneB)
	        {
	            this.sleep(from);

	            if (this.isSleeping(to))
	            {
	                this.wake(to, data);
	            }
	            else
	            {
	                this.start(to, data);
	            }
	        }

	        return this;
	    },

	    getAt: function (index)
	    {
	        return this.scenes[index];
	    },

	    getIndex: function (key)
	    {
	        var scene = this.getScene(key);

	        return this.scenes.indexOf(scene);
	    },

	    bringToTop: function (key)
	    {
	        if (this.isProcessing)
	        {
	            return this.queueOp('bringToTop', key);
	        }

	        var index = this.getIndex(key);
	        var scenes = this.scenes;

	        if (index !== -1 && index < scenes.length)
	        {
	            var scene = this.getScene(key);

	            scenes.splice(index, 1);
	            scenes.push(scene);
	        }

	        return this;
	    },

	    sendToBack: function (key)
	    {
	        if (this.isProcessing)
	        {
	            return this.queueOp('sendToBack', key);
	        }

	        var index = this.getIndex(key);

	        if (index !== -1 && index > 0)
	        {
	            var scene = this.getScene(key);

	            this.scenes.splice(index, 1);
	            this.scenes.unshift(scene);
	        }

	        return this;
	    },

	    moveDown: function (key)
	    {
	        if (this.isProcessing)
	        {
	            return this.queueOp('moveDown', key);
	        }

	        var indexA = this.getIndex(key);

	        if (indexA > 0)
	        {
	            var indexB = indexA - 1;
	            var sceneA = this.getScene(key);
	            var sceneB = this.getAt(indexB);

	            this.scenes[indexA] = sceneB;
	            this.scenes[indexB] = sceneA;
	        }

	        return this;
	    },

	    moveUp: function (key)
	    {
	        if (this.isProcessing)
	        {
	            return this.queueOp('moveUp', key);
	        }

	        var indexA = this.getIndex(key);

	        if (indexA < this.scenes.length - 1)
	        {
	            var indexB = indexA + 1;
	            var sceneA = this.getScene(key);
	            var sceneB = this.getAt(indexB);

	            this.scenes[indexA] = sceneB;
	            this.scenes[indexB] = sceneA;
	        }

	        return this;
	    },

	    moveAbove: function (keyA, keyB)
	    {
	        if (keyA === keyB)
	        {
	            return this;
	        }

	        if (this.isProcessing)
	        {
	            return this.queueOp('moveAbove', keyA, keyB);
	        }

	        var indexA = this.getIndex(keyA);
	        var indexB = this.getIndex(keyB);

	        if (indexA !== -1 && indexB !== -1 && indexB < indexA)
	        {
	            var tempScene = this.getAt(indexB);

	            this.scenes.splice(indexB, 1);

	            this.scenes.splice(indexA + (indexB > indexA), 0, tempScene);
	        }

	        return this;
	    },

	    moveBelow: function (keyA, keyB)
	    {
	        if (keyA === keyB)
	        {
	            return this;
	        }

	        if (this.isProcessing)
	        {
	            return this.queueOp('moveBelow', keyA, keyB);
	        }

	        var indexA = this.getIndex(keyA);
	        var indexB = this.getIndex(keyB);

	        if (indexA !== -1 && indexB !== -1 && indexB > indexA)
	        {
	            var tempScene = this.getAt(indexB);

	            this.scenes.splice(indexB, 1);

	            if (indexA === 0)
	            {
	                this.scenes.unshift(tempScene);
	            }
	            else
	            {

	                this.scenes.splice(indexA - (indexB < indexA), 0, tempScene);
	            }
	        }

	        return this;
	    },

	    queueOp: function (op, keyA, keyB, data)
	    {
	        this._queue.push({ op: op, keyA: keyA, keyB: keyB, data: data });

	        return this;
	    },

	    swapPosition: function (keyA, keyB)
	    {
	        if (keyA === keyB)
	        {
	            return this;
	        }

	        if (this.isProcessing)
	        {
	            return this.queueOp('swapPosition', keyA, keyB);
	        }

	        var indexA = this.getIndex(keyA);
	        var indexB = this.getIndex(keyB);

	        if (indexA !== indexB && indexA !== -1 && indexB !== -1)
	        {
	            var tempScene = this.getAt(indexA);

	            this.scenes[indexA] = this.scenes[indexB];
	            this.scenes[indexB] = tempScene;
	        }

	        return this;
	    },

	    dump: function ()
	    {
	        var out = [];
	        var map = [ 'pending', 'init', 'start', 'loading', 'creating', 'running', 'paused', 'sleeping', 'shutdown', 'destroyed' ];

	        for (var i = 0; i < this.scenes.length; i++)
	        {
	            var sys = this.scenes[i].sys;

	            var key = (sys.settings.visible && (sys.settings.status === CONST.RUNNING || sys.settings.status === CONST.PAUSED)) ? '[*] ' : '[-] ';
	            key += sys.settings.key + ' (' + map[sys.settings.status] + ')';

	            out.push(key);
	        }

	        console.log(out.join('\n'));
	    },

	    destroy: function ()
	    {
	        for (var i = 0; i < this.scenes.length; i++)
	        {
	            var sys = this.scenes[i].sys;

	            sys.destroy();
	        }

	        this.systemScene.sys.destroy();

	        this.update = NOOP;

	        this.scenes = [];

	        this._pending = [];
	        this._start = [];
	        this._queue = [];

	        this.game = null;
	        this.systemScene = null;
	    }

	});

	SceneManager_1 = SceneManager;
	return SceneManager_1;
}

var TextureSource_1;
var hasRequiredTextureSource;

function requireTextureSource () {
	if (hasRequiredTextureSource) return TextureSource_1;
	hasRequiredTextureSource = 1;
	var CanvasPool = requireCanvasPool();
	var Class = requireClass();
	var IsSizePowerOfTwo = requireIsSizePowerOfTwo();
	var ScaleModes = requireScaleModes();
	var WebGLTextureWrapper = requireWebGLTextureWrapper();

	var TextureSource = new Class({

	    initialize:

	    function TextureSource (texture, source, width, height, flipY)
	    {
	        if (flipY === undefined) { flipY = false; }

	        var game = texture.manager.game;

	        this.renderer = game.renderer;

	        this.texture = texture;

	        this.source = source;

	        this.image = (source.compressed) ? null : source;

	        this.compressionAlgorithm = (source.compressed) ? source.format : null;

	        this.resolution = 1;

	        this.width = width || source.naturalWidth || source.videoWidth || source.width || 0;

	        this.height = height || source.naturalHeight || source.videoHeight || source.height || 0;

	        this.scaleMode = ScaleModes.DEFAULT;

	        this.isCanvas = (source instanceof HTMLCanvasElement);

	        this.isVideo = (window.hasOwnProperty('HTMLVideoElement') && source instanceof HTMLVideoElement);

	        this.isRenderTexture = (source.type === 'RenderTexture' || source.type === 'DynamicTexture');

	        this.isGLTexture = source instanceof WebGLTextureWrapper;

	        this.isPowerOf2 = IsSizePowerOfTwo(this.width, this.height);

	        this.glTexture = null;

	        this.flipY = flipY;

	        this.init(game);
	    },

	    init: function (game)
	    {
	        var renderer = this.renderer;

	        if (renderer)
	        {
	            var source = this.source;

	            if (renderer.gl)
	            {
	                var image = this.image;
	                var flipY = this.flipY;
	                var width = this.width;
	                var height = this.height;
	                var scaleMode = this.scaleMode;

	                if (this.isCanvas)
	                {
	                    this.glTexture = renderer.createCanvasTexture(image, false, flipY);
	                }
	                else if (this.isVideo)
	                {
	                    this.glTexture = renderer.createVideoTexture(image, false, flipY);
	                }
	                else if (this.isRenderTexture)
	                {
	                    this.glTexture = renderer.createTextureFromSource(null, width, height, scaleMode);
	                }
	                else if (this.isGLTexture)
	                {
	                    this.glTexture = source;
	                }
	                else if (this.compressionAlgorithm)
	                {
	                    this.glTexture = renderer.createTextureFromSource(source, undefined, undefined, scaleMode);
	                }
	                else if (source instanceof Uint8Array)
	                {
	                    this.glTexture = renderer.createUint8ArrayTexture(source, width, height, scaleMode);
	                }
	                else
	                {
	                    this.glTexture = renderer.createTextureFromSource(image, width, height, scaleMode);
	                }

	                if (typeof WEBGL_DEBUG)
	                {
	                    this.glTexture.spectorMetadata = { textureKey: this.texture.key };
	                }
	            }
	            else if (this.isRenderTexture)
	            {
	                this.image = source.canvas;
	            }
	        }

	        if (!game.config.antialias)
	        {
	            this.setFilter(1);
	        }
	    },

	    setFilter: function (filterMode)
	    {
	        if (this.renderer && this.renderer.gl)
	        {
	            this.renderer.setTextureFilter(this.glTexture, filterMode);
	        }

	        this.scaleMode = filterMode;
	    },

	    setFlipY: function (value)
	    {
	        if (value === undefined) { value = true; }

	        if (value === this.flipY) { return this; }

	        this.flipY = value;
	        this.update();

	        return this;
	    },

	    update: function ()
	    {
	        var renderer = this.renderer;
	        var image = this.image;
	        var flipY = this.flipY;
	        var gl = renderer.gl;

	        if (gl && this.isCanvas)
	        {
	            renderer.updateCanvasTexture(image, this.glTexture, flipY);
	        }
	        else if (gl && this.isVideo)
	        {
	            renderer.updateVideoTexture(image, this.glTexture, flipY);
	        }
	    },

	    destroy: function ()
	    {
	        if (this.glTexture)
	        {
	            this.renderer.deleteTexture(this.glTexture);
	        }

	        if (this.isCanvas)
	        {
	            CanvasPool.remove(this.image);
	        }

	        this.renderer = null;
	        this.texture = null;
	        this.source = null;
	        this.image = null;
	        this.glTexture = null;
	    }

	});

	TextureSource_1 = TextureSource;
	return TextureSource_1;
}

var Texture_1;
var hasRequiredTexture;

function requireTexture () {
	if (hasRequiredTexture) return Texture_1;
	hasRequiredTexture = 1;
	var Class = requireClass();
	var Frame = requireFrame();
	var TextureSource = requireTextureSource();

	var TEXTURE_MISSING_ERROR = 'Texture "%s" has no frame "%s"';

	var Texture = new Class({

	    initialize:

	    function Texture (manager, key, source, width, height)
	    {
	        if (!Array.isArray(source))
	        {
	            source = [ source ];
	        }

	        this.manager = manager;

	        this.key = key;

	        this.source = [];

	        this.dataSource = [];

	        this.frames = {};

	        this.customData = {};

	        this.firstFrame = '__BASE';

	        this.frameTotal = 0;

	        for (var i = 0; i < source.length; i++)
	        {
	            this.source.push(new TextureSource(this, source[i], width, height));
	        }
	    },

	    add: function (name, sourceIndex, x, y, width, height)
	    {
	        if (this.has(name))
	        {
	            return null;
	        }

	        var frame = new Frame(this, name, sourceIndex, x, y, width, height);

	        this.frames[name] = frame;

	        if (this.firstFrame === '__BASE')
	        {
	            this.firstFrame = name;
	        }

	        this.frameTotal++;

	        return frame;
	    },

	    remove: function (name)
	    {
	        if (this.has(name))
	        {
	            var frame = this.get(name);

	            frame.destroy();

	            delete this.frames[name];

	            return true;
	        }

	        return false;
	    },

	    has: function (name)
	    {
	        return this.frames.hasOwnProperty(name);
	    },

	    get: function (name)
	    {

	        if (!name)
	        {
	            name = this.firstFrame;
	        }

	        var frame = this.frames[name];

	        if (!frame)
	        {
	            console.warn(TEXTURE_MISSING_ERROR, this.key, name);

	            frame = this.frames[this.firstFrame];
	        }

	        return frame;
	    },

	    getTextureSourceIndex: function (source)
	    {
	        for (var i = 0; i < this.source.length; i++)
	        {
	            if (this.source[i] === source)
	            {
	                return i;
	            }
	        }

	        return -1;
	    },

	    getFramesFromTextureSource: function (sourceIndex, includeBase)
	    {
	        if (includeBase === undefined) { includeBase = false; }

	        var out = [];

	        for (var frameName in this.frames)
	        {
	            if (frameName === '__BASE' && !includeBase)
	            {
	                continue;
	            }

	            var frame = this.frames[frameName];

	            if (frame.sourceIndex === sourceIndex)
	            {
	                out.push(frame);
	            }
	        }

	        return out;
	    },

	    getFrameBounds: function (sourceIndex)
	    {
	        if (sourceIndex === undefined) { sourceIndex = 0; }

	        var frames = this.getFramesFromTextureSource(sourceIndex, true);

	        var baseFrame = frames[0];

	        var minX = baseFrame.cutX;
	        var minY = baseFrame.cutY;
	        var maxX = baseFrame.cutX + baseFrame.cutWidth;
	        var maxY = baseFrame.cutY + baseFrame.cutHeight;

	        for (var i = 1; i < frames.length; i++)
	        {
	            var frame = frames[i];

	            if (frame.cutX < minX)
	            {
	                minX = frame.cutX;
	            }

	            if (frame.cutY < minY)
	            {
	                minY = frame.cutY;
	            }

	            if (frame.cutX + frame.cutWidth > maxX)
	            {
	                maxX = frame.cutX + frame.cutWidth;
	            }

	            if (frame.cutY + frame.cutHeight > maxY)
	            {
	                maxY = frame.cutY + frame.cutHeight;
	            }
	        }

	        return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
	    },

	    getFrameNames: function (includeBase)
	    {
	        if (includeBase === undefined) { includeBase = false; }

	        var out = Object.keys(this.frames);

	        if (!includeBase)
	        {
	            var idx = out.indexOf('__BASE');

	            if (idx !== -1)
	            {
	                out.splice(idx, 1);
	            }
	        }

	        return out;
	    },

	    getSourceImage: function (name)
	    {
	        if (name === undefined || name === null || this.frameTotal === 1)
	        {
	            name = '__BASE';
	        }

	        var frame = this.frames[name];

	        if (frame)
	        {
	            return frame.source.image;
	        }
	        else
	        {
	            console.warn(TEXTURE_MISSING_ERROR, this.key, name);

	            return this.frames['__BASE'].source.image;
	        }
	    },

	    getDataSourceImage: function (name)
	    {
	        if (name === undefined || name === null || this.frameTotal === 1)
	        {
	            name = '__BASE';
	        }

	        var frame = this.frames[name];
	        var idx;

	        if (!frame)
	        {
	            console.warn(TEXTURE_MISSING_ERROR, this.key, name);

	            idx = this.frames['__BASE'].sourceIndex;
	        }
	        else
	        {
	            idx = frame.sourceIndex;
	        }

	        return this.dataSource[idx].image;
	    },

	    setDataSource: function (data)
	    {
	        if (!Array.isArray(data))
	        {
	            data = [ data ];
	        }

	        for (var i = 0; i < data.length; i++)
	        {
	            var source = this.source[i];

	            this.dataSource.push(new TextureSource(this, data[i], source.width, source.height));
	        }
	    },

	    setFilter: function (filterMode)
	    {
	        var i;

	        for (i = 0; i < this.source.length; i++)
	        {
	            this.source[i].setFilter(filterMode);
	        }

	        for (i = 0; i < this.dataSource.length; i++)
	        {
	            this.dataSource[i].setFilter(filterMode);
	        }
	    },

	    destroy: function ()
	    {
	        var i;
	        var source = this.source;
	        var dataSource = this.dataSource;

	        for (i = 0; i < source.length; i++)
	        {
	            if (source[i])
	            {
	                source[i].destroy();
	            }
	        }

	        for (i = 0; i < dataSource.length; i++)
	        {
	            if (dataSource[i])
	            {
	                dataSource[i].destroy();
	            }
	        }

	        for (var frameName in this.frames)
	        {
	            var frame = this.frames[frameName];

	            if (frame)
	            {
	                frame.destroy();
	            }
	        }

	        this.source = [];
	        this.dataSource = [];
	        this.frames = {};

	        this.manager.removeKey(this.key);

	        this.manager = null;
	    }

	});

	Texture_1 = Texture;
	return Texture_1;
}

var CanvasTexture_1;
var hasRequiredCanvasTexture;

function requireCanvasTexture () {
	if (hasRequiredCanvasTexture) return CanvasTexture_1;
	hasRequiredCanvasTexture = 1;
	var Class = requireClass();
	var Clamp = requireClamp();
	var Color = requireColor$1();
	var CONST = require_const$f();
	var IsSizePowerOfTwo = requireIsSizePowerOfTwo();
	var Texture = requireTexture();

	var CanvasTexture = new Class({

	    Extends: Texture,

	    initialize:

	    function CanvasTexture (manager, key, source, width, height)
	    {
	        Texture.call(this, manager, key, source, width, height);

	        this.add('__BASE', 0, 0, 0, width, height);

	        this._source = this.frames['__BASE'].source;

	        this.canvas = this._source.image;

	        this.context = this.canvas.getContext('2d', { willReadFrequently: true });

	        this.width = width;

	        this.height = height;

	        this.imageData = this.context.getImageData(0, 0, width, height);

	        this.data = null;

	        if (this.imageData)
	        {
	            this.data = this.imageData.data;
	        }

	        this.pixels = null;

	        this.buffer;

	        if (this.data)
	        {
	            if (this.imageData.data.buffer)
	            {
	                this.buffer = this.imageData.data.buffer;
	                this.pixels = new Uint32Array(this.buffer);
	            }
	            else if (window.ArrayBuffer)
	            {
	                this.buffer = new ArrayBuffer(this.imageData.data.length);
	                this.pixels = new Uint32Array(this.buffer);
	            }
	            else
	            {
	                this.pixels = this.imageData.data;
	            }
	        }
	    },

	    update: function ()
	    {
	        this.imageData = this.context.getImageData(0, 0, this.width, this.height);

	        this.data = this.imageData.data;

	        if (this.imageData.data.buffer)
	        {
	            this.buffer = this.imageData.data.buffer;
	            this.pixels = new Uint32Array(this.buffer);
	        }
	        else if (window.ArrayBuffer)
	        {
	            this.buffer = new ArrayBuffer(this.imageData.data.length);
	            this.pixels = new Uint32Array(this.buffer);
	        }
	        else
	        {
	            this.pixels = this.imageData.data;
	        }

	        if (this.manager.game.config.renderType === CONST.WEBGL)
	        {
	            this.refresh();
	        }

	        return this;
	    },

	    draw: function (x, y, source, update)
	    {
	        if (update === undefined) { update = true; }

	        this.context.drawImage(source, x, y);

	        if (update)
	        {
	            this.update();
	        }

	        return this;
	    },

	    drawFrame: function (key, frame, x, y, update)
	    {
	        if (x === undefined) { x = 0; }
	        if (y === undefined) { y = 0; }
	        if (update === undefined) { update = true; }

	        var textureFrame = this.manager.getFrame(key, frame);

	        if (textureFrame)
	        {
	            var cd = textureFrame.canvasData;

	            var width = textureFrame.cutWidth;
	            var height = textureFrame.cutHeight;
	            var res = textureFrame.source.resolution;

	            this.context.drawImage(
	                textureFrame.source.image,
	                cd.x, cd.y,
	                width,
	                height,
	                x, y,
	                width / res,
	                height / res
	            );

	            if (update)
	            {
	                this.update();
	            }
	        }

	        return this;
	    },

	    setPixel: function (x, y, red, green, blue, alpha)
	    {
	        if (alpha === undefined) { alpha = 255; }

	        x = Math.abs(Math.floor(x));
	        y = Math.abs(Math.floor(y));

	        var index = this.getIndex(x, y);

	        if (index > -1)
	        {
	            var imageData = this.context.getImageData(x, y, 1, 1);

	            imageData.data[0] = red;
	            imageData.data[1] = green;
	            imageData.data[2] = blue;
	            imageData.data[3] = alpha;

	            this.context.putImageData(imageData, x, y);
	        }

	        return this;
	    },

	    putData: function (imageData, x, y, dirtyX, dirtyY, dirtyWidth, dirtyHeight)
	    {
	        if (dirtyX === undefined) { dirtyX = 0; }
	        if (dirtyY === undefined) { dirtyY = 0; }
	        if (dirtyWidth === undefined) { dirtyWidth = imageData.width; }
	        if (dirtyHeight === undefined) { dirtyHeight = imageData.height; }

	        this.context.putImageData(imageData, x, y, dirtyX, dirtyY, dirtyWidth, dirtyHeight);

	        return this;
	    },

	    getData: function (x, y, width, height)
	    {
	        x = Clamp(Math.floor(x), 0, this.width - 1);
	        y = Clamp(Math.floor(y), 0, this.height - 1);
	        width = Clamp(width, 1, this.width - x);
	        height = Clamp(height, 1, this.height - y);

	        var imageData = this.context.getImageData(x, y, width, height);

	        return imageData;
	    },

	    getPixel: function (x, y, out)
	    {
	        if (!out)
	        {
	            out = new Color();
	        }

	        var index = this.getIndex(x, y);

	        if (index > -1)
	        {
	            var data = this.data;

	            var r = data[index + 0];
	            var g = data[index + 1];
	            var b = data[index + 2];
	            var a = data[index + 3];

	            out.setTo(r, g, b, a);
	        }

	        return out;
	    },

	    getPixels: function (x, y, width, height)
	    {
	        if (x === undefined) { x = 0; }
	        if (y === undefined) { y = 0; }
	        if (width === undefined) { width = this.width; }
	        if (height === undefined) { height = width; }

	        x = Math.abs(Math.round(x));
	        y = Math.abs(Math.round(y));

	        var left = Clamp(x, 0, this.width);
	        var right = Clamp(x + width, 0, this.width);
	        var top = Clamp(y, 0, this.height);
	        var bottom = Clamp(y + height, 0, this.height);

	        var pixel = new Color();

	        var out = [];

	        for (var py = top; py < bottom; py++)
	        {
	            var row = [];

	            for (var px = left; px < right; px++)
	            {
	                pixel = this.getPixel(px, py, pixel);

	                row.push({ x: px, y: py, color: pixel.color, alpha: pixel.alphaGL });
	            }

	            out.push(row);
	        }

	        return out;
	    },

	    getIndex: function (x, y)
	    {
	        x = Math.abs(Math.round(x));
	        y = Math.abs(Math.round(y));

	        if (x < this.width && y < this.height)
	        {
	            return (x + y * this.width) * 4;
	        }
	        else
	        {
	            return -1;
	        }
	    },

	    refresh: function ()
	    {
	        this._source.update();

	        return this;
	    },

	    getCanvas: function ()
	    {
	        return this.canvas;
	    },

	    getContext: function ()
	    {
	        return this.context;
	    },

	    clear: function (x, y, width, height, update)
	    {
	        if (x === undefined) { x = 0; }
	        if (y === undefined) { y = 0; }
	        if (width === undefined) { width = this.width; }
	        if (height === undefined) { height = this.height; }
	        if (update === undefined) { update = true; }

	        this.context.clearRect(x, y, width, height);

	        if (update)
	        {
	            this.update();
	        }

	        return this;
	    },

	    setSize: function (width, height)
	    {
	        if (height === undefined) { height = width; }

	        if (width !== this.width || height !== this.height)
	        {

	            this.canvas.width = width;
	            this.canvas.height = height;

	            this._source.width = width;
	            this._source.height = height;
	            this._source.isPowerOf2 = IsSizePowerOfTwo(width, height);

	            this.frames['__BASE'].setSize(width, height, 0, 0);

	            this.width = width;
	            this.height = height;

	            this.refresh();
	        }

	        return this;
	    },

	    destroy: function ()
	    {
	        Texture.prototype.destroy.call(this);

	        this._source = null;
	        this.canvas = null;
	        this.context = null;
	        this.imageData = null;
	        this.data = null;
	        this.pixels = null;
	        this.buffer = null;
	    }

	});

	CanvasTexture_1 = CanvasTexture;
	return CanvasTexture_1;
}

var DynamicTexture_1;
var hasRequiredDynamicTexture;

function requireDynamicTexture () {
	if (hasRequiredDynamicTexture) return DynamicTexture_1;
	hasRequiredDynamicTexture = 1;
	var BlendModes = requireBlendModes();
	var Camera = requireCamera();
	var CanvasPool = requireCanvasPool();
	var Class = requireClass();
	var CONST = require_const$f();
	var Frame = requireFrame();
	var GetFastValue = requireGetFastValue();
	var PIPELINES = require_const$9();
	var RenderTarget = requireRenderTarget();
	var Texture = requireTexture();
	var Utils = requireUtils$1();

	var DynamicTexture = new Class({

	    Extends: Texture,

	    initialize:

	    function DynamicTexture (manager, key, width, height, forceEven)
	    {
	        if (width === undefined) { width = 256; }
	        if (height === undefined) { height = 256; }
	        if (forceEven === undefined) { forceEven = true; }

	        this.type = 'DynamicTexture';

	        var renderer = manager.game.renderer;

	        var isCanvas = (renderer && renderer.type === CONST.CANVAS);

	        var source = (isCanvas) ? CanvasPool.create2D(this, width, height) : [ this ];

	        Texture.call(this, manager, key, source, width, height);

	        this.add('__BASE', 0, 0, 0, width, height);

	        this.renderer = renderer;

	        this.width = -1;

	        this.height = -1;

	        this.isDrawing = false;

	        this.canvas = (isCanvas) ? source : null;

	        this.context = (isCanvas) ? source.getContext('2d', { willReadFrequently: true }) : null;

	        this.dirty = false;

	        this.isSpriteTexture = true;

	        this._eraseMode = false;

	        this.camera = new Camera(0, 0, width, height).setScene(manager.game.scene.systemScene, false);

	        this.renderTarget = (!isCanvas) ? new RenderTarget(renderer, width, height, 1, 0, false, false, true, false) : null;

	        this.pipeline = (!isCanvas) ? renderer.pipelines.get(PIPELINES.SINGLE_PIPELINE) : null;

	        this.setSize(width, height, forceEven);
	    },

	    setSize: function (width, height, forceEven)
	    {
	        if (height === undefined) { height = width; }
	        if (forceEven === undefined) { forceEven = true; }

	        if (forceEven)
	        {
	            width = Math.floor(width);
	            height = Math.floor(height);

	            if (width % 2 !== 0)
	            {
	                width++;
	            }

	            if (height % 2 !== 0)
	            {
	                height++;
	            }
	        }

	        var frame = this.get();
	        var source = frame.source;

	        if (width !== this.width || height !== this.height)
	        {
	            if (this.canvas)
	            {
	                this.canvas.width = width;
	                this.canvas.height = height;
	            }

	            var renderTarget = this.renderTarget;

	            if (renderTarget)
	            {
	                if (renderTarget.willResize(width, height))
	                {
	                    renderTarget.resize(width, height);
	                }

	                if (renderTarget.texture !== source.glTexture)
	                {

	                    this.renderer.deleteTexture(source.glTexture);
	                }

	                this.setFromRenderTarget();
	            }

	            this.camera.setSize(width, height);

	            source.width = width;
	            source.height = height;

	            frame.setSize(width, height);

	            this.width = width;
	            this.height = height;
	        }
	        else
	        {

	            var baseFrame = this.getSourceImage();

	            if (frame.cutX + width > baseFrame.width)
	            {
	                width = baseFrame.width - frame.cutX;
	            }

	            if (frame.cutY + height > baseFrame.height)
	            {
	                height = baseFrame.height - frame.cutY;
	            }

	            frame.setSize(width, height, frame.cutX, frame.cutY);
	        }

	        return this;
	    },

	    setFromRenderTarget: function ()
	    {
	        var frame = this.get();
	        var source = frame.source;
	        var renderTarget = this.renderTarget;

	        source.isRenderTexture = true;
	        source.isGLTexture = true;

	        source.glTexture = renderTarget.texture;

	        return this;
	    },

	    setIsSpriteTexture: function (value)
	    {
	        this.isSpriteTexture = value;

	        return this;
	    },

	    fill: function (rgb, alpha, x, y, width, height)
	    {
	        var camera = this.camera;
	        var renderer = this.renderer;

	        if (alpha === undefined) { alpha = 1; }
	        if (x === undefined) { x = 0; }
	        if (y === undefined) { y = 0; }
	        if (width === undefined) { width = this.width; }
	        if (height === undefined) { height = this.height; }

	        var r = (rgb >> 16 & 0xFF);
	        var g = (rgb >> 8 & 0xFF);
	        var b = (rgb & 0xFF);

	        var renderTarget = this.renderTarget;

	        camera.preRender();

	        if (renderTarget)
	        {
	            renderTarget.bind(true);

	            var pipeline = this.pipeline.manager.set(this.pipeline);

	            var sx = renderer.width / renderTarget.width;
	            var sy = renderer.height / renderTarget.height;
	            var ty = renderTarget.height - (y + height);

	            pipeline.drawFillRect(
	                x * sx, ty * sy, width * sx, height * sy,
	                Utils.getTintFromFloats(b / 255, g / 255, r / 255, 1),
	                alpha
	            );

	            renderTarget.unbind(true);
	        }
	        else
	        {
	            var ctx = this.context;

	            renderer.setContext(ctx);

	            ctx.globalCompositeOperation = 'source-over';
	            ctx.fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + alpha + ')';
	            ctx.fillRect(x, y, width, height);

	            renderer.setContext();
	        }

	        this.dirty = true;

	        return this;
	    },

	    clear: function (x, y, width, height)
	    {
	        if (this.dirty)
	        {
	            var ctx = this.context;

	            var renderTarget = this.renderTarget;

	            if (renderTarget)
	            {
	                renderTarget.clear(x, y, width, height);
	            }
	            else if (ctx)
	            {
	                if (x !== undefined && y !== undefined && width !== undefined && height !== undefined)
	                {
	                    ctx.clearRect(x, y, width, height);
	                }
	                else
	                {
	                    ctx.save();
	                    ctx.setTransform(1, 0, 0, 1, 0, 0);
	                    ctx.clearRect(0, 0, this.width, this.height);
	                    ctx.restore();
	                }
	            }

	            this.dirty = false;
	        }

	        return this;
	    },

	    stamp: function (key, frame, x, y, config)
	    {
	        if (x === undefined) { x = 0; }
	        if (y === undefined) { y = 0; }

	        var alpha = GetFastValue(config, 'alpha', 1);
	        var tint = GetFastValue(config, 'tint', 0xffffff);
	        var angle = GetFastValue(config, 'angle', 0);
	        var rotation = GetFastValue(config, 'rotation', 0);
	        var scale = GetFastValue(config, 'scale', 1);
	        var scaleX = GetFastValue(config, 'scaleX', scale);
	        var scaleY = GetFastValue(config, 'scaleY', scale);
	        var originX = GetFastValue(config, 'originX', 0.5);
	        var originY = GetFastValue(config, 'originY', 0.5);
	        var blendMode = GetFastValue(config, 'blendMode', 0);
	        var erase = GetFastValue(config, 'erase', false);
	        var skipBatch = GetFastValue(config, 'skipBatch', false);

	        var stamp = this.manager.resetStamp(alpha, tint);

	        stamp.setAngle(0);

	        if (angle !== 0)
	        {
	            stamp.setAngle(angle);
	        }
	        else if (rotation !== 0)
	        {
	            stamp.setRotation(rotation);
	        }

	        stamp.setScale(scaleX, scaleY);
	        stamp.setTexture(key, frame);
	        stamp.setOrigin(originX, originY);
	        stamp.setBlendMode(blendMode);

	        if (erase)
	        {
	            this._eraseMode = true;
	        }

	        if (!skipBatch)
	        {
	            this.draw(stamp, x, y);
	        }
	        else
	        {
	            this.batchGameObject(stamp, x, y);
	        }

	        if (erase)
	        {
	            this._eraseMode = false;
	        }

	        return this;
	    },

	    erase: function (entries, x, y)
	    {
	        this._eraseMode = true;

	        this.draw(entries, x, y);

	        this._eraseMode = false;

	        return this;
	    },

	    draw: function (entries, x, y, alpha, tint)
	    {
	        this.beginDraw();
	        this.batchDraw(entries, x, y, alpha, tint);
	        this.endDraw();

	        return this;
	    },

	    drawFrame: function (key, frame, x, y, alpha, tint)
	    {
	        this.beginDraw();
	        this.batchDrawFrame(key, frame, x, y, alpha, tint);
	        this.endDraw();

	        return this;
	    },

	    repeat: function (key, frame, x, y, width, height, alpha, tint, skipBatch)
	    {
	        if (x === undefined) { x = 0; }
	        if (y === undefined) { y = 0; }
	        if (width === undefined) { width = this.width; }
	        if (height === undefined) { height = this.height; }
	        if (alpha === undefined) { alpha = 1; }
	        if (tint === undefined) { tint = 0xffffff; }
	        if (skipBatch === undefined) { skipBatch = false; }

	        if (key instanceof Frame)
	        {
	            frame = key;
	        }
	        else
	        {
	            frame = this.manager.getFrame(key, frame);
	        }

	        if (!frame)
	        {
	            return this;
	        }

	        var stamp = this.manager.resetStamp(alpha, tint);

	        stamp.setFrame(frame);
	        stamp.setOrigin(0);

	        var frameWidth = frame.width;
	        var frameHeight = frame.height;

	        width = Math.floor(width);
	        height = Math.floor(height);

	        var hmax = Math.ceil(width / frameWidth);
	        var vmax = Math.ceil(height / frameHeight);

	        var hdiff = (hmax * frameWidth) - width;
	        var vdiff = (vmax * frameHeight) - height;

	        if (hdiff > 0)
	        {
	            hdiff = frameWidth - hdiff;
	        }

	        if (vdiff > 0)
	        {
	            vdiff = frameHeight - vdiff;
	        }

	        if (x < 0)
	        {
	            hmax += Math.ceil(Math.abs(x) / frameWidth);
	        }

	        if (y < 0)
	        {
	            vmax += Math.ceil(Math.abs(y) / frameHeight);
	        }

	        var dx = x;
	        var dy = y;

	        var useCrop = false;
	        var cropRect = this.manager.stampCrop.setTo(0, 0, frameWidth, frameHeight);

	        if (!skipBatch)
	        {
	            this.beginDraw();
	        }

	        for (var ty = 0; ty < vmax; ty++)
	        {

	            if (dy + frameHeight < 0)
	            {

	                dy += frameHeight;
	                continue;
	            }

	            for (var tx = 0; tx < hmax; tx++)
	            {
	                useCrop = false;

	                if (dx + frameWidth < 0)
	                {

	                    dx += frameWidth;
	                    continue;
	                }
	                else if (dx < 0)
	                {

	                    useCrop = true;
	                    cropRect.width = (frameWidth + dx);
	                    cropRect.x = frameWidth - cropRect.width;
	                }

	                if (dy < 0)
	                {

	                    useCrop = true;
	                    cropRect.height = (frameHeight + dy);
	                    cropRect.y = frameHeight - cropRect.height;
	                }

	                if (hdiff > 0 && tx === hmax - 1)
	                {
	                    useCrop = true;
	                    cropRect.width = hdiff;
	                }

	                if (vdiff > 0 && ty === vmax - 1)
	                {
	                    useCrop = true;
	                    cropRect.height = vdiff;
	                }

	                if (useCrop)
	                {
	                    stamp.setCrop(cropRect);
	                }

	                this.batchGameObject(stamp, dx, dy);

	                stamp.isCropped = false;

	                cropRect.setTo(0, 0, frameWidth, frameHeight);

	                dx += frameWidth;
	            }

	            dx = x;
	            dy += frameHeight;
	        }

	        if (!skipBatch)
	        {
	            this.endDraw();
	        }

	        return this;
	    },

	    beginDraw: function ()
	    {
	        if (!this.isDrawing)
	        {
	            var camera = this.camera;
	            var renderer = this.renderer;
	            var renderTarget = this.renderTarget;

	            camera.preRender();

	            if (renderTarget)
	            {
	                renderer.beginCapture(renderTarget.width, renderTarget.height);
	            }
	            else
	            {
	                renderer.setContext(this.context);
	            }

	            this.isDrawing = true;
	        }

	        return this;
	    },

	    batchDraw: function (entries, x, y, alpha, tint)
	    {
	        if (!Array.isArray(entries))
	        {
	            entries = [ entries ];
	        }

	        this.batchList(entries, x, y, alpha, tint);

	        return this;
	    },

	    batchDrawFrame: function (key, frame, x, y, alpha, tint)
	    {
	        if (x === undefined) { x = 0; }
	        if (y === undefined) { y = 0; }
	        if (alpha === undefined) { alpha = 1; }
	        if (tint === undefined) { tint = 0xffffff; }

	        var textureFrame = this.manager.getFrame(key, frame);

	        if (textureFrame)
	        {
	            if (this.renderTarget)
	            {
	                this.pipeline.batchTextureFrame(textureFrame, x, y, tint, alpha, this.camera.matrix, null);
	            }
	            else
	            {
	                this.batchTextureFrame(textureFrame, x, y, alpha, tint);
	            }
	        }

	        return this;
	    },

	    endDraw: function (erase)
	    {
	        if (erase === undefined) { erase = this._eraseMode; }

	        if (this.isDrawing)
	        {
	            var renderer = this.renderer;

	            var renderTarget = this.renderTarget;

	            if (renderTarget)
	            {
	                var canvasTarget = renderer.endCapture();

	                var util = renderer.pipelines.setUtility();

	                util.blitFrame(canvasTarget, renderTarget, 1, false, false, erase, this.isSpriteTexture);

	                renderer.resetScissor();
	                renderer.resetViewport();
	            }
	            else
	            {
	                renderer.setContext();
	            }

	            this.dirty = true;
	            this.isDrawing = false;
	        }

	        return this;
	    },

	    batchList: function (children, x, y, alpha, tint)
	    {
	        var len = children.length;

	        if (len === 0)
	        {
	            return;
	        }

	        for (var i = 0; i < len; i++)
	        {
	            var entry = children[i];

	            if (!entry || entry === this)
	            {
	                continue;
	            }

	            if (entry.renderWebGL || entry.renderCanvas)
	            {

	                this.batchGameObject(entry, x, y);
	            }
	            else if (entry.isParent || entry.list)
	            {

	                this.batchGroup(entry.getChildren(), x, y);
	            }
	            else if (typeof entry === 'string')
	            {

	                this.batchTextureFrameKey(entry, null, x, y, alpha, tint);
	            }
	            else if (entry instanceof Frame)
	            {

	                this.batchTextureFrame(entry, x, y, alpha, tint);
	            }
	            else if (Array.isArray(entry))
	            {

	                this.batchList(entry, x, y, alpha, tint);
	            }
	        }
	    },

	    batchGroup: function (children, x, y)
	    {
	        if (x === undefined) { x = 0; }
	        if (y === undefined) { y = 0; }

	        for (var i = 0; i < children.length; i++)
	        {
	            var entry = children[i];

	            if (entry.willRender(this.camera))
	            {
	                this.batchGameObject(entry, entry.x + x, entry.y + y);
	            }
	        }
	    },

	    batchGameObject: function (gameObject, x, y)
	    {
	        if (x === undefined) { x = gameObject.x; }
	        if (y === undefined) { y = gameObject.y; }

	        var prevX = gameObject.x;
	        var prevY = gameObject.y;

	        var camera = this.camera;
	        var renderer = this.renderer;
	        var eraseMode = this._eraseMode;

	        var mask = gameObject.mask;

	        gameObject.setPosition(x, y);

	        if (this.canvas)
	        {
	            if (eraseMode)
	            {
	                var blendMode = gameObject.blendMode;

	                gameObject.blendMode = BlendModes.ERASE;
	            }

	            if (mask)
	            {
	                mask.preRenderCanvas(renderer, gameObject, camera);
	            }

	            gameObject.renderCanvas(renderer, gameObject, camera, null);

	            if (mask)
	            {
	                mask.postRenderCanvas(renderer, gameObject, camera);
	            }

	            if (eraseMode)
	            {
	                gameObject.blendMode = blendMode;
	            }
	        }
	        else if (renderer)
	        {
	            if (mask)
	            {
	                mask.preRenderWebGL(renderer, gameObject, camera);
	            }

	            if (!eraseMode)
	            {
	                renderer.setBlendMode(gameObject.blendMode);
	            }

	            gameObject.renderWebGL(renderer, gameObject, camera);

	            if (mask)
	            {
	                mask.postRenderWebGL(renderer, camera, this.renderTarget);
	            }
	        }

	        gameObject.setPosition(prevX, prevY);
	    },

	    batchTextureFrameKey: function (key, frame, x, y, alpha, tint)
	    {
	        var textureFrame = this.manager.getFrame(key, frame);

	        if (textureFrame)
	        {
	            this.batchTextureFrame(textureFrame, x, y, alpha, tint);
	        }
	    },

	    batchTextureFrame: function (textureFrame, x, y, alpha, tint)
	    {
	        if (x === undefined) { x = 0; }
	        if (y === undefined) { y = 0; }
	        if (alpha === undefined) { alpha = 1; }
	        if (tint === undefined) { tint = 0xffffff; }

	        var matrix = this.camera.matrix;
	        var renderTarget = this.renderTarget;

	        if (renderTarget)
	        {
	            this.pipeline.batchTextureFrame(textureFrame, x, y, tint, alpha, matrix, null);
	        }
	        else
	        {
	            var ctx = this.context;
	            var cd = textureFrame.canvasData;
	            var source = textureFrame.source.image;

	            ctx.save();

	            ctx.globalCompositeOperation = (this._eraseMode) ? 'destination-out' : 'source-over';

	            ctx.globalAlpha = alpha;

	            matrix.setToContext(ctx);

	            if (cd.width > 0 && cd.height > 0)
	            {
	                ctx.drawImage(source, cd.x, cd.y, cd.width, cd.height, x, y, cd.width, cd.height);
	            }

	            ctx.restore();
	        }
	    },

	    snapshotArea: function (x, y, width, height, callback, type, encoderOptions)
	    {
	        if (this.renderTarget)
	        {
	            this.renderer.snapshotFramebuffer(this.renderTarget.framebuffer, this.width, this.height, callback, false, x, y, width, height, type, encoderOptions);
	        }
	        else
	        {
	            this.renderer.snapshotCanvas(this.canvas, callback, false, x, y, width, height, type, encoderOptions);
	        }

	        return this;
	    },

	    snapshot: function (callback, type, encoderOptions)
	    {
	        return this.snapshotArea(0, 0, this.width, this.height, callback, type, encoderOptions);
	    },

	    snapshotPixel: function (x, y, callback)
	    {
	        return this.snapshotArea(x, y, 1, 1, callback, 'pixel');
	    },

	    getWebGLTexture: function ()
	    {
	        if (this.renderTarget)
	        {
	            return this.renderTarget.texture;
	        }
	    },

	    renderWebGL: function (renderer, src, camera, parentMatrix)
	    {
	        var stamp = this.manager.resetStamp();

	        stamp.setTexture(this);
	        stamp.setOrigin(0);

	        stamp.renderWebGL(renderer, stamp, camera, parentMatrix);
	    },

	    renderCanvas: function ()
	    {

	    },

	    destroy: function ()
	    {
	        var stamp = this.manager.stamp;

	        if (stamp && stamp.texture === this)
	        {
	            this.manager.resetStamp();
	        }

	        Texture.prototype.destroy.call(this);

	        CanvasPool.remove(this.canvas);

	        if (this.renderTarget)
	        {
	            this.renderTarget.destroy();
	        }

	        this.camera.destroy();

	        this.canvas = null;
	        this.context = null;
	        this.renderer = null;
	    }

	});

	DynamicTexture_1 = DynamicTexture;
	return DynamicTexture_1;
}

var ImageWebGLRenderer_1;
var hasRequiredImageWebGLRenderer;

function requireImageWebGLRenderer () {
	if (hasRequiredImageWebGLRenderer) return ImageWebGLRenderer_1;
	hasRequiredImageWebGLRenderer = 1;
	var ImageWebGLRenderer = function (renderer, src, camera, parentMatrix)
	{
	    camera.addToRenderList(src);

	    this.pipeline.batchSprite(src, camera, parentMatrix);
	};

	ImageWebGLRenderer_1 = ImageWebGLRenderer;
	return ImageWebGLRenderer_1;
}

var ImageCanvasRenderer_1;
var hasRequiredImageCanvasRenderer;

function requireImageCanvasRenderer () {
	if (hasRequiredImageCanvasRenderer) return ImageCanvasRenderer_1;
	hasRequiredImageCanvasRenderer = 1;
	var ImageCanvasRenderer = function (renderer, src, camera, parentMatrix)
	{
	    camera.addToRenderList(src);

	    renderer.batchSprite(src, src.frame, camera, parentMatrix);
	};

	ImageCanvasRenderer_1 = ImageCanvasRenderer;
	return ImageCanvasRenderer_1;
}

var ImageRender;
var hasRequiredImageRender;

function requireImageRender () {
	if (hasRequiredImageRender) return ImageRender;
	hasRequiredImageRender = 1;
	var NOOP = requireNOOP();
	var renderWebGL = NOOP;
	var renderCanvas = NOOP;

	if (typeof WEBGL_RENDERER)
	{
	    renderWebGL = requireImageWebGLRenderer();
	}

	if (typeof CANVAS_RENDERER)
	{
	    renderCanvas = requireImageCanvasRenderer();
	}

	ImageRender = {

	    renderWebGL: renderWebGL,
	    renderCanvas: renderCanvas

	};
	return ImageRender;
}

var Image_1$1;
var hasRequiredImage$1;

function requireImage$1 () {
	if (hasRequiredImage$1) return Image_1$1;
	hasRequiredImage$1 = 1;
	var Class = requireClass();
	var Components = requireComponents$2();
	var GameObject = requireGameObject();
	var ImageRender = requireImageRender();

	var Image = new Class({

	    Extends: GameObject,

	    Mixins: [
	        Components.Alpha,
	        Components.BlendMode,
	        Components.Depth,
	        Components.Flip,
	        Components.GetBounds,
	        Components.Mask,
	        Components.Origin,
	        Components.Pipeline,
	        Components.PostPipeline,
	        Components.ScrollFactor,
	        Components.Size,
	        Components.TextureCrop,
	        Components.Tint,
	        Components.Transform,
	        Components.Visible,
	        ImageRender
	    ],

	    initialize:

	    function Image (scene, x, y, texture, frame)
	    {
	        GameObject.call(this, scene, 'Image');

	        this._crop = this.resetCropObject();

	        this.setTexture(texture, frame);
	        this.setPosition(x, y);
	        this.setSizeToFrame();
	        this.setOriginFromFrame();
	        this.initPipeline();
	        this.initPostPipeline(true);
	    }

	});

	Image_1$1 = Image;
	return Image_1$1;
}

var AtlasXML_1;
var hasRequiredAtlasXML;

function requireAtlasXML () {
	if (hasRequiredAtlasXML) return AtlasXML_1;
	hasRequiredAtlasXML = 1;
	var AtlasXML = function (texture, sourceIndex, xml)
	{

	    if (!xml.getElementsByTagName('TextureAtlas'))
	    {
	        console.warn('Invalid Texture Atlas XML given');
	        return;
	    }

	    var source = texture.source[sourceIndex];

	    texture.add('__BASE', sourceIndex, 0, 0, source.width, source.height);

	    var frames = xml.getElementsByTagName('SubTexture');

	    var newFrame;

	    for (var i = 0; i < frames.length; i++)
	    {
	        var frame = frames[i].attributes;

	        var name = frame.name.value;
	        var x = parseInt(frame.x.value, 10);
	        var y = parseInt(frame.y.value, 10);
	        var width = parseInt(frame.width.value, 10);
	        var height = parseInt(frame.height.value, 10);

	        newFrame = texture.add(name, sourceIndex, x, y, width, height);

	        if (frame.frameX)
	        {
	            var frameX = Math.abs(parseInt(frame.frameX.value, 10));
	            var frameY = Math.abs(parseInt(frame.frameY.value, 10));
	            var frameWidth = parseInt(frame.frameWidth.value, 10);
	            var frameHeight = parseInt(frame.frameHeight.value, 10);

	            newFrame.setTrim(
	                width,
	                height,
	                frameX,
	                frameY,
	                frameWidth,
	                frameHeight
	            );
	        }
	    }

	    return texture;
	};

	AtlasXML_1 = AtlasXML;
	return AtlasXML_1;
}

var Canvas_1;
var hasRequiredCanvas$1;

function requireCanvas$1 () {
	if (hasRequiredCanvas$1) return Canvas_1;
	hasRequiredCanvas$1 = 1;
	var Canvas = function (texture, sourceIndex)
	{
	    var source = texture.source[sourceIndex];

	    texture.add('__BASE', sourceIndex, 0, 0, source.width, source.height);

	    return texture;
	};

	Canvas_1 = Canvas;
	return Canvas_1;
}

var Image_1;
var hasRequiredImage;

function requireImage () {
	if (hasRequiredImage) return Image_1;
	hasRequiredImage = 1;
	var Image = function (texture, sourceIndex)
	{
	    var source = texture.source[sourceIndex];

	    texture.add('__BASE', sourceIndex, 0, 0, source.width, source.height);

	    return texture;
	};

	Image_1 = Image;
	return Image_1;
}

var JSONArray_1;
var hasRequiredJSONArray;

function requireJSONArray () {
	if (hasRequiredJSONArray) return JSONArray_1;
	hasRequiredJSONArray = 1;
	var Clone = requireClone$7();

	var JSONArray = function (texture, sourceIndex, json)
	{

	    if (!json['frames'] && !json['textures'])
	    {
	        console.warn('Invalid Texture Atlas JSON Array');
	        return;
	    }

	    var source = texture.source[sourceIndex];

	    texture.add('__BASE', sourceIndex, 0, 0, source.width, source.height);

	    var frames = (Array.isArray(json.textures)) ? json.textures[sourceIndex].frames : json.frames;

	    var newFrame;

	    for (var i = 0; i < frames.length; i++)
	    {
	        var src = frames[i];

	        newFrame = texture.add(src.filename, sourceIndex, src.frame.x, src.frame.y, src.frame.w, src.frame.h);

	        if (!newFrame)
	        {
	            console.warn('Invalid atlas json, frame already exists: ' + src.filename);

	            continue;
	        }

	        if (src.trimmed)
	        {
	            newFrame.setTrim(
	                src.sourceSize.w,
	                src.sourceSize.h,
	                src.spriteSourceSize.x,
	                src.spriteSourceSize.y,
	                src.spriteSourceSize.w,
	                src.spriteSourceSize.h
	            );
	        }

	        if (src.rotated)
	        {
	            newFrame.rotated = true;
	            newFrame.updateUVsInverted();
	        }

	        var pivot = src.anchor || src.pivot;

	        if (pivot)
	        {
	            newFrame.customPivot = true;
	            newFrame.pivotX = pivot.x;
	            newFrame.pivotY = pivot.y;
	        }

	        if (src.scale9Borders)
	        {
	            newFrame.setScale9(
	                src.scale9Borders.x,
	                src.scale9Borders.y,
	                src.scale9Borders.w,
	                src.scale9Borders.h
	            );
	        }

	        newFrame.customData = Clone(src);
	    }

	    for (var dataKey in json)
	    {
	        if (dataKey === 'frames')
	        {
	            continue;
	        }

	        if (Array.isArray(json[dataKey]))
	        {
	            texture.customData[dataKey] = json[dataKey].slice(0);
	        }
	        else
	        {
	            texture.customData[dataKey] = json[dataKey];
	        }
	    }

	    return texture;
	};

	JSONArray_1 = JSONArray;
	return JSONArray_1;
}

var JSONHash_1;
var hasRequiredJSONHash;

function requireJSONHash () {
	if (hasRequiredJSONHash) return JSONHash_1;
	hasRequiredJSONHash = 1;
	var Clone = requireClone$7();

	var JSONHash = function (texture, sourceIndex, json)
	{

	    if (!json['frames'])
	    {
	        console.warn('Invalid Texture Atlas JSON Hash given, missing \'frames\' Object');
	        return;
	    }

	    var source = texture.source[sourceIndex];

	    texture.add('__BASE', sourceIndex, 0, 0, source.width, source.height);

	    var frames = json.frames;
	    var newFrame;

	    for (var key in frames)
	    {
	        if (!frames.hasOwnProperty(key))
	        {
	            continue;
	        }

	        var src = frames[key];

	        newFrame = texture.add(key, sourceIndex, src.frame.x, src.frame.y, src.frame.w, src.frame.h);

	        if (!newFrame)
	        {
	            console.warn('Invalid atlas json, frame already exists: ' + key);

	            continue;
	        }

	        if (src.trimmed)
	        {
	            newFrame.setTrim(
	                src.sourceSize.w,
	                src.sourceSize.h,
	                src.spriteSourceSize.x,
	                src.spriteSourceSize.y,
	                src.spriteSourceSize.w,
	                src.spriteSourceSize.h
	            );
	        }

	        if (src.rotated)
	        {
	            newFrame.rotated = true;
	            newFrame.updateUVsInverted();
	        }

	        var pivot = src.anchor || src.pivot;

	        if (pivot)
	        {
	            newFrame.customPivot = true;
	            newFrame.pivotX = pivot.x;
	            newFrame.pivotY = pivot.y;
	        }

	        if (src.scale9Borders)
	        {
	            newFrame.setScale9(
	                src.scale9Borders.x,
	                src.scale9Borders.y,
	                src.scale9Borders.w,
	                src.scale9Borders.h
	            );
	        }

	        newFrame.customData = Clone(src);
	    }

	    for (var dataKey in json)
	    {
	        if (dataKey === 'frames')
	        {
	            continue;
	        }

	        if (Array.isArray(json[dataKey]))
	        {
	            texture.customData[dataKey] = json[dataKey].slice(0);
	        }
	        else
	        {
	            texture.customData[dataKey] = json[dataKey];
	        }
	    }

	    return texture;
	};

	JSONHash_1 = JSONHash;
	return JSONHash_1;
}

var KTXParser_1;
var hasRequiredKTXParser;

function requireKTXParser () {
	if (hasRequiredKTXParser) return KTXParser_1;
	hasRequiredKTXParser = 1;
	var KTXParser = function (data)
	{
	    var idCheck = [ 0xab, 0x4b, 0x54, 0x58, 0x20, 0x31, 0x31, 0xbb, 0x0d, 0x0a, 0x1a, 0x0a ];

	    var i;
	    var id = new Uint8Array(data, 0, 12);

	    for (i = 0; i < id.length; i++)
	    {
	        if (id[i] !== idCheck[i])
	        {
	            console.warn('KTXParser - Invalid file format');

	            return;
	        }
	    }

	    var size = Uint32Array.BYTES_PER_ELEMENT;

	    var head = new DataView(data, 12, 13 * size);

	    var littleEndian = (head.getUint32(0, true) === 0x04030201);

	    var glType = head.getUint32(1 * size, littleEndian);

	    if (glType !== 0)
	    {
	        console.warn('KTXParser - Only compressed formats supported');

	        return;
	    }

	    var internalFormat = head.getUint32(4 * size, littleEndian);
	    var width = head.getUint32(6 * size, littleEndian);
	    var height = head.getUint32(7 * size, littleEndian);

	    var mipmapLevels = Math.max(1, head.getUint32(11 * size, littleEndian));

	    var bytesOfKeyValueData = head.getUint32(12 * size, littleEndian);

	    var mipmaps = new Array(mipmapLevels);

	    var offset = 12 + 13 * 4 + bytesOfKeyValueData;
	    var levelWidth = width;
	    var levelHeight = height;

	    for (i = 0; i < mipmapLevels; i++)
	    {
	        var levelSize = new Int32Array(data, offset, 1)[0];

	        offset += 4;

	        mipmaps[i] = {
	            data: new Uint8Array(data, offset, levelSize),
	            width: levelWidth,
	            height: levelHeight
	        };

	        levelWidth = Math.max(1, levelWidth >> 1);
	        levelHeight = Math.max(1, levelHeight >> 1);

	        offset += levelSize;
	    }

	    return {
	        mipmaps: mipmaps,
	        width: width,
	        height: height,
	        internalFormat: internalFormat,
	        compressed: true,
	        generateMipmap: false
	    };
	};

	KTXParser_1 = KTXParser;
	return KTXParser_1;
}

var PVRParser_1;
var hasRequiredPVRParser;

function requirePVRParser () {
	if (hasRequiredPVRParser) return PVRParser_1;
	hasRequiredPVRParser = 1;
	function GetSize (width, height, x, y, dx, dy, mult)
	{
	    if (mult === undefined) { mult = 16; }

	    return Math.floor((width + x) / dx) * Math.floor((height + y) / dy) * mult;
	}

	function PVRTC2bppSize (width, height)
	{
	    width = Math.max(width, 16);
	    height = Math.max(height, 8);

	    return width * height / 4;
	}

	function PVRTC4bppSize (width, height)
	{
	    width = Math.max(width, 8);
	    height = Math.max(height, 8);

	    return width * height / 2;
	}

	function BPTCSize (width, height)
	{
	    return Math.ceil(width / 4) * Math.ceil(height / 4) * 16;
	}

	function DXTEtcSmallSize (width, height)
	{
	    return GetSize(width, height, 3, 3, 4, 4, 8);
	}

	function DXTEtcAstcBigSize (width, height)
	{
	    return GetSize(width, height, 3, 3, 4, 4);
	}

	function ATC5x4Size (width, height)
	{
	    return GetSize(width, height, 4, 3, 5, 4);
	}

	function ATC5x5Size (width, height)
	{
	    return GetSize(width, height, 4, 4, 5, 5);
	}

	function ATC6x5Size (width, height)
	{
	    return GetSize(width, height, 5, 4, 6, 5);
	}

	function ATC6x6Size (width, height)
	{
	    return GetSize(width, height, 5, 5, 6, 6);
	}

	function ATC8x5Size (width, height)
	{
	    return GetSize(width, height, 7, 4, 8, 5);
	}

	function ATC8x6Size (width, height)
	{
	    return GetSize(width, height, 7, 5, 8, 6);
	}

	function ATC8x8Size (width, height)
	{
	    return GetSize(width, height, 7, 7, 8, 8);
	}

	function ATC10x5Size (width, height)
	{
	    return GetSize(width, height, 9, 4, 10, 5);
	}

	function ATC10x6Size (width, height)
	{
	    return GetSize(width, height, 9, 5, 10, 6);
	}

	function ATC10x8Size (width, height)
	{
	    return GetSize(width, height, 9, 7, 10, 8);
	}

	function ATC10x10Size (width, height)
	{
	    return GetSize(width, height, 9, 9, 10, 10);
	}

	function ATC12x10Size (width, height)
	{
	    return GetSize(width, height, 11, 9, 12, 10);
	}

	function ATC12x12Size (width, height)
	{
	    return GetSize(width, height, 11, 11, 12, 12);
	}

	var FORMATS = {
	    0: { sizeFunc: PVRTC2bppSize, glFormat: [ 0x8C01 ] },
	    1: { sizeFunc: PVRTC2bppSize, glFormat: [ 0x8C03 ] },
	    2: { sizeFunc: PVRTC4bppSize, glFormat: [ 0x8C00 ] },
	    3: { sizeFunc: PVRTC4bppSize, glFormat: [ 0x8C02 ] },
	    6: { sizeFunc: DXTEtcSmallSize , glFormat: [ 0x8D64 ] },
	    7: { sizeFunc: DXTEtcSmallSize, glFormat: [ 0x83F0, 0x8C4C ] },
	    8: { sizeFunc: DXTEtcAstcBigSize, glFormat: [ 0x83F1, 0x8C4D ] },
	    9: { sizeFunc: DXTEtcAstcBigSize, glFormat: [ 0x83F2, 0x8C4E ] },
	    11: { sizeFunc: DXTEtcAstcBigSize, glFormat: [ 0x83F3, 0x8C4F ] },
	    14: { sizeFunc: BPTCSize, glFormat: [ 0x8E8E, 0x8E8F ] },
	    15: { sizeFunc: BPTCSize, glFormat: [ 0x8E8C, 0x8E8D ] },
	    22: { sizeFunc: DXTEtcSmallSize , glFormat: [ 0x9274, 0x9275 ] },
	    23: { sizeFunc: DXTEtcAstcBigSize, glFormat: [ 0x9278, 0x9279 ] },
	    24: { sizeFunc: DXTEtcSmallSize, glFormat: [ 0x9276, 0x9277 ] },
	    25: { sizeFunc: DXTEtcSmallSize, glFormat: [ 0x9270 ] },
	    26: { sizeFunc: DXTEtcAstcBigSize, glFormat: [ 0x9272 ] },
	    27: { sizeFunc: DXTEtcAstcBigSize, glFormat: [ 0x93B0, 0x93D0 ] },
	    28: { sizeFunc: ATC5x4Size, glFormat: [ 0x93B1, 0x93D1 ] },
	    29: { sizeFunc: ATC5x5Size, glFormat: [ 0x93B2, 0x93D2 ] },
	    30: { sizeFunc: ATC6x5Size, glFormat: [ 0x93B3, 0x93D3 ] },
	    31: { sizeFunc: ATC6x6Size, glFormat: [ 0x93B4, 0x93D4 ] },
	    32: { sizeFunc: ATC8x5Size, glFormat: [ 0x93B5, 0x93D5 ] },
	    33: { sizeFunc: ATC8x6Size, glFormat: [ 0x93B6, 0x93D6 ] },
	    34: { sizeFunc: ATC8x8Size, glFormat: [ 0x93B7, 0x93D7 ] },
	    35: { sizeFunc: ATC10x5Size, glFormat: [ 0x93B8, 0x93D8 ] },
	    36: { sizeFunc: ATC10x6Size, glFormat: [ 0x93B9, 0x93D9 ] },
	    37: { sizeFunc: ATC10x8Size, glFormat: [ 0x93BA, 0x93DA ] },
	    38: { sizeFunc: ATC10x10Size, glFormat: [ 0x93BB, 0x93DB ] },
	    39: { sizeFunc: ATC12x10Size, glFormat: [ 0x93BC, 0x93DC ] },
	    40: { sizeFunc: ATC12x12Size, glFormat: [ 0x93BD, 0x93DD ] }
	};

	var PVRParser = function (data)
	{
	    var header = new Uint32Array(data, 0, 13);

	    var version = header[0];
	    var versionMatch = version === 0x03525650;

	    var pvrFormat = versionMatch ? header[2] : header[3];

	    var colorSpace = header[4];

	    var internalFormat = FORMATS[pvrFormat].glFormat[colorSpace];
	    var sizeFunction = FORMATS[pvrFormat].sizeFunc;

	    var mipmapLevels = header[11];

	    var width = header[7];

	    var height = header[6];

	    var dataOffset = 52 + header[12];

	    var image = new Uint8Array(data, dataOffset);

	    var mipmaps = new Array(mipmapLevels);

	    var offset = 0;
	    var levelWidth = width;
	    var levelHeight = height;

	    for (var i = 0; i < mipmapLevels; i++)
	    {
	        var levelSize = sizeFunction(levelWidth, levelHeight);

	        mipmaps[i] = {
	            data: new Uint8Array(image.buffer, image.byteOffset + offset, levelSize),
	            width: levelWidth,
	            height: levelHeight
	        };

	        levelWidth = Math.max(1, levelWidth >> 1);
	        levelHeight = Math.max(1, levelHeight >> 1);

	        offset += levelSize;
	    }

	    return {
	        mipmaps: mipmaps,
	        width: width,
	        height: height,
	        internalFormat: internalFormat,
	        compressed: true,
	        generateMipmap: false
	    };
	};

	PVRParser_1 = PVRParser;
	return PVRParser_1;
}

var SpriteSheet_1;
var hasRequiredSpriteSheet;

function requireSpriteSheet () {
	if (hasRequiredSpriteSheet) return SpriteSheet_1;
	hasRequiredSpriteSheet = 1;
	var GetFastValue = requireGetFastValue();

	var SpriteSheet = function (texture, sourceIndex, x, y, width, height, config)
	{
	    var frameWidth = GetFastValue(config, 'frameWidth', null);
	    var frameHeight = GetFastValue(config, 'frameHeight', frameWidth);

	    if (frameWidth === null)
	    {
	        throw new Error('TextureManager.SpriteSheet: Invalid frameWidth given.');
	    }

	    var source = texture.source[sourceIndex];

	    texture.add('__BASE', sourceIndex, 0, 0, source.width, source.height);

	    var startFrame = GetFastValue(config, 'startFrame', 0);
	    var endFrame = GetFastValue(config, 'endFrame', -1);
	    var margin = GetFastValue(config, 'margin', 0);
	    var spacing = GetFastValue(config, 'spacing', 0);

	    var row = Math.floor((width - margin + spacing) / (frameWidth + spacing));
	    var column = Math.floor((height - margin + spacing) / (frameHeight + spacing));
	    var total = row * column;

	    if (total === 0)
	    {
	        console.warn('SpriteSheet frame dimensions will result in zero frames for texture:', texture.key);
	    }

	    if (startFrame > total || startFrame < -total)
	    {
	        startFrame = 0;
	    }

	    if (startFrame < 0)
	    {

	        startFrame = total + startFrame;
	    }

	    if (endFrame === -1 || endFrame > total || endFrame < startFrame)
	    {
	        endFrame = total;
	    }

	    var fx = margin;
	    var fy = margin;
	    var ax = 0;
	    var ay = 0;
	    var c = 0;

	    for (var i = 0; i < total; i++)
	    {
	        ax = 0;
	        ay = 0;

	        var w = fx + frameWidth;
	        var h = fy + frameHeight;

	        if (w > width)
	        {
	            ax = w - width;
	        }

	        if (h > height)
	        {
	            ay = h - height;
	        }

	        if (i >= startFrame && i <= endFrame)
	        {
	            texture.add(c, sourceIndex, x + fx, y + fy, frameWidth - ax, frameHeight - ay);

	            c++;
	        }

	        fx += frameWidth + spacing;

	        if (fx + frameWidth > width)
	        {
	            fx = margin;
	            fy += frameHeight + spacing;
	        }
	    }

	    return texture;
	};

	SpriteSheet_1 = SpriteSheet;
	return SpriteSheet_1;
}

var SpriteSheetFromAtlas_1;
var hasRequiredSpriteSheetFromAtlas;

function requireSpriteSheetFromAtlas () {
	if (hasRequiredSpriteSheetFromAtlas) return SpriteSheetFromAtlas_1;
	hasRequiredSpriteSheetFromAtlas = 1;
	var GetFastValue = requireGetFastValue();

	var SpriteSheetFromAtlas = function (texture, frame, config)
	{
	    var frameWidth = GetFastValue(config, 'frameWidth', null);
	    var frameHeight = GetFastValue(config, 'frameHeight', frameWidth);

	    if (!frameWidth)
	    {
	        throw new Error('TextureManager.SpriteSheetFromAtlas: Invalid frameWidth given.');
	    }

	    var source = texture.source[0];
	    texture.add('__BASE', 0, 0, 0, source.width, source.height);

	    GetFastValue(config, 'startFrame', 0);
	    GetFastValue(config, 'endFrame', -1);
	    var margin = GetFastValue(config, 'margin', 0);
	    var spacing = GetFastValue(config, 'spacing', 0);

	    var x = frame.cutX;
	    var y = frame.cutY;

	    var cutWidth = frame.cutWidth;
	    var cutHeight = frame.cutHeight;
	    var sheetWidth = frame.realWidth;
	    var sheetHeight = frame.realHeight;

	    var row = Math.floor((sheetWidth - margin + spacing) / (frameWidth + spacing));
	    var column = Math.floor((sheetHeight - margin + spacing) / (frameHeight + spacing));

	    var leftPad = frame.x;
	    var leftWidth = frameWidth - leftPad;

	    var rightWidth = frameWidth - ((sheetWidth - cutWidth) - leftPad);

	    var topPad = frame.y;
	    var topHeight = frameHeight - topPad;

	    var bottomHeight = frameHeight - ((sheetHeight - cutHeight) - topPad);

	    var sheetFrame;
	    var frameX = margin;
	    var frameY = margin;
	    var frameIndex = 0;
	    var sourceIndex = 0;

	    for (var sheetY = 0; sheetY < column; sheetY++)
	    {
	        var topRow = (sheetY === 0);
	        var bottomRow = (sheetY === column - 1);

	        for (var sheetX = 0; sheetX < row; sheetX++)
	        {
	            var leftRow = (sheetX === 0);
	            var rightRow = (sheetX === row - 1);

	            sheetFrame = texture.add(frameIndex, sourceIndex, x + frameX, y + frameY, frameWidth, frameHeight);

	            if (leftRow || topRow || rightRow || bottomRow)
	            {
	                var destX = (leftRow) ? leftPad : 0;
	                var destY = (topRow) ? topPad : 0;

	                var trimWidth = 0;
	                var trimHeight = 0;

	                if (leftRow)
	                {
	                    trimWidth += (frameWidth - leftWidth);
	                }

	                if (rightRow)
	                {
	                    trimWidth += (frameWidth - rightWidth);
	                }

	                if (topRow)
	                {
	                    trimHeight += (frameHeight - topHeight);
	                }

	                if (bottomRow)
	                {
	                    trimHeight += (frameHeight - bottomHeight);
	                }

	                var destWidth = frameWidth - trimWidth;
	                var destHeight = frameHeight - trimHeight;

	                sheetFrame.cutWidth = destWidth;
	                sheetFrame.cutHeight = destHeight;

	                sheetFrame.setTrim(frameWidth, frameHeight, destX, destY, destWidth, destHeight);
	            }

	            frameX += spacing;

	            if (leftRow)
	            {
	                frameX += leftWidth;
	            }
	            else if (rightRow)
	            {
	                frameX += rightWidth;
	            }
	            else
	            {
	                frameX += frameWidth;
	            }

	            frameIndex++;
	        }

	        frameX = margin;
	        frameY += spacing;

	        if (topRow)
	        {
	            frameY += topHeight;
	        }
	        else if (bottomRow)
	        {
	            frameY += bottomHeight;
	        }
	        else
	        {
	            frameY += frameHeight;
	        }
	    }

	    return texture;
	};

	SpriteSheetFromAtlas_1 = SpriteSheetFromAtlas;
	return SpriteSheetFromAtlas_1;
}

var UnityYAML_1;
var hasRequiredUnityYAML;

function requireUnityYAML () {
	if (hasRequiredUnityYAML) return UnityYAML_1;
	hasRequiredUnityYAML = 1;
	var imageHeight = 0;

	var addFrame = function (texture, sourceIndex, name, frame)
	{

	    var y = imageHeight - frame.y - frame.height;

	    texture.add(name, sourceIndex, frame.x, y, frame.width, frame.height);

	};

	var UnityYAML = function (texture, sourceIndex, yaml)
	{

	    var source = texture.source[sourceIndex];

	    texture.add('__BASE', sourceIndex, 0, 0, source.width, source.height);

	    imageHeight = source.height;

	    var data = yaml.split('\n');

	    var lineRegExp = /^[ ]*(- )*(\w+)+[: ]+(.*)/;

	    var prevSprite = '';
	    var currentSprite = '';
	    var rect = { x: 0, y: 0, width: 0, height: 0 };

	    for (var i = 0; i < data.length; i++)
	    {
	        var results = data[i].match(lineRegExp);

	        if (!results)
	        {
	            continue;
	        }

	        var isList = (results[1] === '- ');
	        var key = results[2];
	        var value = results[3];

	        if (isList)
	        {
	            if (currentSprite !== prevSprite)
	            {
	                addFrame(texture, sourceIndex, currentSprite, rect);

	                prevSprite = currentSprite;
	            }

	            rect = { x: 0, y: 0, width: 0, height: 0 };
	        }

	        if (key === 'name')
	        {

	            currentSprite = value;
	            continue;
	        }

	        switch (key)
	        {
	            case 'x':
	            case 'y':
	            case 'width':
	            case 'height':
	                rect[key] = parseInt(value, 10);
	                break;

	        }
	    }

	    if (currentSprite !== prevSprite)
	    {
	        addFrame(texture, sourceIndex, currentSprite, rect);
	    }

	    return texture;
	};

	UnityYAML_1 = UnityYAML;
	return UnityYAML_1;
}

var parsers$1;
var hasRequiredParsers$1;

function requireParsers$1 () {
	if (hasRequiredParsers$1) return parsers$1;
	hasRequiredParsers$1 = 1;
	parsers$1 = {

	    AtlasXML: requireAtlasXML(),
	    Canvas: requireCanvas$1(),
	    Image: requireImage(),
	    JSONArray: requireJSONArray(),
	    JSONHash: requireJSONHash(),
	    KTXParser: requireKTXParser(),
	    PVRParser: requirePVRParser(),
	    SpriteSheet: requireSpriteSheet(),
	    SpriteSheetFromAtlas: requireSpriteSheetFromAtlas(),
	    UnityYAML: requireUnityYAML()

	};
	return parsers$1;
}

var TextureManager_1;
var hasRequiredTextureManager;

function requireTextureManager () {
	if (hasRequiredTextureManager) return TextureManager_1;
	hasRequiredTextureManager = 1;
	var CanvasPool = requireCanvasPool();
	var CanvasTexture = requireCanvasTexture();
	var Class = requireClass();
	var Color = requireColor$1();
	var CONST = require_const$f();
	var DynamicTexture = requireDynamicTexture();
	var EventEmitter = requireEventemitter3();
	var Events = requireEvents$c();
	var Frame = requireFrame();
	var GameEvents = requireEvents$h();
	var GenerateTexture = requireGenerateTexture();
	var GetValue = requireGetValue();
	var ImageGameObject = requireImage$1();
	var IsPlainObject = requireIsPlainObject();
	var Parser = requireParsers$1();
	var Rectangle = requireRectangle$2();
	var Texture = requireTexture();

	var TextureManager = new Class({

	    Extends: EventEmitter,

	    initialize:

	    function TextureManager (game)
	    {
	        EventEmitter.call(this);

	        this.game = game;

	        this.name = 'TextureManager';

	        this.list = {};

	        this._tempCanvas = CanvasPool.create2D(this);

	        this._tempContext = this._tempCanvas.getContext('2d', { willReadFrequently: true });

	        this._pending = 0;

	        this.stamp;

	        this.stampCrop = new Rectangle();

	        this.silentWarnings = false;

	        game.events.once(GameEvents.BOOT, this.boot, this);
	    },

	    boot: function ()
	    {
	        this._pending = 3;

	        this.on(Events.LOAD, this.updatePending, this);
	        this.on(Events.ERROR, this.updatePending, this);

	        var config = this.game.config;

	        if (config.defaultImage !== null)
	        {
	            this.addBase64('__DEFAULT', config.defaultImage);
	        }

	        if (config.missingImage !== null)
	        {
	            this.addBase64('__MISSING', config.missingImage);
	        }

	        if (config.whiteImage !== null)
	        {
	            this.addBase64('__WHITE', config.whiteImage);
	        }

	        if (this.game.renderer && this.game.renderer.gl)
	        {
	            this.addUint8Array('__NORMAL', new Uint8Array([ 127, 127, 255, 255 ]), 1, 1);
	        }

	        this.game.events.once(GameEvents.DESTROY, this.destroy, this);

	        this.game.events.once(GameEvents.SYSTEM_READY, function (scene)
	        {
	            this.stamp = new ImageGameObject(scene).setOrigin(0);

	        }, this);
	    },

	    updatePending: function ()
	    {
	        this._pending--;

	        if (this._pending === 0)
	        {
	            this.off(Events.LOAD);
	            this.off(Events.ERROR);

	            this.emit(Events.READY);
	        }
	    },

	    checkKey: function (key)
	    {
	        if (!key || typeof key !== 'string' || this.exists(key))
	        {
	            if (!this.silentWarnings)
	            {

	                console.error('Texture key already in use: ' + key);
	            }

	            return false;
	        }

	        return true;
	    },

	    remove: function (key)
	    {
	        if (typeof key === 'string')
	        {
	            if (this.exists(key))
	            {
	                key = this.get(key);
	            }
	            else
	            {
	                if (!this.silentWarnings)
	                {
	                    console.warn('No texture found matching key: ' + key);
	                }

	                return this;
	            }
	        }

	        var textureKey = key.key;

	        if (this.list.hasOwnProperty(textureKey))
	        {
	            key.destroy();

	            this.emit(Events.REMOVE, textureKey);
	            this.emit(Events.REMOVE_KEY + textureKey);
	        }

	        return this;
	    },

	    removeKey: function (key)
	    {
	        if (this.list.hasOwnProperty(key))
	        {
	            delete this.list[key];
	        }

	        return this;
	    },

	    addBase64: function (key, data)
	    {
	        if (this.checkKey(key))
	        {
	            var _this = this;

	            var image = new Image();

	            image.onerror = function ()
	            {
	                _this.emit(Events.ERROR, key);
	            };

	            image.onload = function ()
	            {
	                var texture = _this.create(key, image);

	                if (!texture)
	                {
	                    return;
	                }

	                Parser.Image(texture, 0);

	                _this.emit(Events.ADD, key, texture);
	                _this.emit(Events.ADD_KEY + key, texture);
	                _this.emit(Events.LOAD, key, texture);
	            };

	            image.src = data;
	        }

	        return this;
	    },

	    getBase64: function (key, frame, type, encoderOptions)
	    {
	        if (type === undefined) { type = 'image/png'; }
	        if (encoderOptions === undefined) { encoderOptions = 0.92; }

	        var data = '';

	        var textureFrame = this.getFrame(key, frame);

	        if (textureFrame && (textureFrame.source.isRenderTexture || textureFrame.source.isGLTexture))
	        {
	            if (!this.silentWarnings)
	            {
	                console.warn('Cannot getBase64 from WebGL Texture');
	            }
	        }
	        else if (textureFrame)
	        {
	            var cd = textureFrame.canvasData;

	            var canvas = CanvasPool.create2D(this, cd.width, cd.height);
	            var ctx = canvas.getContext('2d', { willReadFrequently: true });

	            if (cd.width > 0 && cd.height > 0)
	            {
	                ctx.drawImage(
	                    textureFrame.source.image,
	                    cd.x,
	                    cd.y,
	                    cd.width,
	                    cd.height,
	                    0,
	                    0,
	                    cd.width,
	                    cd.height
	                );
	            }

	            data = canvas.toDataURL(type, encoderOptions);

	            CanvasPool.remove(canvas);
	        }

	        return data;
	    },

	    addImage: function (key, source, dataSource)
	    {
	        var texture = null;

	        if (this.checkKey(key))
	        {
	            texture = this.create(key, source);

	            Parser.Image(texture, 0);

	            if (dataSource)
	            {
	                texture.setDataSource(dataSource);
	            }

	            this.emit(Events.ADD, key, texture);
	            this.emit(Events.ADD_KEY + key, texture);
	        }

	        return texture;
	    },

	    addGLTexture: function (key, glTexture)
	    {
	        var texture = null;

	        if (this.checkKey(key))
	        {
	            var width = glTexture.width;
	            var height = glTexture.height;

	            texture = this.create(key, glTexture, width, height);

	            texture.add('__BASE', 0, 0, 0, width, height);

	            this.emit(Events.ADD, key, texture);
	            this.emit(Events.ADD_KEY + key, texture);
	        }

	        return texture;
	    },

	    addCompressedTexture: function (key, textureData, atlasData)
	    {
	        var texture = null;

	        if (this.checkKey(key))
	        {
	            texture = this.create(key, textureData);

	            texture.add('__BASE', 0, 0, 0, textureData.width, textureData.height);

	            if (atlasData)
	            {
	                var parse = function (texture, sourceIndex, atlasData)
	                {
	                    if (Array.isArray(atlasData.textures) || Array.isArray(atlasData.frames))
	                    {
	                        Parser.JSONArray(texture, sourceIndex, atlasData);
	                    }
	                    else
	                    {
	                        Parser.JSONHash(texture, sourceIndex, atlasData);
	                    }
	                };
	                if (Array.isArray(atlasData))
	                {
	                    for (var i = 0; i < atlasData.length; i++)
	                    {
	                        parse(texture, i, atlasData[i]);
	                    }
	                }
	                else
	                {
	                    parse(texture, 0, atlasData);
	                }
	            }

	            this.emit(Events.ADD, key, texture);
	            this.emit(Events.ADD_KEY + key, texture);
	        }

	        return texture;
	    },

	    addRenderTexture: function (key, renderTexture)
	    {
	        var texture = null;

	        if (this.checkKey(key))
	        {
	            texture = this.create(key, renderTexture);

	            texture.add('__BASE', 0, 0, 0, renderTexture.width, renderTexture.height);

	            this.emit(Events.ADD, key, texture);
	            this.emit(Events.ADD_KEY + key, texture);
	        }

	        return texture;
	    },

	    generate: function (key, config)
	    {
	        if (this.checkKey(key))
	        {
	            var canvas = CanvasPool.create(this, 1, 1);

	            config.canvas = canvas;

	            GenerateTexture(config);

	            return this.addCanvas(key, canvas);
	        }
	        else
	        {
	            return null;
	        }
	    },

	    createCanvas: function (key, width, height)
	    {
	        if (width === undefined) { width = 256; }
	        if (height === undefined) { height = 256; }

	        if (this.checkKey(key))
	        {
	            var canvas = CanvasPool.create(this, width, height, CONST.CANVAS, true);

	            return this.addCanvas(key, canvas);
	        }

	        return null;
	    },

	    addCanvas: function (key, source, skipCache)
	    {
	        if (skipCache === undefined) { skipCache = false; }

	        var texture = null;

	        if (skipCache)
	        {
	            texture = new CanvasTexture(this, key, source, source.width, source.height);
	        }
	        else if (this.checkKey(key))
	        {
	            texture = new CanvasTexture(this, key, source, source.width, source.height);

	            this.list[key] = texture;

	            this.emit(Events.ADD, key, texture);
	            this.emit(Events.ADD_KEY + key, texture);
	        }

	        return texture;
	    },

	    addDynamicTexture: function (key, width, height)
	    {
	        var texture = null;

	        if (typeof(key) === 'string' && !this.exists(key))
	        {
	            texture = new DynamicTexture(this, key, width, height);
	        }
	        else
	        {
	            texture = key;
	            key = texture.key;
	        }

	        if (this.checkKey(key))
	        {
	            this.list[key] = texture;

	            this.emit(Events.ADD, key, texture);
	            this.emit(Events.ADD_KEY + key, texture);
	        }
	        else
	        {
	            texture = null;
	        }

	        return texture;
	    },

	    addAtlas: function (key, source, data, dataSource)
	    {

	        if (Array.isArray(data.textures) || Array.isArray(data.frames))
	        {
	            return this.addAtlasJSONArray(key, source, data, dataSource);
	        }
	        else
	        {
	            return this.addAtlasJSONHash(key, source, data, dataSource);
	        }
	    },

	    addAtlasJSONArray: function (key, source, data, dataSource)
	    {
	        var texture = null;

	        if (source instanceof Texture)
	        {
	            key = source.key;
	            texture = source;
	        }
	        else if (this.checkKey(key))
	        {
	            texture = this.create(key, source);
	        }

	        if (texture)
	        {

	            if (Array.isArray(data))
	            {
	                var singleAtlasFile = (data.length === 1); 

	                for (var i = 0; i < texture.source.length; i++)
	                {
	                    var atlasData = singleAtlasFile ? data[0] : data[i];

	                    Parser.JSONArray(texture, i, atlasData);
	                }
	            }
	            else
	            {
	                Parser.JSONArray(texture, 0, data);
	            }

	            if (dataSource)
	            {
	                texture.setDataSource(dataSource);
	            }

	            this.emit(Events.ADD, key, texture);
	            this.emit(Events.ADD_KEY + key, texture);
	        }

	        return texture;
	    },

	    addAtlasJSONHash: function (key, source, data, dataSource)
	    {
	        var texture = null;

	        if (source instanceof Texture)
	        {
	            key = source.key;
	            texture = source;
	        }
	        else if (this.checkKey(key))
	        {
	            texture = this.create(key, source);
	        }

	        if (texture)
	        {
	            if (Array.isArray(data))
	            {
	                for (var i = 0; i < data.length; i++)
	                {
	                    Parser.JSONHash(texture, i, data[i]);
	                }
	            }
	            else
	            {
	                Parser.JSONHash(texture, 0, data);
	            }

	            if (dataSource)
	            {
	                texture.setDataSource(dataSource);
	            }

	            this.emit(Events.ADD, key, texture);
	            this.emit(Events.ADD_KEY + key, texture);
	        }

	        return texture;
	    },

	    addAtlasXML: function (key, source, data, dataSource)
	    {
	        var texture = null;

	        if (source instanceof Texture)
	        {
	            key = source.key;
	            texture = source;
	        }
	        else if (this.checkKey(key))
	        {
	            texture = this.create(key, source);
	        }

	        if (texture)
	        {
	            Parser.AtlasXML(texture, 0, data);

	            if (dataSource)
	            {
	                texture.setDataSource(dataSource);
	            }

	            this.emit(Events.ADD, key, texture);
	            this.emit(Events.ADD_KEY + key, texture);
	        }

	        return texture;
	    },

	    addUnityAtlas: function (key, source, data, dataSource)
	    {
	        var texture = null;

	        if (source instanceof Texture)
	        {
	            key = source.key;
	            texture = source;
	        }
	        else if (this.checkKey(key))
	        {
	            texture = this.create(key, source);
	        }

	        if (texture)
	        {
	            Parser.UnityYAML(texture, 0, data);

	            if (dataSource)
	            {
	                texture.setDataSource(dataSource);
	            }

	            this.emit(Events.ADD, key, texture);
	            this.emit(Events.ADD_KEY + key, texture);
	        }

	        return texture;
	    },

	    addSpriteSheet: function (key, source, config, dataSource)
	    {
	        var texture = null;

	        if (source instanceof Texture)
	        {
	            key = source.key;
	            texture = source;
	        }
	        else if (this.checkKey(key))
	        {
	            texture = this.create(key, source);
	        }

	        if (texture)
	        {
	            var width = texture.source[0].width;
	            var height = texture.source[0].height;

	            Parser.SpriteSheet(texture, 0, 0, 0, width, height, config);

	            if (dataSource)
	            {
	                texture.setDataSource(dataSource);
	            }

	            this.emit(Events.ADD, key, texture);
	            this.emit(Events.ADD_KEY + key, texture);
	        }

	        return texture;
	    },

	    addSpriteSheetFromAtlas: function (key, config)
	    {
	        if (!this.checkKey(key))
	        {
	            return null;
	        }

	        var atlasKey = GetValue(config, 'atlas', null);
	        var atlasFrame = GetValue(config, 'frame', null);

	        if (!atlasKey || !atlasFrame)
	        {
	            return;
	        }

	        var atlas = this.get(atlasKey);
	        var sheet = atlas.get(atlasFrame);

	        if (sheet)
	        {
	            var source = sheet.source.image;
	            if (!source)
	            {
	                source = sheet.source.glTexture;
	            }
	            var texture = this.create(key, source);

	            if (sheet.trimmed)
	            {

	                Parser.SpriteSheetFromAtlas(texture, sheet, config);
	            }
	            else
	            {
	                Parser.SpriteSheet(texture, 0, sheet.cutX, sheet.cutY, sheet.cutWidth, sheet.cutHeight, config);
	            }

	            this.emit(Events.ADD, key, texture);
	            this.emit(Events.ADD_KEY + key, texture);

	            return texture;
	        }
	    },

	    addUint8Array: function (key, data, width, height)
	    {
	        if (
	            !this.checkKey(key) ||
	            data.length / 4 !== width * height
	        )
	        {
	            return null;
	        }

	        var texture = this.create(key, data, width, height);

	        texture.add('__BASE', 0, 0, 0, width, height);

	        this.emit(Events.ADD, key, texture);
	        this.emit(Events.ADD_KEY + key, texture);

	        return texture;
	    },

	    create: function (key, source, width, height)
	    {
	        var texture = null;

	        if (this.checkKey(key))
	        {
	            texture = new Texture(this, key, source, width, height);

	            this.list[key] = texture;
	        }

	        return texture;
	    },

	    exists: function (key)
	    {
	        return (this.list.hasOwnProperty(key));
	    },

	    get: function (key)
	    {
	        if (key === undefined) { key = '__DEFAULT'; }

	        if (this.list[key])
	        {
	            return this.list[key];
	        }
	        else if (key instanceof Texture)
	        {
	            return key;
	        }
	        else if (key instanceof Frame)
	        {
	            return key.texture;
	        }
	        else
	        {
	            return this.list['__MISSING'];
	        }
	    },

	    cloneFrame: function (key, frame)
	    {
	        if (this.list[key])
	        {
	            return this.list[key].get(frame).clone();
	        }
	    },

	    getFrame: function (key, frame)
	    {
	        if (this.list[key])
	        {
	            return this.list[key].get(frame);
	        }
	    },

	    parseFrame: function (key)
	    {
	        if (!key)
	        {
	            return undefined;
	        }
	        else if (typeof key === 'string')
	        {
	            return this.getFrame(key);
	        }
	        else if (Array.isArray(key) && key.length === 2)
	        {
	            return this.getFrame(key[0], key[1]);
	        }
	        else if (IsPlainObject(key))
	        {
	            return this.getFrame(key.key, key.frame);
	        }
	        else if (key instanceof Texture)
	        {
	            return key.get();
	        }
	        else if (key instanceof Frame)
	        {
	            return key;
	        }
	    },

	    getTextureKeys: function ()
	    {
	        var output = [];

	        for (var key in this.list)
	        {
	            if (key !== '__DEFAULT' && key !== '__MISSING' && key !== '__WHITE' && key !== '__NORMAL')
	            {
	                output.push(key);
	            }
	        }

	        return output;
	    },

	    getPixel: function (x, y, key, frame)
	    {
	        var textureFrame = this.getFrame(key, frame);

	        if (textureFrame)
	        {

	            x -= textureFrame.x;
	            y -= textureFrame.y;

	            var data = textureFrame.data.cut;

	            x += data.x;
	            y += data.y;

	            if (x >= data.x && x < data.r && y >= data.y && y < data.b)
	            {
	                var ctx = this._tempContext;

	                ctx.clearRect(0, 0, 1, 1);
	                ctx.drawImage(textureFrame.source.image, x, y, 1, 1, 0, 0, 1, 1);

	                var rgb = ctx.getImageData(0, 0, 1, 1);

	                return new Color(rgb.data[0], rgb.data[1], rgb.data[2], rgb.data[3]);
	            }
	        }

	        return null;
	    },

	    getPixelAlpha: function (x, y, key, frame)
	    {
	        var textureFrame = this.getFrame(key, frame);

	        if (textureFrame)
	        {

	            x -= textureFrame.x;
	            y -= textureFrame.y;

	            var data = textureFrame.data.cut;

	            x += data.x;
	            y += data.y;

	            if (x >= data.x && x < data.r && y >= data.y && y < data.b)
	            {
	                var ctx = this._tempContext;

	                ctx.clearRect(0, 0, 1, 1);
	                ctx.drawImage(textureFrame.source.image, x, y, 1, 1, 0, 0, 1, 1);

	                var rgb = ctx.getImageData(0, 0, 1, 1);

	                return rgb.data[3];
	            }
	        }

	        return null;
	    },

	    setTexture: function (gameObject, key, frame)
	    {
	        if (this.list[key])
	        {
	            gameObject.texture = this.list[key];
	            gameObject.frame = gameObject.texture.get(frame);
	        }

	        return gameObject;
	    },

	    renameTexture: function (currentKey, newKey)
	    {
	        var texture = this.get(currentKey);

	        if (texture && currentKey !== newKey)
	        {
	            texture.key = newKey;

	            this.list[newKey] = texture;

	            delete this.list[currentKey];

	            return true;
	        }

	        return false;
	    },

	    each: function (callback, scope)
	    {
	        var args = [ null ];

	        for (var i = 1; i < arguments.length; i++)
	        {
	            args.push(arguments[i]);
	        }

	        for (var texture in this.list)
	        {
	            args[0] = this.list[texture];

	            callback.apply(scope, args);
	        }
	    },

	    resetStamp: function (alpha, tint)
	    {
	        if (alpha === undefined) { alpha = 1; }
	        if (tint === undefined) { tint = 0xffffff; }

	        var stamp = this.stamp;

	        stamp.setCrop();
	        stamp.setPosition(0);
	        stamp.setAngle(0);
	        stamp.setScale(1);
	        stamp.setAlpha(alpha);
	        stamp.setTint(tint);
	        stamp.setTexture('__WHITE');

	        return stamp;
	    },

	    destroy: function ()
	    {
	        for (var texture in this.list)
	        {
	            this.list[texture].destroy();
	        }

	        this.list = {};

	        this.stamp.destroy();

	        this.game = null;
	        this.stamp = null;

	        CanvasPool.remove(this._tempCanvas);
	    }

	});

	TextureManager_1 = TextureManager;
	return TextureManager_1;
}

var Game_1;
var hasRequiredGame;

function requireGame () {
	if (hasRequiredGame) return Game_1;
	hasRequiredGame = 1;
	var AddToDOM = requireAddToDOM();
	var AnimationManager = requireAnimationManager();
	var CacheManager = requireCacheManager();
	var CanvasPool = requireCanvasPool();
	var Class = requireClass();
	var Config = requireConfig();
	var CreateDOMContainer = requireCreateDOMContainer();
	var CreateRenderer = requireCreateRenderer();
	var DataManager = requireDataManager();
	var Device = requireDevice();
	var DOMContentLoaded = requireDOMContentLoaded();
	var EventEmitter = requireEventemitter3();
	var Events = requireEvents$h();
	var InputManager = requireInputManager();
	var PluginCache = requirePluginCache();
	var PluginManager = requirePluginManager();
	var ScaleManager = requireScaleManager();
	var SceneManager = requireSceneManager();
	var TextureEvents = requireEvents$c();
	var TextureManager = requireTextureManager();
	var TimeStep = requireTimeStep();
	var VisibilityHandler = requireVisibilityHandler();

	var Game = new Class({

	    initialize:

	    function Game (config)
	    {

	        this.config = new Config(config);

	        this.renderer = null;

	        this.domContainer = null;

	        this.canvas = null;

	        this.context = null;

	        this.isBooted = false;

	        this.isRunning = false;

	        this.events = new EventEmitter();

	        this.anims = new AnimationManager(this);

	        this.textures = new TextureManager(this);

	        this.cache = new CacheManager(this);

	        this.registry = new DataManager(this, new EventEmitter());

	        this.input = new InputManager(this, this.config);

	        this.scene = new SceneManager(this, this.config.sceneConfig);

	        this.device = Device;

	        this.scale = new ScaleManager(this, this.config);

	        this.sound = null;

	        this.loop = new TimeStep(this, this.config.fps);

	        this.plugins = new PluginManager(this, this.config);

	        this.pendingDestroy = false;

	        this.removeCanvas = false;

	        this.noReturn = false;

	        this.hasFocus = false;

	        this.isPaused = false;

	        DOMContentLoaded(this.boot.bind(this));
	    },

	    boot: function ()
	    {
	        if (!PluginCache.hasCore('EventEmitter'))
	        {
	            console.warn('Aborting. Core Plugins missing.');
	            return;
	        }

	        this.isBooted = true;

	        this.config.preBoot(this);

	        this.scale.preBoot();

	        CreateRenderer(this);

	        CreateDOMContainer(this);

	        AddToDOM(this.canvas, this.config.parent);

	        this.textures.once(TextureEvents.READY, this.texturesReady, this);

	        this.events.emit(Events.BOOT);

	        if (typeof WEBGL_DEBUG && window)
	        {
	            window.PHASER_GAME = this;
	        }
	    },

	    texturesReady: function ()
	    {

	        this.events.emit(Events.READY);

	        this.start();
	    },

	    start: function ()
	    {
	        this.isRunning = true;

	        this.config.postBoot(this);

	        if (this.renderer)
	        {
	            this.loop.start(this.step.bind(this));
	        }
	        else
	        {
	            this.loop.start(this.headlessStep.bind(this));
	        }

	        VisibilityHandler(this);

	        var eventEmitter = this.events;

	        eventEmitter.on(Events.HIDDEN, this.onHidden, this);
	        eventEmitter.on(Events.VISIBLE, this.onVisible, this);
	        eventEmitter.on(Events.BLUR, this.onBlur, this);
	        eventEmitter.on(Events.FOCUS, this.onFocus, this);
	    },

	    step: function (time, delta)
	    {
	        if (this.pendingDestroy)
	        {
	            return this.runDestroy();
	        }

	        if (this.isPaused)
	        {
	            return;
	        }

	        var eventEmitter = this.events;

	        eventEmitter.emit(Events.PRE_STEP, time, delta);

	        eventEmitter.emit(Events.STEP, time, delta);

	        this.scene.update(time, delta);

	        eventEmitter.emit(Events.POST_STEP, time, delta);

	        var renderer = this.renderer;

	        renderer.preRender();

	        eventEmitter.emit(Events.PRE_RENDER, renderer, time, delta);

	        this.scene.render(renderer);

	        renderer.postRender();

	        eventEmitter.emit(Events.POST_RENDER, renderer, time, delta);
	    },

	    headlessStep: function (time, delta)
	    {
	        if (this.pendingDestroy)
	        {
	            return this.runDestroy();
	        }

	        if (this.isPaused)
	        {
	            return;
	        }

	        var eventEmitter = this.events;

	        eventEmitter.emit(Events.PRE_STEP, time, delta);

	        eventEmitter.emit(Events.STEP, time, delta);

	        this.scene.update(time, delta);

	        eventEmitter.emit(Events.POST_STEP, time, delta);

	        this.scene.isProcessing = false;

	        eventEmitter.emit(Events.PRE_RENDER, null, time, delta);

	        eventEmitter.emit(Events.POST_RENDER, null, time, delta);
	    },

	    onHidden: function ()
	    {
	        this.loop.pause();

	        this.events.emit(Events.PAUSE);
	    },

	    pause: function ()
	    {
	        var wasPaused = this.isPaused;

	        this.isPaused = true;

	        if (!wasPaused)
	        {
	            this.events.emit(Events.PAUSE);
	        }
	    },

	    onVisible: function ()
	    {
	        this.loop.resume();

	        this.events.emit(Events.RESUME, this.loop.pauseDuration);
	    },

	    resume: function ()
	    {
	        var wasPaused = this.isPaused;

	        this.isPaused = false;

	        if (wasPaused)
	        {
	            this.events.emit(Events.RESUME, 0);
	        }
	    },

	    onBlur: function ()
	    {
	        this.hasFocus = false;

	        this.loop.blur();
	    },

	    onFocus: function ()
	    {
	        this.hasFocus = true;

	        this.loop.focus();
	    },

	    getFrame: function ()
	    {
	        return this.loop.frame;
	    },

	    getTime: function ()
	    {
	        return this.loop.now;
	    },

	    destroy: function (removeCanvas, noReturn)
	    {
	        if (noReturn === undefined) { noReturn = false; }

	        this.pendingDestroy = true;

	        this.removeCanvas = removeCanvas;
	        this.noReturn = noReturn;
	    },

	    runDestroy: function ()
	    {
	        this.scene.destroy();

	        this.events.emit(Events.DESTROY);

	        this.events.removeAllListeners();

	        if (this.renderer)
	        {
	            this.renderer.destroy();
	        }

	        if (this.removeCanvas && this.canvas)
	        {
	            CanvasPool.remove(this.canvas);

	            if (this.canvas.parentNode)
	            {
	                this.canvas.parentNode.removeChild(this.canvas);
	            }
	        }

	        if (this.domContainer && this.domContainer.parentNode)
	        {
	            this.domContainer.parentNode.removeChild(this.domContainer);
	        }

	        this.loop.destroy();

	        this.pendingDestroy = false;
	    }

	});

	Game_1 = Game;
	return Game_1;
}

var List_1;
var hasRequiredList;

function requireList () {
	if (hasRequiredList) return List_1;
	hasRequiredList = 1;
	var ArrayUtils = requireArray();
	var Class = requireClass();
	var NOOP = requireNOOP();
	var StableSort = requireStableSort();

	var List = new Class({

	    initialize:

	    function List (parent)
	    {

	        this.parent = parent;

	        this.list = [];

	        this.position = 0;

	        this.addCallback = NOOP;

	        this.removeCallback = NOOP;

	        this._sortKey = '';
	    },

	    add: function (child, skipCallback)
	    {
	        if (skipCallback)
	        {
	            return ArrayUtils.Add(this.list, child);
	        }
	        else
	        {
	            return ArrayUtils.Add(this.list, child, 0, this.addCallback, this);
	        }
	    },

	    addAt: function (child, index, skipCallback)
	    {
	        if (skipCallback)
	        {
	            return ArrayUtils.AddAt(this.list, child, index);
	        }
	        else
	        {
	            return ArrayUtils.AddAt(this.list, child, index, 0, this.addCallback, this);
	        }
	    },

	    getAt: function (index)
	    {
	        return this.list[index];
	    },

	    getIndex: function (child)
	    {

	        return this.list.indexOf(child);
	    },

	    sort: function (property, handler)
	    {
	        if (!property)
	        {
	            return this;
	        }

	        if (handler === undefined)
	        {
	            handler = function (childA, childB)
	            {
	                return childA[property] - childB[property];
	            };
	        }

	        StableSort(this.list, handler);

	        return this;
	    },

	    getByName: function (name)
	    {
	        return ArrayUtils.GetFirst(this.list, 'name', name);
	    },

	    getRandom: function (startIndex, length)
	    {
	        return ArrayUtils.GetRandom(this.list, startIndex, length);
	    },

	    getFirst: function (property, value, startIndex, endIndex)
	    {
	        return ArrayUtils.GetFirst(this.list, property, value, startIndex, endIndex);
	    },

	    getAll: function (property, value, startIndex, endIndex)
	    {
	        return ArrayUtils.GetAll(this.list, property, value, startIndex, endIndex);
	    },

	    count: function (property, value)
	    {
	        return ArrayUtils.CountAllMatching(this.list, property, value);
	    },

	    swap: function (child1, child2)
	    {
	        ArrayUtils.Swap(this.list, child1, child2);
	    },

	    moveTo: function (child, index)
	    {
	        return ArrayUtils.MoveTo(this.list, child, index);
	    },

	    moveAbove: function (child1, child2)
	    {
	        return ArrayUtils.MoveAbove(this.list, child1, child2);
	    },

	    moveBelow: function (child1, child2)
	    {
	        return ArrayUtils.MoveBelow(this.list, child1, child2);
	    },

	    remove: function (child, skipCallback)
	    {
	        if (skipCallback)
	        {
	            return ArrayUtils.Remove(this.list, child);
	        }
	        else
	        {
	            return ArrayUtils.Remove(this.list, child, this.removeCallback, this);
	        }
	    },

	    removeAt: function (index, skipCallback)
	    {
	        if (skipCallback)
	        {
	            return ArrayUtils.RemoveAt(this.list, index);
	        }
	        else
	        {
	            return ArrayUtils.RemoveAt(this.list, index, this.removeCallback, this);
	        }
	    },

	    removeBetween: function (startIndex, endIndex, skipCallback)
	    {
	        if (skipCallback)
	        {
	            return ArrayUtils.RemoveBetween(this.list, startIndex, endIndex);
	        }
	        else
	        {
	            return ArrayUtils.RemoveBetween(this.list, startIndex, endIndex, this.removeCallback, this);
	        }
	    },

	    removeAll: function (skipCallback)
	    {
	        var i = this.list.length;

	        while (i--)
	        {
	            this.remove(this.list[i], skipCallback);
	        }

	        return this;
	    },

	    bringToTop: function (child)
	    {
	        return ArrayUtils.BringToTop(this.list, child);
	    },

	    sendToBack: function (child)
	    {
	        return ArrayUtils.SendToBack(this.list, child);
	    },

	    moveUp: function (child)
	    {
	        ArrayUtils.MoveUp(this.list, child);

	        return child;
	    },

	    moveDown: function (child)
	    {
	        ArrayUtils.MoveDown(this.list, child);

	        return child;
	    },

	    reverse: function ()
	    {
	        this.list.reverse();

	        return this;
	    },

	    shuffle: function ()
	    {
	        ArrayUtils.Shuffle(this.list);

	        return this;
	    },

	    replace: function (oldChild, newChild)
	    {
	        return ArrayUtils.Replace(this.list, oldChild, newChild);
	    },

	    exists: function (child)
	    {
	        return (this.list.indexOf(child) > -1);
	    },

	    setAll: function (property, value, startIndex, endIndex)
	    {
	        ArrayUtils.SetAll(this.list, property, value, startIndex, endIndex);

	        return this;
	    },

	    each: function (callback, context)
	    {
	        var args = [ null ];

	        for (var i = 2; i < arguments.length; i++)
	        {
	            args.push(arguments[i]);
	        }

	        for (i = 0; i < this.list.length; i++)
	        {
	            args[0] = this.list[i];

	            callback.apply(context, args);
	        }
	    },

	    shutdown: function ()
	    {
	        this.removeAll();

	        this.list = [];
	    },

	    destroy: function ()
	    {
	        this.removeAll();

	        this.parent = null;
	        this.addCallback = null;
	        this.removeCallback = null;
	    },

	    length: {

	        get: function ()
	        {
	            return this.list.length;
	        }

	    },

	    first: {

	        get: function ()
	        {
	            this.position = 0;

	            if (this.list.length > 0)
	            {
	                return this.list[0];
	            }
	            else
	            {
	                return null;
	            }
	        }

	    },

	    last: {

	        get: function ()
	        {
	            if (this.list.length > 0)
	            {
	                this.position = this.list.length - 1;

	                return this.list[this.position];
	            }
	            else
	            {
	                return null;
	            }
	        }

	    },

	    next: {

	        get: function ()
	        {
	            if (this.position < this.list.length)
	            {
	                this.position++;

	                return this.list[this.position];
	            }
	            else
	            {
	                return null;
	            }
	        }

	    },

	    previous: {

	        get: function ()
	        {
	            if (this.position > 0)
	            {
	                this.position--;

	                return this.list[this.position];
	            }
	            else
	            {
	                return null;
	            }
	        }

	    }

	});

	List_1 = List;
	return List_1;
}

var DisplayList_1;
var hasRequiredDisplayList;

function requireDisplayList () {
	if (hasRequiredDisplayList) return DisplayList_1;
	hasRequiredDisplayList = 1;
	var Class = requireClass();
	var List = requireList();
	var PluginCache = requirePluginCache();
	var GameObjectEvents = requireEvents$j();
	var SceneEvents = requireEvents$l();
	requireStableSort();

	var DisplayList = new Class({

	    Extends: List,

	    initialize:

	    function DisplayList (scene)
	    {
	        List.call(this, scene);

	        this.sortChildrenFlag = false;

	        this.scene = scene;

	        this.systems = scene.sys;

	        this.events = scene.sys.events;

	        this.addCallback = this.addChildCallback;
	        this.removeCallback = this.removeChildCallback;

	        this.events.once(SceneEvents.BOOT, this.boot, this);
	        this.events.on(SceneEvents.START, this.start, this);
	    },

	    boot: function ()
	    {
	        this.events.once(SceneEvents.DESTROY, this.destroy, this);
	    },

	    addChildCallback: function (gameObject)
	    {
	        if (gameObject.displayList && gameObject.displayList !== this)
	        {
	            gameObject.removeFromDisplayList();
	        }

	        if (gameObject.parentContainer)
	        {
	            gameObject.parentContainer.remove(gameObject);
	        }

	        if (!gameObject.displayList)
	        {
	            this.queueDepthSort();

	            gameObject.displayList = this;

	            gameObject.emit(GameObjectEvents.ADDED_TO_SCENE, gameObject, this.scene);

	            this.events.emit(SceneEvents.ADDED_TO_SCENE, gameObject, this.scene);
	        }
	    },

	    removeChildCallback: function (gameObject)
	    {
	        this.queueDepthSort();

	        gameObject.displayList = null;

	        gameObject.emit(GameObjectEvents.REMOVED_FROM_SCENE, gameObject, this.scene);

	        this.events.emit(SceneEvents.REMOVED_FROM_SCENE, gameObject, this.scene);
	    },

	    start: function ()
	    {
	        this.events.once(SceneEvents.SHUTDOWN, this.shutdown, this);
	    },

	    queueDepthSort: function ()
	    {
	        this.sortChildrenFlag = true;
	    },

	depthSort: function () {
	  if (this.sortChildrenFlag) {
	    this.list.sort(this.sortByDepth);
	  }
	},

	    sortByDepth: function (childA, childB)
	    {
	        return childA._depth - childB._depth;
	    },

	    getChildren: function ()
	    {
	        return this.list;
	    },

	    shutdown: function ()
	    {
	        var list = this.list;
	        var i = list.length;

	        while (i--)
	        {
	            if (list[i])
	            {
	                list[i].destroy(true);
	            }
	        }

	        list.length = 0;

	        this.events.off(SceneEvents.SHUTDOWN, this.shutdown, this);
	    },

	    destroy: function ()
	    {
	        this.shutdown();

	        this.events.off(SceneEvents.START, this.start, this);

	        this.scene = null;
	        this.systems = null;
	        this.events = null;
	    }

	});

	PluginCache.register('DisplayList', DisplayList, 'displayList');

	DisplayList_1 = DisplayList;
	return DisplayList_1;
}

var PROCESS_QUEUE_ADD_EVENT;
var hasRequiredPROCESS_QUEUE_ADD_EVENT;

function requirePROCESS_QUEUE_ADD_EVENT () {
	if (hasRequiredPROCESS_QUEUE_ADD_EVENT) return PROCESS_QUEUE_ADD_EVENT;
	hasRequiredPROCESS_QUEUE_ADD_EVENT = 1;
	PROCESS_QUEUE_ADD_EVENT = 'add';
	return PROCESS_QUEUE_ADD_EVENT;
}

var PROCESS_QUEUE_REMOVE_EVENT;
var hasRequiredPROCESS_QUEUE_REMOVE_EVENT;

function requirePROCESS_QUEUE_REMOVE_EVENT () {
	if (hasRequiredPROCESS_QUEUE_REMOVE_EVENT) return PROCESS_QUEUE_REMOVE_EVENT;
	hasRequiredPROCESS_QUEUE_REMOVE_EVENT = 1;
	PROCESS_QUEUE_REMOVE_EVENT = 'remove';
	return PROCESS_QUEUE_REMOVE_EVENT;
}

var events$7;
var hasRequiredEvents$7;

function requireEvents$7 () {
	if (hasRequiredEvents$7) return events$7;
	hasRequiredEvents$7 = 1;
	events$7 = {

	    PROCESS_QUEUE_ADD: requirePROCESS_QUEUE_ADD_EVENT(),
	    PROCESS_QUEUE_REMOVE: requirePROCESS_QUEUE_REMOVE_EVENT()

	};
	return events$7;
}

var ProcessQueue_1;
var hasRequiredProcessQueue;

function requireProcessQueue () {
	if (hasRequiredProcessQueue) return ProcessQueue_1;
	hasRequiredProcessQueue = 1;
	var Class = requireClass();
	var EventEmitter = requireEventemitter3();
	var Events = requireEvents$7();

	var ProcessQueue = new Class({

	    Extends: EventEmitter,

	    initialize:

	    function ProcessQueue ()
	    {
	        EventEmitter.call(this);

	        this._pending = [];

	        this._active = [];

	        this._destroy = [];

	        this._toProcess = 0;

	        this.checkQueue = false;
	    },

	    isActive: function (item)
	    {
	        return (this._active.indexOf(item) > -1);
	    },

	    isPending: function (item)
	    {
	        return (this._toProcess > 0 && this._pending.indexOf(item) > -1);
	    },

	    isDestroying: function (item)
	    {
	        return (this._destroy.indexOf(item) > -1);
	    },

	    add: function (item)
	    {

	        if (this.checkQueue && (this.isActive(item) && !this.isDestroying(item)) || this.isPending(item))
	        {
	            return item;
	        }

	        this._pending.push(item);

	        this._toProcess++;

	        return item;
	    },

	    remove: function (item)
	    {

	        if (this.isPending(item))
	        {
	            var pending = this._pending;

	            var idx = pending.indexOf(item);

	            if (idx !== -1)
	            {

	                pending.splice(idx, 1);
	            }
	        }
	        else if (this.isActive(item))
	        {

	            this._destroy.push(item);

	            this._toProcess++;
	        }

	        return item;
	    },

	    removeAll: function ()
	    {
	        var list = this._active;
	        var destroy = this._destroy;
	        var i = list.length;

	        while (i--)
	        {
	            destroy.push(list[i]);

	            this._toProcess++;
	        }

	        return this;
	    },

	    update: function ()
	    {
	        if (this._toProcess === 0)
	        {

	            return this._active;
	        }

	        var list = this._destroy;
	        var active = this._active;
	        var i;
	        var item;

	        for (i = 0; i < list.length; i++)
	        {
	            item = list[i];

	            var idx = active.indexOf(item);

	            if (idx !== -1)
	            {
	                active.splice(idx, 1);

	                this.emit(Events.PROCESS_QUEUE_REMOVE, item);
	            }
	        }

	        list.length = 0;

	        list = this._pending;

	        for (i = 0; i < list.length; i++)
	        {
	            item = list[i];

	            if (!this.checkQueue || (this.checkQueue && active.indexOf(item) === -1))
	            {
	                active.push(item);

	                this.emit(Events.PROCESS_QUEUE_ADD, item);
	            }
	        }

	        list.length = 0;

	        this._toProcess = 0;

	        return active;
	    },

	    getActive: function ()
	    {
	        return this._active;
	    },

	    length: {

	        get: function ()
	        {
	            return this._active.length;
	        }

	    },

	    destroy: function ()
	    {
	        this._toProcess = 0;

	        this._pending = [];
	        this._active = [];
	        this._destroy = [];
	    }

	});

	ProcessQueue_1 = ProcessQueue;
	return ProcessQueue_1;
}

var UpdateList_1;
var hasRequiredUpdateList;

function requireUpdateList () {
	if (hasRequiredUpdateList) return UpdateList_1;
	hasRequiredUpdateList = 1;
	var Class = requireClass();
	var ProcessQueue = requireProcessQueue();
	var PluginCache = requirePluginCache();
	var SceneEvents = requireEvents$l();

	var UpdateList = new Class({

	    Extends: ProcessQueue,

	    initialize:

	    function UpdateList (scene)
	    {
	        ProcessQueue.call(this);

	        this.checkQueue = true;

	        this.scene = scene;

	        this.systems = scene.sys;

	        scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
	        scene.sys.events.on(SceneEvents.START, this.start, this);
	    },

	    boot: function ()
	    {
	        this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);
	    },

	    start: function ()
	    {
	        var eventEmitter = this.systems.events;

	        eventEmitter.on(SceneEvents.PRE_UPDATE, this.update, this);
	        eventEmitter.on(SceneEvents.UPDATE, this.sceneUpdate, this);
	        eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);
	    },

	    sceneUpdate: function (time, delta)
	    {
	        var list = this._active;
	        var length = list.length;

	        for (var i = 0; i < length; i++)
	        {
	            var gameObject = list[i];

	            if (gameObject.active)
	            {
	                gameObject.preUpdate.call(gameObject, time, delta);
	            }
	        }
	    },

	    shutdown: function ()
	    {
	        var i = this._active.length;

	        while (i--)
	        {
	            this._active[i].destroy(true);
	        }

	        i = this._pending.length;

	        while (i--)
	        {
	            this._pending[i].destroy(true);
	        }

	        i = this._destroy.length;

	        while (i--)
	        {
	            this._destroy[i].destroy(true);
	        }

	        this._toProcess = 0;

	        this._pending = [];
	        this._active = [];
	        this._destroy = [];

	        this.removeAllListeners();

	        var eventEmitter = this.systems.events;

	        eventEmitter.off(SceneEvents.PRE_UPDATE, this.update, this);
	        eventEmitter.off(SceneEvents.UPDATE, this.sceneUpdate, this);
	        eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);
	    },

	    destroy: function ()
	    {
	        this.shutdown();

	        this.systems.events.off(SceneEvents.START, this.start, this);

	        this.scene = null;
	        this.systems = null;
	    }

	});

	PluginCache.register('UpdateList', UpdateList, 'updateList');

	UpdateList_1 = UpdateList;
	return UpdateList_1;
}

var GetCalcMatrix_1;
var hasRequiredGetCalcMatrix;

function requireGetCalcMatrix () {
	if (hasRequiredGetCalcMatrix) return GetCalcMatrix_1;
	hasRequiredGetCalcMatrix = 1;
	var TransformMatrix = requireTransformMatrix();

	var tempMatrix1 = new TransformMatrix();
	var tempMatrix2 = new TransformMatrix();
	var tempMatrix3 = new TransformMatrix();

	var result = { camera: tempMatrix1, sprite: tempMatrix2, calc: tempMatrix3 };

	var GetCalcMatrix = function (src, camera, parentMatrix)
	{
	    var camMatrix = tempMatrix1;
	    var spriteMatrix = tempMatrix2;
	    var calcMatrix = tempMatrix3;

	    spriteMatrix.applyITRS(src.x, src.y, src.rotation, src.scaleX, src.scaleY);

	    camMatrix.copyFrom(camera.matrix);

	    if (parentMatrix)
	    {

	        camMatrix.multiplyWithOffset(parentMatrix, -camera.scrollX * src.scrollFactorX, -camera.scrollY * src.scrollFactorY);

	        spriteMatrix.e = src.x;
	        spriteMatrix.f = src.y;
	    }
	    else
	    {
	        spriteMatrix.e -= camera.scrollX * src.scrollFactorX;
	        spriteMatrix.f -= camera.scrollY * src.scrollFactorY;
	    }

	    camMatrix.multiply(spriteMatrix, calcMatrix);

	    return result;
	};

	GetCalcMatrix_1 = GetCalcMatrix;
	return GetCalcMatrix_1;
}

var GetAdvancedValue_1;
var hasRequiredGetAdvancedValue;

function requireGetAdvancedValue () {
	if (hasRequiredGetAdvancedValue) return GetAdvancedValue_1;
	hasRequiredGetAdvancedValue = 1;
	var MATH = requireMath();
	var GetValue = requireGetValue();

	var GetAdvancedValue = function (source, key, defaultValue)
	{
	    var value = GetValue(source, key, null);

	    if (value === null)
	    {
	        return defaultValue;
	    }
	    else if (Array.isArray(value))
	    {
	        return MATH.RND.pick(value);
	    }
	    else if (typeof value === 'object')
	    {
	        if (value.hasOwnProperty('randInt'))
	        {
	            return MATH.RND.integerInRange(value.randInt[0], value.randInt[1]);
	        }
	        else if (value.hasOwnProperty('randFloat'))
	        {
	            return MATH.RND.realInRange(value.randFloat[0], value.randFloat[1]);
	        }
	    }
	    else if (typeof value === 'function')
	    {
	        return value(key);
	    }

	    return value;
	};

	GetAdvancedValue_1 = GetAdvancedValue;
	return GetAdvancedValue_1;
}

var BuildGameObject_1;
var hasRequiredBuildGameObject;

function requireBuildGameObject () {
	if (hasRequiredBuildGameObject) return BuildGameObject_1;
	hasRequiredBuildGameObject = 1;
	var BlendModes = requireBlendModes();
	var GetAdvancedValue = requireGetAdvancedValue();

	var BuildGameObject = function (scene, gameObject, config)
	{

	    gameObject.x = GetAdvancedValue(config, 'x', 0);
	    gameObject.y = GetAdvancedValue(config, 'y', 0);
	    gameObject.depth = GetAdvancedValue(config, 'depth', 0);

	    gameObject.flipX = GetAdvancedValue(config, 'flipX', false);
	    gameObject.flipY = GetAdvancedValue(config, 'flipY', false);

	    var scale = GetAdvancedValue(config, 'scale', null);

	    if (typeof scale === 'number')
	    {
	        gameObject.setScale(scale);
	    }
	    else if (scale !== null)
	    {
	        gameObject.scaleX = GetAdvancedValue(scale, 'x', 1);
	        gameObject.scaleY = GetAdvancedValue(scale, 'y', 1);
	    }

	    var scrollFactor = GetAdvancedValue(config, 'scrollFactor', null);

	    if (typeof scrollFactor === 'number')
	    {
	        gameObject.setScrollFactor(scrollFactor);
	    }
	    else if (scrollFactor !== null)
	    {
	        gameObject.scrollFactorX = GetAdvancedValue(scrollFactor, 'x', 1);
	        gameObject.scrollFactorY = GetAdvancedValue(scrollFactor, 'y', 1);
	    }

	    gameObject.rotation = GetAdvancedValue(config, 'rotation', 0);

	    var angle = GetAdvancedValue(config, 'angle', null);

	    if (angle !== null)
	    {
	        gameObject.angle = angle;
	    }

	    gameObject.alpha = GetAdvancedValue(config, 'alpha', 1);

	    var origin = GetAdvancedValue(config, 'origin', null);

	    if (typeof origin === 'number')
	    {
	        gameObject.setOrigin(origin);
	    }
	    else if (origin !== null)
	    {
	        var ox = GetAdvancedValue(origin, 'x', 0.5);
	        var oy = GetAdvancedValue(origin, 'y', 0.5);

	        gameObject.setOrigin(ox, oy);
	    }

	    gameObject.blendMode = GetAdvancedValue(config, 'blendMode', BlendModes.NORMAL);

	    gameObject.visible = GetAdvancedValue(config, 'visible', true);

	    var add = GetAdvancedValue(config, 'add', true);

	    if (add)
	    {
	        scene.sys.displayList.add(gameObject);
	    }

	    if (gameObject.preUpdate)
	    {
	        scene.sys.updateList.add(gameObject);
	    }

	    return gameObject;
	};

	BuildGameObject_1 = BuildGameObject;
	return BuildGameObject_1;
}

var BuildGameObjectAnimation_1;
var hasRequiredBuildGameObjectAnimation;

function requireBuildGameObjectAnimation () {
	if (hasRequiredBuildGameObjectAnimation) return BuildGameObjectAnimation_1;
	hasRequiredBuildGameObjectAnimation = 1;
	var GetAdvancedValue = requireGetAdvancedValue();

	var BuildGameObjectAnimation = function (sprite, config)
	{
	    var animConfig = GetAdvancedValue(config, 'anims', null);

	    if (animConfig === null)
	    {
	        return sprite;
	    }

	    if (typeof animConfig === 'string')
	    {

	        sprite.anims.play(animConfig);
	    }
	    else if (typeof animConfig === 'object')
	    {

	        var anims = sprite.anims;

	        var key = GetAdvancedValue(animConfig, 'key', undefined);

	        if (key)
	        {
	            var startFrame = GetAdvancedValue(animConfig, 'startFrame', undefined);

	            var delay = GetAdvancedValue(animConfig, 'delay', 0);
	            var repeat = GetAdvancedValue(animConfig, 'repeat', 0);
	            var repeatDelay = GetAdvancedValue(animConfig, 'repeatDelay', 0);
	            var yoyo = GetAdvancedValue(animConfig, 'yoyo', false);

	            var play = GetAdvancedValue(animConfig, 'play', false);
	            var delayedPlay = GetAdvancedValue(animConfig, 'delayedPlay', 0);

	            var playConfig = {
	                key: key,
	                delay: delay,
	                repeat: repeat,
	                repeatDelay: repeatDelay,
	                yoyo: yoyo,
	                startFrame: startFrame
	            };

	            if (play)
	            {
	                anims.play(playConfig);
	            }
	            else if (delayedPlay > 0)
	            {
	                anims.playAfterDelay(playConfig, delayedPlay);
	            }
	            else
	            {
	                anims.load(playConfig);
	            }
	        }
	    }

	    return sprite;
	};

	BuildGameObjectAnimation_1 = BuildGameObjectAnimation;
	return BuildGameObjectAnimation_1;
}

var GetBitmapTextSize_1;
var hasRequiredGetBitmapTextSize;

function requireGetBitmapTextSize () {
	if (hasRequiredGetBitmapTextSize) return GetBitmapTextSize_1;
	hasRequiredGetBitmapTextSize = 1;
	var GetBitmapTextSize = function (src, round, updateOrigin, out)
	{
	    if (updateOrigin === undefined) { updateOrigin = false; }

	    if (out === undefined)
	    {
	        out = {
	            local: {
	                x: 0,
	                y: 0,
	                width: 0,
	                height: 0
	            },
	            global: {
	                x: 0,
	                y: 0,
	                width: 0,
	                height: 0
	            },
	            lines: {
	                shortest: 0,
	                longest: 0,
	                lengths: null,
	                height: 0
	            },
	            wrappedText: '',
	            words: [],
	            characters: [],
	            scaleX: 0,
	            scaleY: 0
	        };

	        return out;
	    }

	    var text = src.text;
	    var textLength = text.length;
	    var maxWidth = src.maxWidth;
	    var wordWrapCharCode = src.wordWrapCharCode;

	    var bx = Number.MAX_VALUE;
	    var by = Number.MAX_VALUE;
	    var bw = 0;
	    var bh = 0;

	    var chars = src.fontData.chars;
	    var lineHeight = src.fontData.lineHeight;
	    var letterSpacing = src.letterSpacing;
	    var lineSpacing = src.lineSpacing;

	    var xAdvance = 0;
	    var yAdvance = 0;

	    var charCode = 0;

	    var glyph = null;

	    var align = src._align;

	    var x = 0;
	    var y = 0;

	    var scale = (src.fontSize / src.fontData.size);
	    var sx = scale * src.scaleX;
	    var sy = scale * src.scaleY;

	    var lastGlyph = null;
	    var lastCharCode = 0;
	    var lineWidths = [];
	    var shortestLine = Number.MAX_VALUE;
	    var longestLine = 0;
	    var currentLine = 0;
	    var currentLineWidth = 0;

	    var i;
	    var j;
	    var lines;
	    var words = [];
	    var characters = [];
	    var current = null;

	    var measureTextWidth = function (text, fontData)
	    {
	        var width = 0;

	        for (var i = 0; i < text.length; i++)
	        {
	            var charCode = text.charCodeAt(i);
	            var glyph = fontData.chars[charCode];

	            if (glyph)
	            {
	                width += glyph.xAdvance;
	            }
	        }

	        return width * sx;
	    };

	    if (maxWidth > 0)
	    {

	        lines = text.split('\n');
	        var wrappedLines = [];

	        for (i = 0; i < lines.length; i++)
	        {
	            var line = lines[i];
	            var word = '';
	            var wrappedLine = '';
	            var lineToCheck = '';
	            var lineWithWord = '';

	            for (j = 0; j < line.length; j++)
	            {
	                charCode = line.charCodeAt(j);

	                word += line[j];

	                if (charCode === wordWrapCharCode || j === line.length - 1)
	                {
	                    lineWithWord = lineToCheck + word;

	                    var textWidth = measureTextWidth(lineWithWord, src.fontData);

	                    if (textWidth <= maxWidth)
	                    {
	                        lineToCheck = lineWithWord;
	                    }
	                    else
	                    {

	                        wrappedLine = wrappedLine.slice(0, -1);
	                        wrappedLine += (wrappedLine ? '\n' : '') + lineToCheck;
	                        lineToCheck = word;
	                    }

	                    word = '';
	                }
	            }

	            wrappedLine = wrappedLine.slice(0, -1);
	            wrappedLine += (wrappedLine ? '\n' : '') + lineToCheck;
	            wrappedLines.push(wrappedLine);
	        }

	        text = wrappedLines.join('\n');

	        out.wrappedText = text;

	        textLength = text.length;
	    }

	    var charIndex = 0;

	    for (i = 0; i < textLength; i++)
	    {
	        charCode = text.charCodeAt(i);

	        if (charCode === 10)
	        {
	            if (current !== null)
	            {
	                words.push({
	                    word: current.word,
	                    i: current.i,
	                    x: current.x * sx,
	                    y: current.y * sy,
	                    w: current.w * sx,
	                    h: current.h * sy
	                });

	                current = null;
	            }

	            lastGlyph = null;

	            lineWidths[currentLine] = currentLineWidth;

	            if (currentLineWidth > longestLine)
	            {
	                longestLine = currentLineWidth;
	            }

	            if (currentLineWidth < shortestLine)
	            {
	                shortestLine = currentLineWidth;
	            }

	            currentLine++;
	            currentLineWidth = 0;

	            xAdvance = 0;
	            yAdvance = (lineHeight + lineSpacing) * currentLine;

	            continue;
	        }

	        glyph = chars[charCode];

	        if (!glyph)
	        {
	            continue;
	        }

	        x = xAdvance;
	        y = yAdvance;

	        if (lastGlyph !== null)
	        {
	            var kerningOffset = glyph.kerning[lastCharCode];

	            x += (kerningOffset !== undefined) ? kerningOffset : 0;
	        }

	        if (bx > x)
	        {
	            bx = x;
	        }

	        if (by > y)
	        {
	            by = y;
	        }

	        var gw = x + glyph.xAdvance;
	        var gh = y + lineHeight;

	        if (bw < gw)
	        {
	            bw = gw;
	        }

	        if (bh < gh)
	        {
	            bh = gh;
	        }

	        var charWidth = glyph.xOffset + glyph.xAdvance + ((kerningOffset !== undefined) ? kerningOffset : 0);

	        if (charCode === wordWrapCharCode)
	        {
	            if (current !== null)
	            {
	                words.push({
	                    word: current.word,
	                    i: current.i,
	                    x: current.x * sx,
	                    y: current.y * sy,
	                    w: current.w * sx,
	                    h: current.h * sy
	                });

	                current = null;
	            }
	        }
	        else
	        {
	            if (current === null)
	            {

	                current = { word: '', i: charIndex, x: xAdvance, y: yAdvance, w: 0, h: lineHeight };
	            }

	            current.word = current.word.concat(text[i]);
	            current.w += charWidth;
	        }

	        characters.push({
	            i: charIndex,
	            idx: i,
	            char: text[i],
	            code: charCode,
	            x: (glyph.xOffset + x) * scale,
	            y: (glyph.yOffset + yAdvance) * scale,
	            w: glyph.width * scale,
	            h: glyph.height * scale,
	            t: yAdvance * scale,
	            r: gw * scale,
	            b: lineHeight * scale,
	            line: currentLine,
	            glyph: glyph
	        });

	        xAdvance += glyph.xAdvance + letterSpacing + ((kerningOffset !== undefined) ? kerningOffset : 0);
	        lastGlyph = glyph;
	        lastCharCode = charCode;
	        currentLineWidth = gw * scale;
	        charIndex++;
	    }

	    if (current !== null)
	    {
	        words.push({
	            word: current.word,
	            i: current.i,
	            x: current.x * sx,
	            y: current.y * sy,
	            w: current.w * sx,
	            h: current.h * sy
	        });
	    }

	    lineWidths[currentLine] = currentLineWidth;

	    if (currentLineWidth > longestLine)
	    {
	        longestLine = currentLineWidth;
	    }

	    if (currentLineWidth < shortestLine)
	    {
	        shortestLine = currentLineWidth;
	    }

	    if (align > 0)
	    {
	        for (var c = 0; c < characters.length; c++)
	        {
	            var currentChar = characters[c];

	            if (align === 1)
	            {
	                var ax1 = ((longestLine - lineWidths[currentChar.line]) / 2);

	                currentChar.x += ax1;
	                currentChar.r += ax1;
	            }
	            else if (align === 2)
	            {
	                var ax2 = (longestLine - lineWidths[currentChar.line]);

	                currentChar.x += ax2;
	                currentChar.r += ax2;
	            }
	        }
	    }

	    var local = out.local;
	    var global = out.global;

	    lines = out.lines;

	    local.x = bx * scale;
	    local.y = by * scale;
	    local.width = bw * scale;
	    local.height = bh * scale;

	    global.x = (src.x - src._displayOriginX) + (bx * sx);
	    global.y = (src.y - src._displayOriginY) + (by * sy);

	    global.width = bw * sx;
	    global.height = bh * sy;

	    lines.shortest = shortestLine;
	    lines.longest = longestLine;
	    lines.lengths = lineWidths;

	    if (round)
	    {
	        local.x = Math.ceil(local.x);
	        local.y = Math.ceil(local.y);
	        local.width = Math.ceil(local.width);
	        local.height = Math.ceil(local.height);

	        global.x = Math.ceil(global.x);
	        global.y = Math.ceil(global.y);
	        global.width = Math.ceil(global.width);
	        global.height = Math.ceil(global.height);

	        lines.shortest = Math.ceil(shortestLine);
	        lines.longest = Math.ceil(longestLine);
	    }

	    if (updateOrigin)
	    {
	        src._displayOriginX = (src.originX * local.width);
	        src._displayOriginY = (src.originY * local.height);

	        global.x = src.x - (src._displayOriginX * src.scaleX);
	        global.y = src.y - (src._displayOriginY * src.scaleY);

	        if (round)
	        {
	            global.x = Math.ceil(global.x);
	            global.y = Math.ceil(global.y);
	        }
	    }

	    out.words = words;
	    out.characters = characters;
	    out.lines.height = lineHeight;
	    out.scale = scale;
	    out.scaleX = src.scaleX;
	    out.scaleY = src.scaleY;

	    return out;
	};

	GetBitmapTextSize_1 = GetBitmapTextSize;
	return GetBitmapTextSize_1;
}

var ParseXMLBitmapFont_1;
var hasRequiredParseXMLBitmapFont;

function requireParseXMLBitmapFont () {
	if (hasRequiredParseXMLBitmapFont) return ParseXMLBitmapFont_1;
	hasRequiredParseXMLBitmapFont = 1;
	function getValue (node, attribute)
	{
	    return parseInt(node.getAttribute(attribute), 10);
	}

	var ParseXMLBitmapFont = function (xml, frame, xSpacing, ySpacing, texture)
	{
	    if (xSpacing === undefined) { xSpacing = 0; }
	    if (ySpacing === undefined) { ySpacing = 0; }

	    var textureX = frame.cutX;
	    var textureY = frame.cutY;
	    var textureWidth = frame.source.width;
	    var textureHeight = frame.source.height;
	    var sourceIndex = frame.sourceIndex;

	    var data = {};
	    var info = xml.getElementsByTagName('info')[0];
	    var common = xml.getElementsByTagName('common')[0];

	    data.font = info.getAttribute('face');
	    data.size = getValue(info, 'size');
	    data.lineHeight = getValue(common, 'lineHeight') + ySpacing;
	    data.chars = {};

	    var letters = xml.getElementsByTagName('char');

	    var adjustForTrim = (frame !== undefined && frame.trimmed);

	    if (adjustForTrim)
	    {
	        var top = frame.height;
	        var left = frame.width;
	    }

	    for (var i = 0; i < letters.length; i++)
	    {
	        var node = letters[i];

	        var charCode = getValue(node, 'id');
	        var letter = String.fromCharCode(charCode);
	        var gx = getValue(node, 'x');
	        var gy = getValue(node, 'y');
	        var gw = getValue(node, 'width');
	        var gh = getValue(node, 'height');

	        if (adjustForTrim)
	        {
	            if (gx < left)
	            {
	                left = gx;
	            }

	            if (gy < top)
	            {
	                top = gy;
	            }
	        }

	        if (adjustForTrim && top !== 0 && left !== 0)
	        {

	            gx -= frame.x;
	            gy -= frame.y;
	        }

	        var u0 = (textureX + gx) / textureWidth;
	        var v0 = (textureY + gy) / textureHeight;
	        var u1 = (textureX + gx + gw) / textureWidth;
	        var v1 = (textureY + gy + gh) / textureHeight;

	        data.chars[charCode] =
	        {
	            x: gx,
	            y: gy,
	            width: gw,
	            height: gh,
	            centerX: Math.floor(gw / 2),
	            centerY: Math.floor(gh / 2),
	            xOffset: getValue(node, 'xoffset'),
	            yOffset: getValue(node, 'yoffset'),
	            xAdvance: getValue(node, 'xadvance') + xSpacing,
	            data: {},
	            kerning: {},
	            u0: u0,
	            v0: v0,
	            u1: u1,
	            v1: v1
	        };

	        if (texture && gw !== 0 && gh !== 0)
	        {
	            var charFrame = texture.add(letter, sourceIndex, gx, gy, gw, gh);

	            if (charFrame)
	            {
	                charFrame.setUVs(gw, gh, u0, v0, u1, v1);
	            }
	        }
	    }

	    var kernings = xml.getElementsByTagName('kerning');

	    for (i = 0; i < kernings.length; i++)
	    {
	        var kern = kernings[i];

	        var first = getValue(kern, 'first');
	        var second = getValue(kern, 'second');
	        var amount = getValue(kern, 'amount');

	        data.chars[second].kerning[first] = amount;
	    }

	    return data;
	};

	ParseXMLBitmapFont_1 = ParseXMLBitmapFont;
	return ParseXMLBitmapFont_1;
}

var ParseFromAtlas_1;
var hasRequiredParseFromAtlas;

function requireParseFromAtlas () {
	if (hasRequiredParseFromAtlas) return ParseFromAtlas_1;
	hasRequiredParseFromAtlas = 1;
	var ParseXMLBitmapFont = requireParseXMLBitmapFont();

	var ParseFromAtlas = function (scene, fontName, textureKey, frameKey, xmlKey, xSpacing, ySpacing)
	{
	    var texture = scene.sys.textures.get(textureKey);
	    var frame = texture.get(frameKey);
	    var xml = scene.sys.cache.xml.get(xmlKey);

	    if (frame && xml)
	    {
	        var data = ParseXMLBitmapFont(xml, frame, xSpacing, ySpacing, texture);

	        scene.sys.cache.bitmapFont.add(fontName, { data: data, texture: textureKey, frame: frameKey, fromAtlas: true });

	        return true;
	    }
	    else
	    {
	        return false;
	    }
	};

	ParseFromAtlas_1 = ParseFromAtlas;
	return ParseFromAtlas_1;
}

var BatchChar_1;
var hasRequiredBatchChar;

function requireBatchChar () {
	if (hasRequiredBatchChar) return BatchChar_1;
	hasRequiredBatchChar = 1;
	var BatchChar = function (pipeline, src, char, glyph, offsetX, offsetY, calcMatrix, roundPixels, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, textureUnit)
	{
	    var x = (char.x - src.displayOriginX) + offsetX;
	    var y = (char.y - src.displayOriginY) + offsetY;

	    var xw = x + char.w;
	    var yh = y + char.h;

	    var a = calcMatrix.a;
	    var b = calcMatrix.b;
	    var c = calcMatrix.c;
	    var d = calcMatrix.d;
	    var e = calcMatrix.e;
	    var f = calcMatrix.f;

	    var tx0 = x * a + y * c + e;
	    var ty0 = x * b + y * d + f;

	    var tx1 = x * a + yh * c + e;
	    var ty1 = x * b + yh * d + f;

	    var tx2 = xw * a + yh * c + e;
	    var ty2 = xw * b + yh * d + f;

	    var tx3 = xw * a + y * c + e;
	    var ty3 = xw * b + y * d + f;

	    if (roundPixels)
	    {
	        tx0 = Math.round(tx0);
	        ty0 = Math.round(ty0);

	        tx1 = Math.round(tx1);
	        ty1 = Math.round(ty1);

	        tx2 = Math.round(tx2);
	        ty2 = Math.round(ty2);

	        tx3 = Math.round(tx3);
	        ty3 = Math.round(ty3);
	    }

	    pipeline.batchQuad(src, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, glyph.u0, glyph.v0, glyph.u1, glyph.v1, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, textureUnit);
	};

	BatchChar_1 = BatchChar;
	return BatchChar_1;
}

var BitmapTextWebGLRenderer_1;
var hasRequiredBitmapTextWebGLRenderer;

function requireBitmapTextWebGLRenderer () {
	if (hasRequiredBitmapTextWebGLRenderer) return BitmapTextWebGLRenderer_1;
	hasRequiredBitmapTextWebGLRenderer = 1;
	var BatchChar = requireBatchChar();
	var GetCalcMatrix = requireGetCalcMatrix();
	var Utils = requireUtils$1();

	var BitmapTextWebGLRenderer = function (renderer, src, camera, parentMatrix)
	{
	    var text = src._text;
	    var textLength = text.length;

	    if (textLength === 0)
	    {
	        return;
	    }

	    camera.addToRenderList(src);

	    var pipeline = renderer.pipelines.set(src.pipeline, src);

	    var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;

	    renderer.pipelines.preBatch(src);

	    var roundPixels = camera.roundPixels;

	    var cameraAlpha = camera.alpha;

	    var charColors = src.charColors;

	    var tintEffect = src.tintFill;

	    var getTint = Utils.getTintAppendFloatAlpha;

	    var tintTL = getTint(src.tintTopLeft, cameraAlpha * src._alphaTL);
	    var tintTR = getTint(src.tintTopRight, cameraAlpha * src._alphaTR);
	    var tintBL = getTint(src.tintBottomLeft, cameraAlpha * src._alphaBL);
	    var tintBR = getTint(src.tintBottomRight, cameraAlpha * src._alphaBR);

	    var texture = src.frame.glTexture;
	    var textureUnit = pipeline.setGameObject(src);

	    var bounds = src.getTextBounds(false);

	    var i;
	    var char;
	    var glyph;

	    var characters = bounds.characters;

	    var dropShadowX = src.dropShadowX;
	    var dropShadowY = src.dropShadowY;

	    var dropShadow = (dropShadowX !== 0 || dropShadowY !== 0);

	    if (dropShadow)
	    {
	        var srcShadowColor = src.dropShadowColor;
	        var srcShadowAlpha = src.dropShadowAlpha;

	        var shadowTL = getTint(srcShadowColor, cameraAlpha * srcShadowAlpha * src._alphaTL);
	        var shadowTR = getTint(srcShadowColor, cameraAlpha * srcShadowAlpha * src._alphaTR);
	        var shadowBL = getTint(srcShadowColor, cameraAlpha * srcShadowAlpha * src._alphaBL);
	        var shadowBR = getTint(srcShadowColor, cameraAlpha * srcShadowAlpha * src._alphaBR);

	        for (i = 0; i < characters.length; i++)
	        {
	            char = characters[i];
	            glyph = char.glyph;

	            if (char.code === 32 || glyph.width === 0 || glyph.height === 0)
	            {
	                continue;
	            }

	            BatchChar(pipeline, src, char, glyph, dropShadowX, dropShadowY, calcMatrix, roundPixels, shadowTL, shadowTR, shadowBL, shadowBR, 1, texture, textureUnit);
	        }
	    }

	    for (i = 0; i < characters.length; i++)
	    {
	        char = characters[i];
	        glyph = char.glyph;

	        if (char.code === 32 || glyph.width === 0 || glyph.height === 0)
	        {
	            continue;
	        }

	        if (pipeline.shouldFlush(6))
	        {
	            pipeline.flush();
	            textureUnit = pipeline.setGameObject(src);
	        }

	        if (charColors[char.i])
	        {
	            var color = charColors[char.i];

	            var charTintEffect = color.tintEffect;
	            var charTintTL = getTint(color.tintTL, cameraAlpha * src._alphaTL);
	            var charTintTR = getTint(color.tintTR, cameraAlpha * src._alphaTR);
	            var charTintBL = getTint(color.tintBL, cameraAlpha * src._alphaBL);
	            var charTintBR = getTint(color.tintBR, cameraAlpha * src._alphaBR);

	            BatchChar(pipeline, src, char, glyph, 0, 0, calcMatrix, roundPixels, charTintTL, charTintTR, charTintBL, charTintBR, charTintEffect, texture, textureUnit);
	        }
	        else
	        {
	            BatchChar(pipeline, src, char, glyph, 0, 0, calcMatrix, roundPixels, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, textureUnit);
	        }

	    }

	    renderer.pipelines.postBatch(src);
	};

	BitmapTextWebGLRenderer_1 = BitmapTextWebGLRenderer;
	return BitmapTextWebGLRenderer_1;
}

var SetTransform_1;
var hasRequiredSetTransform;

function requireSetTransform () {
	if (hasRequiredSetTransform) return SetTransform_1;
	hasRequiredSetTransform = 1;
	var GetCalcMatrix = requireGetCalcMatrix();

	var SetTransform = function (renderer, ctx, src, camera, parentMatrix)
	{
	    var alpha = camera.alpha * src.alpha;

	    if (alpha <= 0)
	    {

	        return false;
	    }

	    var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;

	    ctx.globalCompositeOperation = renderer.blendModes[src.blendMode];

	    ctx.globalAlpha = alpha;

	    ctx.save();

	    calcMatrix.setToContext(ctx);

	    ctx.imageSmoothingEnabled = src.frame ? !src.frame.source.scaleMode : renderer.antialias;

	    return true;
	};

	SetTransform_1 = SetTransform;
	return SetTransform_1;
}

var BitmapTextCanvasRenderer_1;
var hasRequiredBitmapTextCanvasRenderer;

function requireBitmapTextCanvasRenderer () {
	if (hasRequiredBitmapTextCanvasRenderer) return BitmapTextCanvasRenderer_1;
	hasRequiredBitmapTextCanvasRenderer = 1;
	var SetTransform = requireSetTransform();

	var BitmapTextCanvasRenderer = function (renderer, src, camera, parentMatrix)
	{
	    var text = src._text;
	    var textLength = text.length;

	    var ctx = renderer.currentContext;

	    if (textLength === 0 || !SetTransform(renderer, ctx, src, camera, parentMatrix))
	    {
	        return;
	    }

	    camera.addToRenderList(src);

	    var textureFrame = src.fromAtlas
	        ? src.frame
	        : src.texture.frames['__BASE'];

	    var chars = src.fontData.chars;
	    var lineHeight = src.fontData.lineHeight;
	    var letterSpacing = src._letterSpacing;
	    var lineSpacing = src._lineSpacing;

	    var xAdvance = 0;
	    var yAdvance = 0;

	    var charCode = 0;

	    var glyph = null;
	    var glyphX = 0;
	    var glyphY = 0;
	    var glyphW = 0;
	    var glyphH = 0;

	    var x = 0;
	    var y = 0;

	    var lastGlyph = null;
	    var lastCharCode = 0;

	    var image = textureFrame.source.image;

	    var textureX = textureFrame.cutX;
	    var textureY = textureFrame.cutY;

	    var scale = (src._fontSize / src.fontData.size);

	    var align = src._align;
	    var currentLine = 0;
	    var lineOffsetX = 0;

	    var bounds = src.getTextBounds(false);

	    if (src.maxWidth > 0)
	    {
	        text = bounds.wrappedText;
	        textLength = text.length;
	    }

	    var lineData = src._bounds.lines;

	    if (align === 1)
	    {
	        lineOffsetX = (lineData.longest - lineData.lengths[0]) / 2;
	    }
	    else if (align === 2)
	    {
	        lineOffsetX = (lineData.longest - lineData.lengths[0]);
	    }

	    ctx.translate(-src.displayOriginX, -src.displayOriginY);

	    var roundPixels = camera.roundPixels;

	    for (var i = 0; i < textLength; i++)
	    {
	        charCode = text.charCodeAt(i);

	        if (charCode === 10)
	        {
	            currentLine++;

	            if (align === 1)
	            {
	                lineOffsetX = (lineData.longest - lineData.lengths[currentLine]) / 2;
	            }
	            else if (align === 2)
	            {
	                lineOffsetX = (lineData.longest - lineData.lengths[currentLine]);
	            }

	            xAdvance = 0;
	            yAdvance += lineHeight + lineSpacing;

	            lastGlyph = null;

	            continue;
	        }

	        glyph = chars[charCode];

	        if (!glyph)
	        {
	            continue;
	        }

	        glyphX = textureX + glyph.x;
	        glyphY = textureY + glyph.y;

	        glyphW = glyph.width;
	        glyphH = glyph.height;

	        x = glyph.xOffset + xAdvance;
	        y = glyph.yOffset + yAdvance;

	        if (lastGlyph !== null)
	        {
	            var kerningOffset = glyph.kerning[lastCharCode];
	            x += (kerningOffset !== undefined) ? kerningOffset : 0;
	        }

	        x *= scale;
	        y *= scale;

	        x += lineOffsetX;

	        xAdvance += glyph.xAdvance + letterSpacing + ((kerningOffset !== undefined) ? kerningOffset : 0);
	        lastGlyph = glyph;
	        lastCharCode = charCode;

	        if (glyphW === 0 || glyphH === 0 || charCode === 32)
	        {
	            continue;
	        }

	        if (roundPixels)
	        {
	            x = Math.round(x);
	            y = Math.round(y);
	        }

	        ctx.save();

	        ctx.translate(x, y);

	        ctx.scale(scale, scale);

	        ctx.drawImage(image, glyphX, glyphY, glyphW, glyphH, 0, 0, glyphW, glyphH);

	        ctx.restore();
	    }

	    ctx.restore();
	};

	BitmapTextCanvasRenderer_1 = BitmapTextCanvasRenderer;
	return BitmapTextCanvasRenderer_1;
}

var BitmapTextRender;
var hasRequiredBitmapTextRender;

function requireBitmapTextRender () {
	if (hasRequiredBitmapTextRender) return BitmapTextRender;
	hasRequiredBitmapTextRender = 1;
	var NOOP = requireNOOP();
	var renderWebGL = NOOP;
	var renderCanvas = NOOP;

	if (typeof WEBGL_RENDERER)
	{
	    renderWebGL = requireBitmapTextWebGLRenderer();
	}

	if (typeof CANVAS_RENDERER)
	{
	    renderCanvas = requireBitmapTextCanvasRenderer();
	}

	BitmapTextRender = {

	    renderWebGL: renderWebGL,
	    renderCanvas: renderCanvas

	};
	return BitmapTextRender;
}

var BitmapText_1;
var hasRequiredBitmapText;

function requireBitmapText () {
	if (hasRequiredBitmapText) return BitmapText_1;
	hasRequiredBitmapText = 1;
	var Class = requireClass();
	var Clamp = requireClamp();
	var Components = requireComponents$2();
	var GameObject = requireGameObject();
	var GetBitmapTextSize = requireGetBitmapTextSize();
	var ParseFromAtlas = requireParseFromAtlas();
	var ParseXMLBitmapFont = requireParseXMLBitmapFont();
	var Rectangle = requireRectangle$2();
	var Render = requireBitmapTextRender();

	var BitmapText = new Class({

	    Extends: GameObject,

	    Mixins: [
	        Components.Alpha,
	        Components.BlendMode,
	        Components.Depth,
	        Components.GetBounds,
	        Components.Mask,
	        Components.Origin,
	        Components.Pipeline,
	        Components.PostPipeline,
	        Components.ScrollFactor,
	        Components.Texture,
	        Components.Tint,
	        Components.Transform,
	        Components.Visible,
	        Render
	    ],

	    initialize:

	    function BitmapText (scene, x, y, font, text, size, align)
	    {
	        if (text === undefined) { text = ''; }
	        if (align === undefined) { align = 0; }

	        GameObject.call(this, scene, 'BitmapText');

	        this.font = font;

	        var entry = this.scene.sys.cache.bitmapFont.get(font);

	        if (!entry)
	        {
	            throw new Error('Invalid BitmapText key: ' + font);
	        }

	        this.fontData = entry.data;

	        this._text = '';

	        this._fontSize = size || this.fontData.size;

	        this._letterSpacing = 0;

	        this._lineSpacing = 0;

	        this._align = align;

	        this._bounds = GetBitmapTextSize();

	        this._dirty = true;

	        this._maxWidth = 0;

	        this.wordWrapCharCode = 32;

	        this.charColors = [];

	        this.dropShadowX = 0;

	        this.dropShadowY = 0;

	        this.dropShadowColor = 0x000000;

	        this.dropShadowAlpha = 0.5;

	        this.fromAtlas = entry.fromAtlas;

	        this.setTexture(entry.texture, entry.frame);
	        this.setPosition(x, y);
	        this.setOrigin(0, 0);
	        this.initPipeline();
	        this.initPostPipeline();

	        this.setText(text);
	    },

	    setLeftAlign: function ()
	    {
	        this._align = BitmapText.ALIGN_LEFT;

	        this._dirty = true;

	        return this;
	    },

	    setCenterAlign: function ()
	    {
	        this._align = BitmapText.ALIGN_CENTER;

	        this._dirty = true;

	        return this;
	    },

	    setRightAlign: function ()
	    {
	        this._align = BitmapText.ALIGN_RIGHT;

	        this._dirty = true;

	        return this;
	    },

	    setFontSize: function (size)
	    {
	        this._fontSize = size;

	        this._dirty = true;

	        return this;
	    },

	    setLetterSpacing: function (spacing)
	    {
	        if (spacing === undefined) { spacing = 0; }

	        this._letterSpacing = spacing;

	        this._dirty = true;

	        return this;
	    },

	    setLineSpacing: function (spacing)
	    {
	        if (spacing === undefined) { spacing = 0; }

	        this.lineSpacing = spacing;

	        return this;
	    },

	    setText: function (value)
	    {
	        if (!value && value !== 0)
	        {
	            value = '';
	        }

	        if (Array.isArray(value))
	        {
	            value = value.join('\n');
	        }

	        if (value !== this.text)
	        {
	            this._text = value.toString();

	            this._dirty = true;

	            this.updateDisplayOrigin();
	        }

	        return this;
	    },

	    setDropShadow: function (x, y, color, alpha)
	    {
	        if (x === undefined) { x = 0; }
	        if (y === undefined) { y = 0; }
	        if (color === undefined) { color = 0x000000; }
	        if (alpha === undefined) { alpha = 0.5; }

	        this.dropShadowX = x;
	        this.dropShadowY = y;
	        this.dropShadowColor = color;
	        this.dropShadowAlpha = alpha;

	        return this;
	    },

	    setCharacterTint: function (start, length, tintFill, topLeft, topRight, bottomLeft, bottomRight)
	    {
	        if (start === undefined) { start = 0; }
	        if (length === undefined) { length = 1; }
	        if (tintFill === undefined) { tintFill = false; }
	        if (topLeft === undefined) { topLeft = -1; }

	        if (topRight === undefined)
	        {
	            topRight = topLeft;
	            bottomLeft = topLeft;
	            bottomRight = topLeft;
	        }

	        var len = this.text.length;

	        if (length === -1)
	        {
	            length = len;
	        }

	        if (start < 0)
	        {
	            start = len + start;
	        }

	        start = Clamp(start, 0, len - 1);

	        var end = Clamp(start + length, start, len);

	        var charColors = this.charColors;

	        for (var i = start; i < end; i++)
	        {
	            var color = charColors[i];

	            if (topLeft === -1)
	            {
	                charColors[i] = null;
	            }
	            else
	            {
	                var tintEffect = (tintFill) ? 1 : 0;

	                if (color)
	                {
	                    color.tintEffect = tintEffect;
	                    color.tintTL = topLeft;
	                    color.tintTR = topRight;
	                    color.tintBL = bottomLeft;
	                    color.tintBR = bottomRight;
	                }
	                else
	                {
	                    charColors[i] = {
	                        tintEffect: tintEffect,
	                        tintTL: topLeft,
	                        tintTR: topRight,
	                        tintBL: bottomLeft,
	                        tintBR: bottomRight
	                    };
	                }
	            }
	        }

	        return this;
	    },

	    setWordTint: function (word, count, tintFill, topLeft, topRight, bottomLeft, bottomRight)
	    {
	        if (count === undefined) { count = 1; }

	        var bounds = this.getTextBounds();

	        var words = bounds.words;

	        var wordIsNumber = (typeof(word) === 'number');

	        var total = 0;

	        for (var i = 0; i < words.length; i++)
	        {
	            var lineword = words[i];

	            if ((wordIsNumber && i === word) || (!wordIsNumber && lineword.word === word))
	            {
	                this.setCharacterTint(lineword.i, lineword.word.length, tintFill, topLeft, topRight, bottomLeft, bottomRight);

	                total++;

	                if (total === count)
	                {
	                    return this;
	                }
	            }
	        }

	        return this;
	    },

	    getTextBounds: function (round)
	    {

	        var bounds = this._bounds;

	        if (this._dirty || round || this.scaleX !== bounds.scaleX || this.scaleY !== bounds.scaleY)
	        {
	            GetBitmapTextSize(this, round, true, bounds);

	            this._dirty = false;
	        }

	        return bounds;
	    },

	    getCharacterAt: function (x, y, camera)
	    {
	        var point = this.getLocalPoint(x, y, null, camera);

	        var bounds = this.getTextBounds();

	        var chars = bounds.characters;

	        var tempRect = new Rectangle();

	        for (var i = 0; i < chars.length; i++)
	        {
	            var char = chars[i];

	            tempRect.setTo(char.x, char.t, char.r - char.x, char.b);

	            if (tempRect.contains(point.x, point.y))
	            {
	                return char;
	            }
	        }

	        return null;
	    },

	    updateDisplayOrigin: function ()
	    {
	        this._dirty = true;

	        this.getTextBounds(false);

	        return this;
	    },

	    setFont: function (key, size, align)
	    {
	        if (size === undefined) { size = this._fontSize; }
	        if (align === undefined) { align = this._align; }

	        var entry = this.scene.sys.cache.bitmapFont.get(key);

	        if (entry)
	        {
	            this.font = key;
	            this.fontData = entry.data;
	            this._fontSize = size;
	            this._align = align;
	            this.fromAtlas = entry.fromAtlas === true;

	            this.setTexture(entry.texture, entry.frame);

	            GetBitmapTextSize(this, false, true, this._bounds);
	        }

	        return this;
	    },

	    setMaxWidth: function (value, wordWrapCharCode)
	    {
	        this._maxWidth = value;

	        this._dirty = true;

	        if (wordWrapCharCode !== undefined)
	        {
	            this.wordWrapCharCode = wordWrapCharCode;
	        }

	        return this;
	    },

	    setDisplaySize: function (displayWidth, displayHeight)
	    {
	        this.setScale(1, 1);

	        this.getTextBounds(false);

	        var scaleX = displayWidth / this.width;

	        var scaleY = displayHeight / this.height;

	        this.setScale(scaleX, scaleY);

	        return this;
	    },

	    align: {

	        set: function (value)
	        {
	            this._align = value;
	            this._dirty = true;
	        },

	        get: function ()
	        {
	            return this._align;
	        }

	    },

	    text: {

	        set: function (value)
	        {
	            this.setText(value);
	        },

	        get: function ()
	        {
	            return this._text;
	        }

	    },

	    fontSize: {

	        set: function (value)
	        {
	            this._fontSize = value;
	            this._dirty = true;
	        },

	        get: function ()
	        {
	            return this._fontSize;
	        }

	    },

	    letterSpacing: {

	        set: function (value)
	        {
	            this._letterSpacing = value;
	            this._dirty = true;
	        },

	        get: function ()
	        {
	            return this._letterSpacing;
	        }

	    },

	    lineSpacing: {

	        set: function (value)
	        {
	            this._lineSpacing = value;
	            this._dirty = true;
	        },

	        get: function ()
	        {
	            return this._lineSpacing;
	        }

	    },

	    maxWidth: {

	        set: function (value)
	        {
	            this._maxWidth = value;
	            this._dirty = true;
	        },

	        get: function ()
	        {
	            return this._maxWidth;
	        }

	    },

	    width: {

	        get: function ()
	        {
	            this.getTextBounds(false);

	            return this._bounds.global.width;
	        }

	    },

	    height: {

	        get: function ()
	        {
	            this.getTextBounds(false);

	            return this._bounds.global.height;
	        }

	    },

	    displayWidth: {

	        set: function(value)
	        {
	            this.setScaleX(1);

	            this.getTextBounds(false);

	            var scale = value / this.width;

	            this.setScaleX(scale);
	        },

	        get: function ()
	        {
	            return this.width;
	        }

	    },

	    displayHeight: {

	        set: function(value)
	        {
	            this.setScaleY(1);

	            this.getTextBounds(false);

	            var scale = value / this.height;

	            this.setScaleY(scale);
	        },

	        get: function ()
	        {
	            return this.height;
	        }

	    },

	    toJSON: function ()
	    {
	        var out = Components.ToJSON(this);

	        var data = {
	            font: this.font,
	            text: this.text,
	            fontSize: this.fontSize,
	            letterSpacing: this.letterSpacing,
	            lineSpacing: this.lineSpacing,
	            align: this.align
	        };

	        out.data = data;

	        return out;
	    },

	    preDestroy: function ()
	    {
	        this.charColors.length = 0;
	        this._bounds = null;
	        this.fontData = null;
	    }

	});

	BitmapText.ALIGN_LEFT = 0;

	BitmapText.ALIGN_CENTER = 1;

	BitmapText.ALIGN_RIGHT = 2;

	BitmapText.ParseFromAtlas = ParseFromAtlas;

	BitmapText.ParseXMLBitmapFont = ParseXMLBitmapFont;

	BitmapText_1 = BitmapText;
	return BitmapText_1;
}

var BlitterWebGLRenderer_1;
var hasRequiredBlitterWebGLRenderer;

function requireBlitterWebGLRenderer () {
	if (hasRequiredBlitterWebGLRenderer) return BlitterWebGLRenderer_1;
	hasRequiredBlitterWebGLRenderer = 1;
	var TransformMatrix = requireTransformMatrix();
	var Utils = requireUtils$1();

	var tempMatrix = new TransformMatrix();

	var BlitterWebGLRenderer = function (renderer, src, camera, parentMatrix)
	{
	    var list = src.getRenderList();
	    var alpha = camera.alpha * src.alpha;

	    if (list.length === 0 || alpha === 0)
	    {

	        return;
	    }

	    camera.addToRenderList(src);

	    var pipeline = renderer.pipelines.set(this.pipeline, src);

	    var cameraScrollX = camera.scrollX * src.scrollFactorX;
	    var cameraScrollY = camera.scrollY * src.scrollFactorY;

	    var calcMatrix = tempMatrix.copyFrom(camera.matrix);

	    if (parentMatrix)
	    {
	        calcMatrix.multiplyWithOffset(parentMatrix, -cameraScrollX, -cameraScrollY);

	        cameraScrollX = 0;
	        cameraScrollY = 0;
	    }

	    var blitterX = src.x - cameraScrollX;
	    var blitterY = src.y - cameraScrollY;
	    var prevTextureSourceIndex = -1;
	    var tintEffect = false;
	    var roundPixels = camera.roundPixels;

	    renderer.pipelines.preBatch(src);

	    for (var i = 0; i < list.length; i++)
	    {
	        var bob = list[i];
	        var frame = bob.frame;
	        var bobAlpha = bob.alpha * alpha;

	        if (bobAlpha === 0)
	        {
	            continue;
	        }

	        var width = frame.width;
	        var height = frame.height;

	        var x = blitterX + bob.x + frame.x;
	        var y = blitterY + bob.y + frame.y;

	        if (bob.flipX)
	        {
	            width *= -1;
	            x += frame.width;
	        }

	        if (bob.flipY)
	        {
	            height *= -1;
	            y += frame.height;
	        }

	        var quad = calcMatrix.setQuad(x, y, x + width, y + height, roundPixels);

	        var tint = Utils.getTintAppendFloatAlpha(bob.tint, bobAlpha);

	        if (frame.sourceIndex !== prevTextureSourceIndex)
	        {
	            var textureUnit = pipeline.setGameObject(src, frame);

	            prevTextureSourceIndex = frame.sourceIndex;
	        }

	        if (pipeline.batchQuad(src, quad[0], quad[1], quad[2], quad[3], quad[4], quad[5], quad[6], quad[7], frame.u0, frame.v0, frame.u1, frame.v1, tint, tint, tint, tint, tintEffect, frame.glTexture, textureUnit))
	        {
	            prevTextureSourceIndex = -1;
	        }
	    }

	    renderer.pipelines.postBatch(src);
	};

	BlitterWebGLRenderer_1 = BlitterWebGLRenderer;
	return BlitterWebGLRenderer_1;
}

var BlitterCanvasRenderer_1;
var hasRequiredBlitterCanvasRenderer;

function requireBlitterCanvasRenderer () {
	if (hasRequiredBlitterCanvasRenderer) return BlitterCanvasRenderer_1;
	hasRequiredBlitterCanvasRenderer = 1;
	var BlitterCanvasRenderer = function (renderer, src, camera, parentMatrix)
	{
	    var list = src.getRenderList();

	    if (list.length === 0)
	    {
	        return;
	    }

	    var ctx = renderer.currentContext;

	    var alpha = camera.alpha * src.alpha;

	    if (alpha === 0)
	    {

	        return;
	    }

	    camera.addToRenderList(src);

	    ctx.globalCompositeOperation = renderer.blendModes[src.blendMode];

	    ctx.imageSmoothingEnabled = !src.frame.source.scaleMode;

	    var cameraScrollX = src.x - camera.scrollX * src.scrollFactorX;
	    var cameraScrollY = src.y - camera.scrollY * src.scrollFactorY;

	    ctx.save();

	    if (parentMatrix)
	    {
	        parentMatrix.copyToContext(ctx);
	    }

	    var roundPixels = camera.roundPixels;

	    for (var i = 0; i < list.length; i++)
	    {
	        var bob = list[i];
	        var flip = (bob.flipX || bob.flipY);
	        var frame = bob.frame;
	        var cd = frame.canvasData;
	        var dx = frame.x;
	        var dy = frame.y;
	        var fx = 1;
	        var fy = 1;

	        var bobAlpha = bob.alpha * alpha;

	        if (bobAlpha === 0)
	        {
	            continue;
	        }

	        ctx.globalAlpha = bobAlpha;

	        if (!flip)
	        {
	            if (roundPixels)
	            {
	                dx = Math.round(dx);
	                dy = Math.round(dy);
	            }

	            if (cd.width > 0 && cd.height > 0)
	            {
	                ctx.drawImage(
	                    frame.source.image,
	                    cd.x,
	                    cd.y,
	                    cd.width,
	                    cd.height,
	                    dx + bob.x + cameraScrollX,
	                    dy + bob.y + cameraScrollY,
	                    cd.width,
	                    cd.height
	                );
	            }
	        }
	        else
	        {
	            if (bob.flipX)
	            {
	                fx = -1;
	                dx -= cd.width;
	            }

	            if (bob.flipY)
	            {
	                fy = -1;
	                dy -= cd.height;
	            }

	            if (cd.width > 0 && cd.height > 0)
	            {
	                ctx.save();
	                ctx.translate(bob.x + cameraScrollX, bob.y + cameraScrollY);
	                ctx.scale(fx, fy);
	                ctx.drawImage(frame.source.image, cd.x, cd.y, cd.width, cd.height, dx, dy, cd.width, cd.height);
	                ctx.restore();
	            }
	        }
	    }

	    ctx.restore();
	};

	BlitterCanvasRenderer_1 = BlitterCanvasRenderer;
	return BlitterCanvasRenderer_1;
}

var BlitterRender;
var hasRequiredBlitterRender;

function requireBlitterRender () {
	if (hasRequiredBlitterRender) return BlitterRender;
	hasRequiredBlitterRender = 1;
	var NOOP = requireNOOP();
	var renderWebGL = NOOP;
	var renderCanvas = NOOP;

	if (typeof WEBGL_RENDERER)
	{
	    renderWebGL = requireBlitterWebGLRenderer();
	}

	if (typeof CANVAS_RENDERER)
	{
	    renderCanvas = requireBlitterCanvasRenderer();
	}

	BlitterRender = {

	    renderWebGL: renderWebGL,
	    renderCanvas: renderCanvas

	};
	return BlitterRender;
}

var Bob_1;
var hasRequiredBob;

function requireBob () {
	if (hasRequiredBob) return Bob_1;
	hasRequiredBob = 1;
	var Class = requireClass();
	var Frame = requireFrame();

	var Bob = new Class({

	    initialize:

	    function Bob (blitter, x, y, frame, visible)
	    {

	        this.parent = blitter;

	        this.x = x;

	        this.y = y;

	        this.frame = frame;

	        this.data = {};

	        this.tint = 0xffffff;

	        this._visible = visible;

	        this._alpha = 1;

	        this.flipX = false;

	        this.flipY = false;

	        this.hasTransformComponent = true;
	    },

	    setFrame: function (frame)
	    {
	        if (frame === undefined)
	        {
	            this.frame = this.parent.frame;
	        }
	        else if (frame instanceof Frame && frame.texture === this.parent.texture)
	        {
	            this.frame = frame;
	        }
	        else
	        {
	            this.frame = this.parent.texture.get(frame);
	        }

	        return this;
	    },

	    resetFlip: function ()
	    {
	        this.flipX = false;
	        this.flipY = false;

	        return this;
	    },

	    reset: function (x, y, frame)
	    {
	        this.x = x;
	        this.y = y;

	        this.flipX = false;
	        this.flipY = false;

	        this._alpha = 1;
	        this._visible = true;

	        this.parent.dirty = true;

	        if (frame)
	        {
	            this.setFrame(frame);
	        }

	        return this;
	    },

	    setPosition: function (x, y)
	    {
	        this.x = x;
	        this.y = y;

	        return this;
	    },

	    setFlipX: function (value)
	    {
	        this.flipX = value;

	        return this;
	    },

	    setFlipY: function (value)
	    {
	        this.flipY = value;

	        return this;
	    },

	    setFlip: function (x, y)
	    {
	        this.flipX = x;
	        this.flipY = y;

	        return this;
	    },

	    setVisible: function (value)
	    {
	        this.visible = value;

	        return this;
	    },

	    setAlpha: function (value)
	    {
	        this.alpha = value;

	        return this;
	    },

	    setTint: function (value)
	    {
	        this.tint = value;

	        return this;
	    },

	    destroy: function ()
	    {
	        this.parent.dirty = true;

	        this.parent.children.remove(this);

	        this.parent = undefined;
	        this.frame = undefined;
	        this.data = undefined;
	    },

	    visible: {

	        get: function ()
	        {
	            return this._visible;
	        },

	        set: function (value)
	        {
	            this.parent.dirty |= (this._visible !== value);
	            this._visible = value;
	        }

	    },

	    alpha: {

	        get: function ()
	        {
	            return this._alpha;
	        },

	        set: function (value)
	        {
	            this.parent.dirty |= ((this._alpha > 0) !== (value > 0));
	            this._alpha = value;
	        }

	    }

	});

	Bob_1 = Bob;
	return Bob_1;
}

var Blitter_1;
var hasRequiredBlitter;

function requireBlitter () {
	if (hasRequiredBlitter) return Blitter_1;
	hasRequiredBlitter = 1;
	var BlitterRender = requireBlitterRender();
	var Bob = requireBob();
	var Class = requireClass();
	var Components = requireComponents$2();
	var Frame = requireFrame();
	var GameObject = requireGameObject();
	var List = requireList();

	var Blitter = new Class({

	    Extends: GameObject,

	    Mixins: [
	        Components.Alpha,
	        Components.BlendMode,
	        Components.Depth,
	        Components.Mask,
	        Components.Pipeline,
	        Components.PostPipeline,
	        Components.ScrollFactor,
	        Components.Size,
	        Components.Texture,
	        Components.Transform,
	        Components.Visible,
	        BlitterRender
	    ],

	    initialize:

	    function Blitter (scene, x, y, texture, frame)
	    {
	        GameObject.call(this, scene, 'Blitter');

	        this.setTexture(texture, frame);
	        this.setPosition(x, y);
	        this.initPipeline();
	        this.initPostPipeline();

	        this.children = new List();

	        this.renderList = [];

	        this.dirty = false;
	    },

	    create: function (x, y, frame, visible, index)
	    {
	        if (visible === undefined) { visible = true; }
	        if (index === undefined) { index = this.children.length; }

	        if (frame === undefined)
	        {
	            frame = this.frame;
	        }
	        else if (!(frame instanceof Frame))
	        {
	            frame = this.texture.get(frame);
	        }

	        var bob = new Bob(this, x, y, frame, visible);

	        this.children.addAt(bob, index, false);

	        this.dirty = true;

	        return bob;
	    },

	    createFromCallback: function (callback, quantity, frame, visible)
	    {
	        var bobs = this.createMultiple(quantity, frame, visible);

	        for (var i = 0; i < bobs.length; i++)
	        {
	            var bob = bobs[i];

	            callback.call(this, bob, i);
	        }

	        return bobs;
	    },

	    createMultiple: function (quantity, frame, visible)
	    {
	        if (frame === undefined) { frame = this.frame.name; }
	        if (visible === undefined) { visible = true; }

	        if (!Array.isArray(frame))
	        {
	            frame = [ frame ];
	        }

	        var bobs = [];
	        var _this = this;

	        frame.forEach(function (singleFrame)
	        {
	            for (var i = 0; i < quantity; i++)
	            {
	                bobs.push(_this.create(0, 0, singleFrame, visible));
	            }
	        });

	        return bobs;
	    },

	    childCanRender: function (child)
	    {
	        return (child.visible && child.alpha > 0);
	    },

	    getRenderList: function ()
	    {
	        if (this.dirty)
	        {
	            this.renderList = this.children.list.filter(this.childCanRender, this);
	            this.dirty = false;
	        }

	        return this.renderList;
	    },

	    clear: function ()
	    {
	        this.children.removeAll();
	        this.dirty = true;
	    },

	    preDestroy: function ()
	    {
	        this.children.destroy();

	        this.renderList = [];
	    }

	});

	Blitter_1 = Blitter;
	return Blitter_1;
}

var ContainerWebGLRenderer_1;
var hasRequiredContainerWebGLRenderer;

function requireContainerWebGLRenderer () {
	if (hasRequiredContainerWebGLRenderer) return ContainerWebGLRenderer_1;
	hasRequiredContainerWebGLRenderer = 1;
	var ContainerWebGLRenderer = function (renderer, container, camera, parentMatrix)
	{
	    camera.addToRenderList(container);

	    var children = container.list;
	    var childCount = children.length;

	    if (childCount === 0)
	    {
	        return;
	    }

	    var transformMatrix = container.localTransform;

	    if (parentMatrix)
	    {
	        transformMatrix.loadIdentity();
	        transformMatrix.multiply(parentMatrix);
	        transformMatrix.translate(container.x, container.y);
	        transformMatrix.rotate(container.rotation);
	        transformMatrix.scale(container.scaleX, container.scaleY);
	    }
	    else
	    {
	        transformMatrix.applyITRS(container.x, container.y, container.rotation, container.scaleX, container.scaleY);
	    }

	    renderer.pipelines.preBatch(container);

	    var containerHasBlendMode = (container.blendMode !== -1);

	    if (!containerHasBlendMode)
	    {

	        renderer.setBlendMode(0);
	    }

	    var alpha = container.alpha;

	    var scrollFactorX = container.scrollFactorX;
	    var scrollFactorY = container.scrollFactorY;

	    for (var i = 0; i < childCount; i++)
	    {
	        var child = children[i];

	        if (!child.willRender(camera))
	        {
	            continue;
	        }

	        var childAlphaTopLeft;
	        var childAlphaTopRight;
	        var childAlphaBottomLeft;
	        var childAlphaBottomRight;

	        if (child.alphaTopLeft !== undefined)
	        {
	            childAlphaTopLeft = child.alphaTopLeft;
	            childAlphaTopRight = child.alphaTopRight;
	            childAlphaBottomLeft = child.alphaBottomLeft;
	            childAlphaBottomRight = child.alphaBottomRight;
	        }
	        else
	        {
	            var childAlpha = child.alpha;

	            childAlphaTopLeft = childAlpha;
	            childAlphaTopRight = childAlpha;
	            childAlphaBottomLeft = childAlpha;
	            childAlphaBottomRight = childAlpha;
	        }

	        var childScrollFactorX = child.scrollFactorX;
	        var childScrollFactorY = child.scrollFactorY;

	        if (!containerHasBlendMode && child.blendMode !== renderer.currentBlendMode)
	        {

	            renderer.setBlendMode(child.blendMode);
	        }

	        var mask = child.mask;

	        if (mask)
	        {
	            mask.preRenderWebGL(renderer, child, camera);
	        }

	        var type = child.type;

	        if (type !== renderer.currentType)
	        {
	            renderer.newType = true;
	            renderer.currentType = type;
	        }

	        renderer.nextTypeMatch = (i < childCount - 1) ? (children[i + 1].type === renderer.currentType) : false;

	        child.setScrollFactor(childScrollFactorX * scrollFactorX, childScrollFactorY * scrollFactorY);

	        child.setAlpha(childAlphaTopLeft * alpha, childAlphaTopRight * alpha, childAlphaBottomLeft * alpha, childAlphaBottomRight * alpha);

	        child.renderWebGL(renderer, child, camera, transformMatrix, container);

	        child.setAlpha(childAlphaTopLeft, childAlphaTopRight, childAlphaBottomLeft, childAlphaBottomRight);

	        child.setScrollFactor(childScrollFactorX, childScrollFactorY);

	        if (mask)
	        {
	            mask.postRenderWebGL(renderer, camera);
	        }

	        renderer.newType = false;
	    }

	    renderer.pipelines.postBatch(container);
	};

	ContainerWebGLRenderer_1 = ContainerWebGLRenderer;
	return ContainerWebGLRenderer_1;
}

var ContainerCanvasRenderer_1;
var hasRequiredContainerCanvasRenderer;

function requireContainerCanvasRenderer () {
	if (hasRequiredContainerCanvasRenderer) return ContainerCanvasRenderer_1;
	hasRequiredContainerCanvasRenderer = 1;
	var ContainerCanvasRenderer = function (renderer, container, camera, parentMatrix)
	{
	    camera.addToRenderList(container);

	    var children = container.list;

	    if (children.length === 0)
	    {
	        return;
	    }

	    var transformMatrix = container.localTransform;

	    if (parentMatrix)
	    {
	        transformMatrix.loadIdentity();
	        transformMatrix.multiply(parentMatrix);
	        transformMatrix.translate(container.x, container.y);
	        transformMatrix.rotate(container.rotation);
	        transformMatrix.scale(container.scaleX, container.scaleY);
	    }
	    else
	    {
	        transformMatrix.applyITRS(container.x, container.y, container.rotation, container.scaleX, container.scaleY);
	    }

	    var containerHasBlendMode = (container.blendMode !== -1);

	    if (!containerHasBlendMode)
	    {

	        renderer.setBlendMode(0);
	    }

	    var alpha = container._alpha;
	    var scrollFactorX = container.scrollFactorX;
	    var scrollFactorY = container.scrollFactorY;

	    if (container.mask)
	    {
	        container.mask.preRenderCanvas(renderer, null, camera);
	    }

	    for (var i = 0; i < children.length; i++)
	    {
	        var child = children[i];

	        if (!child.willRender(camera))
	        {
	            continue;
	        }

	        var childAlpha = child.alpha;
	        var childScrollFactorX = child.scrollFactorX;
	        var childScrollFactorY = child.scrollFactorY;

	        if (!containerHasBlendMode && child.blendMode !== renderer.currentBlendMode)
	        {

	            renderer.setBlendMode(child.blendMode);
	        }

	        child.setScrollFactor(childScrollFactorX * scrollFactorX, childScrollFactorY * scrollFactorY);
	        child.setAlpha(childAlpha * alpha);

	        child.renderCanvas(renderer, child, camera, transformMatrix);

	        child.setAlpha(childAlpha);
	        child.setScrollFactor(childScrollFactorX, childScrollFactorY);
	    }

	    if (container.mask)
	    {
	        container.mask.postRenderCanvas(renderer);
	    }
	};

	ContainerCanvasRenderer_1 = ContainerCanvasRenderer;
	return ContainerCanvasRenderer_1;
}

var ContainerRender;
var hasRequiredContainerRender;

function requireContainerRender () {
	if (hasRequiredContainerRender) return ContainerRender;
	hasRequiredContainerRender = 1;
	var NOOP = requireNOOP();
	var renderWebGL = NOOP;
	var renderCanvas = NOOP;

	if (typeof WEBGL_RENDERER)
	{
	    renderWebGL = requireContainerWebGLRenderer();
	}

	if (typeof CANVAS_RENDERER)
	{
	    renderCanvas = requireContainerCanvasRenderer();
	}

	ContainerRender = {

	    renderWebGL: renderWebGL,
	    renderCanvas: renderCanvas

	};
	return ContainerRender;
}

var Union_1;
var hasRequiredUnion;

function requireUnion () {
	if (hasRequiredUnion) return Union_1;
	hasRequiredUnion = 1;
	var Rectangle = requireRectangle$2();

	var Union = function (rectA, rectB, out)
	{
	    if (out === undefined) { out = new Rectangle(); }

	    var x = Math.min(rectA.x, rectB.x);
	    var y = Math.min(rectA.y, rectB.y);
	    var w = Math.max(rectA.right, rectB.right) - x;
	    var h = Math.max(rectA.bottom, rectB.bottom) - y;

	    return out.setTo(x, y, w, h);
	};

	Union_1 = Union;
	return Union_1;
}

var Container_1;
var hasRequiredContainer;

function requireContainer () {
	if (hasRequiredContainer) return Container_1;
	hasRequiredContainer = 1;
	var ArrayUtils = requireArray();
	var BlendModes = requireBlendModes();
	var Class = requireClass();
	var Components = requireComponents$2();
	var Events = requireEvents$j();
	var GameObject = requireGameObject();
	var Rectangle = requireRectangle$2();
	var Render = requireContainerRender();
	var Union = requireUnion();
	var Vector2 = requireVector2();

	var tempTransformMatrix = new Components.TransformMatrix();

	var Container = new Class({

	    Extends: GameObject,

	    Mixins: [
	        Components.AlphaSingle,
	        Components.BlendMode,
	        Components.ComputedSize,
	        Components.Depth,
	        Components.Mask,
	        Components.PostPipeline,
	        Components.Transform,
	        Components.Visible,
	        Render
	    ],

	    initialize:

	    function Container (scene, x, y, children)
	    {
	        GameObject.call(this, scene, 'Container');

	        this.list = [];

	        this.exclusive = true;

	        this.maxSize = -1;

	        this.position = 0;

	        this.localTransform = new Components.TransformMatrix();

	        this._sortKey = '';

	        this._sysEvents = scene.sys.events;

	        this.scrollFactorX = 1;

	        this.scrollFactorY = 1;

	        this.initPostPipeline();

	        this.setPosition(x, y);

	        this.setBlendMode(BlendModes.SKIP_CHECK);

	        if (children)
	        {
	            this.add(children);
	        }
	    },

	    originX: {

	        get: function ()
	        {
	            return 0.5;
	        }

	    },

	    originY: {

	        get: function ()
	        {
	            return 0.5;
	        }

	    },

	    displayOriginX: {

	        get: function ()
	        {
	            return this.width * 0.5;
	        }

	    },

	    displayOriginY: {

	        get: function ()
	        {
	            return this.height * 0.5;
	        }

	    },

	    setExclusive: function (value)
	    {
	        if (value === undefined) { value = true; }

	        this.exclusive = value;

	        return this;
	    },

	    getBounds: function (output)
	    {
	        if (output === undefined) { output = new Rectangle(); }

	        output.setTo(this.x, this.y, 0, 0);

	        if (this.parentContainer)
	        {
	            var parentMatrix = this.parentContainer.getBoundsTransformMatrix();
	            var transformedPosition = parentMatrix.transformPoint(this.x, this.y);

	            output.setTo(transformedPosition.x, transformedPosition.y, 0, 0);
	        }

	        if (this.list.length > 0)
	        {
	            var children = this.list;
	            var tempRect = new Rectangle();
	            var hasSetFirst = false;

	            output.setEmpty();

	            for (var i = 0; i < children.length; i++)
	            {
	                var entry = children[i];

	                if (entry.getBounds)
	                {
	                    entry.getBounds(tempRect);

	                    if (!hasSetFirst)
	                    {
	                        output.setTo(tempRect.x, tempRect.y, tempRect.width, tempRect.height);
	                        hasSetFirst = true;
	                    }
	                    else
	                    {
	                        Union(tempRect, output, output);
	                    }
	                }
	            }
	        }

	        return output;
	    },

	    addHandler: function (gameObject)
	    {
	        gameObject.once(Events.DESTROY, this.onChildDestroyed, this);

	        if (this.exclusive)
	        {
	            if (gameObject.parentContainer)
	            {
	                gameObject.parentContainer.remove(gameObject);
	            }

	            gameObject.parentContainer = this;

	            gameObject.removeFromDisplayList();

	            gameObject.addedToScene();
	        }
	    },

	    removeHandler: function (gameObject)
	    {
	        gameObject.off(Events.DESTROY, this.remove, this);

	        if (this.exclusive)
	        {
	            gameObject.parentContainer = null;

	            gameObject.removedFromScene();

	            gameObject.addToDisplayList();
	        }
	    },

	    pointToContainer: function (source, output)
	    {
	        if (output === undefined) { output = new Vector2(); }

	        if (this.parentContainer)
	        {
	            this.parentContainer.pointToContainer(source, output);
	        }
	        else
	        {
	            output.x = source.x;
	            output.y = source.y;
	        }

	        var tempMatrix = tempTransformMatrix;

	        tempMatrix.applyITRS(this.x, this.y, this.rotation, this.scaleX, this.scaleY);

	        tempMatrix.invert();

	        tempMatrix.transformPoint(source.x, source.y, output);

	        return output;
	    },

	    getBoundsTransformMatrix: function ()
	    {
	        return this.getWorldTransformMatrix(tempTransformMatrix, this.localTransform);
	    },

	    add: function (child)
	    {
	        ArrayUtils.Add(this.list, child, this.maxSize, this.addHandler, this);

	        return this;
	    },

	    addAt: function (child, index)
	    {
	        ArrayUtils.AddAt(this.list, child, index, this.maxSize, this.addHandler, this);

	        return this;
	    },

	    getAt: function (index)
	    {
	        return this.list[index];
	    },

	    getIndex: function (child)
	    {
	        return this.list.indexOf(child);
	    },

	    sort: function (property, handler)
	    {
	        if (!property)
	        {
	            return this;
	        }

	        if (handler === undefined)
	        {
	            handler = function (childA, childB)
	            {
	                return childA[property] - childB[property];
	            };
	        }

	        ArrayUtils.StableSort(this.list, handler);

	        return this;
	    },

	    getByName: function (name)
	    {
	        return ArrayUtils.GetFirst(this.list, 'name', name);
	    },

	    getRandom: function (startIndex, length)
	    {
	        return ArrayUtils.GetRandom(this.list, startIndex, length);
	    },

	    getFirst: function (property, value, startIndex, endIndex)
	    {
	        return ArrayUtils.GetFirst(this.list, property, value, startIndex, endIndex);
	    },

	    getAll: function (property, value, startIndex, endIndex)
	    {
	        return ArrayUtils.GetAll(this.list, property, value, startIndex, endIndex);
	    },

	    count: function (property, value, startIndex, endIndex)
	    {
	        return ArrayUtils.CountAllMatching(this.list, property, value, startIndex, endIndex);
	    },

	    swap: function (child1, child2)
	    {
	        ArrayUtils.Swap(this.list, child1, child2);

	        return this;
	    },

	    moveTo: function (child, index)
	    {
	        ArrayUtils.MoveTo(this.list, child, index);

	        return this;
	    },

	    moveAbove: function (child1, child2)
	    {
	        ArrayUtils.MoveAbove(this.list, child1, child2);

	        return this;
	    },

	    moveBelow: function (child1, child2)
	    {
	        ArrayUtils.MoveBelow(this.list, child1, child2);

	        return this;
	    },

	    remove: function (child, destroyChild)
	    {
	        var removed = ArrayUtils.Remove(this.list, child, this.removeHandler, this);

	        if (destroyChild && removed)
	        {
	            if (!Array.isArray(removed))
	            {
	                removed = [ removed ];
	            }

	            for (var i = 0; i < removed.length; i++)
	            {
	                removed[i].destroy();
	            }
	        }

	        return this;
	    },

	    removeAt: function (index, destroyChild)
	    {
	        var removed = ArrayUtils.RemoveAt(this.list, index, this.removeHandler, this);

	        if (destroyChild && removed)
	        {
	            removed.destroy();
	        }

	        return this;
	    },

	    removeBetween: function (startIndex, endIndex, destroyChild)
	    {
	        var removed = ArrayUtils.RemoveBetween(this.list, startIndex, endIndex, this.removeHandler, this);

	        if (destroyChild)
	        {
	            for (var i = 0; i < removed.length; i++)
	            {
	                removed[i].destroy();
	            }
	        }

	        return this;
	    },

	    removeAll: function (destroyChild)
	    {
	        var list = this.list;

	        if (destroyChild)
	        {
	            for (var i = 0; i < list.length; i++)
	            {
	                if (list[i] && list[i].scene)
	                {
	                    list[i].off(Events.DESTROY, this.onChildDestroyed, this);

	                    list[i].destroy();
	                }
	            }

	            this.list = [];
	        }
	        else
	        {
	            ArrayUtils.RemoveBetween(list, 0, list.length, this.removeHandler, this);
	        }

	        return this;
	    },

	    bringToTop: function (child)
	    {
	        ArrayUtils.BringToTop(this.list, child);

	        return this;
	    },

	    sendToBack: function (child)
	    {
	        ArrayUtils.SendToBack(this.list, child);

	        return this;
	    },

	    moveUp: function (child)
	    {
	        ArrayUtils.MoveUp(this.list, child);

	        return this;
	    },

	    moveDown: function (child)
	    {
	        ArrayUtils.MoveDown(this.list, child);

	        return this;
	    },

	    reverse: function ()
	    {
	        this.list.reverse();

	        return this;
	    },

	    shuffle: function ()
	    {
	        ArrayUtils.Shuffle(this.list);

	        return this;
	    },

	    replace: function (oldChild, newChild, destroyChild)
	    {
	        var moved = ArrayUtils.Replace(this.list, oldChild, newChild);

	        if (moved)
	        {
	            this.addHandler(newChild);
	            this.removeHandler(oldChild);

	            if (destroyChild)
	            {
	                oldChild.destroy();
	            }
	        }

	        return this;
	    },

	    exists: function (child)
	    {
	        return (this.list.indexOf(child) > -1);
	    },

	    setAll: function (property, value, startIndex, endIndex)
	    {
	        ArrayUtils.SetAll(this.list, property, value, startIndex, endIndex);

	        return this;
	    },

	    each: function (callback, context)
	    {
	        var args = [ null ];
	        var i;
	        var temp = this.list.slice();
	        var len = temp.length;

	        for (i = 2; i < arguments.length; i++)
	        {
	            args.push(arguments[i]);
	        }

	        for (i = 0; i < len; i++)
	        {
	            args[0] = temp[i];

	            callback.apply(context, args);
	        }

	        return this;
	    },

	    iterate: function (callback, context)
	    {
	        var args = [ null ];
	        var i;

	        for (i = 2; i < arguments.length; i++)
	        {
	            args.push(arguments[i]);
	        }

	        for (i = 0; i < this.list.length; i++)
	        {
	            args[0] = this.list[i];

	            callback.apply(context, args);
	        }

	        return this;
	    },

	    setScrollFactor: function (x, y, updateChildren)
	    {
	        if (y === undefined) { y = x; }
	        if (updateChildren === undefined) { updateChildren = false; }

	        this.scrollFactorX = x;
	        this.scrollFactorY = y;

	        if (updateChildren)
	        {
	            ArrayUtils.SetAll(this.list, 'scrollFactorX', x);
	            ArrayUtils.SetAll(this.list, 'scrollFactorY', y);
	        }

	        return this;
	    },

	    length: {

	        get: function ()
	        {
	            return this.list.length;
	        }

	    },

	    first: {

	        get: function ()
	        {
	            this.position = 0;

	            if (this.list.length > 0)
	            {
	                return this.list[0];
	            }
	            else
	            {
	                return null;
	            }
	        }

	    },

	    last: {

	        get: function ()
	        {
	            if (this.list.length > 0)
	            {
	                this.position = this.list.length - 1;

	                return this.list[this.position];
	            }
	            else
	            {
	                return null;
	            }
	        }

	    },

	    next: {

	        get: function ()
	        {
	            if (this.position < this.list.length)
	            {
	                this.position++;

	                return this.list[this.position];
	            }
	            else
	            {
	                return null;
	            }
	        }

	    },

	    previous: {

	        get: function ()
	        {
	            if (this.position > 0)
	            {
	                this.position--;

	                return this.list[this.position];
	            }
	            else
	            {
	                return null;
	            }
	        }

	    },

	    preDestroy: function ()
	    {
	        this.removeAll(!!this.exclusive);

	        this.localTransform.destroy();

	        this.list = [];
	    },

	    onChildDestroyed: function (gameObject)
	    {
	        ArrayUtils.Remove(this.list, gameObject);

	        if (this.exclusive)
	        {
	            gameObject.parentContainer = null;

	            gameObject.removedFromScene();
	        }
	    }

	});

	Container_1 = Container;
	return Container_1;
}

var CSSBlendModes;
var hasRequiredCSSBlendModes;

function requireCSSBlendModes () {
	if (hasRequiredCSSBlendModes) return CSSBlendModes;
	hasRequiredCSSBlendModes = 1;
	CSSBlendModes = [
	    'normal',
	    'multiply',
	    'multiply',
	    'screen',
	    'overlay',
	    'darken',
	    'lighten',
	    'color-dodge',
	    'color-burn',
	    'hard-light',
	    'soft-light',
	    'difference',
	    'exclusion',
	    'hue',
	    'saturation',
	    'color',
	    'luminosity'
	];
	return CSSBlendModes;
}

var DOMElementCSSRenderer_1;
var hasRequiredDOMElementCSSRenderer;

function requireDOMElementCSSRenderer () {
	if (hasRequiredDOMElementCSSRenderer) return DOMElementCSSRenderer_1;
	hasRequiredDOMElementCSSRenderer = 1;
	var CSSBlendModes = requireCSSBlendModes();
	var GameObject = requireGameObject();
	var TransformMatrix = requireTransformMatrix();

	var tempMatrix1 = new TransformMatrix();
	var tempMatrix2 = new TransformMatrix();
	var tempMatrix3 = new TransformMatrix();

	var DOMElementCSSRenderer = function (renderer, src, camera, parentMatrix)
	{
	    if (!src.node)
	    {
	        return;
	    }

	    var style = src.node.style;
	    var settings = src.scene.sys.settings;

	    if (!style || !settings.visible || GameObject.RENDER_MASK !== src.renderFlags || (src.cameraFilter !== 0 && (src.cameraFilter & camera.id)) || (src.parentContainer && !src.parentContainer.willRender()))
	    {
	        style.display = 'none';

	        return;
	    }

	    var parent = src.parentContainer;
	    var alpha = camera.alpha * src.alpha;

	    if (parent)
	    {
	        alpha *= parent.alpha;
	    }

	    var camMatrix = tempMatrix1;
	    var srcMatrix = tempMatrix2;
	    var calcMatrix = tempMatrix3;

	    var dx = 0;
	    var dy = 0;

	    var tx = '0%';
	    var ty = '0%';

	    if (parentMatrix)
	    {
	        dx = (src.width * src.scaleX) * src.originX;
	        dy = (src.height * src.scaleY) * src.originY;

	        srcMatrix.applyITRS(src.x - dx, src.y - dy, src.rotation, src.scaleX, src.scaleY);

	        camMatrix.copyFrom(camera.matrix);

	        camMatrix.multiplyWithOffset(parentMatrix, -camera.scrollX * src.scrollFactorX, -camera.scrollY * src.scrollFactorY);

	        srcMatrix.e = src.x - dx;
	        srcMatrix.f = src.y - dy;

	        camMatrix.multiply(srcMatrix, calcMatrix);
	    }
	    else
	    {
	        dx = (src.width) * src.originX;
	        dy = (src.height) * src.originY;

	        srcMatrix.applyITRS(src.x, src.y, src.rotation, src.scaleX, src.scaleY);

	        camMatrix.copyFrom(camera.matrix);

	        tx = (100 * src.originX) + '%';
	        ty = (100 * src.originY) + '%';

	        srcMatrix.e -= camera.scrollX * src.scrollFactorX;
	        srcMatrix.f -= camera.scrollY * src.scrollFactorY;

	        camMatrix.multiply(srcMatrix, calcMatrix);

	        calcMatrix.e -= dx;
	        calcMatrix.f -= dy;
	    }

	    if (!src.transformOnly)
	    {
	        style.display = 'block';
	        style.opacity = alpha;
	        style.zIndex = src._depth;
	        style.pointerEvents = src.pointerEvents;
	        style.mixBlendMode = CSSBlendModes[src._blendMode];
	    }

	    style.transform =
	        calcMatrix.getCSSMatrix() +
	        ' skew(' + src.skewX + 'rad, ' + src.skewY + 'rad)' +
	        ' rotate3d(' + src.rotate3d.x + ',' + src.rotate3d.y + ',' + src.rotate3d.z + ',' + src.rotate3d.w + src.rotate3dAngle + ')';

	    style.transformOrigin = tx + ' ' + ty;
	};

	DOMElementCSSRenderer_1 = DOMElementCSSRenderer;
	return DOMElementCSSRenderer_1;
}

var DOMElementRender;
var hasRequiredDOMElementRender;

function requireDOMElementRender () {
	if (hasRequiredDOMElementRender) return DOMElementRender;
	hasRequiredDOMElementRender = 1;
	var NOOP = requireNOOP();
	var renderWebGL = NOOP;
	var renderCanvas = NOOP;

	if (typeof WEBGL_RENDERER)
	{
	    renderWebGL = requireDOMElementCSSRenderer();
	}

	if (typeof CANVAS_RENDERER)
	{
	    renderCanvas = requireDOMElementCSSRenderer();
	}

	DOMElementRender = {

	    renderWebGL: renderWebGL,
	    renderCanvas: renderCanvas

	};
	return DOMElementRender;
}

var DOMElement_1;
var hasRequiredDOMElement;

function requireDOMElement () {
	if (hasRequiredDOMElement) return DOMElement_1;
	hasRequiredDOMElement = 1;
	var Class = requireClass();
	var Components = requireComponents$2();
	var DOMElementRender = requireDOMElementRender();
	var GameObject = requireGameObject();
	var IsPlainObject = requireIsPlainObject();
	var RemoveFromDOM = requireRemoveFromDOM();
	var SCENE_EVENTS = requireEvents$l();
	var Vector4 = requireVector4();

	var DOMElement = new Class({

	    Extends: GameObject,

	    Mixins: [
	        Components.AlphaSingle,
	        Components.BlendMode,
	        Components.Depth,
	        Components.Origin,
	        Components.ScrollFactor,
	        Components.Transform,
	        Components.Visible,
	        DOMElementRender
	    ],

	    initialize:

	    function DOMElement (scene, x, y, element, style, innerText)
	    {
	        GameObject.call(this, scene, 'DOMElement');

	        this.parent = scene.sys.game.domContainer;

	        if (!this.parent)
	        {
	            throw new Error('No DOM Container set in game config');
	        }

	        this.cache = scene.sys.cache.html;

	        this.node;

	        this.transformOnly = false;

	        this.skewX = 0;

	        this.skewY = 0;

	        this.rotate3d = new Vector4();

	        this.rotate3dAngle = 'deg';

	        this.pointerEvents = 'auto';

	        this.width = 0;

	        this.height = 0;

	        this.displayWidth = 0;

	        this.displayHeight = 0;

	        this.handler = this.dispatchNativeEvent.bind(this);

	        this.setPosition(x, y);

	        if (typeof element === 'string')
	        {

	            if (element[0] === '#')
	            {
	                this.setElement(element.substr(1), style, innerText);
	            }
	            else
	            {
	                this.createElement(element, style, innerText);
	            }
	        }
	        else if (element)
	        {
	            this.setElement(element, style, innerText);
	        }

	        scene.sys.events.on(SCENE_EVENTS.SLEEP, this.handleSceneEvent, this);
	        scene.sys.events.on(SCENE_EVENTS.WAKE, this.handleSceneEvent, this);
	        scene.sys.events.on(SCENE_EVENTS.PRE_RENDER, this.preRender, this);
	    },

	    handleSceneEvent: function (sys)
	    {
	        var node = this.node;
	        var style = node.style;

	        if (node)
	        {
	            style.display = (sys.settings.visible) ? 'block' : 'none';
	        }
	    },

	    setSkew: function (x, y)
	    {
	        if (x === undefined) { x = 0; }
	        if (y === undefined) { y = x; }

	        this.skewX = x;
	        this.skewY = y;

	        return this;
	    },

	    setPerspective: function (value)
	    {
	        this.parent.style.perspective = value + 'px';

	        return this;
	    },

	    perspective: {

	        get: function ()
	        {
	            return parseFloat(this.parent.style.perspective);
	        },

	        set: function (value)
	        {
	            this.parent.style.perspective = value + 'px';
	        }

	    },

	    addListener: function (events)
	    {
	        if (this.node)
	        {
	            events = events.split(' ');

	            for (var i = 0; i < events.length; i++)
	            {
	                this.node.addEventListener(events[i], this.handler, false);
	            }
	        }

	        return this;
	    },

	    removeListener: function (events)
	    {
	        if (this.node)
	        {
	            events = events.split(' ');

	            for (var i = 0; i < events.length; i++)
	            {
	                this.node.removeEventListener(events[i], this.handler);
	            }
	        }

	        return this;
	    },

	    dispatchNativeEvent: function (event)
	    {
	        this.emit(event.type, event);
	    },

	    createElement: function (tagName, style, innerText)
	    {
	        return this.setElement(document.createElement(tagName), style, innerText);
	    },

	    setElement: function (element, style, innerText)
	    {

	        this.removeElement();

	        var target;

	        if (typeof element === 'string')
	        {

	            if (element[0] === '#')
	            {
	                element = element.substr(1);
	            }

	            target = document.getElementById(element);
	        }
	        else if (typeof element === 'object' && element.nodeType === 1)
	        {
	            target = element;
	        }

	        if (!target)
	        {
	            return this;
	        }

	        this.node = target;

	        if (style && IsPlainObject(style))
	        {
	            for (var key in style)
	            {
	                target.style[key] = style[key];
	            }
	        }
	        else if (typeof style === 'string')
	        {
	            target.style = style;
	        }

	        target.style.zIndex = '0';
	        target.style.display = 'inline';
	        target.style.position = 'absolute';

	        target.phaser = this;

	        this.parent.appendChild(target);

	        if (innerText)
	        {
	            target.innerText = innerText;
	        }

	        return this.updateSize();
	    },

	    createFromCache: function (key, tagName)
	    {
	        var html = this.cache.get(key);

	        if (html)
	        {
	            this.createFromHTML(html, tagName);
	        }

	        return this;
	    },

	    createFromHTML: function (html, tagName)
	    {
	        if (tagName === undefined) { tagName = 'div'; }

	        this.removeElement();

	        var element = document.createElement(tagName);

	        this.node = element;

	        element.style.zIndex = '0';
	        element.style.display = 'inline';
	        element.style.position = 'absolute';

	        element.phaser = this;

	        this.parent.appendChild(element);

	        element.innerHTML = html;

	        return this.updateSize();
	    },

	    removeElement: function ()
	    {
	        if (this.node)
	        {
	            RemoveFromDOM(this.node);

	            this.node = null;
	        }

	        return this;
	    },

	    updateSize: function ()
	    {
	        var node = this.node;

	        this.width = node.clientWidth;
	        this.height = node.clientHeight;

	        this.displayWidth = this.width * this.scaleX;
	        this.displayHeight = this.height * this.scaleY;

	        return this;
	    },

	    getChildByProperty: function (property, value)
	    {
	        if (this.node)
	        {
	            var children = this.node.querySelectorAll('*');

	            for (var i = 0; i < children.length; i++)
	            {
	                if (children[i][property] === value)
	                {
	                    return children[i];
	                }
	            }
	        }

	        return null;
	    },

	    getChildByID: function (id)
	    {
	        return this.getChildByProperty('id', id);
	    },

	    getChildByName: function (name)
	    {
	        return this.getChildByProperty('name', name);
	    },

	    setClassName: function (className)
	    {
	        if (this.node)
	        {
	            this.node.className = className;

	            this.updateSize();
	        }

	        return this;
	    },

	    setText: function (text)
	    {
	        if (this.node)
	        {
	            this.node.innerText = text;

	            this.updateSize();
	        }

	        return this;
	    },

	    setHTML: function (html)
	    {
	        if (this.node)
	        {
	            this.node.innerHTML = html;

	            this.updateSize();
	        }

	        return this;
	    },

	    preRender: function ()
	    {
	        var parent = this.parentContainer;
	        var node = this.node;

	        if (node && parent && !parent.willRender())
	        {
	            node.style.display = 'none';
	        }
	    },

	    willRender: function ()
	    {
	        return true;
	    },

	    preDestroy: function ()
	    {
	        this.removeElement();

	        this.scene.sys.events.off(SCENE_EVENTS.SLEEP, this.handleSceneEvent, this);
	        this.scene.sys.events.off(SCENE_EVENTS.WAKE, this.handleSceneEvent, this);
	        this.scene.sys.events.off(SCENE_EVENTS.PRE_RENDER, this.preRender, this);
	    }

	});

	DOMElement_1 = DOMElement;
	return DOMElement_1;
}

var DynamicBitmapTextWebGLRenderer_1;
var hasRequiredDynamicBitmapTextWebGLRenderer;

function requireDynamicBitmapTextWebGLRenderer () {
	if (hasRequiredDynamicBitmapTextWebGLRenderer) return DynamicBitmapTextWebGLRenderer_1;
	hasRequiredDynamicBitmapTextWebGLRenderer = 1;
	var GetCalcMatrix = requireGetCalcMatrix();
	var TransformMatrix = requireTransformMatrix();
	var Utils = requireUtils$1();

	var tempMatrix = new TransformMatrix();

	var DynamicBitmapTextWebGLRenderer = function (renderer, src, camera, parentMatrix)
	{
	    var text = src.text;
	    var textLength = text.length;

	    if (textLength === 0)
	    {
	        return;
	    }

	    camera.addToRenderList(src);

	    var pipeline = renderer.pipelines.set(src.pipeline, src);

	    var result = GetCalcMatrix(src, camera, parentMatrix);

	    renderer.pipelines.preBatch(src);

	    var spriteMatrix = result.sprite;
	    var calcMatrix = result.calc;

	    var fontMatrix = tempMatrix;

	    var crop = (src.cropWidth > 0 || src.cropHeight > 0);

	    if (crop)
	    {
	        pipeline.flush();

	        renderer.pushScissor(
	            calcMatrix.tx,
	            calcMatrix.ty,
	            src.cropWidth * calcMatrix.scaleX,
	            src.cropHeight * calcMatrix.scaleY
	        );
	    }

	    var frame = src.frame;
	    var texture = frame.glTexture;

	    var tintEffect = src.tintFill;
	    var tintTL = Utils.getTintAppendFloatAlpha(src.tintTopLeft, camera.alpha * src._alphaTL);
	    var tintTR = Utils.getTintAppendFloatAlpha(src.tintTopRight, camera.alpha * src._alphaTR);
	    var tintBL = Utils.getTintAppendFloatAlpha(src.tintBottomLeft, camera.alpha * src._alphaBL);
	    var tintBR = Utils.getTintAppendFloatAlpha(src.tintBottomRight, camera.alpha * src._alphaBR);

	    var textureUnit = pipeline.setGameObject(src);

	    var xAdvance = 0;
	    var yAdvance = 0;
	    var charCode = 0;
	    var lastCharCode = 0;
	    var letterSpacing = src.letterSpacing;
	    var glyph;
	    var glyphW = 0;
	    var glyphH = 0;
	    var lastGlyph;
	    var scrollX = src.scrollX;
	    var scrollY = src.scrollY;

	    var fontData = src.fontData;
	    var chars = fontData.chars;
	    var lineHeight = fontData.lineHeight;
	    var scale = (src.fontSize / fontData.size);
	    var rotation = 0;

	    var align = src._align;
	    var currentLine = 0;
	    var lineOffsetX = 0;

	    var bounds = src.getTextBounds(false);

	    if (src.maxWidth > 0)
	    {
	        text = bounds.wrappedText;
	        textLength = text.length;
	    }

	    var lineData = src._bounds.lines;

	    if (align === 1)
	    {
	        lineOffsetX = (lineData.longest - lineData.lengths[0]) / 2;
	    }
	    else if (align === 2)
	    {
	        lineOffsetX = (lineData.longest - lineData.lengths[0]);
	    }

	    var roundPixels = camera.roundPixels;
	    var displayCallback = src.displayCallback;
	    var callbackData = src.callbackData;

	    for (var i = 0; i < textLength; i++)
	    {
	        charCode = text.charCodeAt(i);

	        if (charCode === 10)
	        {
	            currentLine++;

	            if (align === 1)
	            {
	                lineOffsetX = (lineData.longest - lineData.lengths[currentLine]) / 2;
	            }
	            else if (align === 2)
	            {
	                lineOffsetX = (lineData.longest - lineData.lengths[currentLine]);
	            }

	            xAdvance = 0;
	            yAdvance += lineHeight;
	            lastGlyph = null;

	            continue;
	        }

	        glyph = chars[charCode];

	        if (!glyph)
	        {
	            continue;
	        }

	        glyphW = glyph.width;
	        glyphH = glyph.height;

	        var x = (glyph.xOffset + xAdvance) - scrollX;
	        var y = (glyph.yOffset + yAdvance) - scrollY;

	        if (lastGlyph !== null)
	        {
	            var kerningOffset = glyph.kerning[lastCharCode] || 0;
	            x += kerningOffset;
	            xAdvance += kerningOffset;
	        }

	        xAdvance += glyph.xAdvance + letterSpacing;
	        lastGlyph = glyph;
	        lastCharCode = charCode;

	        if (glyphW === 0 || glyphH === 0 || charCode === 32)
	        {
	            continue;
	        }

	        scale = (src.fontSize / src.fontData.size);
	        rotation = 0;

	        if (displayCallback)
	        {
	            callbackData.color = 0;
	            callbackData.tint.topLeft = tintTL;
	            callbackData.tint.topRight = tintTR;
	            callbackData.tint.bottomLeft = tintBL;
	            callbackData.tint.bottomRight = tintBR;
	            callbackData.index = i;
	            callbackData.charCode = charCode;
	            callbackData.x = x;
	            callbackData.y = y;
	            callbackData.scale = scale;
	            callbackData.rotation = rotation;
	            callbackData.data = glyph.data;

	            var output = displayCallback(callbackData);

	            x = output.x;
	            y = output.y;
	            scale = output.scale;
	            rotation = output.rotation;

	            if (output.color)
	            {
	                tintTL = output.color;
	                tintTR = output.color;
	                tintBL = output.color;
	                tintBR = output.color;
	            }
	            else
	            {
	                tintTL = output.tint.topLeft;
	                tintTR = output.tint.topRight;
	                tintBL = output.tint.bottomLeft;
	                tintBR = output.tint.bottomRight;
	            }

	            tintTL = Utils.getTintAppendFloatAlpha(tintTL, camera.alpha * src._alphaTL);
	            tintTR = Utils.getTintAppendFloatAlpha(tintTR, camera.alpha * src._alphaTR);
	            tintBL = Utils.getTintAppendFloatAlpha(tintBL, camera.alpha * src._alphaBL);
	            tintBR = Utils.getTintAppendFloatAlpha(tintBR, camera.alpha * src._alphaBR);
	        }

	        x *= scale;
	        y *= scale;

	        x -= src.displayOriginX;
	        y -= src.displayOriginY;

	        x += lineOffsetX;

	        fontMatrix.applyITRS(x, y, rotation, scale, scale);

	        calcMatrix.multiply(fontMatrix, spriteMatrix);

	        var u0 = glyph.u0;
	        var v0 = glyph.v0;
	        var u1 = glyph.u1;
	        var v1 = glyph.v1;

	        var xw = glyphW;
	        var yh = glyphH;

	        var tx0 = spriteMatrix.e;
	        var ty0 = spriteMatrix.f;

	        var tx1 = yh * spriteMatrix.c + spriteMatrix.e;
	        var ty1 = yh * spriteMatrix.d + spriteMatrix.f;

	        var tx2 = xw * spriteMatrix.a + yh * spriteMatrix.c + spriteMatrix.e;
	        var ty2 = xw * spriteMatrix.b + yh * spriteMatrix.d + spriteMatrix.f;

	        var tx3 = xw * spriteMatrix.a + spriteMatrix.e;
	        var ty3 = xw * spriteMatrix.b + spriteMatrix.f;

	        if (roundPixels)
	        {
	            tx0 = Math.round(tx0);
	            ty0 = Math.round(ty0);

	            tx1 = Math.round(tx1);
	            ty1 = Math.round(ty1);

	            tx2 = Math.round(tx2);
	            ty2 = Math.round(ty2);

	            tx3 = Math.round(tx3);
	            ty3 = Math.round(ty3);
	        }

	        if (pipeline.shouldFlush(6))
	        {
	            pipeline.flush();
	            textureUnit = pipeline.setGameObject(src);
	        }

	        pipeline.batchQuad(src, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, u0, v0, u1, v1, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, textureUnit);
	    }

	    if (crop)
	    {
	        pipeline.flush();

	        renderer.popScissor();
	    }

	    renderer.pipelines.postBatch(src);
	};

	DynamicBitmapTextWebGLRenderer_1 = DynamicBitmapTextWebGLRenderer;
	return DynamicBitmapTextWebGLRenderer_1;
}

var DynamicBitmapTextCanvasRenderer_1;
var hasRequiredDynamicBitmapTextCanvasRenderer;

function requireDynamicBitmapTextCanvasRenderer () {
	if (hasRequiredDynamicBitmapTextCanvasRenderer) return DynamicBitmapTextCanvasRenderer_1;
	hasRequiredDynamicBitmapTextCanvasRenderer = 1;
	var SetTransform = requireSetTransform();

	var DynamicBitmapTextCanvasRenderer = function (renderer, src, camera, parentMatrix)
	{
	    var text = src._text;
	    var textLength = text.length;

	    var ctx = renderer.currentContext;

	    if (textLength === 0 || !SetTransform(renderer, ctx, src, camera, parentMatrix))
	    {
	        return;
	    }

	    camera.addToRenderList(src);

	    var textureFrame = src.fromAtlas
	        ? src.frame
	        : src.texture.frames['__BASE'];

	    var displayCallback = src.displayCallback;
	    var callbackData = src.callbackData;

	    var chars = src.fontData.chars;
	    var lineHeight = src.fontData.lineHeight;
	    var letterSpacing = src._letterSpacing;

	    var xAdvance = 0;
	    var yAdvance = 0;

	    var charCode = 0;

	    var glyph = null;
	    var glyphX = 0;
	    var glyphY = 0;
	    var glyphW = 0;
	    var glyphH = 0;

	    var x = 0;
	    var y = 0;

	    var lastGlyph = null;
	    var lastCharCode = 0;

	    var image = src.frame.source.image;

	    var textureX = textureFrame.cutX;
	    var textureY = textureFrame.cutY;

	    var rotation = 0;
	    var scale = 0;
	    var baseScale = (src._fontSize / src.fontData.size);

	    var align = src._align;
	    var currentLine = 0;
	    var lineOffsetX = 0;

	    src.getTextBounds(false);

	    var lineData = src._bounds.lines;

	    if (align === 1)
	    {
	        lineOffsetX = (lineData.longest - lineData.lengths[0]) / 2;
	    }
	    else if (align === 2)
	    {
	        lineOffsetX = (lineData.longest - lineData.lengths[0]);
	    }

	    ctx.translate(-src.displayOriginX, -src.displayOriginY);

	    var roundPixels = camera.roundPixels;

	    if (src.cropWidth > 0 && src.cropHeight > 0)
	    {
	        ctx.beginPath();
	        ctx.rect(0, 0, src.cropWidth, src.cropHeight);
	        ctx.clip();
	    }

	    for (var i = 0; i < textLength; i++)
	    {

	        scale = baseScale;
	        rotation = 0;

	        charCode = text.charCodeAt(i);

	        if (charCode === 10)
	        {
	            currentLine++;

	            if (align === 1)
	            {
	                lineOffsetX = (lineData.longest - lineData.lengths[currentLine]) / 2;
	            }
	            else if (align === 2)
	            {
	                lineOffsetX = (lineData.longest - lineData.lengths[currentLine]);
	            }

	            xAdvance = 0;
	            yAdvance += lineHeight;
	            lastGlyph = null;

	            continue;
	        }

	        glyph = chars[charCode];

	        if (!glyph)
	        {
	            continue;
	        }

	        glyphX = textureX + glyph.x;
	        glyphY = textureY + glyph.y;

	        glyphW = glyph.width;
	        glyphH = glyph.height;

	        x = (glyph.xOffset + xAdvance) - src.scrollX;
	        y = (glyph.yOffset + yAdvance) - src.scrollY;

	        if (lastGlyph !== null)
	        {
	            var kerningOffset = glyph.kerning[lastCharCode];
	            x += (kerningOffset !== undefined) ? kerningOffset : 0;
	        }

	        if (displayCallback)
	        {
	            callbackData.index = i;
	            callbackData.charCode = charCode;
	            callbackData.x = x;
	            callbackData.y = y;
	            callbackData.scale = scale;
	            callbackData.rotation = rotation;
	            callbackData.data = glyph.data;

	            var output = displayCallback(callbackData);

	            x = output.x;
	            y = output.y;
	            scale = output.scale;
	            rotation = output.rotation;
	        }

	        x *= scale;
	        y *= scale;

	        x += lineOffsetX;

	        xAdvance += glyph.xAdvance + letterSpacing + ((kerningOffset !== undefined) ? kerningOffset : 0);
	        lastGlyph = glyph;
	        lastCharCode = charCode;

	        if (glyphW === 0 || glyphH === 0 || charCode === 32)
	        {
	            continue;
	        }

	        if (roundPixels)
	        {
	            x = Math.round(x);
	            y = Math.round(y);
	        }

	        ctx.save();

	        ctx.translate(x, y);

	        ctx.rotate(rotation);

	        ctx.scale(scale, scale);

	        ctx.drawImage(image, glyphX, glyphY, glyphW, glyphH, 0, 0, glyphW, glyphH);

	        ctx.restore();
	    }

	    ctx.restore();
	};

	DynamicBitmapTextCanvasRenderer_1 = DynamicBitmapTextCanvasRenderer;
	return DynamicBitmapTextCanvasRenderer_1;
}

var DynamicBitmapTextRender;
var hasRequiredDynamicBitmapTextRender;

function requireDynamicBitmapTextRender () {
	if (hasRequiredDynamicBitmapTextRender) return DynamicBitmapTextRender;
	hasRequiredDynamicBitmapTextRender = 1;
	var NOOP = requireNOOP();
	var renderWebGL = NOOP;
	var renderCanvas = NOOP;

	if (typeof WEBGL_RENDERER)
	{
	    renderWebGL = requireDynamicBitmapTextWebGLRenderer();
	}

	if (typeof CANVAS_RENDERER)
	{
	    renderCanvas = requireDynamicBitmapTextCanvasRenderer();
	}

	DynamicBitmapTextRender = {

	    renderWebGL: renderWebGL,
	    renderCanvas: renderCanvas

	};
	return DynamicBitmapTextRender;
}

var DynamicBitmapText_1;
var hasRequiredDynamicBitmapText;

function requireDynamicBitmapText () {
	if (hasRequiredDynamicBitmapText) return DynamicBitmapText_1;
	hasRequiredDynamicBitmapText = 1;
	var BitmapText = requireBitmapText();
	var Class = requireClass();
	var Render = requireDynamicBitmapTextRender();

	var DynamicBitmapText = new Class({

	    Extends: BitmapText,

	    Mixins: [
	        Render
	    ],

	    initialize:

	    function DynamicBitmapText (scene, x, y, font, text, size, align)
	    {
	        BitmapText.call(this, scene, x, y, font, text, size, align);

	        this.type = 'DynamicBitmapText';

	        this.scrollX = 0;

	        this.scrollY = 0;

	        this.cropWidth = 0;

	        this.cropHeight = 0;

	        this.displayCallback;

	        this.callbackData = {
	            parent: this,
	            color: 0,
	            tint: {
	                topLeft: 0,
	                topRight: 0,
	                bottomLeft: 0,
	                bottomRight: 0
	            },
	            index: 0,
	            charCode: 0,
	            x: 0,
	            y: 0,
	            scale: 0,
	            rotation: 0,
	            data: 0
	        };
	    },

	    setSize: function (width, height)
	    {
	        this.cropWidth = width;
	        this.cropHeight = height;

	        return this;
	    },

	    setDisplayCallback: function (callback)
	    {
	        this.displayCallback = callback;

	        return this;
	    },

	    setScrollX: function (value)
	    {
	        this.scrollX = value;

	        return this;
	    },

	    setScrollY: function (value)
	    {
	        this.scrollY = value;

	        return this;
	    }

	});

	DynamicBitmapText_1 = DynamicBitmapText;
	return DynamicBitmapText_1;
}

var ExternWebGLRenderer_1;
var hasRequiredExternWebGLRenderer;

function requireExternWebGLRenderer () {
	if (hasRequiredExternWebGLRenderer) return ExternWebGLRenderer_1;
	hasRequiredExternWebGLRenderer = 1;
	var GetCalcMatrix = requireGetCalcMatrix();

	var ExternWebGLRenderer = function (renderer, src, camera, parentMatrix)
	{
	    renderer.pipelines.clear();

	    var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;

	    src.render.call(src, renderer, camera, calcMatrix);

	    renderer.pipelines.rebind();
	};

	ExternWebGLRenderer_1 = ExternWebGLRenderer;
	return ExternWebGLRenderer_1;
}

var ExternRender;
var hasRequiredExternRender;

function requireExternRender () {
	if (hasRequiredExternRender) return ExternRender;
	hasRequiredExternRender = 1;
	var NOOP = requireNOOP();
	var renderWebGL = NOOP;

	if (typeof WEBGL_RENDERER)
	{
	    renderWebGL = requireExternWebGLRenderer();
	}

	ExternRender = {

	    renderWebGL: renderWebGL,

	};
	return ExternRender;
}

var Extern_1;
var hasRequiredExtern;

function requireExtern () {
	if (hasRequiredExtern) return Extern_1;
	hasRequiredExtern = 1;
	var Class = requireClass();
	var Components = requireComponents$2();
	var GameObject = requireGameObject();
	var ExternRender = requireExternRender();

	var Extern = new Class({

	    Extends: GameObject,

	    Mixins: [
	        Components.Alpha,
	        Components.BlendMode,
	        Components.Depth,
	        Components.Flip,
	        Components.Origin,
	        Components.ScrollFactor,
	        Components.Size,
	        Components.Texture,
	        Components.Tint,
	        Components.Transform,
	        Components.Visible,
	        ExternRender
	    ],

	    initialize:

	    function Extern (scene)
	    {
	        GameObject.call(this, scene, 'Extern');
	    },

	    addedToScene: function ()
	    {
	        this.scene.sys.updateList.add(this);
	    },

	    removedFromScene: function ()
	    {
	        this.scene.sys.updateList.remove(this);
	    },

	    preUpdate: function ()
	    {

	    },

	    render: function ()
	    {

	    }

	});

	Extern_1 = Extern;
	return Extern_1;
}

var Commands;
var hasRequiredCommands;

function requireCommands () {
	if (hasRequiredCommands) return Commands;
	hasRequiredCommands = 1;
	Commands = {

	    ARC: 0,
	    BEGIN_PATH: 1,
	    CLOSE_PATH: 2,
	    FILL_RECT: 3,
	    LINE_TO: 4,
	    MOVE_TO: 5,
	    LINE_STYLE: 6,
	    FILL_STYLE: 7,
	    FILL_PATH: 8,
	    STROKE_PATH: 9,
	    FILL_TRIANGLE: 10,
	    STROKE_TRIANGLE: 11,
	    SAVE: 14,
	    RESTORE: 15,
	    TRANSLATE: 16,
	    SCALE: 17,
	    ROTATE: 18,
	    GRADIENT_FILL_STYLE: 21,
	    GRADIENT_LINE_STYLE: 22

	};
	return Commands;
}

var Contains_1$2;
var hasRequiredContains$2;

function requireContains$2 () {
	if (hasRequiredContains$2) return Contains_1$2;
	hasRequiredContains$2 = 1;
	var Contains = function (ellipse, x, y)
	{
	    if (ellipse.width <= 0 || ellipse.height <= 0)
	    {
	        return false;
	    }

	    var normx = ((x - ellipse.x) / ellipse.width);
	    var normy = ((y - ellipse.y) / ellipse.height);

	    normx *= normx;
	    normy *= normy;

	    return (normx + normy < 0.25);
	};

	Contains_1$2 = Contains;
	return Contains_1$2;
}

var CircumferencePoint_1;
var hasRequiredCircumferencePoint;

function requireCircumferencePoint () {
	if (hasRequiredCircumferencePoint) return CircumferencePoint_1;
	hasRequiredCircumferencePoint = 1;
	var Point = requirePoint$1();

	var CircumferencePoint = function (ellipse, angle, out)
	{
	    if (out === undefined) { out = new Point(); }

	    var halfWidth = ellipse.width / 2;
	    var halfHeight = ellipse.height / 2;

	    out.x = ellipse.x + halfWidth * Math.cos(angle);
	    out.y = ellipse.y + halfHeight * Math.sin(angle);

	    return out;
	};

	CircumferencePoint_1 = CircumferencePoint;
	return CircumferencePoint_1;
}

var GetPoint_1$1;
var hasRequiredGetPoint$1;

function requireGetPoint$1 () {
	if (hasRequiredGetPoint$1) return GetPoint_1$1;
	hasRequiredGetPoint$1 = 1;
	var CircumferencePoint = requireCircumferencePoint();
	var FromPercent = requireFromPercent();
	var MATH_CONST = require_const$c();
	var Point = requirePoint$1();

	var GetPoint = function (ellipse, position, out)
	{
	    if (out === undefined) { out = new Point(); }

	    var angle = FromPercent(position, 0, MATH_CONST.PI2);

	    return CircumferencePoint(ellipse, angle, out);
	};

	GetPoint_1$1 = GetPoint;
	return GetPoint_1$1;
}

var Circumference_1;
var hasRequiredCircumference;

function requireCircumference () {
	if (hasRequiredCircumference) return Circumference_1;
	hasRequiredCircumference = 1;
	var Circumference = function (ellipse)
	{
	    var rx = ellipse.width / 2;
	    var ry = ellipse.height / 2;
	    var h = Math.pow((rx - ry), 2) / Math.pow((rx + ry), 2);

	    return (Math.PI * (rx + ry)) * (1 + ((3 * h) / (10 + Math.sqrt(4 - (3 * h)))));
	};

	Circumference_1 = Circumference;
	return Circumference_1;
}

var GetPoints_1$2;
var hasRequiredGetPoints$2;

function requireGetPoints$2 () {
	if (hasRequiredGetPoints$2) return GetPoints_1$2;
	hasRequiredGetPoints$2 = 1;
	var Circumference = requireCircumference();
	var CircumferencePoint = requireCircumferencePoint();
	var FromPercent = requireFromPercent();
	var MATH_CONST = require_const$c();

	var GetPoints = function (ellipse, quantity, stepRate, out)
	{
	    if (out === undefined) { out = []; }

	    if (!quantity && stepRate > 0)
	    {
	        quantity = Circumference(ellipse) / stepRate;
	    }

	    for (var i = 0; i < quantity; i++)
	    {
	        var angle = FromPercent(i / quantity, 0, MATH_CONST.PI2);

	        out.push(CircumferencePoint(ellipse, angle));
	    }

	    return out;
	};

	GetPoints_1$2 = GetPoints;
	return GetPoints_1$2;
}

var Ellipse_1$1;
var hasRequiredEllipse$2;

function requireEllipse$2 () {
	if (hasRequiredEllipse$2) return Ellipse_1$1;
	hasRequiredEllipse$2 = 1;
	var Class = requireClass();
	var Contains = requireContains$2();
	var GetPoint = requireGetPoint$1();
	var GetPoints = requireGetPoints$2();
	var GEOM_CONST = require_const$d();
	var Random = requireRandom$2();

	var Ellipse = new Class({

	    initialize:

	    function Ellipse (x, y, width, height)
	    {
	        if (x === undefined) { x = 0; }
	        if (y === undefined) { y = 0; }
	        if (width === undefined) { width = 0; }
	        if (height === undefined) { height = 0; }

	        this.type = GEOM_CONST.ELLIPSE;

	        this.x = x;

	        this.y = y;

	        this.width = width;

	        this.height = height;
	    },

	    contains: function (x, y)
	    {
	        return Contains(this, x, y);
	    },

	    getPoint: function (position, point)
	    {
	        return GetPoint(this, position, point);
	    },

	    getPoints: function (quantity, stepRate, output)
	    {
	        return GetPoints(this, quantity, stepRate, output);
	    },

	    getRandomPoint: function (point)
	    {
	        return Random(this, point);
	    },

	    setTo: function (x, y, width, height)
	    {
	        this.x = x;
	        this.y = y;
	        this.width = width;
	        this.height = height;

	        return this;
	    },

	    setEmpty: function ()
	    {
	        this.width = 0;
	        this.height = 0;

	        return this;
	    },

	    setPosition: function (x, y)
	    {
	        if (y === undefined) { y = x; }

	        this.x = x;
	        this.y = y;

	        return this;
	    },

	    setSize: function (width, height)
	    {
	        if (height === undefined) { height = width; }

	        this.width = width;
	        this.height = height;

	        return this;
	    },

	    isEmpty: function ()
	    {
	        return (this.width <= 0 || this.height <= 0);
	    },

	    getMinorRadius: function ()
	    {
	        return Math.min(this.width, this.height) / 2;
	    },

	    getMajorRadius: function ()
	    {
	        return Math.max(this.width, this.height) / 2;
	    },

	    left: {

	        get: function ()
	        {
	            return this.x - (this.width / 2);
	        },

	        set: function (value)
	        {
	            this.x = value + (this.width / 2);
	        }

	    },

	    right: {

	        get: function ()
	        {
	            return this.x + (this.width / 2);
	        },

	        set: function (value)
	        {
	            this.x = value - (this.width / 2);
	        }

	    },

	    top: {

	        get: function ()
	        {
	            return this.y - (this.height / 2);
	        },

	        set: function (value)
	        {
	            this.y = value + (this.height / 2);
	        }

	    },

	    bottom: {

	        get: function ()
	        {
	            return this.y + (this.height / 2);
	        },

	        set: function (value)
	        {
	            this.y = value - (this.height / 2);
	        }

	    }

	});

	Ellipse_1$1 = Ellipse;
	return Ellipse_1$1;
}

var GraphicsWebGLRenderer_1;
var hasRequiredGraphicsWebGLRenderer;

function requireGraphicsWebGLRenderer () {
	if (hasRequiredGraphicsWebGLRenderer) return GraphicsWebGLRenderer_1;
	hasRequiredGraphicsWebGLRenderer = 1;
	var Commands = requireCommands();
	var GetCalcMatrix = requireGetCalcMatrix();
	var TransformMatrix = requireTransformMatrix();
	var Utils = requireUtils$1();

	var Point = function (x, y, width)
	{
	    this.x = x;
	    this.y = y;
	    this.width = width;
	};

	var Path = function (x, y, width)
	{
	    this.points = [];
	    this.pointsLength = 1;
	    this.points[0] = new Point(x, y, width);
	};

	var matrixStack = [];
	var tempMatrix = new TransformMatrix();

	var GraphicsWebGLRenderer = function (renderer, src, camera, parentMatrix)
	{
	    if (src.commandBuffer.length === 0)
	    {
	        return;
	    }

	    camera.addToRenderList(src);

	    var pipeline = renderer.pipelines.set(src.pipeline, src);

	    renderer.pipelines.preBatch(src);

	    var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;

	    var currentMatrix = tempMatrix.loadIdentity();

	    var commands = src.commandBuffer;
	    var alpha = camera.alpha * src.alpha;

	    var lineWidth = 1;
	    var fillTint = pipeline.fillTint;
	    var strokeTint = pipeline.strokeTint;

	    var tx = 0;
	    var ty = 0;
	    var ta = 0;
	    var iterStep = 0.01;
	    var PI2 = Math.PI * 2;

	    var cmd;

	    var path = [];
	    var pathIndex = 0;
	    var pathOpen = true;
	    var lastPath = null;

	    var getTint = Utils.getTintAppendFloatAlpha;

	    for (var cmdIndex = 0; cmdIndex < commands.length; cmdIndex++)
	    {
	        cmd = commands[cmdIndex];

	        switch (cmd)
	        {
	            case Commands.BEGIN_PATH:
	            {
	                path.length = 0;
	                lastPath = null;
	                pathOpen = true;
	                break;
	            }

	            case Commands.CLOSE_PATH:
	            {
	                pathOpen = false;

	                if (lastPath && lastPath.points.length)
	                {
	                    lastPath.points.push(lastPath.points[0]);
	                }
	                break;
	            }

	            case Commands.FILL_PATH:
	            {
	                for (pathIndex = 0; pathIndex < path.length; pathIndex++)
	                {
	                    pipeline.batchFillPath(
	                        path[pathIndex].points,
	                        currentMatrix,
	                        calcMatrix
	                    );
	                }
	                break;
	            }

	            case Commands.STROKE_PATH:
	            {
	                for (pathIndex = 0; pathIndex < path.length; pathIndex++)
	                {
	                    pipeline.batchStrokePath(
	                        path[pathIndex].points,
	                        lineWidth,
	                        pathOpen,
	                        currentMatrix,
	                        calcMatrix
	                    );
	                }
	                break;
	            }

	            case Commands.LINE_STYLE:
	            {
	                lineWidth = commands[++cmdIndex];
	                var strokeColor = commands[++cmdIndex];
	                var strokeAlpha = commands[++cmdIndex] * alpha;
	                var strokeTintColor = getTint(strokeColor, strokeAlpha);
	                strokeTint.TL = strokeTintColor;
	                strokeTint.TR = strokeTintColor;
	                strokeTint.BL = strokeTintColor;
	                strokeTint.BR = strokeTintColor;
	                break;
	            }

	            case Commands.FILL_STYLE:
	            {
	                var fillColor = commands[++cmdIndex];
	                var fillAlpha = commands[++cmdIndex] * alpha;
	                var fillTintColor = getTint(fillColor, fillAlpha);
	                fillTint.TL = fillTintColor;
	                fillTint.TR = fillTintColor;
	                fillTint.BL = fillTintColor;
	                fillTint.BR = fillTintColor;
	                break;
	            }

	            case Commands.GRADIENT_FILL_STYLE:
	            {
	                var alphaTL = commands[++cmdIndex] * alpha;
	                var alphaTR = commands[++cmdIndex] * alpha;
	                var alphaBL = commands[++cmdIndex] * alpha;
	                var alphaBR = commands[++cmdIndex] * alpha;

	                fillTint.TL = getTint(commands[++cmdIndex], alphaTL);
	                fillTint.TR = getTint(commands[++cmdIndex], alphaTR);
	                fillTint.BL = getTint(commands[++cmdIndex], alphaBL);
	                fillTint.BR = getTint(commands[++cmdIndex], alphaBR);
	                break;
	            }

	            case Commands.GRADIENT_LINE_STYLE:
	            {
	                lineWidth = commands[++cmdIndex];
	                var gradientLineAlpha = commands[++cmdIndex] * alpha;
	                strokeTint.TL = getTint(commands[++cmdIndex], gradientLineAlpha);
	                strokeTint.TR = getTint(commands[++cmdIndex], gradientLineAlpha);
	                strokeTint.BL = getTint(commands[++cmdIndex], gradientLineAlpha);
	                strokeTint.BR = getTint(commands[++cmdIndex], gradientLineAlpha);
	                break;
	            }

	            case Commands.ARC:
	            {
	                var iteration = 0;
	                var x = commands[++cmdIndex];
	                var y = commands[++cmdIndex];
	                var radius = commands[++cmdIndex];
	                var startAngle = commands[++cmdIndex];
	                var endAngle = commands[++cmdIndex];
	                var anticlockwise = commands[++cmdIndex];
	                var overshoot = commands[++cmdIndex];

	                endAngle -= startAngle;

	                if (anticlockwise)
	                {
	                    if (endAngle < -PI2)
	                    {
	                        endAngle = -PI2;
	                    }
	                    else if (endAngle > 0)
	                    {
	                        endAngle = -PI2 + endAngle % PI2;
	                    }
	                }
	                else if (endAngle > PI2)
	                {
	                    endAngle = PI2;
	                }
	                else if (endAngle < 0)
	                {
	                    endAngle = PI2 + endAngle % PI2;
	                }

	                if (lastPath === null)
	                {
	                    lastPath = new Path(x + Math.cos(startAngle) * radius, y + Math.sin(startAngle) * radius, lineWidth);
	                    path.push(lastPath);
	                    iteration += iterStep;
	                }

	                while (iteration < 1 + overshoot)
	                {
	                    ta = endAngle * iteration + startAngle;
	                    tx = x + Math.cos(ta) * radius;
	                    ty = y + Math.sin(ta) * radius;

	                    lastPath.points.push(new Point(tx, ty, lineWidth));

	                    iteration += iterStep;
	                }

	                ta = endAngle + startAngle;
	                tx = x + Math.cos(ta) * radius;
	                ty = y + Math.sin(ta) * radius;

	                lastPath.points.push(new Point(tx, ty, lineWidth));

	                break;
	            }

	            case Commands.FILL_RECT:
	            {
	                pipeline.batchFillRect(
	                    commands[++cmdIndex],
	                    commands[++cmdIndex],
	                    commands[++cmdIndex],
	                    commands[++cmdIndex],
	                    currentMatrix,
	                    calcMatrix
	                );
	                break;
	            }

	            case Commands.FILL_TRIANGLE:
	            {
	                pipeline.batchFillTriangle(
	                    commands[++cmdIndex],
	                    commands[++cmdIndex],
	                    commands[++cmdIndex],
	                    commands[++cmdIndex],
	                    commands[++cmdIndex],
	                    commands[++cmdIndex],
	                    currentMatrix,
	                    calcMatrix
	                );
	                break;
	            }

	            case Commands.STROKE_TRIANGLE:
	            {
	                pipeline.batchStrokeTriangle(
	                    commands[++cmdIndex],
	                    commands[++cmdIndex],
	                    commands[++cmdIndex],
	                    commands[++cmdIndex],
	                    commands[++cmdIndex],
	                    commands[++cmdIndex],
	                    lineWidth,
	                    currentMatrix,
	                    calcMatrix
	                );
	                break;
	            }

	            case Commands.LINE_TO:
	            {
	                if (lastPath !== null)
	                {
	                    lastPath.points.push(new Point(commands[++cmdIndex], commands[++cmdIndex], lineWidth));
	                }
	                else
	                {
	                    lastPath = new Path(commands[++cmdIndex], commands[++cmdIndex], lineWidth);
	                    path.push(lastPath);
	                }
	                break;
	            }

	            case Commands.MOVE_TO:
	            {
	                lastPath = new Path(commands[++cmdIndex], commands[++cmdIndex], lineWidth);
	                path.push(lastPath);
	                break;
	            }

	            case Commands.SAVE:
	            {
	                matrixStack.push(currentMatrix.copyToArray());
	                break;
	            }

	            case Commands.RESTORE:
	            {
	                currentMatrix.copyFromArray(matrixStack.pop());
	                break;
	            }

	            case Commands.TRANSLATE:
	            {
	                x = commands[++cmdIndex];
	                y = commands[++cmdIndex];
	                currentMatrix.translate(x, y);
	                break;
	            }

	            case Commands.SCALE:
	            {
	                x = commands[++cmdIndex];
	                y = commands[++cmdIndex];
	                currentMatrix.scale(x, y);
	                break;
	            }

	            case Commands.ROTATE:
	            {
	                currentMatrix.rotate(commands[++cmdIndex]);
	                break;
	            }
	        }
	    }

	    renderer.pipelines.postBatch(src);
	};

	GraphicsWebGLRenderer_1 = GraphicsWebGLRenderer;
	return GraphicsWebGLRenderer_1;
}

var GraphicsCanvasRenderer_1;
var hasRequiredGraphicsCanvasRenderer;

function requireGraphicsCanvasRenderer () {
	if (hasRequiredGraphicsCanvasRenderer) return GraphicsCanvasRenderer_1;
	hasRequiredGraphicsCanvasRenderer = 1;
	var Commands = requireCommands();
	var SetTransform = requireSetTransform();

	var GraphicsCanvasRenderer = function (renderer, src, camera, parentMatrix, renderTargetCtx, allowClip)
	{
	    var commandBuffer = src.commandBuffer;
	    var commandBufferLength = commandBuffer.length;

	    var ctx = renderTargetCtx || renderer.currentContext;

	    if (commandBufferLength === 0 || !SetTransform(renderer, ctx, src, camera, parentMatrix))
	    {
	        return;
	    }

	    camera.addToRenderList(src);

	    var lineAlpha = 1;
	    var fillAlpha = 1;
	    var lineColor = 0;
	    var fillColor = 0;
	    var lineWidth = 1;
	    var red = 0;
	    var green = 0;
	    var blue = 0;

	    ctx.beginPath();

	    for (var index = 0; index < commandBufferLength; ++index)
	    {
	        var commandID = commandBuffer[index];

	        switch (commandID)
	        {
	            case Commands.ARC:
	                ctx.arc(
	                    commandBuffer[index + 1],
	                    commandBuffer[index + 2],
	                    commandBuffer[index + 3],
	                    commandBuffer[index + 4],
	                    commandBuffer[index + 5],
	                    commandBuffer[index + 6]
	                );

	                index += 7;
	                break;

	            case Commands.LINE_STYLE:
	                lineWidth = commandBuffer[index + 1];
	                lineColor = commandBuffer[index + 2];
	                lineAlpha = commandBuffer[index + 3];
	                red = ((lineColor & 0xFF0000) >>> 16);
	                green = ((lineColor & 0xFF00) >>> 8);
	                blue = (lineColor & 0xFF);
	                ctx.strokeStyle = 'rgba(' + red + ',' + green + ',' + blue + ',' + lineAlpha + ')';
	                ctx.lineWidth = lineWidth;
	                index += 3;
	                break;

	            case Commands.FILL_STYLE:
	                fillColor = commandBuffer[index + 1];
	                fillAlpha = commandBuffer[index + 2];
	                red = ((fillColor & 0xFF0000) >>> 16);
	                green = ((fillColor & 0xFF00) >>> 8);
	                blue = (fillColor & 0xFF);
	                ctx.fillStyle = 'rgba(' + red + ',' + green + ',' + blue + ',' + fillAlpha + ')';
	                index += 2;
	                break;

	            case Commands.BEGIN_PATH:
	                ctx.beginPath();
	                break;

	            case Commands.CLOSE_PATH:
	                ctx.closePath();
	                break;

	            case Commands.FILL_PATH:
	                if (!allowClip)
	                {
	                    ctx.fill();
	                }
	                break;

	            case Commands.STROKE_PATH:
	                if (!allowClip)
	                {
	                    ctx.stroke();
	                }
	                break;

	            case Commands.FILL_RECT:
	                if (!allowClip)
	                {
	                    ctx.fillRect(
	                        commandBuffer[index + 1],
	                        commandBuffer[index + 2],
	                        commandBuffer[index + 3],
	                        commandBuffer[index + 4]
	                    );
	                }
	                else
	                {
	                    ctx.rect(
	                        commandBuffer[index + 1],
	                        commandBuffer[index + 2],
	                        commandBuffer[index + 3],
	                        commandBuffer[index + 4]
	                    );
	                }
	                index += 4;
	                break;

	            case Commands.FILL_TRIANGLE:
	                ctx.beginPath();
	                ctx.moveTo(commandBuffer[index + 1], commandBuffer[index + 2]);
	                ctx.lineTo(commandBuffer[index + 3], commandBuffer[index + 4]);
	                ctx.lineTo(commandBuffer[index + 5], commandBuffer[index + 6]);
	                ctx.closePath();
	                if (!allowClip)
	                {
	                    ctx.fill();
	                }
	                index += 6;
	                break;

	            case Commands.STROKE_TRIANGLE:
	                ctx.beginPath();
	                ctx.moveTo(commandBuffer[index + 1], commandBuffer[index + 2]);
	                ctx.lineTo(commandBuffer[index + 3], commandBuffer[index + 4]);
	                ctx.lineTo(commandBuffer[index + 5], commandBuffer[index + 6]);
	                ctx.closePath();
	                if (!allowClip)
	                {
	                    ctx.stroke();
	                }
	                index += 6;
	                break;

	            case Commands.LINE_TO:
	                ctx.lineTo(
	                    commandBuffer[index + 1],
	                    commandBuffer[index + 2]
	                );
	                index += 2;
	                break;

	            case Commands.MOVE_TO:
	                ctx.moveTo(
	                    commandBuffer[index + 1],
	                    commandBuffer[index + 2]
	                );
	                index += 2;
	                break;

	            case Commands.LINE_FX_TO:
	                ctx.lineTo(
	                    commandBuffer[index + 1],
	                    commandBuffer[index + 2]
	                );
	                index += 5;
	                break;

	            case Commands.MOVE_FX_TO:
	                ctx.moveTo(
	                    commandBuffer[index + 1],
	                    commandBuffer[index + 2]
	                );
	                index += 5;
	                break;

	            case Commands.SAVE:
	                ctx.save();
	                break;

	            case Commands.RESTORE:
	                ctx.restore();
	                break;

	            case Commands.TRANSLATE:
	                ctx.translate(
	                    commandBuffer[index + 1],
	                    commandBuffer[index + 2]
	                );
	                index += 2;
	                break;

	            case Commands.SCALE:
	                ctx.scale(
	                    commandBuffer[index + 1],
	                    commandBuffer[index + 2]
	                );
	                index += 2;
	                break;

	            case Commands.ROTATE:
	                ctx.rotate(
	                    commandBuffer[index + 1]
	                );
	                index += 1;
	                break;

	            case Commands.GRADIENT_FILL_STYLE:
	                index += 5;
	                break;

	            case Commands.GRADIENT_LINE_STYLE:
	                index += 6;
	                break;
	        }
	    }

	    ctx.restore();
	};

	GraphicsCanvasRenderer_1 = GraphicsCanvasRenderer;
	return GraphicsCanvasRenderer_1;
}

var GraphicsRender;
var hasRequiredGraphicsRender;

function requireGraphicsRender () {
	if (hasRequiredGraphicsRender) return GraphicsRender;
	hasRequiredGraphicsRender = 1;
	var NOOP = requireNOOP();
	var renderWebGL = NOOP;
	var renderCanvas = NOOP;

	if (typeof WEBGL_RENDERER)
	{
	    renderWebGL = requireGraphicsWebGLRenderer();

	    renderCanvas = requireGraphicsCanvasRenderer();
	}

	if (typeof CANVAS_RENDERER)
	{
	    renderCanvas = requireGraphicsCanvasRenderer();
	}

	GraphicsRender = {

	    renderWebGL: renderWebGL,
	    renderCanvas: renderCanvas

	};
	return GraphicsRender;
}

var Graphics_1;
var hasRequiredGraphics;

function requireGraphics () {
	if (hasRequiredGraphics) return Graphics_1;
	hasRequiredGraphics = 1;
	var BaseCamera = requireBaseCamera();
	var Class = requireClass();
	var Commands = requireCommands();
	var Components = requireComponents$2();
	var Ellipse = requireEllipse$2();
	var GameObject = requireGameObject();
	var GetFastValue = requireGetFastValue();
	var GetValue = requireGetValue();
	var MATH_CONST = require_const$c();
	var Render = requireGraphicsRender();

	var Graphics = new Class({

	    Extends: GameObject,

	    Mixins: [
	        Components.AlphaSingle,
	        Components.BlendMode,
	        Components.Depth,
	        Components.Mask,
	        Components.Pipeline,
	        Components.PostPipeline,
	        Components.Transform,
	        Components.Visible,
	        Components.ScrollFactor,
	        Render
	    ],

	    initialize:

	    function Graphics (scene, options)
	    {
	        var x = GetValue(options, 'x', 0);
	        var y = GetValue(options, 'y', 0);

	        GameObject.call(this, scene, 'Graphics');

	        this.setPosition(x, y);
	        this.initPipeline();
	        this.initPostPipeline();

	        this.displayOriginX = 0;

	        this.displayOriginY = 0;

	        this.commandBuffer = [];

	        this.defaultFillColor = -1;

	        this.defaultFillAlpha = 1;

	        this.defaultStrokeWidth = 1;

	        this.defaultStrokeColor = -1;

	        this.defaultStrokeAlpha = 1;

	        this._lineWidth = 1;

	        this.lineStyle(1, 0, 0);
	        this.fillStyle(0, 0);

	        this.setDefaultStyles(options);
	    },

	    setDefaultStyles: function (options)
	    {
	        if (GetValue(options, 'lineStyle', null))
	        {
	            this.defaultStrokeWidth = GetValue(options, 'lineStyle.width', 1);
	            this.defaultStrokeColor = GetValue(options, 'lineStyle.color', 0xffffff);
	            this.defaultStrokeAlpha = GetValue(options, 'lineStyle.alpha', 1);

	            this.lineStyle(this.defaultStrokeWidth, this.defaultStrokeColor, this.defaultStrokeAlpha);
	        }

	        if (GetValue(options, 'fillStyle', null))
	        {
	            this.defaultFillColor = GetValue(options, 'fillStyle.color', 0xffffff);
	            this.defaultFillAlpha = GetValue(options, 'fillStyle.alpha', 1);

	            this.fillStyle(this.defaultFillColor, this.defaultFillAlpha);
	        }

	        return this;
	    },

	    lineStyle: function (lineWidth, color, alpha)
	    {
	        if (alpha === undefined) { alpha = 1; }

	        this.commandBuffer.push(
	            Commands.LINE_STYLE,
	            lineWidth, color, alpha
	        );

	        this._lineWidth = lineWidth;

	        return this;
	    },

	    fillStyle: function (color, alpha)
	    {
	        if (alpha === undefined) { alpha = 1; }

	        this.commandBuffer.push(
	            Commands.FILL_STYLE,
	            color, alpha
	        );

	        return this;
	    },

	    fillGradientStyle: function (topLeft, topRight, bottomLeft, bottomRight, alphaTopLeft, alphaTopRight, alphaBottomLeft, alphaBottomRight)
	    {
	        if (alphaTopLeft === undefined) { alphaTopLeft = 1; }
	        if (alphaTopRight === undefined) { alphaTopRight = alphaTopLeft; }
	        if (alphaBottomLeft === undefined) { alphaBottomLeft = alphaTopLeft; }
	        if (alphaBottomRight === undefined) { alphaBottomRight = alphaTopLeft; }

	        this.commandBuffer.push(
	            Commands.GRADIENT_FILL_STYLE,
	            alphaTopLeft, alphaTopRight, alphaBottomLeft, alphaBottomRight,
	            topLeft, topRight, bottomLeft, bottomRight
	        );

	        return this;
	    },

	    lineGradientStyle: function (lineWidth, topLeft, topRight, bottomLeft, bottomRight, alpha)
	    {
	        if (alpha === undefined) { alpha = 1; }

	        this.commandBuffer.push(
	            Commands.GRADIENT_LINE_STYLE,
	            lineWidth, alpha, topLeft, topRight, bottomLeft, bottomRight
	        );

	        return this;
	    },

	    beginPath: function ()
	    {
	        this.commandBuffer.push(
	            Commands.BEGIN_PATH
	        );

	        return this;
	    },

	    closePath: function ()
	    {
	        this.commandBuffer.push(
	            Commands.CLOSE_PATH
	        );

	        return this;
	    },

	    fillPath: function ()
	    {
	        this.commandBuffer.push(
	            Commands.FILL_PATH
	        );

	        return this;
	    },

	    fill: function ()
	    {
	        this.commandBuffer.push(
	            Commands.FILL_PATH
	        );

	        return this;
	    },

	    strokePath: function ()
	    {
	        this.commandBuffer.push(
	            Commands.STROKE_PATH
	        );

	        return this;
	    },

	    stroke: function ()
	    {
	        this.commandBuffer.push(
	            Commands.STROKE_PATH
	        );

	        return this;
	    },

	    fillCircleShape: function (circle)
	    {
	        return this.fillCircle(circle.x, circle.y, circle.radius);
	    },

	    strokeCircleShape: function (circle)
	    {
	        return this.strokeCircle(circle.x, circle.y, circle.radius);
	    },

	    fillCircle: function (x, y, radius)
	    {
	        this.beginPath();
	        this.arc(x, y, radius, 0, MATH_CONST.PI2);
	        this.fillPath();

	        return this;
	    },

	    strokeCircle: function (x, y, radius)
	    {
	        this.beginPath();
	        this.arc(x, y, radius, 0, MATH_CONST.PI2);
	        this.strokePath();

	        return this;
	    },

	    fillRectShape: function (rect)
	    {
	        return this.fillRect(rect.x, rect.y, rect.width, rect.height);
	    },

	    strokeRectShape: function (rect)
	    {
	        return this.strokeRect(rect.x, rect.y, rect.width, rect.height);
	    },

	    fillRect: function (x, y, width, height)
	    {
	        this.commandBuffer.push(
	            Commands.FILL_RECT,
	            x, y, width, height
	        );

	        return this;
	    },

	    strokeRect: function (x, y, width, height)
	    {
	        var lineWidthHalf = this._lineWidth / 2;
	        var minx = x - lineWidthHalf;
	        var maxx = x + lineWidthHalf;

	        this.beginPath();
	        this.moveTo(x, y);
	        this.lineTo(x, y + height);
	        this.strokePath();

	        this.beginPath();
	        this.moveTo(x + width, y);
	        this.lineTo(x + width, y + height);
	        this.strokePath();

	        this.beginPath();
	        this.moveTo(minx, y);
	        this.lineTo(maxx + width, y);
	        this.strokePath();

	        this.beginPath();
	        this.moveTo(minx, y + height);
	        this.lineTo(maxx + width, y + height);
	        this.strokePath();

	        return this;
	    },

	    fillRoundedRect: function (x, y, width, height, radius)
	    {
	        if (radius === undefined) { radius = 20; }

	        var tl = radius;
	        var tr = radius;
	        var bl = radius;
	        var br = radius;

	        if (typeof radius !== 'number')
	        {
	            tl = GetFastValue(radius, 'tl', 20);
	            tr = GetFastValue(radius, 'tr', 20);
	            bl = GetFastValue(radius, 'bl', 20);
	            br = GetFastValue(radius, 'br', 20);
	        }

	        var convexTL = (tl >= 0);
	        var convexTR = (tr >= 0);
	        var convexBL = (bl >= 0);
	        var convexBR = (br >= 0);

	        tl = Math.abs(tl);
	        tr = Math.abs(tr);
	        bl = Math.abs(bl);
	        br = Math.abs(br);

	        this.beginPath();
	        this.moveTo(x + tl, y);
	        this.lineTo(x + width - tr, y);

	        if (convexTR)
	        {
	            this.arc(x + width - tr, y + tr, tr, -MATH_CONST.TAU, 0);
	        }
	        else
	        {
	            this.arc(x + width, y, tr, Math.PI, MATH_CONST.TAU, true);
	        }

	        this.lineTo(x + width, y + height - br);

	        if (convexBR)
	        {
	            this.arc(x + width - br, y + height - br, br, 0, MATH_CONST.TAU);
	        }
	        else
	        {
	            this.arc(x + width, y + height, br, -MATH_CONST.TAU, Math.PI, true);
	        }

	        this.lineTo(x + bl, y + height);

	        if (convexBL)
	        {
	            this.arc(x + bl, y + height - bl, bl, MATH_CONST.TAU, Math.PI);
	        }
	        else
	        {
	            this.arc(x, y + height, bl, 0, -MATH_CONST.TAU, true);
	        }

	        this.lineTo(x, y + tl);

	        if (convexTL)
	        {
	            this.arc(x + tl, y + tl, tl, -Math.PI, -MATH_CONST.TAU);
	        }
	        else
	        {
	            this.arc(x, y, tl, MATH_CONST.TAU, 0, true);
	        }

	        this.fillPath();

	        return this;
	    },

	    strokeRoundedRect: function (x, y, width, height, radius)
	    {
	        if (radius === undefined) { radius = 20; }

	        var tl = radius;
	        var tr = radius;
	        var bl = radius;
	        var br = radius;

	        var maxRadius = Math.min(width, height) / 2;

	        if (typeof radius !== 'number')
	        {
	            tl = GetFastValue(radius, 'tl', 20);
	            tr = GetFastValue(radius, 'tr', 20);
	            bl = GetFastValue(radius, 'bl', 20);
	            br = GetFastValue(radius, 'br', 20);
	        }

	        var convexTL = (tl >= 0);
	        var convexTR = (tr >= 0);
	        var convexBL = (bl >= 0);
	        var convexBR = (br >= 0);

	        tl = Math.min(Math.abs(tl), maxRadius);
	        tr = Math.min(Math.abs(tr), maxRadius);
	        bl = Math.min(Math.abs(bl), maxRadius);
	        br = Math.min(Math.abs(br), maxRadius);

	        this.beginPath();
	        this.moveTo(x + tl, y);
	        this.lineTo(x + width - tr, y);
	        this.moveTo(x + width - tr, y);

	        if (convexTR)
	        {
	            this.arc(x + width - tr, y + tr, tr, -MATH_CONST.TAU, 0);
	        }
	        else
	        {
	            this.arc(x + width, y, tr, Math.PI, MATH_CONST.TAU, true);
	        }

	        this.lineTo(x + width, y + height - br);
	        this.moveTo(x + width, y + height - br);

	        if (convexBR)
	        {
	            this.arc(x + width - br, y + height - br, br, 0, MATH_CONST.TAU);
	        }
	        else
	        {
	            this.arc(x + width, y + height, br, -MATH_CONST.TAU, Math.PI, true);
	        }

	        this.lineTo(x + bl, y + height);
	        this.moveTo(x + bl, y + height);

	        if (convexBL)
	        {
	            this.arc(x + bl, y + height - bl, bl, MATH_CONST.TAU, Math.PI);
	        }
	        else
	        {
	            this.arc(x, y + height, bl, 0, -MATH_CONST.TAU, true);
	        }

	        this.lineTo(x, y + tl);
	        this.moveTo(x, y + tl);

	        if (convexTL)
	        {
	            this.arc(x + tl, y + tl, tl, -Math.PI, -MATH_CONST.TAU);
	        }
	        else
	        {
	            this.arc(x, y, tl, MATH_CONST.TAU, 0, true);
	        }

	        this.strokePath();

	        return this;
	    },

	    fillPointShape: function (point, size)
	    {
	        return this.fillPoint(point.x, point.y, size);
	    },

	    fillPoint: function (x, y, size)
	    {
	        if (!size || size < 1)
	        {
	            size = 1;
	        }
	        else
	        {
	            x -= (size / 2);
	            y -= (size / 2);
	        }

	        this.commandBuffer.push(
	            Commands.FILL_RECT,
	            x, y, size, size
	        );

	        return this;
	    },

	    fillTriangleShape: function (triangle)
	    {
	        return this.fillTriangle(triangle.x1, triangle.y1, triangle.x2, triangle.y2, triangle.x3, triangle.y3);
	    },

	    strokeTriangleShape: function (triangle)
	    {
	        return this.strokeTriangle(triangle.x1, triangle.y1, triangle.x2, triangle.y2, triangle.x3, triangle.y3);
	    },

	    fillTriangle: function (x0, y0, x1, y1, x2, y2)
	    {
	        this.commandBuffer.push(
	            Commands.FILL_TRIANGLE,
	            x0, y0, x1, y1, x2, y2
	        );

	        return this;
	    },

	    strokeTriangle: function (x0, y0, x1, y1, x2, y2)
	    {
	        this.commandBuffer.push(
	            Commands.STROKE_TRIANGLE,
	            x0, y0, x1, y1, x2, y2
	        );

	        return this;
	    },

	    strokeLineShape: function (line)
	    {
	        return this.lineBetween(line.x1, line.y1, line.x2, line.y2);
	    },

	    lineBetween: function (x1, y1, x2, y2)
	    {
	        this.beginPath();
	        this.moveTo(x1, y1);
	        this.lineTo(x2, y2);
	        this.strokePath();

	        return this;
	    },

	    lineTo: function (x, y)
	    {
	        this.commandBuffer.push(
	            Commands.LINE_TO,
	            x, y
	        );

	        return this;
	    },

	    moveTo: function (x, y)
	    {
	        this.commandBuffer.push(
	            Commands.MOVE_TO,
	            x, y
	        );

	        return this;
	    },

	    strokePoints: function (points, closeShape, closePath, endIndex)
	    {
	        if (closeShape === undefined) { closeShape = false; }
	        if (closePath === undefined) { closePath = false; }
	        if (endIndex === undefined) { endIndex = points.length; }

	        this.beginPath();

	        this.moveTo(points[0].x, points[0].y);

	        for (var i = 1; i < endIndex; i++)
	        {
	            this.lineTo(points[i].x, points[i].y);
	        }

	        if (closeShape)
	        {
	            this.lineTo(points[0].x, points[0].y);
	        }

	        if (closePath)
	        {
	            this.closePath();
	        }

	        this.strokePath();

	        return this;
	    },

	    fillPoints: function (points, closeShape, closePath, endIndex)
	    {
	        if (closeShape === undefined) { closeShape = false; }
	        if (closePath === undefined) { closePath = false; }
	        if (endIndex === undefined) { endIndex = points.length; }

	        this.beginPath();

	        this.moveTo(points[0].x, points[0].y);

	        for (var i = 1; i < endIndex; i++)
	        {
	            this.lineTo(points[i].x, points[i].y);
	        }

	        if (closeShape)
	        {
	            this.lineTo(points[0].x, points[0].y);
	        }

	        if (closePath)
	        {
	            this.closePath();
	        }

	        this.fillPath();

	        return this;
	    },

	    strokeEllipseShape: function (ellipse, smoothness)
	    {
	        if (smoothness === undefined) { smoothness = 32; }

	        var points = ellipse.getPoints(smoothness);

	        return this.strokePoints(points, true);
	    },

	    strokeEllipse: function (x, y, width, height, smoothness)
	    {
	        if (smoothness === undefined) { smoothness = 32; }

	        var ellipse = new Ellipse(x, y, width, height);

	        var points = ellipse.getPoints(smoothness);

	        return this.strokePoints(points, true);
	    },

	    fillEllipseShape: function (ellipse, smoothness)
	    {
	        if (smoothness === undefined) { smoothness = 32; }

	        var points = ellipse.getPoints(smoothness);

	        return this.fillPoints(points, true);
	    },

	    fillEllipse: function (x, y, width, height, smoothness)
	    {
	        if (smoothness === undefined) { smoothness = 32; }

	        var ellipse = new Ellipse(x, y, width, height);

	        var points = ellipse.getPoints(smoothness);

	        return this.fillPoints(points, true);
	    },

	    arc: function (x, y, radius, startAngle, endAngle, anticlockwise, overshoot)
	    {
	        if (anticlockwise === undefined) { anticlockwise = false; }
	        if (overshoot === undefined) { overshoot = 0; }

	        this.commandBuffer.push(
	            Commands.ARC,
	            x, y, radius, startAngle, endAngle, anticlockwise, overshoot
	        );

	        return this;
	    },

	    slice: function (x, y, radius, startAngle, endAngle, anticlockwise, overshoot)
	    {
	        if (anticlockwise === undefined) { anticlockwise = false; }
	        if (overshoot === undefined) { overshoot = 0; }

	        this.commandBuffer.push(Commands.BEGIN_PATH);

	        this.commandBuffer.push(Commands.MOVE_TO, x, y);

	        this.commandBuffer.push(Commands.ARC, x, y, radius, startAngle, endAngle, anticlockwise, overshoot);

	        this.commandBuffer.push(Commands.CLOSE_PATH);

	        return this;
	    },

	    save: function ()
	    {
	        this.commandBuffer.push(
	            Commands.SAVE
	        );

	        return this;
	    },

	    restore: function ()
	    {
	        this.commandBuffer.push(
	            Commands.RESTORE
	        );

	        return this;
	    },

	    translateCanvas: function (x, y)
	    {
	        this.commandBuffer.push(
	            Commands.TRANSLATE,
	            x, y
	        );

	        return this;
	    },

	    scaleCanvas: function (x, y)
	    {
	        this.commandBuffer.push(
	            Commands.SCALE,
	            x, y
	        );

	        return this;
	    },

	    rotateCanvas: function (radians)
	    {
	        this.commandBuffer.push(
	            Commands.ROTATE,
	            radians
	        );

	        return this;
	    },

	    clear: function ()
	    {
	        this.commandBuffer.length = 0;

	        if (this.defaultFillColor > -1)
	        {
	            this.fillStyle(this.defaultFillColor, this.defaultFillAlpha);
	        }

	        if (this.defaultStrokeColor > -1)
	        {
	            this.lineStyle(this.defaultStrokeWidth, this.defaultStrokeColor, this.defaultStrokeAlpha);
	        }

	        return this;
	    },

	    generateTexture: function (key, width, height)
	    {
	        var sys = this.scene.sys;
	        var renderer = sys.game.renderer;

	        if (width === undefined) { width = sys.scale.width; }
	        if (height === undefined) { height = sys.scale.height; }

	        Graphics.TargetCamera.setScene(this.scene);
	        Graphics.TargetCamera.setViewport(0, 0, width, height);
	        Graphics.TargetCamera.scrollX = this.x;
	        Graphics.TargetCamera.scrollY = this.y;

	        var texture;
	        var ctx;
	        var willRead = { willReadFrequently: true };

	        if (typeof key === 'string')
	        {
	            if (sys.textures.exists(key))
	            {

	                texture = sys.textures.get(key);

	                var src = texture.getSourceImage();

	                if (src instanceof HTMLCanvasElement)
	                {
	                    ctx = src.getContext('2d', willRead);
	                }
	            }
	            else
	            {

	                texture = sys.textures.createCanvas(key, width, height);

	                ctx = texture.getSourceImage().getContext('2d', willRead);
	            }
	        }
	        else if (key instanceof HTMLCanvasElement)
	        {

	            ctx = key.getContext('2d', willRead);
	        }

	        if (ctx)
	        {

	            this.renderCanvas(renderer, this, Graphics.TargetCamera, null, ctx, false);

	            if (texture)
	            {
	                texture.refresh();
	            }
	        }

	        return this;
	    },

	    preDestroy: function ()
	    {
	        this.commandBuffer = [];
	    }

	});

	Graphics.TargetCamera = new BaseCamera();

	Graphics_1 = Graphics;
	return Graphics_1;
}

var HasValue_1;
var hasRequiredHasValue;

function requireHasValue () {
	if (hasRequiredHasValue) return HasValue_1;
	hasRequiredHasValue = 1;
	var HasValue = function (source, key)
	{
	    return (source.hasOwnProperty(key));
	};

	HasValue_1 = HasValue;
	return HasValue_1;
}

var _Set;
var hasRequired_Set;

function require_Set () {
	if (hasRequired_Set) return _Set;
	hasRequired_Set = 1;
	var Class = requireClass();

	var Set = new Class({

	    initialize:

	    function Set (elements)
	    {

	        this.entries = [];

	        if (Array.isArray(elements))
	        {
	            for (var i = 0; i < elements.length; i++)
	            {
	                this.set(elements[i]);
	            }
	        }
	    },

	    set: function (value)
	    {
	        if (this.entries.indexOf(value) === -1)
	        {
	            this.entries.push(value);
	        }

	        return this;
	    },

	    get: function (property, value)
	    {
	        for (var i = 0; i < this.entries.length; i++)
	        {
	            var entry = this.entries[i];

	            if (entry[property] === value)
	            {
	                return entry;
	            }
	        }
	    },

	    getArray: function ()
	    {
	        return this.entries.slice(0);
	    },

	    delete: function (value)
	    {
	        var index = this.entries.indexOf(value);

	        if (index > -1)
	        {
	            this.entries.splice(index, 1);
	        }

	        return this;
	    },

	    dump: function ()
	    {

	        console.group('Set');

	        for (var i = 0; i < this.entries.length; i++)
	        {
	            var entry = this.entries[i];
	            console.log(entry);
	        }

	        console.groupEnd();
	    },

	    each: function (callback, callbackScope)
	    {
	        var i;
	        var temp = this.entries.slice();
	        var len = temp.length;

	        if (callbackScope)
	        {
	            for (i = 0; i < len; i++)
	            {
	                if (callback.call(callbackScope, temp[i], i) === false)
	                {
	                    break;
	                }
	            }
	        }
	        else
	        {
	            for (i = 0; i < len; i++)
	            {
	                if (callback(temp[i], i) === false)
	                {
	                    break;
	                }
	            }
	        }

	        return this;
	    },

	    iterate: function (callback, callbackScope)
	    {
	        var i;
	        var len = this.entries.length;

	        if (callbackScope)
	        {
	            for (i = 0; i < len; i++)
	            {
	                if (callback.call(callbackScope, this.entries[i], i) === false)
	                {
	                    break;
	                }
	            }
	        }
	        else
	        {
	            for (i = 0; i < len; i++)
	            {
	                if (callback(this.entries[i], i) === false)
	                {
	                    break;
	                }
	            }
	        }

	        return this;
	    },

	    iterateLocal: function (callbackKey)
	    {
	        var i;
	        var args = [];

	        for (i = 1; i < arguments.length; i++)
	        {
	            args.push(arguments[i]);
	        }

	        var len = this.entries.length;

	        for (i = 0; i < len; i++)
	        {
	            var entry = this.entries[i];

	            entry[callbackKey].apply(entry, args);
	        }

	        return this;
	    },

	    clear: function ()
	    {
	        this.entries.length = 0;

	        return this;
	    },

	    contains: function (value)
	    {
	        return (this.entries.indexOf(value) > -1);
	    },

	    union: function (set)
	    {
	        var newSet = new Set();

	        set.entries.forEach(function (value)
	        {
	            newSet.set(value);
	        });

	        this.entries.forEach(function (value)
	        {
	            newSet.set(value);
	        });

	        return newSet;
	    },

	    intersect: function (set)
	    {
	        var newSet = new Set();

	        this.entries.forEach(function (value)
	        {
	            if (set.contains(value))
	            {
	                newSet.set(value);
	            }
	        });

	        return newSet;
	    },

	    difference: function (set)
	    {
	        var newSet = new Set();

	        this.entries.forEach(function (value)
	        {
	            if (!set.contains(value))
	            {
	                newSet.set(value);
	            }
	        });

	        return newSet;
	    },

	    size: {

	        get: function ()
	        {
	            return this.entries.length;
	        },

	        set: function (value)
	        {
	            if (value < this.entries.length)
	            {
	                return this.entries.length = value;
	            }
	            else
	            {
	                return this.entries.length;
	            }
	        }

	    }

	});

	_Set = Set;
	return _Set;
}

var SpriteWebGLRenderer_1;
var hasRequiredSpriteWebGLRenderer;

function requireSpriteWebGLRenderer () {
	if (hasRequiredSpriteWebGLRenderer) return SpriteWebGLRenderer_1;
	hasRequiredSpriteWebGLRenderer = 1;
	var SpriteWebGLRenderer = function (renderer, src, camera, parentMatrix)
	{
	    camera.addToRenderList(src);

	    src.pipeline.batchSprite(src, camera, parentMatrix);
	};

	SpriteWebGLRenderer_1 = SpriteWebGLRenderer;
	return SpriteWebGLRenderer_1;
}

var SpriteCanvasRenderer_1;
var hasRequiredSpriteCanvasRenderer;

function requireSpriteCanvasRenderer () {
	if (hasRequiredSpriteCanvasRenderer) return SpriteCanvasRenderer_1;
	hasRequiredSpriteCanvasRenderer = 1;
	var SpriteCanvasRenderer = function (renderer, src, camera, parentMatrix)
	{
	    camera.addToRenderList(src);

	    renderer.batchSprite(src, src.frame, camera, parentMatrix);
	};

	SpriteCanvasRenderer_1 = SpriteCanvasRenderer;
	return SpriteCanvasRenderer_1;
}

var SpriteRender;
var hasRequiredSpriteRender;

function requireSpriteRender () {
	if (hasRequiredSpriteRender) return SpriteRender;
	hasRequiredSpriteRender = 1;
	var NOOP = requireNOOP();
	var renderWebGL = NOOP;
	var renderCanvas = NOOP;

	if (typeof WEBGL_RENDERER)
	{
	    renderWebGL = requireSpriteWebGLRenderer();
	}

	if (typeof CANVAS_RENDERER)
	{
	    renderCanvas = requireSpriteCanvasRenderer();
	}

	SpriteRender = {

	    renderWebGL: renderWebGL,
	    renderCanvas: renderCanvas

	};
	return SpriteRender;
}

var Sprite_1;
var hasRequiredSprite;

function requireSprite () {
	if (hasRequiredSprite) return Sprite_1;
	hasRequiredSprite = 1;
	var AnimationState = requireAnimationState();
	var Class = requireClass();
	var Components = requireComponents$2();
	var GameObject = requireGameObject();
	var SpriteRender = requireSpriteRender();

	var Sprite = new Class({

	    Extends: GameObject,

	    Mixins: [
	        Components.Alpha,
	        Components.BlendMode,
	        Components.Depth,
	        Components.Flip,
	        Components.GetBounds,
	        Components.Mask,
	        Components.Origin,
	        Components.Pipeline,
	        Components.PostPipeline,
	        Components.ScrollFactor,
	        Components.Size,
	        Components.TextureCrop,
	        Components.Tint,
	        Components.Transform,
	        Components.Visible,
	        SpriteRender
	    ],

	    initialize:

	    function Sprite (scene, x, y, texture, frame)
	    {
	        GameObject.call(this, scene, 'Sprite');

	        this._crop = this.resetCropObject();

	        this.anims = new AnimationState(this);

	        this.setTexture(texture, frame);
	        this.setPosition(x, y);
	        this.setSizeToFrame();
	        this.setOriginFromFrame();
	        this.initPipeline();
	        this.initPostPipeline(true);
	    },

	    addedToScene: function ()
	    {
	        this.scene.sys.updateList.add(this);
	    },

	    removedFromScene: function ()
	    {
	        this.scene.sys.updateList.remove(this);
	    },

	    preUpdate: function (time, delta)
	    {
	        this.anims.update(time, delta);
	    },

	    play: function (key, ignoreIfPlaying)
	    {
	        return this.anims.play(key, ignoreIfPlaying);
	    },

	    playReverse: function (key, ignoreIfPlaying)
	    {
	        return this.anims.playReverse(key, ignoreIfPlaying);
	    },

	    playAfterDelay: function (key, delay)
	    {
	        return this.anims.playAfterDelay(key, delay);
	    },

	    playAfterRepeat: function (key, repeatCount)
	    {
	        return this.anims.playAfterRepeat(key, repeatCount);
	    },

	    chain: function (key)
	    {
	        return this.anims.chain(key);
	    },

	    stop: function ()
	    {
	        return this.anims.stop();
	    },

	    stopAfterDelay: function (delay)
	    {
	        return this.anims.stopAfterDelay(delay);
	    },

	    stopAfterRepeat: function (repeatCount)
	    {
	        return this.anims.stopAfterRepeat(repeatCount);
	    },

	    stopOnFrame: function (frame)
	    {
	        return this.anims.stopOnFrame(frame);
	    },

	    toJSON: function ()
	    {
	        return Components.ToJSON(this);
	    },

	    preDestroy: function ()
	    {
	        this.anims.destroy();

	        this.anims = undefined;
	    }

	});

	Sprite_1 = Sprite;
	return Sprite_1;
}

var Group_1;
var hasRequiredGroup;

function requireGroup () {
	if (hasRequiredGroup) return Group_1;
	hasRequiredGroup = 1;
	var Actions = requireActions();
	var Class = requireClass();
	var Events = requireEvents$j();
	var EventEmitter = requireEventemitter3();
	var GetAll = requireGetAll();
	var GetFastValue = requireGetFastValue();
	var GetValue = requireGetValue();
	var HasValue = requireHasValue();
	var IsPlainObject = requireIsPlainObject();
	var Range = requireRange();
	var Set = require_Set();
	var Sprite = requireSprite();

	var Group = new Class({

	    Extends: EventEmitter,

	    initialize:

	    function Group (scene, children, config)
	    {
	        EventEmitter.call(this);

	        if (config)
	        {

	            if (children && !Array.isArray(children))
	            {
	                children = [ children ];
	            }
	        }
	        else if (Array.isArray(children))
	        {

	            if (IsPlainObject(children[0]))
	            {

	                config = children;
	                children = null;
	            }
	        }
	        else if (IsPlainObject(children))
	        {

	            config = children;
	            children = null;
	        }

	        this.scene = scene;

	        this.children = new Set();

	        this.isParent = true;

	        this.type = 'Group';

	        this.classType = GetFastValue(config, 'classType', Sprite);

	        this.name = GetFastValue(config, 'name', '');

	        this.active = GetFastValue(config, 'active', true);

	        this.maxSize = GetFastValue(config, 'maxSize', -1);

	        this.defaultKey = GetFastValue(config, 'defaultKey', null);

	        this.defaultFrame = GetFastValue(config, 'defaultFrame', null);

	        this.runChildUpdate = GetFastValue(config, 'runChildUpdate', false);

	        this.createCallback = GetFastValue(config, 'createCallback', null);

	        this.removeCallback = GetFastValue(config, 'removeCallback', null);

	        this.createMultipleCallback = GetFastValue(config, 'createMultipleCallback', null);

	        this.internalCreateCallback = GetFastValue(config, 'internalCreateCallback', null);

	        this.internalRemoveCallback = GetFastValue(config, 'internalRemoveCallback', null);

	        if (children)
	        {
	            this.addMultiple(children);
	        }

	        if (config)
	        {
	            this.createMultiple(config);
	        }

	        this.on(Events.ADDED_TO_SCENE, this.addedToScene, this);
	        this.on(Events.REMOVED_FROM_SCENE, this.removedFromScene, this);
	    },

	    addedToScene: function ()
	    {
	        this.scene.sys.updateList.add(this);
	    },

	    removedFromScene: function ()
	    {
	        this.scene.sys.updateList.remove(this);
	    },

	    create: function (x, y, key, frame, visible, active)
	    {
	        if (x === undefined) { x = 0; }
	        if (y === undefined) { y = 0; }
	        if (key === undefined) { key = this.defaultKey; }
	        if (frame === undefined) { frame = this.defaultFrame; }
	        if (visible === undefined) { visible = true; }
	        if (active === undefined) { active = true; }

	        if (this.isFull())
	        {
	            return null;
	        }

	        var child = new this.classType(this.scene, x, y, key, frame);

	        child.addToDisplayList(this.scene.sys.displayList);
	        child.addToUpdateList();

	        child.visible = visible;
	        child.setActive(active);

	        this.add(child);

	        return child;
	    },

	    createMultiple: function (config)
	    {
	        if (this.isFull())
	        {
	            return [];
	        }

	        if (!Array.isArray(config))
	        {
	            config = [ config ];
	        }

	        var output = [];

	        if (config[0].key)
	        {
	            for (var i = 0; i < config.length; i++)
	            {
	                var entries = this.createFromConfig(config[i]);

	                output = output.concat(entries);
	            }
	        }

	        return output;
	    },

	    createFromConfig: function (options)
	    {
	        if (this.isFull())
	        {
	            return [];
	        }

	        this.classType = GetFastValue(options, 'classType', this.classType);

	        var key = GetFastValue(options, 'key', undefined);
	        var frame = GetFastValue(options, 'frame', null);
	        var visible = GetFastValue(options, 'visible', true);
	        var active = GetFastValue(options, 'active', true);

	        var entries = [];

	        if (key === undefined)
	        {
	            return entries;
	        }
	        else
	        {
	            if (!Array.isArray(key))
	            {
	                key = [ key ];
	            }

	            if (!Array.isArray(frame))
	            {
	                frame = [ frame ];
	            }
	        }

	        var repeat = GetFastValue(options, 'repeat', 0);
	        var randomKey = GetFastValue(options, 'randomKey', false);
	        var randomFrame = GetFastValue(options, 'randomFrame', false);
	        var yoyo = GetFastValue(options, 'yoyo', false);
	        var quantity = GetFastValue(options, 'quantity', false);
	        var frameQuantity = GetFastValue(options, 'frameQuantity', 1);
	        var max = GetFastValue(options, 'max', 0);

	        var range = Range(key, frame, {
	            max: max,
	            qty: (quantity) ? quantity : frameQuantity,
	            random: randomKey,
	            randomB: randomFrame,
	            repeat: repeat,
	            yoyo: yoyo
	        });

	        if (options.createCallback)
	        {
	            this.createCallback = options.createCallback;
	        }

	        if (options.removeCallback)
	        {
	            this.removeCallback = options.removeCallback;
	        }

	        if (options.internalCreateCallback)
	        {
	            this.internalCreateCallback = options.internalCreateCallback;
	        }

	        if (options.internalRemoveCallback)
	        {
	            this.internalRemoveCallback = options.internalRemoveCallback;
	        }

	        for (var c = 0; c < range.length; c++)
	        {
	            var created = this.create(0, 0, range[c].a, range[c].b, visible, active);

	            if (!created)
	            {
	                break;
	            }

	            entries.push(created);
	        }

	        if (HasValue(options, 'setXY'))
	        {
	            var x = GetValue(options, 'setXY.x', 0);
	            var y = GetValue(options, 'setXY.y', 0);
	            var stepX = GetValue(options, 'setXY.stepX', 0);
	            var stepY = GetValue(options, 'setXY.stepY', 0);

	            Actions.SetXY(entries, x, y, stepX, stepY);
	        }

	        if (HasValue(options, 'setRotation'))
	        {
	            var rotation = GetValue(options, 'setRotation.value', 0);
	            var stepRotation = GetValue(options, 'setRotation.step', 0);

	            Actions.SetRotation(entries, rotation, stepRotation);
	        }

	        if (HasValue(options, 'setScale'))
	        {
	            var scaleX = GetValue(options, 'setScale.x', 1);
	            var scaleY = GetValue(options, 'setScale.y', scaleX);
	            var stepScaleX = GetValue(options, 'setScale.stepX', 0);
	            var stepScaleY = GetValue(options, 'setScale.stepY', 0);

	            Actions.SetScale(entries, scaleX, scaleY, stepScaleX, stepScaleY);
	        }

	        if (HasValue(options, 'setOrigin'))
	        {
	            var originX = GetValue(options, 'setOrigin.x', 0.5);
	            var originY = GetValue(options, 'setOrigin.y', originX);
	            var stepOriginX = GetValue(options, 'setOrigin.stepX', 0);
	            var stepOriginY = GetValue(options, 'setOrigin.stepY', 0);

	            Actions.SetOrigin(entries, originX, originY, stepOriginX, stepOriginY);
	        }

	        if (HasValue(options, 'setAlpha'))
	        {
	            var alpha = GetValue(options, 'setAlpha.value', 1);
	            var stepAlpha = GetValue(options, 'setAlpha.step', 0);

	            Actions.SetAlpha(entries, alpha, stepAlpha);
	        }

	        if (HasValue(options, 'setDepth'))
	        {
	            var depth = GetValue(options, 'setDepth.value', 0);
	            var stepDepth = GetValue(options, 'setDepth.step', 0);

	            Actions.SetDepth(entries, depth, stepDepth);
	        }

	        if (HasValue(options, 'setScrollFactor'))
	        {
	            var scrollFactorX = GetValue(options, 'setScrollFactor.x', 1);
	            var scrollFactorY = GetValue(options, 'setScrollFactor.y', scrollFactorX);
	            var stepScrollFactorX = GetValue(options, 'setScrollFactor.stepX', 0);
	            var stepScrollFactorY = GetValue(options, 'setScrollFactor.stepY', 0);

	            Actions.SetScrollFactor(entries, scrollFactorX, scrollFactorY, stepScrollFactorX, stepScrollFactorY);
	        }

	        var hitArea = GetFastValue(options, 'hitArea', null);
	        var hitAreaCallback = GetFastValue(options, 'hitAreaCallback', null);

	        if (hitArea)
	        {
	            Actions.SetHitArea(entries, hitArea, hitAreaCallback);
	        }

	        var grid = GetFastValue(options, 'gridAlign', false);

	        if (grid)
	        {
	            Actions.GridAlign(entries, grid);
	        }

	        if (this.createMultipleCallback)
	        {
	            this.createMultipleCallback.call(this, entries);
	        }

	        return entries;
	    },

	    preUpdate: function (time, delta)
	    {
	        if (!this.runChildUpdate || this.children.size === 0)
	        {
	            return;
	        }

	        var temp = this.children.entries.slice();

	        for (var i = 0; i < temp.length; i++)
	        {
	            var item = temp[i];

	            if (item.active)
	            {
	                item.update(time, delta);
	            }
	        }
	    },

	    add: function (child, addToScene)
	    {
	        if (addToScene === undefined) { addToScene = false; }

	        if (this.isFull())
	        {
	            return this;
	        }

	        this.children.set(child);

	        if (this.internalCreateCallback)
	        {
	            this.internalCreateCallback.call(this, child);
	        }

	        if (this.createCallback)
	        {
	            this.createCallback.call(this, child);
	        }

	        if (addToScene)
	        {
	            child.addToDisplayList(this.scene.sys.displayList);
	            child.addToUpdateList();
	        }

	        child.on(Events.DESTROY, this.remove, this);

	        return this;
	    },

	    addMultiple: function (children, addToScene)
	    {
	        if (addToScene === undefined) { addToScene = false; }

	        if (Array.isArray(children))
	        {
	            for (var i = 0; i < children.length; i++)
	            {
	                this.add(children[i], addToScene);
	            }
	        }

	        return this;
	    },

	    remove: function (child, removeFromScene, destroyChild)
	    {
	        if (removeFromScene === undefined) { removeFromScene = false; }
	        if (destroyChild === undefined) { destroyChild = false; }

	        if (!this.children.contains(child))
	        {
	            return this;
	        }

	        this.children.delete(child);

	        if (this.internalRemoveCallback)
	        {
	            this.internalRemoveCallback.call(this, child);
	        }

	        if (this.removeCallback)
	        {
	            this.removeCallback.call(this, child);
	        }

	        child.off(Events.DESTROY, this.remove, this);

	        if (destroyChild)
	        {
	            child.destroy();
	        }
	        else if (removeFromScene)
	        {
	            child.removeFromDisplayList();
	            child.removeFromUpdateList();
	        }

	        return this;
	    },

	    clear: function (removeFromScene, destroyChild)
	    {
	        if (removeFromScene === undefined) { removeFromScene = false; }
	        if (destroyChild === undefined) { destroyChild = false; }

	        var children = this.children;

	        for (var i = 0; i < children.size; i++)
	        {
	            var gameObject = children.entries[i];

	            gameObject.off(Events.DESTROY, this.remove, this);

	            if (destroyChild)
	            {
	                gameObject.destroy();
	            }
	            else if (removeFromScene)
	            {
	                gameObject.removeFromDisplayList();
	                gameObject.removeFromUpdateList();
	            }
	        }

	        this.children.clear();

	        return this;
	    },

	    contains: function (child)
	    {
	        return this.children.contains(child);
	    },

	    getChildren: function ()
	    {
	        return this.children.entries;
	    },

	    getLength: function ()
	    {
	        return this.children.size;
	    },

	    getMatching: function (property, value, startIndex, endIndex)
	    {
	        return GetAll(this.children.entries, property, value, startIndex, endIndex);
	    },

	    getFirst: function (state, createIfNull, x, y, key, frame, visible)
	    {
	        return this.getHandler(true, 1, state, createIfNull, x, y, key, frame, visible);
	    },

	    getFirstNth: function (nth, state, createIfNull, x, y, key, frame, visible)
	    {
	        return this.getHandler(true, nth, state, createIfNull, x, y, key, frame, visible);
	    },

	    getLast: function (state, createIfNull, x, y, key, frame, visible)
	    {
	        return this.getHandler(false, 1, state, createIfNull, x, y, key, frame, visible);
	    },

	    getLastNth: function (nth, state, createIfNull, x, y, key, frame, visible)
	    {
	        return this.getHandler(false, nth, state, createIfNull, x, y, key, frame, visible);
	    },

	    getHandler: function (forwards, nth, state, createIfNull, x, y, key, frame, visible)
	    {
	        if (state === undefined) { state = false; }
	        if (createIfNull === undefined) { createIfNull = false; }

	        var gameObject;

	        var i;
	        var total = 0;
	        var children = this.children.entries;

	        if (forwards)
	        {
	            for (i = 0; i < children.length; i++)
	            {
	                gameObject = children[i];

	                if (gameObject.active === state)
	                {
	                    total++;

	                    if (total === nth)
	                    {
	                        break;
	                    }
	                }
	                else
	                {
	                    gameObject = null;
	                }
	            }
	        }
	        else
	        {
	            for (i = children.length - 1; i >= 0; i--)
	            {
	                gameObject = children[i];

	                if (gameObject.active === state)
	                {
	                    total++;

	                    if (total === nth)
	                    {
	                        break;
	                    }
	                }
	                else
	                {
	                    gameObject = null;
	                }
	            }
	        }

	        if (gameObject)
	        {
	            if (typeof(x) === 'number')
	            {
	                gameObject.x = x;
	            }

	            if (typeof(y) === 'number')
	            {
	                gameObject.y = y;
	            }

	            return gameObject;
	        }

	        if (createIfNull)
	        {
	            return this.create(x, y, key, frame, visible);
	        }
	        else
	        {
	            return null;
	        }
	    },

	    get: function (x, y, key, frame, visible)
	    {
	        return this.getFirst(false, true, x, y, key, frame, visible);
	    },

	    getFirstAlive: function (createIfNull, x, y, key, frame, visible)
	    {
	        return this.getFirst(true, createIfNull, x, y, key, frame, visible);
	    },

	    getFirstDead: function (createIfNull, x, y, key, frame, visible)
	    {
	        return this.getFirst(false, createIfNull, x, y, key, frame, visible);
	    },

	    playAnimation: function (key, startFrame)
	    {
	        Actions.PlayAnimation(this.children.entries, key, startFrame);

	        return this;
	    },

	    isFull: function ()
	    {
	        if (this.maxSize === -1)
	        {
	            return false;
	        }
	        else
	        {
	            return (this.children.size >= this.maxSize);
	        }
	    },

	    countActive: function (value)
	    {
	        if (value === undefined) { value = true; }

	        var total = 0;

	        for (var i = 0; i < this.children.size; i++)
	        {
	            if (this.children.entries[i].active === value)
	            {
	                total++;
	            }
	        }

	        return total;
	    },

	    getTotalUsed: function ()
	    {
	        return this.countActive();
	    },

	    getTotalFree: function ()
	    {
	        var used = this.getTotalUsed();
	        var capacity = (this.maxSize === -1) ? 999999999999 : this.maxSize;

	        return (capacity - used);
	    },

	    setActive: function (value)
	    {
	        this.active = value;

	        return this;
	    },

	    setName: function (value)
	    {
	        this.name = value;

	        return this;
	    },

	    propertyValueSet: function (key, value, step, index, direction)
	    {
	        Actions.PropertyValueSet(this.children.entries, key, value, step, index, direction);

	        return this;
	    },

	    propertyValueInc: function (key, value, step, index, direction)
	    {
	        Actions.PropertyValueInc(this.children.entries, key, value, step, index, direction);

	        return this;
	    },

	    setX: function (value, step)
	    {
	        Actions.SetX(this.children.entries, value, step);

	        return this;
	    },

	    setY: function (value, step)
	    {
	        Actions.SetY(this.children.entries, value, step);

	        return this;
	    },

	    setXY: function (x, y, stepX, stepY)
	    {
	        Actions.SetXY(this.children.entries, x, y, stepX, stepY);

	        return this;
	    },

	    incX: function (value, step)
	    {
	        Actions.IncX(this.children.entries, value, step);

	        return this;
	    },

	    incY: function (value, step)
	    {
	        Actions.IncY(this.children.entries, value, step);

	        return this;
	    },

	    incXY: function (x, y, stepX, stepY)
	    {
	        Actions.IncXY(this.children.entries, x, y, stepX, stepY);

	        return this;
	    },

	    shiftPosition: function (x, y, direction)
	    {
	        Actions.ShiftPosition(this.children.entries, x, y, direction);

	        return this;
	    },

	    angle: function (value, step)
	    {
	        Actions.Angle(this.children.entries, value, step);

	        return this;
	    },

	    rotate: function (value, step)
	    {
	        Actions.Rotate(this.children.entries, value, step);

	        return this;
	    },

	    rotateAround: function (point, angle)
	    {
	        Actions.RotateAround(this.children.entries, point, angle);

	        return this;
	    },

	    rotateAroundDistance: function (point, angle, distance)
	    {
	        Actions.RotateAroundDistance(this.children.entries, point, angle, distance);

	        return this;
	    },

	    setAlpha: function (value, step)
	    {
	        Actions.SetAlpha(this.children.entries, value, step);

	        return this;
	    },

	    setTint: function (topLeft, topRight, bottomLeft, bottomRight)
	    {
	        Actions.SetTint(this.children.entries, topLeft, topRight, bottomLeft, bottomRight);

	        return this;
	    },

	    setOrigin: function (originX, originY, stepX, stepY)
	    {
	        Actions.SetOrigin(this.children.entries, originX, originY, stepX, stepY);

	        return this;
	    },

	    scaleX: function (value, step)
	    {
	        Actions.ScaleX(this.children.entries, value, step);

	        return this;
	    },

	    scaleY: function (value, step)
	    {
	        Actions.ScaleY(this.children.entries, value, step);

	        return this;
	    },

	    scaleXY: function (scaleX, scaleY, stepX, stepY)
	    {
	        Actions.ScaleXY(this.children.entries, scaleX, scaleY, stepX, stepY);

	        return this;
	    },

	    setDepth: function (value, step)
	    {
	        Actions.SetDepth(this.children.entries, value, step);

	        return this;
	    },

	    setBlendMode: function (value)
	    {
	        Actions.SetBlendMode(this.children.entries, value);

	        return this;
	    },

	    setHitArea: function (hitArea, hitAreaCallback)
	    {
	        Actions.SetHitArea(this.children.entries, hitArea, hitAreaCallback);

	        return this;
	    },

	    shuffle: function ()
	    {
	        Actions.Shuffle(this.children.entries);

	        return this;
	    },

	    kill: function (gameObject)
	    {
	        if (this.children.contains(gameObject))
	        {
	            gameObject.setActive(false);
	        }
	    },

	    killAndHide: function (gameObject)
	    {
	        if (this.children.contains(gameObject))
	        {
	            gameObject.setActive(false);
	            gameObject.setVisible(false);
	        }
	    },

	    setVisible: function (value, index, direction)
	    {
	        Actions.SetVisible(this.children.entries, value, index, direction);

	        return this;
	    },

	    toggleVisible: function ()
	    {
	        Actions.ToggleVisible(this.children.entries);

	        return this;
	    },

	    destroy: function (destroyChildren, removeFromScene)
	    {
	        if (destroyChildren === undefined) { destroyChildren = false; }
	        if (removeFromScene === undefined) { removeFromScene = false; }

	        if (!this.scene || this.ignoreDestroy)
	        {
	            return;
	        }

	        this.emit(Events.DESTROY, this);

	        this.removeAllListeners();

	        this.scene.sys.updateList.remove(this);

	        this.clear(removeFromScene, destroyChildren);

	        this.scene = undefined;
	        this.children = undefined;
	    }

	});

	Group_1 = Group;
	return Group_1;
}

var LayerWebGLRenderer_1;
var hasRequiredLayerWebGLRenderer;

function requireLayerWebGLRenderer () {
	if (hasRequiredLayerWebGLRenderer) return LayerWebGLRenderer_1;
	hasRequiredLayerWebGLRenderer = 1;
	var LayerWebGLRenderer = function (renderer, layer, camera)
	{
	    var children = layer.list;
	    var childCount = children.length;

	    if (childCount === 0)
	    {
	        return;
	    }

	    layer.depthSort();

	    renderer.pipelines.preBatch(layer);

	    var layerHasBlendMode = (layer.blendMode !== -1);

	    if (!layerHasBlendMode)
	    {

	        renderer.setBlendMode(0);
	    }

	    var alpha = layer.alpha;

	    for (var i = 0; i < childCount; i++)
	    {
	        var child = children[i];

	        if (!child.willRender(camera))
	        {
	            continue;
	        }

	        var childAlphaTopLeft;
	        var childAlphaTopRight;
	        var childAlphaBottomLeft;
	        var childAlphaBottomRight;

	        if (child.alphaTopLeft !== undefined)
	        {
	            childAlphaTopLeft = child.alphaTopLeft;
	            childAlphaTopRight = child.alphaTopRight;
	            childAlphaBottomLeft = child.alphaBottomLeft;
	            childAlphaBottomRight = child.alphaBottomRight;
	        }
	        else
	        {
	            var childAlpha = child.alpha;

	            childAlphaTopLeft = childAlpha;
	            childAlphaTopRight = childAlpha;
	            childAlphaBottomLeft = childAlpha;
	            childAlphaBottomRight = childAlpha;
	        }

	        if (!layerHasBlendMode && child.blendMode !== renderer.currentBlendMode)
	        {

	            renderer.setBlendMode(child.blendMode);
	        }

	        var mask = child.mask;

	        if (mask)
	        {
	            mask.preRenderWebGL(renderer, child, camera);
	        }

	        var type = child.type;

	        if (type !== renderer.currentType)
	        {
	            renderer.newType = true;
	            renderer.currentType = type;
	        }

	        renderer.nextTypeMatch = (i < childCount - 1) ? (children[i + 1].type === renderer.currentType) : false;

	        child.setAlpha(childAlphaTopLeft * alpha, childAlphaTopRight * alpha, childAlphaBottomLeft * alpha, childAlphaBottomRight * alpha);

	        child.renderWebGL(renderer, child, camera);

	        child.setAlpha(childAlphaTopLeft, childAlphaTopRight, childAlphaBottomLeft, childAlphaBottomRight);

	        if (mask)
	        {
	            mask.postRenderWebGL(renderer, camera);
	        }

	        renderer.newType = false;
	    }

	    renderer.pipelines.postBatch(layer);
	};

	LayerWebGLRenderer_1 = LayerWebGLRenderer;
	return LayerWebGLRenderer_1;
}

var LayerCanvasRenderer_1;
var hasRequiredLayerCanvasRenderer;

function requireLayerCanvasRenderer () {
	if (hasRequiredLayerCanvasRenderer) return LayerCanvasRenderer_1;
	hasRequiredLayerCanvasRenderer = 1;
	var LayerCanvasRenderer = function (renderer, layer, camera)
	{
	    var children = layer.list;

	    if (children.length === 0)
	    {
	        return;
	    }

	    layer.depthSort();

	    var layerHasBlendMode = (layer.blendMode !== -1);

	    if (!layerHasBlendMode)
	    {

	        renderer.setBlendMode(0);
	    }

	    var alpha = layer._alpha;

	    if (layer.mask)
	    {
	        layer.mask.preRenderCanvas(renderer, null, camera);
	    }

	    for (var i = 0; i < children.length; i++)
	    {
	        var child = children[i];

	        if (!child.willRender(camera))
	        {
	            continue;
	        }

	        var childAlpha = child.alpha;

	        if (!layerHasBlendMode && child.blendMode !== renderer.currentBlendMode)
	        {

	            renderer.setBlendMode(child.blendMode);
	        }

	        child.setAlpha(childAlpha * alpha);

	        child.renderCanvas(renderer, child, camera);

	        child.setAlpha(childAlpha);
	    }

	    if (layer.mask)
	    {
	        layer.mask.postRenderCanvas(renderer);
	    }
	};

	LayerCanvasRenderer_1 = LayerCanvasRenderer;
	return LayerCanvasRenderer_1;
}

var LayerRender;
var hasRequiredLayerRender;

function requireLayerRender () {
	if (hasRequiredLayerRender) return LayerRender;
	hasRequiredLayerRender = 1;
	var NOOP = requireNOOP();
	var renderWebGL = NOOP;
	var renderCanvas = NOOP;

	if (typeof WEBGL_RENDERER)
	{
	    renderWebGL = requireLayerWebGLRenderer();
	}

	if (typeof CANVAS_RENDERER)
	{
	    renderCanvas = requireLayerCanvasRenderer();
	}

	LayerRender = {

	    renderWebGL: renderWebGL,
	    renderCanvas: renderCanvas

	};
	return LayerRender;
}

var Layer_1;
var hasRequiredLayer;

function requireLayer () {
	if (hasRequiredLayer) return Layer_1;
	hasRequiredLayer = 1;
	var BlendModes = requireBlendModes();
	var Class = requireClass();
	var Components = requireComponents$2();
	var ComponentsToJSON = requireToJSON();
	var DataManager = requireDataManager();
	var EventEmitter = requireEventemitter3();
	var GameObjectEvents = requireEvents$j();
	var List = requireList();
	var Render = requireLayerRender();
	var SceneEvents = requireEvents$l();
	var StableSort = requireStableSort();

	var Layer = new Class({

	    Extends: List,

	    Mixins: [
	        Components.AlphaSingle,
	        Components.BlendMode,
	        Components.Depth,
	        Components.Mask,
	        Components.PostPipeline,
	        Components.Visible,
	        EventEmitter,
	        Render
	    ],

	    initialize:

	    function Layer (scene, children)
	    {
	        List.call(this, scene);
	        EventEmitter.call(this);

	        this.scene = scene;

	        this.displayList = null;

	        this.type = 'Layer';

	        this.state = 0;

	        this.parentContainer = null;

	        this.name = '';

	        this.active = true;

	        this.tabIndex = -1;

	        this.data = null;

	        this.renderFlags = 15;

	        this.cameraFilter = 0;

	        this.input = null;

	        this.body = null;

	        this.ignoreDestroy = false;

	        this.systems = scene.sys;

	        this.events = scene.sys.events;

	        this.sortChildrenFlag = false;

	        this.addCallback = this.addChildCallback;
	        this.removeCallback = this.removeChildCallback;

	        this.initPostPipeline();

	        this.clearAlpha();

	        this.setBlendMode(BlendModes.SKIP_CHECK);

	        if (children)
	        {
	            this.add(children);
	        }

	        scene.sys.queueDepthSort();
	    },

	    setActive: function (value)
	    {
	        this.active = value;

	        return this;
	    },

	    setName: function (value)
	    {
	        this.name = value;

	        return this;
	    },

	    setState: function (value)
	    {
	        this.state = value;

	        return this;
	    },

	    setDataEnabled: function ()
	    {
	        if (!this.data)
	        {
	            this.data = new DataManager(this);
	        }

	        return this;
	    },

	    setData: function (key, value)
	    {
	        if (!this.data)
	        {
	            this.data = new DataManager(this);
	        }

	        this.data.set(key, value);

	        return this;
	    },

	    incData: function (key, value)
	    {
	        if (!this.data)
	        {
	            this.data = new DataManager(this);
	        }

	        this.data.inc(key, value);

	        return this;
	    },

	    toggleData: function (key)
	    {
	        if (!this.data)
	        {
	            this.data = new DataManager(this);
	        }

	        this.data.toggle(key);

	        return this;
	    },

	    getData: function (key)
	    {
	        if (!this.data)
	        {
	            this.data = new DataManager(this);
	        }

	        return this.data.get(key);
	    },

	    setInteractive: function ()
	    {
	        return this;
	    },

	    disableInteractive: function ()
	    {
	        return this;
	    },

	    removeInteractive: function ()
	    {
	        return this;
	    },

	    addedToScene: function ()
	    {
	    },

	    removedFromScene: function ()
	    {
	    },

	    update: function ()
	    {
	    },

	    toJSON: function ()
	    {
	        return ComponentsToJSON(this);
	    },

	    willRender: function (camera)
	    {
	        return !(this.renderFlags !== 15 || this.list.length === 0 || (this.cameraFilter !== 0 && (this.cameraFilter & camera.id)));
	    },

	    getIndexList: function ()
	    {

	        var child = this;
	        var parent = this.parentContainer;

	        var indexes = [];

	        while (parent)
	        {
	            indexes.unshift(parent.getIndex(child));

	            child = parent;

	            if (!parent.parentContainer)
	            {
	                break;
	            }
	            else
	            {
	                parent = parent.parentContainer;
	            }
	        }

	        indexes.unshift(this.displayList.getIndex(child));

	        return indexes;
	    },

	    addChildCallback: function (gameObject)
	    {
	        var displayList = gameObject.displayList;

	        if (displayList && displayList !== this)
	        {
	            gameObject.removeFromDisplayList();
	        }

	        if (!gameObject.displayList)
	        {
	            this.queueDepthSort();

	            gameObject.displayList = this;

	            gameObject.emit(GameObjectEvents.ADDED_TO_SCENE, gameObject, this.scene);

	            this.events.emit(SceneEvents.ADDED_TO_SCENE, gameObject, this.scene);
	        }
	    },

	    removeChildCallback: function (gameObject)
	    {
	        this.queueDepthSort();

	        gameObject.displayList = null;

	        gameObject.emit(GameObjectEvents.REMOVED_FROM_SCENE, gameObject, this.scene);

	        this.events.emit(SceneEvents.REMOVED_FROM_SCENE, gameObject, this.scene);
	    },

	    queueDepthSort: function ()
	    {
	        this.sortChildrenFlag = true;
	    },

	    depthSort: function ()
	    {
	        if (this.sortChildrenFlag)
	        {
	            StableSort(this.list, this.sortByDepth);

	            this.sortChildrenFlag = false;
	        }
	    },

	    sortByDepth: function (childA, childB)
	    {
	        return childA._depth - childB._depth;
	    },

	    getChildren: function ()
	    {
	        return this.list;
	    },

	    addToDisplayList: function (displayList)
	    {
	        if (displayList === undefined) { displayList = this.scene.sys.displayList; }

	        if (this.displayList && this.displayList !== displayList)
	        {
	            this.removeFromDisplayList();
	        }

	        if (!displayList.exists(this))
	        {
	            this.displayList = displayList;

	            displayList.add(this, true);

	            displayList.queueDepthSort();

	            this.emit(GameObjectEvents.ADDED_TO_SCENE, this, this.scene);

	            displayList.events.emit(SceneEvents.ADDED_TO_SCENE, this, this.scene);
	        }

	        return this;
	    },

	    removeFromDisplayList: function ()
	    {
	        var displayList = this.displayList || this.scene.sys.displayList;

	        if (displayList.exists(this))
	        {
	            displayList.remove(this, true);

	            displayList.queueDepthSort();

	            this.displayList = null;

	            this.emit(GameObjectEvents.REMOVED_FROM_SCENE, this, this.scene);

	            displayList.events.emit(SceneEvents.REMOVED_FROM_SCENE, this, this.scene);
	        }

	        return this;
	    },

	    getDisplayList: function ()
	    {
	        var list = null;

	        if (this.parentContainer)
	        {
	            list = this.parentContainer.list;
	        }
	        else if (this.displayList)
	        {
	            list = this.displayList.list;
	        }

	        return list;
	    },

	    destroy: function (fromScene)
	    {

	        if (!this.scene || this.ignoreDestroy)
	        {
	            return;
	        }

	        this.emit(GameObjectEvents.DESTROY, this);

	        var list = this.list;

	        while (list.length)
	        {
	            list[0].destroy(fromScene);
	        }

	        this.removeAllListeners();

	        this.resetPostPipeline(true);

	        if (this.displayList)
	        {
	            this.displayList.remove(this, true, false);

	            this.displayList.queueDepthSort();
	        }

	        if (this.data)
	        {
	            this.data.destroy();

	            this.data = undefined;
	        }

	        this.active = false;
	        this.visible = false;

	        this.list = undefined;
	        this.scene = undefined;
	        this.displayList = undefined;
	        this.systems = undefined;
	        this.events = undefined;
	    }

	});

	Layer_1 = Layer;
	return Layer_1;
}

var GetInterpolationFunction_1;
var hasRequiredGetInterpolationFunction;

function requireGetInterpolationFunction () {
	if (hasRequiredGetInterpolationFunction) return GetInterpolationFunction_1;
	hasRequiredGetInterpolationFunction = 1;
	var Bezier = requireBezierInterpolation();
	var CatmullRom = requireCatmullRomInterpolation();
	var Linear = requireLinearInterpolation();

	var FuncMap = {
	    bezier: Bezier,
	    catmull: CatmullRom,
	    catmullrom: CatmullRom,
	    linear: Linear
	};

	var GetInterpolationFunction = function (interpolation)
	{
	    if (interpolation === null)
	    {
	        return null;
	    }

	    var interpolationFunction = FuncMap.linear;

	    if (typeof interpolation === 'string')
	    {

	        if (FuncMap.hasOwnProperty(interpolation))
	        {
	            interpolationFunction = FuncMap[interpolation];
	        }
	    }
	    else if (typeof interpolation === 'function')
	    {

	        interpolationFunction = interpolation;
	    }

	    return interpolationFunction;
	};

	GetInterpolationFunction_1 = GetInterpolationFunction;
	return GetInterpolationFunction_1;
}

var EmitterOp_1;
var hasRequiredEmitterOp;

function requireEmitterOp () {
	if (hasRequiredEmitterOp) return EmitterOp_1;
	hasRequiredEmitterOp = 1;
	var Between = requireBetween$1();
	var Clamp = requireClamp();
	var Class = requireClass();
	var FloatBetween = requireFloatBetween();
	var GetEaseFunction = requireGetEaseFunction();
	var GetFastValue = requireGetFastValue();
	var GetInterpolationFunction = requireGetInterpolationFunction();
	var SnapTo = requireSnapTo();
	var Wrap = requireWrap$1();

	var EmitterOp = new Class({

	    initialize:

	    function EmitterOp (key, defaultValue, emitOnly)
	    {
	        if (emitOnly === undefined) { emitOnly = false; }

	        this.propertyKey = key;

	        this.propertyValue = defaultValue;

	        this.defaultValue = defaultValue;

	        this.steps = 0;

	        this.counter = 0;

	        this.yoyo = false;

	        this.direction = 0;

	        this.start = 0;

	        this.current = 0;

	        this.end = 0;

	        this.ease = null;

	        this.interpolation = null;

	        this.emitOnly = emitOnly;

	        this.onEmit = this.defaultEmit;

	        this.onUpdate = this.defaultUpdate;

	        this.active = true;

	        this.method = 0;

	        this._onEmit;

	        this._onUpdate;
	    },

	    loadConfig: function (config, newKey)
	    {
	        if (config === undefined)
	        {
	            config = {};
	        }

	        if (newKey)
	        {
	            this.propertyKey = newKey;
	        }

	        this.propertyValue = GetFastValue(
	            config,
	            this.propertyKey,
	            this.defaultValue
	        );

	        this.method = this.getMethod();

	        this.setMethods();

	        if (this.emitOnly)
	        {

	            this.onUpdate = this.defaultUpdate;
	        }
	    },

	    toJSON: function ()
	    {
	        return JSON.stringify(this.propertyValue);
	    },

	    onChange: function (value)
	    {
	        var current;

	        switch (this.method)
	        {

	            case 1:
	            case 3:
	            case 8:
	                current = value;
	                break;

	            case 2:
	                if (this.propertyValue.indexOf(value) >= 0)
	                {
	                    current = value;
	                }
	                break;

	            case 4:
	                var step = (this.end - this.start) / this.steps;
	                current = SnapTo(value, step);
	                this.counter = current;
	                break;

	            case 5:
	            case 6:
	            case 7:
	                current = Clamp(value, this.start, this.end);
	                break;

	            case 9:
	                current = this.start[0];
	                break;
	        }

	        this.current = current;

	        return this;
	    },

	    getMethod: function ()
	    {
	        var value = this.propertyValue;

	        if (value === null)
	        {
	            return 0;
	        }

	        var t = typeof value;

	        if (t === 'number')
	        {

	            return 1;
	        }
	        else if (Array.isArray(value))
	        {

	            return 2;
	        }
	        else if (t === 'function')
	        {

	            return 3;
	        }
	        else if (t === 'object')
	        {
	            if (this.hasBoth(value, 'start', 'end'))
	            {
	                if (this.has(value, 'steps'))
	                {

	                    return 4;
	                }
	                else
	                {

	                    return 5;
	                }
	            }
	            else if (this.hasBoth(value, 'min', 'max'))
	            {

	                return 6;
	            }
	            else if (this.has(value, 'random'))
	            {

	                return 7;
	            }
	            else if (this.hasEither(value, 'onEmit', 'onUpdate'))
	            {

	                return 8;
	            }
	            else if (this.hasEither(value, 'values', 'interpolation'))
	            {

	                return 9;
	            }
	        }

	        return 0;
	    },

	    setMethods: function ()
	    {
	        var value = this.propertyValue;
	        var current = value;

	        var onEmit = this.defaultEmit;
	        var onUpdate = this.defaultUpdate;

	        switch (this.method)
	        {

	            case 1:
	                onEmit = this.staticValueEmit;
	                break;

	            case 2:
	                onEmit = this.randomStaticValueEmit;
	                current = value[0];
	                break;

	            case 3:
	                this._onEmit = value;
	                onEmit = this.proxyEmit;
	                current = this.defaultValue;
	                break;

	            case 4:
	                this.start = value.start;
	                this.end = value.end;
	                this.steps = value.steps;
	                this.counter = this.start;
	                this.yoyo = this.has(value, 'yoyo') ? value.yoyo : false;
	                this.direction = 0;
	                onEmit = this.steppedEmit;
	                current = this.start;
	                break;

	            case 5:
	                this.start = value.start;
	                this.end = value.end;
	                var easeType = this.has(value, 'ease') ? value.ease : 'Linear';
	                this.ease = GetEaseFunction(easeType, value.easeParams);
	                onEmit = (this.has(value, 'random') && value.random) ? this.randomRangedValueEmit : this.easedValueEmit;
	                onUpdate = this.easeValueUpdate;
	                current = this.start;
	                break;

	            case 6:
	                this.start = value.min;
	                this.end = value.max;
	                onEmit = (this.has(value, 'int') && value.int) ? this.randomRangedIntEmit : this.randomRangedValueEmit;
	                current = this.start;
	                break;

	            case 7:
	                var rnd = value.random;

	                if (Array.isArray(rnd))
	                {
	                    this.start = rnd[0];
	                    this.end = rnd[1];
	                }

	                onEmit = this.randomRangedIntEmit;
	                current = this.start;
	                break;

	            case 8:
	                this._onEmit = (this.has(value, 'onEmit')) ? value.onEmit : this.defaultEmit;
	                this._onUpdate = (this.has(value, 'onUpdate')) ? value.onUpdate : this.defaultUpdate;
	                onEmit = this.proxyEmit;
	                onUpdate = this.proxyUpdate;
	                current = this.defaultValue;
	                break;

	            case 9:
	                this.start = value.values;
	                var easeTypeI = this.has(value, 'ease') ? value.ease : 'Linear';
	                this.ease = GetEaseFunction(easeTypeI, value.easeParams);
	                this.interpolation = GetInterpolationFunction(value.interpolation);
	                onEmit = this.easedValueEmit;
	                onUpdate = this.easeValueUpdate;
	                current = this.start[0];
	                break;
	        }

	        this.onEmit = onEmit;
	        this.onUpdate = onUpdate;
	        this.current = current;

	        return this;
	    },

	    has: function (object, key)
	    {
	        return object.hasOwnProperty(key);
	    },

	    hasBoth: function (object, key1, key2)
	    {
	        return object.hasOwnProperty(key1) && object.hasOwnProperty(key2);
	    },

	    hasEither: function (object, key1, key2)
	    {
	        return object.hasOwnProperty(key1) || object.hasOwnProperty(key2);
	    },

	    defaultEmit: function ()
	    {
	        return this.defaultValue;
	    },

	    defaultUpdate: function (particle, key, t, value)
	    {
	        return value;
	    },

	    proxyEmit: function (particle, key, value)
	    {
	        var result = this._onEmit(particle, key, value);

	        this.current = result;

	        return result;
	    },

	    proxyUpdate: function (particle, key, t, value)
	    {
	        var result = this._onUpdate(particle, key, t, value);

	        this.current = result;

	        return result;
	    },

	    staticValueEmit: function ()
	    {
	        return this.current;
	    },

	    staticValueUpdate: function ()
	    {
	        return this.current;
	    },

	    randomStaticValueEmit: function ()
	    {
	        var randomIndex = Math.floor(Math.random() * this.propertyValue.length);

	        this.current = this.propertyValue[randomIndex];

	        return this.current;
	    },

	    randomRangedValueEmit: function (particle, key)
	    {
	        var value = FloatBetween(this.start, this.end);

	        if (particle && particle.data[key])
	        {
	            particle.data[key].min = value;
	            particle.data[key].max = this.end;
	        }

	        this.current = value;

	        return value;
	    },

	    randomRangedIntEmit: function (particle, key)
	    {
	        var value = Between(this.start, this.end);

	        if (particle && particle.data[key])
	        {
	            particle.data[key].min = value;
	            particle.data[key].max = this.end;
	        }

	        this.current = value;

	        return value;
	    },

	    steppedEmit: function ()
	    {
	        var current = this.counter;

	        var next = current;

	        var step = (this.end - this.start) / this.steps;

	        if (this.yoyo)
	        {
	            var over;

	            if (this.direction === 0)
	            {

	                next += step;

	                if (next >= this.end)
	                {
	                    over = next - this.end;

	                    next = this.end - over;

	                    this.direction = 1;
	                }
	            }
	            else
	            {

	                next -= step;

	                if (next <= this.start)
	                {
	                    over = this.start - next;

	                    next = this.start + over;

	                    this.direction = 0;
	                }
	            }

	            this.counter = next;
	        }
	        else
	        {
	            this.counter = Wrap(next + step, this.start, this.end);
	        }

	        this.current = current;

	        return current;
	    },

	    easedValueEmit: function (particle, key)
	    {
	        if (particle && particle.data[key])
	        {
	            var data = particle.data[key];

	            data.min = this.start;
	            data.max = this.end;
	        }

	        this.current = this.start;

	        return this.start;
	    },

	    easeValueUpdate: function (particle, key, t)
	    {
	        var data = particle.data[key];

	        var current;
	        var v = this.ease(t);

	        if (this.interpolation)
	        {
	            current = this.interpolation(this.start, v);
	        }
	        else
	        {
	            current = (data.max - data.min) * v + data.min;
	        }

	        this.current = current;

	        return current;
	    },

	    destroy: function ()
	    {
	        this.propertyValue = null;
	        this.defaultValue = null;
	        this.ease = null;
	        this.interpolation = null;
	        this._onEmit = null;
	        this._onUpdate = null;
	    }
	});

	EmitterOp_1 = EmitterOp;
	return EmitterOp_1;
}

var EmitterColorOp_1;
var hasRequiredEmitterColorOp;

function requireEmitterColorOp () {
	if (hasRequiredEmitterColorOp) return EmitterColorOp_1;
	hasRequiredEmitterColorOp = 1;
	var Class = requireClass();
	var EmitterOp = requireEmitterOp();
	var GetColor = requireGetColor();
	var GetEaseFunction = requireGetEaseFunction();
	var GetInterpolationFunction = requireGetInterpolationFunction();
	var IntegerToRGB = requireIntegerToRGB();

	var EmitterColorOp = new Class({

	    Extends: EmitterOp,

	    initialize:

	    function EmitterColorOp (key)
	    {
	        EmitterOp.call(this, key, null, false);

	        this.active = false;

	        this.easeName = 'Linear';

	        this.r = [];

	        this.g = [];

	        this.b = [];
	    },

	    getMethod: function ()
	    {
	        return (this.propertyValue === null) ? 0 : 9;
	    },

	    setMethods: function ()
	    {
	        var value = this.propertyValue;
	        var current = value;

	        var onEmit = this.defaultEmit;
	        var onUpdate = this.defaultUpdate;

	        if (this.method === 9)
	        {
	            this.start = value[0];
	            this.ease = GetEaseFunction('Linear');
	            this.interpolation = GetInterpolationFunction('linear');

	            onEmit = this.easedValueEmit;
	            onUpdate = this.easeValueUpdate;
	            current = value[0];

	            this.active = true;

	            this.r.length = 0;
	            this.g.length = 0;
	            this.b.length = 0;

	            for (var i = 0; i < value.length; i++)
	            {

	                var color = IntegerToRGB(value[i]);

	                this.r.push(color.r);
	                this.g.push(color.g);
	                this.b.push(color.b);
	            }
	        }

	        this.onEmit = onEmit;
	        this.onUpdate = onUpdate;
	        this.current = current;

	        return this;
	    },

	    setEase: function (value)
	    {
	        this.easeName = value;

	        this.ease = GetEaseFunction(value);
	    },

	    easedValueEmit: function ()
	    {
	        this.current = this.start;

	        return this.start;
	    },

	    easeValueUpdate: function (particle, key, t)
	    {
	        var v = this.ease(t);

	        var r = this.interpolation(this.r, v);
	        var g = this.interpolation(this.g, v);
	        var b = this.interpolation(this.b, v);

	        var current = GetColor(r, g, b);

	        this.current = current;

	        return current;
	    }

	});

	EmitterColorOp_1 = EmitterColorOp;
	return EmitterColorOp_1;
}

var COMPLETE_EVENT$2;
var hasRequiredCOMPLETE_EVENT$2;

function requireCOMPLETE_EVENT$2 () {
	if (hasRequiredCOMPLETE_EVENT$2) return COMPLETE_EVENT$2;
	hasRequiredCOMPLETE_EVENT$2 = 1;
	COMPLETE_EVENT$2 = 'complete';
	return COMPLETE_EVENT$2;
}

var DEATH_ZONE_EVENT;
var hasRequiredDEATH_ZONE_EVENT;

function requireDEATH_ZONE_EVENT () {
	if (hasRequiredDEATH_ZONE_EVENT) return DEATH_ZONE_EVENT;
	hasRequiredDEATH_ZONE_EVENT = 1;
	DEATH_ZONE_EVENT = 'deathzone';
	return DEATH_ZONE_EVENT;
}

var EXPLODE_EVENT;
var hasRequiredEXPLODE_EVENT;

function requireEXPLODE_EVENT () {
	if (hasRequiredEXPLODE_EVENT) return EXPLODE_EVENT;
	hasRequiredEXPLODE_EVENT = 1;
	EXPLODE_EVENT = 'explode';
	return EXPLODE_EVENT;
}

var START_EVENT;
var hasRequiredSTART_EVENT;

function requireSTART_EVENT () {
	if (hasRequiredSTART_EVENT) return START_EVENT;
	hasRequiredSTART_EVENT = 1;
	START_EVENT = 'start';
	return START_EVENT;
}

var STOP_EVENT$1;
var hasRequiredSTOP_EVENT$1;

function requireSTOP_EVENT$1 () {
	if (hasRequiredSTOP_EVENT$1) return STOP_EVENT$1;
	hasRequiredSTOP_EVENT$1 = 1;
	STOP_EVENT$1 = 'stop';
	return STOP_EVENT$1;
}

var events$6;
var hasRequiredEvents$6;

function requireEvents$6 () {
	if (hasRequiredEvents$6) return events$6;
	hasRequiredEvents$6 = 1;
	events$6 = {

	    COMPLETE: requireCOMPLETE_EVENT$2(),
	    DEATH_ZONE: requireDEATH_ZONE_EVENT(),
	    EXPLODE: requireEXPLODE_EVENT(),
	    START: requireSTART_EVENT(),
	    STOP: requireSTOP_EVENT$1()

	};
	return events$6;
}

var ParticleProcessor_1;
var hasRequiredParticleProcessor;

function requireParticleProcessor () {
	if (hasRequiredParticleProcessor) return ParticleProcessor_1;
	hasRequiredParticleProcessor = 1;
	var Class = requireClass();

	var ParticleProcessor = new Class({

	    initialize:

	    function ParticleProcessor (x, y, active)
	    {
	        if (x === undefined) { x = 0; }
	        if (y === undefined) { y = 0; }
	        if (active === undefined) { active = true; }

	        this.emitter;

	        this.x = x;

	        this.y = y;

	        this.active = active;
	    },

	    update: function ()
	    {
	    },

	    destroy: function ()
	    {
	        this.emitter = null;
	    }

	});

	ParticleProcessor_1 = ParticleProcessor;
	return ParticleProcessor_1;
}

var GravityWell_1;
var hasRequiredGravityWell;

function requireGravityWell () {
	if (hasRequiredGravityWell) return GravityWell_1;
	hasRequiredGravityWell = 1;
	var Class = requireClass();
	var GetFastValue = requireGetFastValue();
	var ParticleProcessor = requireParticleProcessor();

	var GravityWell = new Class({

	    Extends: ParticleProcessor,

	    initialize:

	    function GravityWell (x, y, power, epsilon, gravity)
	    {
	        if (typeof x === 'object')
	        {
	            var config = x;

	            x = GetFastValue(config, 'x', 0);
	            y = GetFastValue(config, 'y', 0);
	            power = GetFastValue(config, 'power', 0);
	            epsilon = GetFastValue(config, 'epsilon', 100);
	            gravity = GetFastValue(config, 'gravity', 50);
	        }
	        else
	        {
	            if (x === undefined) { x = 0; }
	            if (y === undefined) { y = 0; }
	            if (power === undefined) { power = 0; }
	            if (epsilon === undefined) { epsilon = 100; }
	            if (gravity === undefined) { gravity = 50; }
	        }

	        ParticleProcessor.call(this, x, y, true);

	        this._gravity = gravity;

	        this._power = power * gravity;

	        this._epsilon = epsilon * epsilon;
	    },

	    update: function (particle, delta)
	    {
	        var x = this.x - particle.x;
	        var y = this.y - particle.y;
	        var dSq = x * x + y * y;

	        if (dSq === 0)
	        {
	            return;
	        }

	        var d = Math.sqrt(dSq);

	        if (dSq < this._epsilon)
	        {
	            dSq = this._epsilon;
	        }

	        var factor = ((this._power * delta) / (dSq * d)) * 100;

	        particle.velocityX += x * factor;
	        particle.velocityY += y * factor;
	    },

	    epsilon: {

	        get: function ()
	        {
	            return Math.sqrt(this._epsilon);
	        },

	        set: function (value)
	        {
	            this._epsilon = value * value;
	        }

	    },

	    power: {

	        get: function ()
	        {
	            return this._power / this._gravity;
	        },

	        set: function (value)
	        {
	            this._power = value * this._gravity;
	        }

	    },

	    gravity: {

	        get: function ()
	        {
	            return this._gravity;
	        },

	        set: function (value)
	        {
	            var pwr = this.power;
	            this._gravity = value;
	            this.power = pwr;
	        }

	    }

	});

	GravityWell_1 = GravityWell;
	return GravityWell_1;
}

var Particle_1;
var hasRequiredParticle;

function requireParticle () {
	if (hasRequiredParticle) return Particle_1;
	hasRequiredParticle = 1;
	var AnimationState = requireAnimationState();
	var Clamp = requireClamp();
	var Class = requireClass();
	var DegToRad = requireDegToRad();
	var Rectangle = requireRectangle$2();
	var RotateAround = requireRotateAround$1();
	var Vector2 = requireVector2();

	var Particle = new Class({

	    initialize:

	    function Particle (emitter)
	    {

	        this.emitter = emitter;

	        this.texture = null;

	        this.frame = null;

	        this.x = 0;

	        this.y = 0;

	        this.worldPosition = new Vector2();

	        this.velocityX = 0;

	        this.velocityY = 0;

	        this.accelerationX = 0;

	        this.accelerationY = 0;

	        this.maxVelocityX = 10000;

	        this.maxVelocityY = 10000;

	        this.bounce = 0;

	        this.scaleX = 1;

	        this.scaleY = 1;

	        this.alpha = 1;

	        this.angle = 0;

	        this.rotation = 0;

	        this.tint = 0xffffff;

	        this.life = 1000;

	        this.lifeCurrent = 1000;

	        this.delayCurrent = 0;

	        this.holdCurrent = 0;

	        this.lifeT = 0;

	        this.data = {
	            tint: { min: 0xffffff, max: 0xffffff },
	            alpha: { min: 1, max: 1 },
	            rotate: { min: 0, max: 0 },
	            scaleX: { min: 1, max: 1 },
	            scaleY: { min: 1, max: 1 },
	            x: { min: 0, max: 0 },
	            y: { min: 0, max: 0 },
	            accelerationX: { min: 0, max: 0 },
	            accelerationY: { min: 0, max: 0 },
	            maxVelocityX: { min: 0, max: 0 },
	            maxVelocityY: { min: 0, max: 0 },
	            moveToX: { min: 0, max: 0 },
	            moveToY: { min: 0, max: 0 },
	            bounce: { min: 0, max: 0 }
	        };

	        this.isCropped = false;

	        this.scene = emitter.scene;

	        this.anims = null;

	        if (this.emitter.anims.length > 0)
	        {
	            this.anims = new AnimationState(this);
	        }

	        this.bounds = new Rectangle();
	    },

	    emit: function (event, a1, a2, a3, a4, a5)
	    {
	        return this.emitter.emit(event, a1, a2, a3, a4, a5);
	    },

	    isAlive: function ()
	    {
	        return (this.lifeCurrent > 0);
	    },

	    kill: function ()
	    {
	        this.lifeCurrent = 0;
	    },

	    setPosition: function (x, y)
	    {
	        if (x === undefined) { x = 0; }
	        if (y === undefined) { y = 0; }

	        this.x = x;
	        this.y = y;
	    },

	    fire: function (x, y)
	    {
	        var emitter = this.emitter;
	        var ops = emitter.ops;

	        var anim = emitter.getAnim();

	        if (anim)
	        {
	            this.anims.play(anim);
	        }
	        else
	        {
	            this.frame = emitter.getFrame();
	            this.texture = this.frame.texture;
	        }

	        if (!this.frame)
	        {
	            throw new Error('Particle has no texture frame');
	        }

	        emitter.getEmitZone(this);

	        if (x === undefined)
	        {
	            this.x += ops.x.onEmit(this, 'x');
	        }
	        else if (ops.x.steps > 0)
	        {

	            this.x += x + ops.x.onEmit(this, 'x');
	        }
	        else
	        {
	            this.x += x;
	        }

	        if (y === undefined)
	        {
	            this.y += ops.y.onEmit(this, 'y');
	        }
	        else if (ops.y.steps > 0)
	        {

	            this.y += y + ops.y.onEmit(this, 'y');
	        }
	        else
	        {
	            this.y += y;
	        }

	        this.life = ops.lifespan.onEmit(this, 'lifespan');
	        this.lifeCurrent = this.life;
	        this.lifeT = 0;

	        this.delayCurrent = ops.delay.onEmit(this, 'delay');
	        this.holdCurrent = ops.hold.onEmit(this, 'hold');

	        this.scaleX = ops.scaleX.onEmit(this, 'scaleX');
	        this.scaleY = (ops.scaleY.active) ? ops.scaleY.onEmit(this, 'scaleY') : this.scaleX;

	        this.angle = ops.rotate.onEmit(this, 'rotate');

	        this.rotation = DegToRad(this.angle);

	        emitter.worldMatrix.transformPoint(this.x, this.y, this.worldPosition);

	        if (this.delayCurrent === 0 && emitter.getDeathZone(this))
	        {
	            this.lifeCurrent = 0;

	            return false;
	        }

	        var sx = ops.speedX.onEmit(this, 'speedX');
	        var sy = (ops.speedY.active) ? ops.speedY.onEmit(this, 'speedY') : sx;

	        if (emitter.radial)
	        {
	            var rad = DegToRad(ops.angle.onEmit(this, 'angle'));

	            this.velocityX = Math.cos(rad) * Math.abs(sx);
	            this.velocityY = Math.sin(rad) * Math.abs(sy);
	        }
	        else if (emitter.moveTo)
	        {
	            var mx = ops.moveToX.onEmit(this, 'moveToX');
	            var my = ops.moveToY.onEmit(this, 'moveToY');
	            var lifeS = this.life / 1000;

	            this.velocityX = (mx - this.x) / lifeS;
	            this.velocityY = (my - this.y) / lifeS;
	        }
	        else
	        {
	            this.velocityX = sx;
	            this.velocityY = sy;
	        }

	        if (emitter.acceleration)
	        {
	            this.accelerationX = ops.accelerationX.onEmit(this, 'accelerationX');
	            this.accelerationY = ops.accelerationY.onEmit(this, 'accelerationY');
	        }

	        this.maxVelocityX = ops.maxVelocityX.onEmit(this, 'maxVelocityX');
	        this.maxVelocityY = ops.maxVelocityY.onEmit(this, 'maxVelocityY');

	        this.bounce = ops.bounce.onEmit(this, 'bounce');

	        this.alpha = ops.alpha.onEmit(this, 'alpha');

	        if (ops.color.active)
	        {
	            this.tint = ops.color.onEmit(this, 'tint');
	        }
	        else
	        {
	            this.tint = ops.tint.onEmit(this, 'tint');
	        }

	        return true;
	    },

	    update: function (delta, step, processors)
	    {
	        if (this.lifeCurrent <= 0)
	        {

	            if (this.holdCurrent > 0)
	            {
	                this.holdCurrent -= delta;

	                return (this.holdCurrent <= 0);
	            }
	            else
	            {
	                return true;
	            }
	        }

	        if (this.delayCurrent > 0)
	        {
	            this.delayCurrent -= delta;

	            return false;
	        }

	        if (this.anims)
	        {
	            this.anims.update(0, delta);
	        }

	        var emitter = this.emitter;
	        var ops = emitter.ops;

	        var t = 1 - (this.lifeCurrent / this.life);

	        this.lifeT = t;

	        this.x = ops.x.onUpdate(this, 'x', t, this.x);
	        this.y = ops.y.onUpdate(this, 'y', t, this.y);

	        if (emitter.moveTo)
	        {
	            var mx = ops.moveToX.onUpdate(this, 'moveToX', t, emitter.moveToX);
	            var my = ops.moveToY.onUpdate(this, 'moveToY', t, emitter.moveToY);
	            var lifeS = this.lifeCurrent / 1000;

	            this.velocityX = (mx - this.x) / lifeS;
	            this.velocityY = (my - this.y) / lifeS;
	        }

	        this.computeVelocity(emitter, delta, step, processors, t);

	        this.scaleX = ops.scaleX.onUpdate(this, 'scaleX', t, this.scaleX);

	        if (ops.scaleY.active)
	        {
	            this.scaleY = ops.scaleY.onUpdate(this, 'scaleY', t, this.scaleY);
	        }
	        else
	        {
	            this.scaleY = this.scaleX;
	        }

	        this.angle = ops.rotate.onUpdate(this, 'rotate', t, this.angle);

	        this.rotation = DegToRad(this.angle);

	        if (emitter.getDeathZone(this))
	        {
	            this.lifeCurrent = 0;

	            return true;
	        }

	        this.alpha = Clamp(ops.alpha.onUpdate(this, 'alpha', t, this.alpha), 0, 1);

	        if (ops.color.active)
	        {
	            this.tint = ops.color.onUpdate(this, 'color', t, this.tint);
	        }
	        else
	        {
	            this.tint = ops.tint.onUpdate(this, 'tint', t, this.tint);
	        }

	        this.lifeCurrent -= delta;

	        return (this.lifeCurrent <= 0 && this.holdCurrent <= 0);
	    },

	    computeVelocity: function (emitter, delta, step, processors, t)
	    {
	        var ops = emitter.ops;

	        var vx = this.velocityX;
	        var vy = this.velocityY;

	        var ax = ops.accelerationX.onUpdate(this, 'accelerationX', t, this.accelerationX);
	        var ay = ops.accelerationY.onUpdate(this, 'accelerationY', t, this.accelerationY);

	        var mx = ops.maxVelocityX.onUpdate(this, 'maxVelocityX', t, this.maxVelocityX);
	        var my = ops.maxVelocityY.onUpdate(this, 'maxVelocityY', t, this.maxVelocityY);

	        this.bounce = ops.bounce.onUpdate(this, 'bounce', t, this.bounce);

	        vx += (emitter.gravityX * step) + (ax * step);
	        vy += (emitter.gravityY * step) + (ay * step);

	        vx = Clamp(vx, -mx, mx);
	        vy = Clamp(vy, -my, my);

	        this.velocityX = vx;
	        this.velocityY = vy;

	        this.x += vx * step;
	        this.y += vy * step;

	        emitter.worldMatrix.transformPoint(this.x, this.y, this.worldPosition);

	        for (var i = 0; i < processors.length; i++)
	        {
	            var processor = processors[i];

	            if (processor.active)
	            {
	                processor.update(this, delta, step, t);
	            }
	        }
	    },

	    setSizeToFrame: function ()
	    {

	    },

	    getBounds: function (matrix)
	    {
	        if (matrix === undefined) { matrix = this.emitter.getWorldTransformMatrix(); }

	        var sx = Math.abs(matrix.scaleX) * this.scaleX;
	        var sy = Math.abs(matrix.scaleY) * this.scaleY;

	        var x = this.x;
	        var y = this.y;
	        var rotation = this.rotation;
	        var width = (this.frame.width * sx) / 2;
	        var height = (this.frame.height * sy) / 2;

	        var bounds = this.bounds;

	        var topLeft = new Vector2(x - width, y - height);
	        var topRight = new Vector2(x + width, y - height);
	        var bottomLeft = new Vector2(x - width, y + height);
	        var bottomRight = new Vector2(x + width, y + height);

	        if (rotation !== 0)
	        {
	            RotateAround(topLeft, x, y, rotation);
	            RotateAround(topRight, x, y, rotation);
	            RotateAround(bottomLeft, x, y, rotation);
	            RotateAround(bottomRight, x, y, rotation);
	        }

	        matrix.transformPoint(topLeft.x, topLeft.y, topLeft);
	        matrix.transformPoint(topRight.x, topRight.y, topRight);
	        matrix.transformPoint(bottomLeft.x, bottomLeft.y, bottomLeft);
	        matrix.transformPoint(bottomRight.x, bottomRight.y, bottomRight);

	        bounds.x = Math.min(topLeft.x, topRight.x, bottomLeft.x, bottomRight.x);
	        bounds.y = Math.min(topLeft.y, topRight.y, bottomLeft.y, bottomRight.y);
	        bounds.width = Math.max(topLeft.x, topRight.x, bottomLeft.x, bottomRight.x) - bounds.x;
	        bounds.height = Math.max(topLeft.y, topRight.y, bottomLeft.y, bottomRight.y) - bounds.y;

	        return bounds;
	    },

	    destroy: function ()
	    {
	        if (this.anims)
	        {
	            this.anims.destroy();
	        }

	        this.anims = null;
	        this.emitter = null;
	        this.texture = null;
	        this.frame = null;
	        this.scene = null;
	    }

	});

	Particle_1 = Particle;
	return Particle_1;
}

var ParticleBounds_1;
var hasRequiredParticleBounds;

function requireParticleBounds () {
	if (hasRequiredParticleBounds) return ParticleBounds_1;
	hasRequiredParticleBounds = 1;
	var Class = requireClass();
	var ParticleProcessor = requireParticleProcessor();
	var Rectangle = requireRectangle$2();

	var ParticleBounds = new Class({

	    Extends: ParticleProcessor,

	    initialize:

	    function ParticleBounds (x, y, width, height, collideLeft, collideRight, collideTop, collideBottom)
	    {
	        if (collideLeft === undefined) { collideLeft = true; }
	        if (collideRight === undefined) { collideRight = true; }
	        if (collideTop === undefined) { collideTop = true; }
	        if (collideBottom === undefined) { collideBottom = true; }

	        ParticleProcessor.call(this, x, y, true);

	        this.bounds = new Rectangle(x, y, width, height);

	        this.collideLeft = collideLeft;

	        this.collideRight = collideRight;

	        this.collideTop = collideTop;

	        this.collideBottom = collideBottom;
	    },

	    update: function (particle)
	    {
	        var bounds = this.bounds;
	        var bounce = -particle.bounce;
	        var pos = particle.worldPosition;

	        if (pos.x < bounds.x && this.collideLeft)
	        {
	            particle.x += bounds.x - pos.x;
	            particle.velocityX *= bounce;
	        }
	        else if (pos.x > bounds.right && this.collideRight)
	        {
	            particle.x -= pos.x - bounds.right;
	            particle.velocityX *= bounce;
	        }

	        if (pos.y < bounds.y && this.collideTop)
	        {
	            particle.y += bounds.y - pos.y;
	            particle.velocityY *= bounce;
	        }
	        else if (pos.y > bounds.bottom && this.collideBottom)
	        {
	            particle.y -= pos.y - bounds.bottom;
	            particle.velocityY *= bounce;
	        }
	    }

	});

	ParticleBounds_1 = ParticleBounds;
	return ParticleBounds_1;
}

var CopyFrom_1$5;
var hasRequiredCopyFrom$5;

function requireCopyFrom$5 () {
	if (hasRequiredCopyFrom$5) return CopyFrom_1$5;
	hasRequiredCopyFrom$5 = 1;
	var CopyFrom = function (source, dest)
	{
	    return dest.setTo(source.x, source.y, source.width, source.height);
	};

	CopyFrom_1$5 = CopyFrom;
	return CopyFrom_1$5;
}

var DeathZone_1;
var hasRequiredDeathZone;

function requireDeathZone () {
	if (hasRequiredDeathZone) return DeathZone_1;
	hasRequiredDeathZone = 1;
	var Class = requireClass();

	var DeathZone = new Class({

	    initialize:

	    function DeathZone (source, killOnEnter)
	    {

	        this.source = source;

	        this.killOnEnter = killOnEnter;
	    },

	    willKill: function (particle)
	    {
	        var pos = particle.worldPosition;
	        var withinZone = this.source.contains(pos.x, pos.y);

	        return (withinZone && this.killOnEnter || !withinZone && !this.killOnEnter);
	    }

	});

	DeathZone_1 = DeathZone;
	return DeathZone_1;
}

var EdgeZone_1;
var hasRequiredEdgeZone;

function requireEdgeZone () {
	if (hasRequiredEdgeZone) return EdgeZone_1;
	hasRequiredEdgeZone = 1;
	var Class = requireClass();

	var EdgeZone = new Class({

	    initialize:

	    function EdgeZone (source, quantity, stepRate, yoyo, seamless, total)
	    {
	        if (yoyo === undefined) { yoyo = false; }
	        if (seamless === undefined) { seamless = true; }
	        if (total === undefined) { total = -1; }

	        this.source = source;

	        this.points = [];

	        this.quantity = quantity;

	        this.stepRate = stepRate;

	        this.yoyo = yoyo;

	        this.counter = -1;

	        this.seamless = seamless;

	        this._length = 0;

	        this._direction = 0;

	        this.total = total;

	        this.updateSource();
	    },

	    updateSource: function ()
	    {
	        this.points = this.source.getPoints(this.quantity, this.stepRate);

	        if (this.seamless)
	        {
	            var a = this.points[0];
	            var b = this.points[this.points.length - 1];

	            if (a.x === b.x && a.y === b.y)
	            {
	                this.points.pop();
	            }
	        }

	        var oldLength = this._length;

	        this._length = this.points.length;

	        if (this._length < oldLength && this.counter > this._length)
	        {
	            this.counter = this._length - 1;
	        }

	        return this;
	    },

	    changeSource: function (source)
	    {
	        this.source = source;

	        return this.updateSource();
	    },

	    getPoint: function (particle)
	    {
	        if (this._direction === 0)
	        {
	            this.counter++;

	            if (this.counter >= this._length)
	            {
	                if (this.yoyo)
	                {
	                    this._direction = 1;
	                    this.counter = this._length - 1;
	                }
	                else
	                {
	                    this.counter = 0;
	                }
	            }
	        }
	        else
	        {
	            this.counter--;

	            if (this.counter === -1)
	            {
	                if (this.yoyo)
	                {
	                    this._direction = 0;
	                    this.counter = 0;
	                }
	                else
	                {
	                    this.counter = this._length - 1;
	                }
	            }
	        }

	        var point = this.points[this.counter];

	        if (point)
	        {
	            particle.x = point.x;
	            particle.y = point.y;
	        }
	    }

	});

	EdgeZone_1 = EdgeZone;
	return EdgeZone_1;
}

var HasAll_1;
var hasRequiredHasAll;

function requireHasAll () {
	if (hasRequiredHasAll) return HasAll_1;
	hasRequiredHasAll = 1;
	var HasAll = function (source, keys)
	{
	    for (var i = 0; i < keys.length; i++)
	    {
	        if (!source.hasOwnProperty(keys[i]))
	        {
	            return false;
	        }
	    }

	    return true;
	};

	HasAll_1 = HasAll;
	return HasAll_1;
}

var HasAny_1;
var hasRequiredHasAny;

function requireHasAny () {
	if (hasRequiredHasAny) return HasAny_1;
	hasRequiredHasAny = 1;
	var HasAny = function (source, keys)
	{
	    for (var i = 0; i < keys.length; i++)
	    {
	        if (source.hasOwnProperty(keys[i]))
	        {
	            return true;
	        }
	    }

	    return false;
	};

	HasAny_1 = HasAny;
	return HasAny_1;
}

var Inflate_1;
var hasRequiredInflate;

function requireInflate () {
	if (hasRequiredInflate) return Inflate_1;
	hasRequiredInflate = 1;
	var CenterOn = requireCenterOn$2();

	var Inflate = function (rect, x, y)
	{
	    var cx = rect.centerX;
	    var cy = rect.centerY;

	    rect.setSize(rect.width + (x * 2), rect.height + (y * 2));

	    return CenterOn(rect, cx, cy);
	};

	Inflate_1 = Inflate;
	return Inflate_1;
}

var MergeRect_1;
var hasRequiredMergeRect;

function requireMergeRect () {
	if (hasRequiredMergeRect) return MergeRect_1;
	hasRequiredMergeRect = 1;
	var MergeRect = function (target, source)
	{
	    var minX = Math.min(target.x, source.x);
	    var maxX = Math.max(target.right, source.right);

	    target.x = minX;
	    target.width = maxX - minX;

	    var minY = Math.min(target.y, source.y);
	    var maxY = Math.max(target.bottom, source.bottom);

	    target.y = minY;
	    target.height = maxY - minY;

	    return target;
	};

	MergeRect_1 = MergeRect;
	return MergeRect_1;
}

var MergeRight_1;
var hasRequiredMergeRight;

function requireMergeRight () {
	if (hasRequiredMergeRight) return MergeRight_1;
	hasRequiredMergeRight = 1;
	var Clone = requireClone$7();

	var MergeRight = function (obj1, obj2)
	{
	    var clone = Clone(obj1);

	    for (var key in obj2)
	    {
	        if (clone.hasOwnProperty(key))
	        {
	            clone[key] = obj2[key];
	        }
	    }

	    return clone;
	};

	MergeRight_1 = MergeRight;
	return MergeRight_1;
}

var RandomZone_1;
var hasRequiredRandomZone;

function requireRandomZone () {
	if (hasRequiredRandomZone) return RandomZone_1;
	hasRequiredRandomZone = 1;
	var Class = requireClass();
	var Vector2 = requireVector2();

	var RandomZone = new Class({

	    initialize:

	    function RandomZone (source)
	    {

	        this.source = source;

	        this._tempVec = new Vector2();

	        this.total = -1;
	    },

	    getPoint: function (particle)
	    {
	        var vec = this._tempVec;

	        this.source.getRandomPoint(vec);

	        particle.x = vec.x;
	        particle.y = vec.y;
	    }

	});

	RandomZone_1 = RandomZone;
	return RandomZone_1;
}

var RectangleToRectangle_1;
var hasRequiredRectangleToRectangle;

function requireRectangleToRectangle () {
	if (hasRequiredRectangleToRectangle) return RectangleToRectangle_1;
	hasRequiredRectangleToRectangle = 1;
	var RectangleToRectangle = function (rectA, rectB)
	{
	    if (rectA.width <= 0 || rectA.height <= 0 || rectB.width <= 0 || rectB.height <= 0)
	    {
	        return false;
	    }

	    return !(rectA.right < rectB.x || rectA.bottom < rectB.y || rectA.x > rectB.right || rectA.y > rectB.bottom);
	};

	RectangleToRectangle_1 = RectangleToRectangle;
	return RectangleToRectangle_1;
}

var ParticleEmitterWebGLRenderer_1;
var hasRequiredParticleEmitterWebGLRenderer;

function requireParticleEmitterWebGLRenderer () {
	if (hasRequiredParticleEmitterWebGLRenderer) return ParticleEmitterWebGLRenderer_1;
	hasRequiredParticleEmitterWebGLRenderer = 1;
	var RectangleToRectangle = requireRectangleToRectangle();
	var TransformMatrix = requireTransformMatrix();
	var Utils = requireUtils$1();

	var tempMatrix1 = new TransformMatrix();
	var tempMatrix2 = new TransformMatrix();
	var tempMatrix3 = new TransformMatrix();
	var tempMatrix4 = new TransformMatrix();

	var ParticleEmitterWebGLRenderer = function (renderer, emitter, camera, parentMatrix)
	{
	    var pipeline = renderer.pipelines.set(emitter.pipeline);

	    var camMatrix = tempMatrix1;
	    var calcMatrix = tempMatrix2;
	    var particleMatrix = tempMatrix3;
	    var managerMatrix = tempMatrix4;

	    if (parentMatrix)
	    {
	        managerMatrix.loadIdentity();
	        managerMatrix.multiply(parentMatrix);
	        managerMatrix.translate(emitter.x, emitter.y);
	        managerMatrix.rotate(emitter.rotation);
	        managerMatrix.scale(emitter.scaleX, emitter.scaleY);
	    }
	    else
	    {
	        managerMatrix.applyITRS(emitter.x, emitter.y, emitter.rotation, emitter.scaleX, emitter.scaleY);
	    }

	    var getTint = Utils.getTintAppendFloatAlpha;
	    var camerAlpha = camera.alpha;
	    var emitterAlpha = emitter.alpha;

	    renderer.pipelines.preBatch(emitter);

	    var particles = emitter.alive;
	    var particleCount = particles.length;
	    var viewBounds = emitter.viewBounds;

	    if (particleCount === 0 || (viewBounds && !RectangleToRectangle(viewBounds, camera.worldView)))
	    {
	        return;
	    }

	    if (emitter.sortCallback)
	    {
	        emitter.depthSort();
	    }

	    camera.addToRenderList(emitter);

	    camMatrix.copyFrom(camera.matrix);

	    camMatrix.multiplyWithOffset(managerMatrix, -camera.scrollX * emitter.scrollFactorX, -camera.scrollY * emitter.scrollFactorY);

	    renderer.setBlendMode(emitter.blendMode);

	    if (emitter.mask)
	    {
	        emitter.mask.preRenderWebGL(renderer, emitter, camera);

	        renderer.pipelines.set(emitter.pipeline);
	    }

	    var tintEffect = emitter.tintFill;
	    var textureUnit;
	    var glTexture;

	    for (var i = 0; i < particleCount; i++)
	    {
	        var particle = particles[i];

	        var alpha = particle.alpha * emitterAlpha * camerAlpha;

	        if (alpha <= 0 || particle.scaleX === 0 || particle.scaleY === 0)
	        {
	            continue;
	        }

	        particleMatrix.applyITRS(particle.x, particle.y, particle.rotation, particle.scaleX, particle.scaleY);

	        particleMatrix.e = particle.x;
	        particleMatrix.f = particle.y;

	        camMatrix.multiply(particleMatrix, calcMatrix);

	        var frame = particle.frame;

	        if (frame.glTexture !== glTexture)
	        {
	            glTexture = frame.glTexture;

	            textureUnit = pipeline.setGameObject(emitter, frame);
	        }

	        var x = -frame.halfWidth;
	        var y = -frame.halfHeight;

	        var quad = calcMatrix.setQuad(x, y, x + frame.width, y + frame.height);

	        var tint = getTint(particle.tint, alpha);

	        if (pipeline.shouldFlush(6))
	        {
	            pipeline.flush();

	            textureUnit = pipeline.setGameObject(emitter, frame);
	        }

	        pipeline.batchQuad(
	            emitter,
	            quad[0], quad[1], quad[2], quad[3], quad[4], quad[5], quad[6], quad[7],
	            frame.u0, frame.v0, frame.u1, frame.v1,
	            tint, tint, tint, tint,
	            tintEffect,
	            glTexture,
	            textureUnit
	        );
	    }

	    if (emitter.mask)
	    {
	        emitter.mask.postRenderWebGL(renderer, camera);
	    }

	    renderer.pipelines.postBatch(emitter);
	};

	ParticleEmitterWebGLRenderer_1 = ParticleEmitterWebGLRenderer;
	return ParticleEmitterWebGLRenderer_1;
}

var ParticleEmitterCanvasRenderer_1;
var hasRequiredParticleEmitterCanvasRenderer;

function requireParticleEmitterCanvasRenderer () {
	if (hasRequiredParticleEmitterCanvasRenderer) return ParticleEmitterCanvasRenderer_1;
	hasRequiredParticleEmitterCanvasRenderer = 1;
	var RectangleToRectangle = requireRectangleToRectangle();
	var TransformMatrix = requireTransformMatrix();

	var tempMatrix1 = new TransformMatrix();
	var tempMatrix2 = new TransformMatrix();
	var tempMatrix3 = new TransformMatrix();
	var tempMatrix4 = new TransformMatrix();

	var ParticleEmitterCanvasRenderer = function (renderer, emitter, camera, parentMatrix)
	{
	    var camMatrix = tempMatrix1;
	    var calcMatrix = tempMatrix2;
	    var particleMatrix = tempMatrix3;
	    var managerMatrix = tempMatrix4;

	    if (parentMatrix)
	    {
	        managerMatrix.loadIdentity();
	        managerMatrix.multiply(parentMatrix);
	        managerMatrix.translate(emitter.x, emitter.y);
	        managerMatrix.rotate(emitter.rotation);
	        managerMatrix.scale(emitter.scaleX, emitter.scaleY);
	    }
	    else
	    {
	        managerMatrix.applyITRS(emitter.x, emitter.y, emitter.rotation, emitter.scaleX, emitter.scaleY);
	    }

	    var ctx = renderer.currentContext;
	    var roundPixels = camera.roundPixels;
	    var camerAlpha = camera.alpha;
	    var emitterAlpha = emitter.alpha;

	    var particles = emitter.alive;
	    var particleCount = particles.length;
	    var viewBounds = emitter.viewBounds;

	    if (!emitter.visible || particleCount === 0 || (viewBounds && !RectangleToRectangle(viewBounds, camera.worldView)))
	    {
	        return;
	    }

	    if (emitter.sortCallback)
	    {
	        emitter.depthSort();
	    }

	    camera.addToRenderList(emitter);

	    var scrollFactorX = emitter.scrollFactorX;
	    var scrollFactorY = emitter.scrollFactorY;

	    ctx.save();

	    ctx.globalCompositeOperation = renderer.blendModes[emitter.blendMode];

	    for (var i = 0; i < particleCount; i++)
	    {
	        var particle = particles[i];

	        var alpha = particle.alpha * emitterAlpha * camerAlpha;

	        if (alpha <= 0 || particle.scaleX === 0 || particle.scaleY === 0)
	        {
	            continue;
	        }

	        particleMatrix.applyITRS(particle.x, particle.y, particle.rotation, particle.scaleX, particle.scaleY);

	        camMatrix.copyFrom(camera.matrix);

	        camMatrix.multiplyWithOffset(managerMatrix, -camera.scrollX * scrollFactorX, -camera.scrollY * scrollFactorY);

	        particleMatrix.e = particle.x;
	        particleMatrix.f = particle.y;

	        camMatrix.multiply(particleMatrix, calcMatrix);

	        var frame = particle.frame;
	        var cd = frame.canvasData;

	        if (cd.width > 0 && cd.height > 0)
	        {
	            var x = -(frame.halfWidth);
	            var y = -(frame.halfHeight);

	            ctx.globalAlpha = alpha;

	            ctx.save();

	            calcMatrix.setToContext(ctx);

	            if (roundPixels)
	            {
	                x = Math.round(x);
	                y = Math.round(y);
	            }

	            ctx.imageSmoothingEnabled = !frame.source.scaleMode;

	            ctx.drawImage(frame.source.image, cd.x, cd.y, cd.width, cd.height, x, y, cd.width, cd.height);

	            ctx.restore();
	        }
	    }

	    ctx.restore();
	};

	ParticleEmitterCanvasRenderer_1 = ParticleEmitterCanvasRenderer;
	return ParticleEmitterCanvasRenderer_1;
}

var ParticleEmitterRender;
var hasRequiredParticleEmitterRender;

function requireParticleEmitterRender () {
	if (hasRequiredParticleEmitterRender) return ParticleEmitterRender;
	hasRequiredParticleEmitterRender = 1;
	var NOOP = requireNOOP();
	var renderWebGL = NOOP;
	var renderCanvas = NOOP;

	if (typeof WEBGL_RENDERER)
	{
	    renderWebGL = requireParticleEmitterWebGLRenderer();
	}

	if (typeof CANVAS_RENDERER)
	{
	    renderCanvas = requireParticleEmitterCanvasRenderer();
	}

	ParticleEmitterRender = {

	    renderWebGL: renderWebGL,
	    renderCanvas: renderCanvas

	};
	return ParticleEmitterRender;
}

var ParticleEmitter_1;
var hasRequiredParticleEmitter;

function requireParticleEmitter () {
	if (hasRequiredParticleEmitter) return ParticleEmitter_1;
	hasRequiredParticleEmitter = 1;
	var Class = requireClass();
	var Components = requireComponents$2();
	var ComponentsToJSON = requireToJSON();
	var CopyFrom = requireCopyFrom$5();
	var DeathZone = requireDeathZone();
	var EdgeZone = requireEdgeZone();
	var EmitterColorOp = requireEmitterColorOp();
	var EmitterOp = requireEmitterOp();
	var Events = requireEvents$6();
	var GameObject = requireGameObject();
	var GetFastValue = requireGetFastValue();
	var GetRandom = requireGetRandom();
	var GravityWell = requireGravityWell();
	var HasAll = requireHasAll();
	var HasAny = requireHasAny();
	var HasValue = requireHasValue();
	var Inflate = requireInflate();
	var List = requireList();
	var MergeRect = requireMergeRect();
	var MergeRight = requireMergeRight();
	var Particle = requireParticle();
	var ParticleBounds = requireParticleBounds();
	var RandomZone = requireRandomZone();
	var Rectangle = requireRectangle$2();
	var RectangleToRectangle = requireRectangleToRectangle();
	var Remove = requireRemove();
	var Render = requireParticleEmitterRender();
	var StableSort = requireStableSort();
	var TransformMatrix = requireTransformMatrix();
	var Vector2 = requireVector2();
	var Wrap = requireWrap$1();

	var configFastMap = [
	    'active',
	    'advance',
	    'blendMode',
	    'colorEase',
	    'deathCallback',
	    'deathCallbackScope',
	    'duration',
	    'emitCallback',
	    'emitCallbackScope',
	    'follow',
	    'frequency',
	    'gravityX',
	    'gravityY',
	    'maxAliveParticles',
	    'maxParticles',
	    'name',
	    'emitting',
	    'particleBringToTop',
	    'particleClass',
	    'radial',
	    'sortCallback',
	    'sortOrderAsc',
	    'sortProperty',
	    'stopAfter',
	    'tintFill',
	    'timeScale',
	    'trackVisible',
	    'visible'
	];

	var configOpMap = [
	    'accelerationX',
	    'accelerationY',
	    'alpha',
	    'angle',
	    'bounce',
	    'color',
	    'delay',
	    'hold',
	    'lifespan',
	    'maxVelocityX',
	    'maxVelocityY',
	    'moveToX',
	    'moveToY',
	    'quantity',
	    'rotate',
	    'scaleX',
	    'scaleY',
	    'speedX',
	    'speedY',
	    'tint',
	    'x',
	    'y'
	];

	var ParticleEmitter = new Class({

	    Extends: GameObject,

	    Mixins: [
	        Components.AlphaSingle,
	        Components.BlendMode,
	        Components.Depth,
	        Components.Mask,
	        Components.Pipeline,
	        Components.PostPipeline,
	        Components.ScrollFactor,
	        Components.Texture,
	        Components.Transform,
	        Components.Visible,
	        Render
	    ],

	    initialize:

	    function ParticleEmitter (scene, x, y, texture, config)
	    {
	        GameObject.call(this, scene, 'ParticleEmitter');

	        this.particleClass = Particle;

	        this.config = null;

	        this.ops = {
	            accelerationX: new EmitterOp('accelerationX', 0),
	            accelerationY: new EmitterOp('accelerationY', 0),
	            alpha: new EmitterOp('alpha', 1),
	            angle: new EmitterOp('angle', { min: 0, max: 360 }, true),
	            bounce: new EmitterOp('bounce', 0),
	            color: new EmitterColorOp('color'),
	            delay: new EmitterOp('delay', 0, true),
	            hold: new EmitterOp('hold', 0, true),
	            lifespan: new EmitterOp('lifespan', 1000, true),
	            maxVelocityX: new EmitterOp('maxVelocityX', 10000),
	            maxVelocityY: new EmitterOp('maxVelocityY', 10000),
	            moveToX: new EmitterOp('moveToX', 0),
	            moveToY: new EmitterOp('moveToY', 0),
	            quantity: new EmitterOp('quantity', 1, true),
	            rotate: new EmitterOp('rotate', 0),
	            scaleX: new EmitterOp('scaleX', 1),
	            scaleY: new EmitterOp('scaleY', 1),
	            speedX: new EmitterOp('speedX', 0, true),
	            speedY: new EmitterOp('speedY', 0, true),
	            tint: new EmitterOp('tint', 0xffffff),
	            x: new EmitterOp('x', 0),
	            y: new EmitterOp('y', 0)
	        };

	        this.radial = true;

	        this.gravityX = 0;

	        this.gravityY = 0;

	        this.acceleration = false;

	        this.moveTo = false;

	        this.emitCallback = null;

	        this.emitCallbackScope = null;

	        this.deathCallback = null;

	        this.deathCallbackScope = null;

	        this.maxParticles = 0;

	        this.maxAliveParticles = 0;

	        this.stopAfter = 0;

	        this.duration = 0;

	        this.frequency = 0;

	        this.emitting = true;

	        this.particleBringToTop = true;

	        this.timeScale = 1;

	        this.emitZones = [];

	        this.deathZones = [];

	        this.viewBounds = null;

	        this.follow = null;

	        this.followOffset = new Vector2();

	        this.trackVisible = false;

	        this.frames = [];

	        this.randomFrame = true;

	        this.frameQuantity = 1;

	        this.anims = [];

	        this.randomAnim = true;

	        this.animQuantity = 1;

	        this.dead = [];

	        this.alive = [];

	        this.counters = new Float32Array(10);

	        this.skipping = false;

	        this.worldMatrix = new TransformMatrix();

	        this.sortProperty = '';

	        this.sortOrderAsc = true;

	        this.sortCallback = this.depthSortCallback;

	        this.processors = new List(this);

	        this.tintFill = false;

	        this.initPipeline();
	        this.initPostPipeline();

	        this.setPosition(x, y);
	        this.setTexture(texture);

	        if (config)
	        {
	            this.setConfig(config);
	        }
	    },

	    addedToScene: function ()
	    {
	        this.scene.sys.updateList.add(this);
	    },

	    removedFromScene: function ()
	    {
	        this.scene.sys.updateList.remove(this);
	    },

	    setConfig: function (config)
	    {
	        if (!config)
	        {
	            return this;
	        }

	        this.config = config;

	        var i = 0;
	        var key = '';

	        var ops = this.ops;

	        for (i = 0; i < configOpMap.length; i++)
	        {
	            key = configOpMap[i];

	            ops[key].loadConfig(config);
	        }

	        for (i = 0; i < configFastMap.length; i++)
	        {
	            key = configFastMap[i];

	            if (HasValue(config, key))
	            {
	                this[key] = GetFastValue(config, key);
	            }
	        }

	        this.acceleration = (this.accelerationX !== 0 || this.accelerationY !== 0);

	        this.moveTo = HasAll(config, [ 'moveToX', 'moveToY' ]);

	        if (HasValue(config, 'speed'))
	        {
	            ops.speedX.loadConfig(config, 'speed');
	            ops.speedY.active = false;
	        }

	        if (HasAny(config, [ 'speedX', 'speedY' ]) || this.moveTo)
	        {
	            this.radial = false;
	        }

	        if (HasValue(config, 'scale'))
	        {
	            ops.scaleX.loadConfig(config, 'scale');
	            ops.scaleY.active = false;
	        }

	        if (HasValue(config, 'callbackScope'))
	        {
	            var callbackScope = GetFastValue(config, 'callbackScope', null);

	            this.emitCallbackScope = callbackScope;
	            this.deathCallbackScope = callbackScope;
	        }

	        if (HasValue(config, 'emitZone'))
	        {
	            this.addEmitZone(config.emitZone);
	        }

	        if (HasValue(config, 'deathZone'))
	        {
	            this.addDeathZone(config.deathZone);
	        }

	        if (HasValue(config, 'bounds'))
	        {
	            var bounds = this.addParticleBounds(config.bounds);

	            bounds.collideLeft = GetFastValue(config, 'collideLeft', true);
	            bounds.collideRight = GetFastValue(config, 'collideRight', true);
	            bounds.collideTop = GetFastValue(config, 'collideTop', true);
	            bounds.collideBottom = GetFastValue(config, 'collideBottom', true);
	        }

	        if (HasValue(config, 'followOffset'))
	        {
	            this.followOffset.setFromObject(GetFastValue(config, 'followOffset', 0));
	        }

	        if (HasValue(config, 'texture'))
	        {
	            this.setTexture(config.texture);
	        }

	        if (HasValue(config, 'frame'))
	        {
	            this.setEmitterFrame(config.frame);
	        }
	        else if (HasValue(config, 'anim'))
	        {
	            this.setAnim(config.anim);
	        }

	        if (HasValue(config, 'reserve'))
	        {
	            this.reserve(config.reserve);
	        }

	        if (HasValue(config, 'advance'))
	        {
	            this.fastForward(config.advance);
	        }

	        this.resetCounters(this.frequency, this.emitting);

	        if (this.emitting)
	        {
	            this.emit(Events.START, this);
	        }

	        return this;
	    },

	    updateConfig: function (config)
	    {
	        if (config)
	        {
	            if (!this.config)
	            {
	                this.setConfig(config);
	            }
	            else
	            {
	                this.setConfig(MergeRight(this.config, config));
	            }
	        }

	        return this;
	    },

	    toJSON: function ()
	    {
	        var output = ComponentsToJSON(this);

	        var i = 0;
	        var key = '';

	        for (i = 0; i < configFastMap.length; i++)
	        {
	            key = configFastMap[i];

	            output[key] = this[key];
	        }

	        var ops = this.ops;

	        for (i = 0; i < configOpMap.length; i++)
	        {
	            key = configOpMap[i];

	            if (ops[key])
	            {
	                output[key] = ops[key].toJSON();
	            }
	        }

	        if (!ops.speedY.active)
	        {
	            delete output.speedX;
	            output.speed = ops.speedX.toJSON();
	        }

	        if (this.scaleX === this.scaleY)
	        {
	            delete output.scaleX;
	            delete output.scaleY;
	            output.scale = ops.scaleX.toJSON();
	        }

	        return output;
	    },

	    resetCounters: function (frequency, on)
	    {
	        var counters = this.counters;

	        counters.fill(0);

	        counters[0] = frequency;

	        if (on)
	        {
	            counters[5] = 1;
	        }
	    },

	    startFollow: function (target, offsetX, offsetY, trackVisible)
	    {
	        if (offsetX === undefined) { offsetX = 0; }
	        if (offsetY === undefined) { offsetY = 0; }
	        if (trackVisible === undefined) { trackVisible = false; }

	        this.follow = target;
	        this.followOffset.set(offsetX, offsetY);
	        this.trackVisible = trackVisible;

	        return this;
	    },

	    stopFollow: function ()
	    {
	        this.follow = null;
	        this.followOffset.set(0, 0);
	        this.trackVisible = false;

	        return this;
	    },

	    getFrame: function ()
	    {
	        var frames = this.frames;
	        var len = frames.length;
	        var current;

	        if (len === 1)
	        {
	            current = frames[0];
	        }
	        else if (this.randomFrame)
	        {
	            current = GetRandom(frames);
	        }
	        else
	        {
	            current = frames[this.currentFrame];

	            this.frameCounter++;

	            if (this.frameCounter === this.frameQuantity)
	            {
	                this.frameCounter = 0;

	                this.currentFrame++;

	                if (this.currentFrame === len)
	                {
	                    this.currentFrame = 0;
	                }
	            }
	        }

	        return this.texture.get(current);
	    },

	    setEmitterFrame: function (frames, pickRandom, quantity)
	    {
	        if (pickRandom === undefined) { pickRandom = true; }
	        if (quantity === undefined) { quantity = 1; }

	        this.randomFrame = pickRandom;
	        this.frameQuantity = quantity;

	        this.currentFrame = 0;

	        var t = typeof (frames);

	        this.frames.length = 0;

	        if (Array.isArray(frames))
	        {
	            this.frames = this.frames.concat(frames);
	        }
	        else if (t === 'string' || t === 'number')
	        {
	            this.frames.push(frames);
	        }
	        else if (t === 'object')
	        {
	            var frameConfig = frames;

	            frames = GetFastValue(frameConfig, 'frames', null);

	            if (frames)
	            {
	                this.frames = this.frames.concat(frames);
	            }

	            var isCycle = GetFastValue(frameConfig, 'cycle', false);

	            this.randomFrame = (isCycle) ? false : true;

	            this.frameQuantity = GetFastValue(frameConfig, 'quantity', quantity);
	        }

	        if (this.frames.length === 1)
	        {
	            this.frameQuantity = 1;
	            this.randomFrame = false;
	        }

	        return this;
	    },

	    getAnim: function ()
	    {
	        var anims = this.anims;
	        var len = anims.length;

	        if (len === 0)
	        {
	            return null;
	        }
	        else if (len === 1)
	        {
	            return anims[0];
	        }
	        else if (this.randomAnim)
	        {
	            return GetRandom(anims);
	        }
	        else
	        {
	            var anim = anims[this.currentAnim];

	            this.animCounter++;

	            if (this.animCounter >= this.animQuantity)
	            {
	                this.animCounter = 0;
	                this.currentAnim = Wrap(this.currentAnim + 1, 0, len);
	            }

	            return anim;
	        }
	    },

	    setAnim: function (anims, pickRandom, quantity)
	    {
	        if (pickRandom === undefined) { pickRandom = true; }
	        if (quantity === undefined) { quantity = 1; }

	        this.randomAnim = pickRandom;
	        this.animQuantity = quantity;

	        this.currentAnim = 0;

	        var t = typeof (anims);

	        this.anims.length = 0;

	        if (Array.isArray(anims))
	        {
	            this.anims = this.anims.concat(anims);
	        }
	        else if (t === 'string')
	        {
	            this.anims.push(anims);
	        }
	        else if (t === 'object')
	        {
	            var animConfig = anims;

	            anims = GetFastValue(animConfig, 'anims', null);

	            if (anims)
	            {
	                this.anims = this.anims.concat(anims);
	            }

	            var isCycle = GetFastValue(animConfig, 'cycle', false);

	            this.randomAnim = (isCycle) ? false : true;

	            this.animQuantity = GetFastValue(animConfig, 'quantity', quantity);
	        }

	        if (this.anims.length === 1)
	        {
	            this.animQuantity = 1;
	            this.randomAnim = false;
	        }

	        return this;
	    },

	    setRadial: function (value)
	    {
	        if (value === undefined) { value = true; }

	        this.radial = value;

	        return this;
	    },

	    addParticleBounds: function (x, y, width, height, collideLeft, collideRight, collideTop, collideBottom)
	    {
	        if (typeof x === 'object')
	        {
	            var obj = x;

	            x = obj.x;
	            y = obj.y;
	            width = (HasValue(obj, 'w')) ? obj.w : obj.width;
	            height = (HasValue(obj, 'h')) ? obj.h : obj.height;
	        }

	        return this.addParticleProcessor(new ParticleBounds(x, y, width, height, collideLeft, collideRight, collideTop, collideBottom));
	    },

	    setParticleSpeed: function (x, y)
	    {
	        if (y === undefined) { y = x; }

	        this.ops.speedX.onChange(x);

	        if (x === y)
	        {
	            this.ops.speedY.active = false;
	        }
	        else
	        {
	            this.ops.speedY.onChange(y);
	        }

	        this.radial = true;

	        return this;
	    },

	    setParticleScale: function (x, y)
	    {
	        if (x === undefined) { x = 1; }
	        if (y === undefined) { y = x; }

	        this.ops.scaleX.onChange(x);
	        this.ops.scaleY.onChange(y);

	        return this;
	    },

	    setParticleGravity: function (x, y)
	    {
	        this.gravityX = x;
	        this.gravityY = y;

	        return this;
	    },

	    setParticleAlpha: function (value)
	    {
	        this.ops.alpha.onChange(value);

	        return this;
	    },

	    setParticleTint: function (value)
	    {
	        this.ops.tint.onChange(value);

	        return this;
	    },

	    setEmitterAngle: function (value)
	    {
	        this.ops.angle.onChange(value);

	        return this;
	    },

	    setParticleLifespan: function (value)
	    {
	        this.ops.lifespan.onChange(value);

	        return this;
	    },

	    setQuantity: function (quantity)
	    {
	        this.quantity = quantity;

	        return this;
	    },

	    setFrequency: function (frequency, quantity)
	    {
	        this.frequency = frequency;

	        this.flowCounter = (frequency > 0) ? frequency : 0;

	        if (quantity)
	        {
	            this.quantity = quantity;
	        }

	        return this;
	    },

	    addDeathZone: function (config)
	    {
	        if (!Array.isArray(config))
	        {
	            config = [ config ];
	        }

	        var zone;
	        var output = [];

	        for (var i = 0; i < config.length; i++)
	        {
	            zone = config[i];

	            if (zone instanceof DeathZone)
	            {
	                output.push(zone);
	            }
	            else if (typeof zone.contains === 'function')
	            {
	                zone = new DeathZone(zone, true);

	                output.push(zone);
	            }
	            else
	            {
	                var type = GetFastValue(zone, 'type', 'onEnter');
	                var source = GetFastValue(zone, 'source', null);

	                if (source && typeof source.contains === 'function')
	                {
	                    var killOnEnter = (type === 'onEnter') ? true : false;

	                    zone = new DeathZone(source, killOnEnter);

	                    output.push(zone);
	                }
	            }
	        }

	        this.deathZones = this.deathZones.concat(output);

	        return output;
	    },

	    removeDeathZone: function (zone)
	    {
	        Remove(this.deathZones, zone);

	        return this;
	    },

	    clearDeathZones: function ()
	    {
	        this.deathZones.length = 0;

	        return this;
	    },

	    addEmitZone: function (config)
	    {
	        if (!Array.isArray(config))
	        {
	            config = [ config ];
	        }

	        var zone;
	        var output = [];

	        for (var i = 0; i < config.length; i++)
	        {
	            zone = config[i];

	            if (zone instanceof RandomZone || zone instanceof EdgeZone)
	            {
	                output.push(zone);
	            }
	            else
	            {

	                var source = GetFastValue(zone, 'source', null);

	                if (source)
	                {
	                    var type = GetFastValue(zone, 'type', 'random');

	                    if (type === 'random' && typeof source.getRandomPoint === 'function')
	                    {
	                        zone = new RandomZone(source);

	                        output.push(zone);
	                    }
	                    else if (type === 'edge' && typeof source.getPoints === 'function')
	                    {
	                        var quantity = GetFastValue(zone, 'quantity', 1);
	                        var stepRate = GetFastValue(zone, 'stepRate', 0);
	                        var yoyo = GetFastValue(zone, 'yoyo', false);
	                        var seamless = GetFastValue(zone, 'seamless', true);
	                        var total = GetFastValue(zone, 'total', -1);

	                        zone = new EdgeZone(source, quantity, stepRate, yoyo, seamless, total);

	                        output.push(zone);
	                    }
	                }
	            }
	        }

	        this.emitZones = this.emitZones.concat(output);

	        return output;
	    },

	    removeEmitZone: function (zone)
	    {
	        Remove(this.emitZones, zone);

	        this.zoneIndex = 0;

	        return this;
	    },

	    clearEmitZones: function ()
	    {
	        this.emitZones.length = 0;

	        this.zoneIndex = 0;

	        return this;
	    },

	    getEmitZone: function (particle)
	    {
	        var zones = this.emitZones;
	        var len = zones.length;

	        if (len === 0)
	        {
	            return;
	        }
	        else
	        {
	            var zone = zones[this.zoneIndex];

	            zone.getPoint(particle);

	            if (zone.total > -1)
	            {
	                this.zoneTotal++;

	                if (this.zoneTotal === zone.total)
	                {
	                    this.zoneTotal = 0;

	                    this.zoneIndex++;

	                    if (this.zoneIndex === len)
	                    {
	                        this.zoneIndex = 0;
	                    }
	                }
	            }
	        }
	    },

	    getDeathZone: function (particle)
	    {
	        var zones = this.deathZones;

	        for (var i = 0; i < zones.length; i++)
	        {
	            var zone = zones[i];

	            if (zone.willKill(particle))
	            {
	                this.emit(Events.DEATH_ZONE, this, particle, zone);

	                return true;
	            }
	        }

	        return false;
	    },

	    setEmitZone: function (zone)
	    {
	        var index;

	        if (isFinite(zone))
	        {
	            index = zone;
	        }
	        else
	        {
	            index = this.emitZones.indexOf(zone);
	        }

	        if (index >= 0)
	        {
	            this.zoneIndex = index;
	        }

	        return this;
	    },

	    addParticleProcessor: function (processor)
	    {
	        if (!this.processors.exists(processor))
	        {
	            if (processor.emitter)
	            {
	                processor.emitter.removeParticleProcessor(processor);
	            }

	            this.processors.add(processor);

	            processor.emitter = this;
	        }

	        return processor;
	    },

	    removeParticleProcessor: function (processor)
	    {
	        if (this.processors.exists(processor))
	        {
	            this.processors.remove(processor, true);

	            processor.emitter = null;
	        }

	        return processor;
	    },

	    getProcessors: function ()
	    {
	        return this.processors.getAll('active', true);
	    },

	    createGravityWell: function (config)
	    {
	        return this.addParticleProcessor(new GravityWell(config));
	    },

	    reserve: function (count)
	    {
	        var dead = this.dead;

	        if (this.maxParticles > 0)
	        {
	            var total = this.getParticleCount();

	            if (total + count > this.maxParticles)
	            {
	                count = this.maxParticles - (total + count);
	            }
	        }

	        for (var i = 0; i < count; i++)
	        {
	            dead.push(new this.particleClass(this));
	        }

	        return this;
	    },

	    getAliveParticleCount: function ()
	    {
	        return this.alive.length;
	    },

	    getDeadParticleCount: function ()
	    {
	        return this.dead.length;
	    },

	    getParticleCount: function ()
	    {
	        return this.getAliveParticleCount() + this.getDeadParticleCount();
	    },

	    atLimit: function ()
	    {
	        if (this.maxParticles > 0 && this.getParticleCount() >= this.maxParticles)
	        {
	            return true;
	        }

	        return (this.maxAliveParticles > 0 && this.getAliveParticleCount() >= this.maxAliveParticles);
	    },

	    onParticleEmit: function (callback, context)
	    {
	        if (callback === undefined)
	        {

	            this.emitCallback = null;
	            this.emitCallbackScope = null;
	        }
	        else if (typeof callback === 'function')
	        {
	            this.emitCallback = callback;

	            if (context)
	            {
	                this.emitCallbackScope = context;
	            }
	        }

	        return this;
	    },

	    onParticleDeath: function (callback, context)
	    {
	        if (callback === undefined)
	        {

	            this.deathCallback = null;
	            this.deathCallbackScope = null;
	        }
	        else if (typeof callback === 'function')
	        {
	            this.deathCallback = callback;

	            if (context)
	            {
	                this.deathCallbackScope = context;
	            }
	        }

	        return this;
	    },

	    killAll: function ()
	    {
	        var dead = this.dead;
	        var alive = this.alive;

	        while (alive.length > 0)
	        {
	            dead.push(alive.pop());
	        }

	        return this;
	    },

	    forEachAlive: function (callback, context)
	    {
	        var alive = this.alive;
	        var length = alive.length;

	        for (var i = 0; i < length; i++)
	        {

	            callback.call(context, alive[i], this);
	        }

	        return this;
	    },

	    forEachDead: function (callback, context)
	    {
	        var dead = this.dead;
	        var length = dead.length;

	        for (var i = 0; i < length; i++)
	        {
	            callback.call(context, dead[i], this);
	        }

	        return this;
	    },

	    start: function (advance, duration)
	    {
	        if (advance === undefined) { advance = 0; }

	        if (!this.emitting)
	        {
	            if (advance > 0)
	            {
	                this.fastForward(advance);
	            }

	            this.emitting = true;

	            this.resetCounters(this.frequency, true);

	            if (duration !== undefined)
	            {
	                this.duration = Math.abs(duration);
	            }

	            this.emit(Events.START, this);
	        }

	        return this;
	    },

	    stop: function (kill)
	    {
	        if (kill === undefined) { kill = false; }

	        if (this.emitting)
	        {
	            this.emitting = false;

	            if (kill)
	            {
	                this.killAll();
	            }

	            this.emit(Events.STOP, this);
	        }

	        return this;
	    },

	    pause: function ()
	    {
	        this.active = false;

	        return this;
	    },

	    resume: function ()
	    {
	        this.active = true;

	        return this;
	    },

	    setSortProperty: function (property, ascending)
	    {
	        if (property === undefined) { property = ''; }
	        if (ascending === undefined) { ascending = this.true; }

	        this.sortProperty = property;
	        this.sortOrderAsc = ascending;
	        this.sortCallback = this.depthSortCallback;

	        return this;
	    },

	    setSortCallback: function (callback)
	    {
	        if (this.sortProperty !== '')
	        {
	            callback = this.depthSortCallback;
	        }
	        else
	        {
	            callback = null;
	        }

	        this.sortCallback = callback;

	        return this;
	    },

	    depthSort: function ()
	    {
	        StableSort(this.alive, this.sortCallback.bind(this));

	        return this;
	    },

	    depthSortCallback: function (a, b)
	    {
	        var key = this.sortProperty;

	        if (this.sortOrderAsc)
	        {
	            return a[key] - b[key];
	        }
	        else
	        {
	            return b[key] - a[key];
	        }
	    },

	    flow: function (frequency, count, stopAfter)
	    {
	        if (count === undefined) { count = 1; }

	        this.emitting = false;

	        this.frequency = frequency;
	        this.quantity = count;

	        if (stopAfter !== undefined)
	        {
	            this.stopAfter = stopAfter;
	        }

	        return this.start();
	    },

	    explode: function (count, x, y)
	    {
	        this.frequency = -1;

	        this.resetCounters(-1, true);

	        var particle = this.emitParticle(count, x, y);

	        this.emit(Events.EXPLODE, this, particle);

	        return particle;
	    },

	    emitParticleAt: function (x, y, count)
	    {
	        return this.emitParticle(count, x, y);
	    },

	    emitParticle: function (count, x, y)
	    {
	        if (this.atLimit())
	        {
	            return;
	        }

	        if (count === undefined)
	        {
	            count = this.ops.quantity.onEmit();
	        }

	        var dead = this.dead;
	        var stopAfter = this.stopAfter;

	        var followX = (this.follow) ? this.follow.x + this.followOffset.x : x;
	        var followY = (this.follow) ? this.follow.y + this.followOffset.y : y;

	        for (var i = 0; i < count; i++)
	        {
	            var particle = dead.pop();

	            if (!particle)
	            {
	                particle = new this.particleClass(this);
	            }

	            if (particle.fire(followX, followY))
	            {
	                if (this.particleBringToTop)
	                {
	                    this.alive.push(particle);
	                }
	                else
	                {
	                    this.alive.unshift(particle);
	                }

	                if (this.emitCallback)
	                {
	                    this.emitCallback.call(this.emitCallbackScope, particle, this);
	                }
	            }
	            else
	            {
	                this.dead.push(particle);
	            }

	            if (stopAfter > 0)
	            {
	                this.stopCounter++;

	                if (this.stopCounter >= stopAfter)
	                {
	                    break;
	                }
	            }

	            if (this.atLimit())
	            {
	                break;
	            }
	        }

	        return particle;
	    },

	    fastForward: function (time, delta)
	    {
	        if (delta === undefined) { delta = 1000 / 60; }

	        var total = 0;

	        this.skipping = true;

	        while (total < Math.abs(time))
	        {
	            this.preUpdate(0, delta);

	            total += delta;
	        }

	        this.skipping = false;

	        return this;
	    },

	    preUpdate: function (time, delta)
	    {

	        delta *= this.timeScale;

	        var step = (delta / 1000);

	        if (this.trackVisible)
	        {
	            this.visible = this.follow.visible;
	        }

	        this.getWorldTransformMatrix(this.worldMatrix);

	        var processors = this.getProcessors();

	        var particles = this.alive;
	        var dead = this.dead;

	        var i = 0;
	        var rip = [];
	        var length = particles.length;

	        for (i = 0; i < length; i++)
	        {
	            var particle = particles[i];

	            if (particle.update(delta, step, processors))
	            {
	                rip.push({ index: i, particle: particle });
	            }
	        }

	        length = rip.length;

	        if (length > 0)
	        {
	            var deathCallback = this.deathCallback;
	            var deathCallbackScope = this.deathCallbackScope;

	            for (i = length - 1; i >= 0; i--)
	            {
	                var entry = rip[i];

	                particles.splice(entry.index, 1);

	                dead.push(entry.particle);

	                if (deathCallback)
	                {
	                    deathCallback.call(deathCallbackScope, entry.particle);
	                }

	                entry.particle.setPosition();
	            }
	        }

	        if (!this.emitting && !this.skipping)
	        {
	            if (this.completeFlag === 1 && particles.length === 0)
	            {
	                this.completeFlag = 0;

	                this.emit(Events.COMPLETE, this);
	            }

	            return;
	        }

	        if (this.frequency === 0)
	        {
	            this.emitParticle();
	        }
	        else if (this.frequency > 0)
	        {
	            this.flowCounter -= delta;

	            while (this.flowCounter <= 0)
	            {

	                this.emitParticle();

	                this.flowCounter += this.frequency;
	            }
	        }

	        if (!this.skipping)
	        {
	            if (this.duration > 0)
	            {

	                this.elapsed += delta;

	                if (this.elapsed >= this.duration)
	                {
	                    this.stop();
	                }
	            }

	            if (this.stopAfter > 0 && this.stopCounter >= this.stopAfter)
	            {
	                this.stop();
	            }
	        }
	    },

	    overlap: function (target)
	    {
	        var matrix = this.getWorldTransformMatrix();

	        var alive = this.alive;
	        var length = alive.length;

	        var output = [];

	        for (var i = 0; i < length; i++)
	        {
	            var particle = alive[i];

	            if (RectangleToRectangle(target, particle.getBounds(matrix)))
	            {
	                output.push(particle);
	            }
	        }

	        return output;
	    },

	    getBounds: function (padding, advance, delta, output)
	    {
	        if (padding === undefined) { padding = 0; }
	        if (advance === undefined) { advance = 0; }
	        if (delta === undefined) { delta = 1000 / 60; }
	        if (output === undefined) { output = new Rectangle(); }

	        var matrix = this.getWorldTransformMatrix();

	        var i;
	        var bounds;
	        var alive = this.alive;
	        var setFirst = false;

	        output.setTo(0, 0, 0, 0);

	        if (advance > 0)
	        {
	            var total = 0;

	            this.skipping = true;

	            while (total < Math.abs(advance))
	            {
	                this.preUpdate(0, delta);

	                for (i = 0; i < alive.length; i++)
	                {
	                    bounds = alive[i].getBounds(matrix);

	                    if (!setFirst)
	                    {
	                        setFirst = true;

	                        CopyFrom(bounds, output);
	                    }
	                    else
	                    {
	                        MergeRect(output, bounds);
	                    }
	                }

	                total += delta;
	            }

	            this.skipping = false;
	        }
	        else
	        {
	            for (i = 0; i < alive.length; i++)
	            {
	                bounds = alive[i].getBounds(matrix);

	                if (!setFirst)
	                {
	                    setFirst = true;

	                    CopyFrom(bounds, output);
	                }
	                else
	                {
	                    MergeRect(output, bounds);
	                }
	            }
	        }

	        if (padding > 0)
	        {
	            Inflate(output, padding, padding);
	        }

	        return output;
	    },

	    createEmitter: function ()
	    {
	        throw new Error('createEmitter removed. See ParticleEmitter docs for info');
	    },

	    particleX: {

	        get: function ()
	        {
	            return this.ops.x.current;
	        },

	        set: function (value)
	        {
	            this.ops.x.onChange(value);
	        }

	    },

	    particleY: {

	        get: function ()
	        {
	            return this.ops.y.current;
	        },

	        set: function (value)
	        {
	            this.ops.y.onChange(value);
	        }

	    },

	    accelerationX: {

	        get: function ()
	        {
	            return this.ops.accelerationX.current;
	        },

	        set: function (value)
	        {
	            this.ops.accelerationX.onChange(value);
	        }

	    },

	    accelerationY: {

	        get: function ()
	        {
	            return this.ops.accelerationY.current;
	        },

	        set: function (value)
	        {
	            this.ops.accelerationY.onChange(value);
	        }

	    },

	    maxVelocityX: {

	        get: function ()
	        {
	            return this.ops.maxVelocityX.current;
	        },

	        set: function (value)
	        {
	            this.ops.maxVelocityX.onChange(value);
	        }

	    },

	    maxVelocityY: {

	        get: function ()
	        {
	            return this.ops.maxVelocityY.current;
	        },

	        set: function (value)
	        {
	            this.ops.maxVelocityY.onChange(value);
	        }

	    },

	    speed: {

	        get: function ()
	        {
	            return this.ops.speedX.current;
	        },

	        set: function (value)
	        {
	            this.ops.speedX.onChange(value);
	            this.ops.speedY.onChange(value);
	        }

	    },

	    speedX: {

	        get: function ()
	        {
	            return this.ops.speedX.current;
	        },

	        set: function (value)
	        {
	            this.ops.speedX.onChange(value);
	        }

	    },

	    speedY: {

	        get: function ()
	        {
	            return this.ops.speedY.current;
	        },

	        set: function (value)
	        {
	            this.ops.speedY.onChange(value);
	        }

	    },

	    moveToX: {

	        get: function ()
	        {
	            return this.ops.moveToX.current;
	        },

	        set: function (value)
	        {
	            this.ops.moveToX.onChange(value);
	        }

	    },

	    moveToY: {

	        get: function ()
	        {
	            return this.ops.moveToY.current;
	        },

	        set: function (value)
	        {
	            this.ops.moveToY.onChange(value);
	        }

	    },

	    bounce: {

	        get: function ()
	        {
	            return this.ops.bounce.current;
	        },

	        set: function (value)
	        {
	            this.ops.bounce.onChange(value);
	        }

	    },

	    particleScaleX: {

	        get: function ()
	        {
	            return this.ops.scaleX.current;
	        },

	        set: function (value)
	        {
	            this.ops.scaleX.onChange(value);
	        }

	    },

	    particleScaleY: {

	        get: function ()
	        {
	            return this.ops.scaleY.current;
	        },

	        set: function (value)
	        {
	            this.ops.scaleY.onChange(value);
	        }

	    },

	    particleColor: {

	        get: function ()
	        {
	            return this.ops.color.current;
	        },

	        set: function (value)
	        {
	            this.ops.color.onChange(value);
	        }

	    },

	    colorEase: {

	        get: function ()
	        {
	            return this.ops.color.easeName;
	        },

	        set: function (value)
	        {
	            this.ops.color.setEase(value);
	        }

	    },

	    particleTint: {

	        get: function ()
	        {
	            return this.ops.tint.current;
	        },

	        set: function (value)
	        {
	            this.ops.tint.onChange(value);
	        }

	    },

	    particleAlpha: {

	        get: function ()
	        {
	            return this.ops.alpha.current;
	        },

	        set: function (value)
	        {
	            this.ops.alpha.onChange(value);
	        }

	    },

	    lifespan: {

	        get: function ()
	        {
	            return this.ops.lifespan.current;
	        },

	        set: function (value)
	        {
	            this.ops.lifespan.onChange(value);
	        }

	    },

	    particleAngle: {

	        get: function ()
	        {
	            return this.ops.angle.current;
	        },

	        set: function (value)
	        {
	            this.ops.angle.onChange(value);
	        }

	    },

	    particleRotate: {

	        get: function ()
	        {
	            return this.ops.rotate.current;
	        },

	        set: function (value)
	        {
	            this.ops.rotate.onChange(value);
	        }

	    },

	    quantity: {

	        get: function ()
	        {
	            return this.ops.quantity.current;
	        },

	        set: function (value)
	        {
	            this.ops.quantity.onChange(value);
	        }

	    },

	    delay: {

	        get: function ()
	        {
	            return this.ops.delay.current;
	        },

	        set: function (value)
	        {
	            this.ops.delay.onChange(value);
	        }

	    },

	    hold: {

	        get: function ()
	        {
	            return this.ops.hold.current;
	        },

	        set: function (value)
	        {
	            this.ops.hold.onChange(value);
	        }

	    },

	    flowCounter: {

	        get: function ()
	        {
	            return this.counters[0];
	        },

	        set: function (value)
	        {
	            this.counters[0] = value;
	        }

	    },

	    frameCounter: {

	        get: function ()
	        {
	            return this.counters[1];
	        },

	        set: function (value)
	        {
	            this.counters[1] = value;
	        }

	    },

	    animCounter: {

	        get: function ()
	        {
	            return this.counters[2];
	        },

	        set: function (value)
	        {
	            this.counters[2] = value;
	        }

	    },

	    elapsed: {

	        get: function ()
	        {
	            return this.counters[3];
	        },

	        set: function (value)
	        {
	            this.counters[3] = value;
	        }

	    },

	    stopCounter: {

	        get: function ()
	        {
	            return this.counters[4];
	        },

	        set: function (value)
	        {
	            this.counters[4] = value;
	        }

	    },

	    completeFlag: {

	        get: function ()
	        {
	            return this.counters[5];
	        },

	        set: function (value)
	        {
	            this.counters[5] = value;
	        }

	    },

	    zoneIndex: {

	        get: function ()
	        {
	            return this.counters[6];
	        },

	        set: function (value)
	        {
	            this.counters[6] = value;
	        }

	    },

	    zoneTotal: {

	        get: function ()
	        {
	            return this.counters[7];
	        },

	        set: function (value)
	        {
	            this.counters[7] = value;
	        }

	    },

	    currentFrame: {

	        get: function ()
	        {
	            return this.counters[8];
	        },

	        set: function (value)
	        {
	            this.counters[8] = value;
	        }

	    },

	    currentAnim: {

	        get: function ()
	        {
	            return this.counters[9];
	        },

	        set: function (value)
	        {
	            this.counters[9] = value;
	        }

	    },

	    preDestroy: function ()
	    {
	        this.texture = null;
	        this.frames = null;
	        this.anims = null;
	        this.emitCallback = null;
	        this.emitCallbackScope = null;
	        this.deathCallback = null;
	        this.deathCallbackScope = null;
	        this.emitZones = null;
	        this.deathZones = null;
	        this.bounds = null;
	        this.follow = null;
	        this.counters = null;

	        var i;

	        var ops = this.ops;

	        for (i = 0; i < configOpMap.length; i++)
	        {
	            var key = configOpMap[i];

	            ops[key].destroy();
	        }

	        for (i = 0; i < this.alive.length; i++)
	        {
	            this.alive[i].destroy();
	        }

	        for (i = 0; i < this.dead.length; i++)
	        {
	            this.dead[i].destroy();
	        }

	        this.ops = null;
	        this.alive = [];
	        this.dead = [];
	        this.worldMatrix.destroy();
	    }

	});

	ParticleEmitter_1 = ParticleEmitter;
	return ParticleEmitter_1;
}

var zones;
var hasRequiredZones;

function requireZones () {
	if (hasRequiredZones) return zones;
	hasRequiredZones = 1;
	zones = {

	    DeathZone: requireDeathZone(),
	    EdgeZone: requireEdgeZone(),
	    RandomZone: requireRandomZone()

	};
	return zones;
}

var particles;
var hasRequiredParticles;

function requireParticles () {
	if (hasRequiredParticles) return particles;
	hasRequiredParticles = 1;
	particles = {

	    EmitterColorOp: requireEmitterColorOp(),
	    EmitterOp: requireEmitterOp(),
	    Events: requireEvents$6(),
	    GravityWell: requireGravityWell(),
	    Particle: requireParticle(),
	    ParticleBounds: requireParticleBounds(),
	    ParticleEmitter: requireParticleEmitter(),
	    ParticleProcessor: requireParticleProcessor(),
	    Zones: requireZones()

	};
	return particles;
}

var PathFollower_1;
var hasRequiredPathFollower;

function requirePathFollower () {
	if (hasRequiredPathFollower) return PathFollower_1;
	hasRequiredPathFollower = 1;
	var Class = requireClass();
	var Components = requireComponents$2();
	var Sprite = requireSprite();

	var PathFollower = new Class({

	    Extends: Sprite,

	    Mixins: [
	        Components.PathFollower
	    ],

	    initialize:

	    function PathFollower (scene, path, x, y, texture, frame)
	    {
	        Sprite.call(this, scene, x, y, texture, frame);

	        this.path = path;
	    },

	    preUpdate: function (time, delta)
	    {
	        this.anims.update(time, delta);
	        this.pathUpdate(time);
	    }

	});

	PathFollower_1 = PathFollower;
	return PathFollower_1;
}

var RenderTexture_1;
var hasRequiredRenderTexture;

function requireRenderTexture () {
	if (hasRequiredRenderTexture) return RenderTexture_1;
	hasRequiredRenderTexture = 1;
	var Class = requireClass();
	var DynamicTexture = requireDynamicTexture();
	var Image = requireImage$1();

	var RenderTexture = new Class({

	    Extends: Image,

	    initialize:

	    function RenderTexture (scene, x, y, width, height, forceEven)
	    {
	        if (x === undefined) { x = 0; }
	        if (y === undefined) { y = 0; }
	        if (width === undefined) { width = 32; }
	        if (height === undefined) { height = 32; }
	        if (forceEven === undefined) { forceEven = true; }

	        var dynamicTexture = new DynamicTexture(scene.sys.textures, '', width, height, forceEven);

	        Image.call(this, scene, x, y, dynamicTexture);

	        this.type = 'RenderTexture';

	        this.camera = this.texture.camera;

	        this._saved = false;
	    },

	    setSize: function (width, height)
	    {
	        this.width = width;
	        this.height = height;

	        this.updateDisplayOrigin();

	        var input = this.input;

	        if (input && !input.customHitArea)
	        {
	            input.hitArea.width = width;
	            input.hitArea.height = height;
	        }

	        return this;
	    },

	    resize: function (width, height, forceEven)
	    {
	        this.texture.setSize(width, height, forceEven);

	        this.setSize(this.texture.width, this.texture.height);

	        return this;
	    },

	    saveTexture: function (key)
	    {
	        var texture = this.texture;

	        texture.key = key;

	        if (texture.manager.addDynamicTexture(texture))
	        {
	            this._saved = true;
	        }

	        return texture;
	    },

	    fill: function (rgb, alpha, x, y, width, height)
	    {
	        this.texture.fill(rgb, alpha, x, y, width, height);

	        return this;
	    },

	    clear: function ()
	    {
	        this.texture.clear();

	        return this;
	    },

	    stamp: function (key, frame, x, y, config)
	    {
	        this.texture.stamp(key, frame, x, y, config);

	        return this;
	    },

	    erase: function (entries, x, y)
	    {
	        this.texture.erase(entries, x, y);

	        return this;
	    },

	    draw: function (entries, x, y, alpha, tint)
	    {
	        this.texture.draw(entries, x, y, alpha, tint);

	        return this;
	    },

	    drawFrame: function (key, frame, x, y, alpha, tint)
	    {
	        this.texture.drawFrame(key, frame, x, y, alpha, tint);

	        return this;
	    },

	    repeat: function (key, frame, x, y, width, height, alpha, tint, skipBatch)
	    {
	        this.texture.repeat(key, frame, x, y, width, height, alpha, tint, skipBatch);

	        return this;
	    },

	    beginDraw: function ()
	    {
	        this.texture.beginDraw();

	        return this;
	    },

	    batchDraw: function (entries, x, y, alpha, tint)
	    {
	        this.texture.batchDraw(entries, x, y, alpha, tint);

	        return this;
	    },

	    batchDrawFrame: function (key, frame, x, y, alpha, tint)
	    {
	        this.texture.batchDrawFrame(key, frame, x, y, alpha, tint);

	        return this;
	    },

	    endDraw: function (erase)
	    {
	        this.texture.endDraw(erase);

	        return this;
	    },

	    snapshotArea: function (x, y, width, height, callback, type, encoderOptions)
	    {
	        this.texture.snapshotArea(x, y, width, height, callback, type, encoderOptions);

	        return this;
	    },

	    snapshot: function (callback, type, encoderOptions)
	    {
	        return this.snapshotArea(0, 0, this.width, this.height, callback, type, encoderOptions);
	    },

	    snapshotPixel: function (x, y, callback)
	    {
	        return this.snapshotArea(x, y, 1, 1, callback, 'pixel');
	    },

	    preDestroy: function ()
	    {
	        this.camera = null;

	        if (!this._saved)
	        {
	            this.texture.destroy();
	        }
	    }

	});

	RenderTexture_1 = RenderTexture;
	return RenderTexture_1;
}

var _const$4;
var hasRequired_const$4;

function require_const$4 () {
	if (hasRequired_const$4) return _const$4;
	hasRequired_const$4 = 1;
	var RETRO_FONT_CONST = {

	    TEXT_SET1: ' !"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~',

	    TEXT_SET2: ' !"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ',

	    TEXT_SET3: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ',

	    TEXT_SET4: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789',

	    TEXT_SET5: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() \'!?-*:0123456789',

	    TEXT_SET6: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789"(),-.\' ',

	    TEXT_SET7: 'AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW")28FLRX-\'39',

	    TEXT_SET8: '0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ',

	    TEXT_SET9: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,\'"?!',

	    TEXT_SET10: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',

	    TEXT_SET11: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ.,"-+!?()\':;0123456789'

	};

	_const$4 = RETRO_FONT_CONST;
	return _const$4;
}

var ParseRetroFont_1;
var hasRequiredParseRetroFont;

function requireParseRetroFont () {
	if (hasRequiredParseRetroFont) return ParseRetroFont_1;
	hasRequiredParseRetroFont = 1;
	var GetValue = requireGetValue();

	var ParseRetroFont = function (scene, config)
	{
	    var w = config.width;
	    var h = config.height;

	    var cx = Math.floor(w / 2);
	    var cy = Math.floor(h / 2);

	    var letters = GetValue(config, 'chars', '');

	    if (letters === '')
	    {
	        return;
	    }

	    var key = GetValue(config, 'image', '');

	    var frame = scene.sys.textures.getFrame(key);
	    var textureX = frame.cutX;
	    var textureY = frame.cutY;
	    var textureWidth = frame.source.width;
	    var textureHeight = frame.source.height;

	    var offsetX = GetValue(config, 'offset.x', 0);
	    var offsetY = GetValue(config, 'offset.y', 0);
	    var spacingX = GetValue(config, 'spacing.x', 0);
	    var spacingY = GetValue(config, 'spacing.y', 0);
	    var lineSpacing = GetValue(config, 'lineSpacing', 0);

	    var charsPerRow = GetValue(config, 'charsPerRow', null);

	    if (charsPerRow === null)
	    {
	        charsPerRow = textureWidth / w;

	        if (charsPerRow > letters.length)
	        {
	            charsPerRow = letters.length;
	        }
	    }

	    var x = offsetX;
	    var y = offsetY;

	    var data = {
	        retroFont: true,
	        font: key,
	        size: w,
	        lineHeight: h + lineSpacing,
	        chars: {}
	    };

	    var r = 0;

	    for (var i = 0; i < letters.length; i++)
	    {
	        var charCode = letters.charCodeAt(i);

	        var u0 = (textureX + x) / textureWidth;
	        var v0 = (textureY + y) / textureHeight;
	        var u1 = (textureX + x + w) / textureWidth;
	        var v1 = (textureY + y + h) / textureHeight;

	        data.chars[charCode] =
	        {
	            x: x,
	            y: y,
	            width: w,
	            height: h,
	            centerX: cx,
	            centerY: cy,
	            xOffset: 0,
	            yOffset: 0,
	            xAdvance: w,
	            data: {},
	            kerning: {},
	            u0: u0,
	            v0: v0,
	            u1: u1,
	            v1: v1
	        };

	        r++;

	        if (r === charsPerRow)
	        {
	            r = 0;
	            x = offsetX;
	            y += h + spacingY;
	        }
	        else
	        {
	            x += w + spacingX;
	        }
	    }

	    var entry = {
	        data: data,
	        frame: null,
	        texture: key
	    };

	    return entry;
	};

	ParseRetroFont_1 = ParseRetroFont;
	return ParseRetroFont_1;
}

var RetroFont_1;
var hasRequiredRetroFont;

function requireRetroFont () {
	if (hasRequiredRetroFont) return RetroFont_1;
	hasRequiredRetroFont = 1;
	var RETRO_FONT_CONST = require_const$4();
	var Extend = requireExtend$1();

	var RetroFont = { Parse: requireParseRetroFont() };

	RetroFont = Extend(false, RetroFont, RETRO_FONT_CONST);

	RetroFont_1 = RetroFont;
	return RetroFont_1;
}

var RopeWebGLRenderer_1;
var hasRequiredRopeWebGLRenderer;

function requireRopeWebGLRenderer () {
	if (hasRequiredRopeWebGLRenderer) return RopeWebGLRenderer_1;
	hasRequiredRopeWebGLRenderer = 1;
	var GetCalcMatrix = requireGetCalcMatrix();
	var Utils = requireUtils$1();

	var RopeWebGLRenderer = function (renderer, src, camera, parentMatrix)
	{
	    camera.addToRenderList(src);

	    var pipeline = renderer.pipelines.set(src.pipeline, src);

	    var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;

	    var vertices = src.vertices;
	    var uvs = src.uv;
	    var colors = src.colors;
	    var alphas = src.alphas;
	    var alpha = src.alpha;
	    var getTint = Utils.getTintAppendFloatAlpha;
	    var roundPixels = camera.roundPixels;

	    var meshVerticesLength = vertices.length;
	    var vertexCount = Math.floor(meshVerticesLength * 0.5);

	    pipeline.flush();

	    renderer.pipelines.preBatch(src);

	    var textureUnit = pipeline.setGameObject(src);

	    var vertexViewF32 = pipeline.vertexViewF32;
	    var vertexViewU32 = pipeline.vertexViewU32;

	    var vertexOffset = (pipeline.vertexCount * pipeline.currentShader.vertexComponentCount) - 1;

	    var colorIndex = 0;

	    var tintEffect = src.tintFill;

	    if (src.dirty)
	    {
	        src.updateVertices();
	    }

	    var debugCallback = src.debugCallback;
	    var debugVerts = [];

	    for (var i = 0; i < meshVerticesLength; i += 2)
	    {
	        var x = vertices[i + 0];
	        var y = vertices[i + 1];

	        var tx = x * calcMatrix.a + y * calcMatrix.c + calcMatrix.e;
	        var ty = x * calcMatrix.b + y * calcMatrix.d + calcMatrix.f;

	        if (roundPixels)
	        {
	            tx = Math.round(tx);
	            ty = Math.round(ty);
	        }

	        vertexViewF32[++vertexOffset] = tx;
	        vertexViewF32[++vertexOffset] = ty;
	        vertexViewF32[++vertexOffset] = uvs[i + 0];
	        vertexViewF32[++vertexOffset] = uvs[i + 1];
	        vertexViewF32[++vertexOffset] = textureUnit;
	        vertexViewF32[++vertexOffset] = tintEffect;
	        vertexViewU32[++vertexOffset] = getTint(colors[colorIndex], camera.alpha * (alphas[colorIndex] * alpha));

	        colorIndex++;

	        if (debugCallback)
	        {
	            debugVerts[i + 0] = tx;
	            debugVerts[i + 1] = ty;
	        }
	    }

	    if (debugCallback)
	    {
	        debugCallback.call(src, src, meshVerticesLength, debugVerts);
	    }

	    pipeline.vertexCount += vertexCount;

	    pipeline.currentBatch.count = (pipeline.vertexCount - pipeline.currentBatch.start);

	    renderer.pipelines.postBatch(src);
	};

	RopeWebGLRenderer_1 = RopeWebGLRenderer;
	return RopeWebGLRenderer_1;
}

var RopeCanvasRenderer_1;
var hasRequiredRopeCanvasRenderer;

function requireRopeCanvasRenderer () {
	if (hasRequiredRopeCanvasRenderer) return RopeCanvasRenderer_1;
	hasRequiredRopeCanvasRenderer = 1;
	var RopeCanvasRenderer = function ()
	{
	};

	RopeCanvasRenderer_1 = RopeCanvasRenderer;
	return RopeCanvasRenderer_1;
}

var RopeRender;
var hasRequiredRopeRender;

function requireRopeRender () {
	if (hasRequiredRopeRender) return RopeRender;
	hasRequiredRopeRender = 1;
	var NOOP = requireNOOP();
	var renderWebGL = NOOP;
	var renderCanvas = NOOP;

	if (typeof WEBGL_RENDERER)
	{
	    renderWebGL = requireRopeWebGLRenderer();
	}

	if (typeof CANVAS_RENDERER)
	{
	    renderCanvas = requireRopeCanvasRenderer();
	}

	RopeRender = {

	    renderWebGL: renderWebGL,
	    renderCanvas: renderCanvas

	};
	return RopeRender;
}

var Rope_1;
var hasRequiredRope;

function requireRope () {
	if (hasRequiredRope) return Rope_1;
	hasRequiredRope = 1;
	var AnimationState = requireAnimationState();
	var Class = requireClass();
	var Components = requireComponents$2();
	var GameObject = requireGameObject();
	var PIPELINE_CONST = require_const$9();
	var RopeRender = requireRopeRender();
	var Vector2 = requireVector2();

	var Rope = new Class({

	    Extends: GameObject,

	    Mixins: [
	        Components.AlphaSingle,
	        Components.BlendMode,
	        Components.Depth,
	        Components.Flip,
	        Components.Mask,
	        Components.Pipeline,
	        Components.PostPipeline,
	        Components.Size,
	        Components.Texture,
	        Components.Transform,
	        Components.Visible,
	        Components.ScrollFactor,
	        RopeRender
	    ],

	    initialize:

	    function Rope (scene, x, y, texture, frame, points, horizontal, colors, alphas)
	    {
	        if (texture === undefined) { texture = '__DEFAULT'; }
	        if (points === undefined) { points = 2; }
	        if (horizontal === undefined) { horizontal = true; }

	        GameObject.call(this, scene, 'Rope');

	        this.anims = new AnimationState(this);

	        this.points = points;

	        this.vertices;

	        this.uv;

	        this.colors;

	        this.alphas;

	        this.tintFill = (texture === '__DEFAULT') ? true : false;

	        this.dirty = false;

	        this.horizontal = horizontal;

	        this._flipX = false;

	        this._flipY = false;

	        this._perp = new Vector2();

	        this.debugCallback = null;

	        this.debugGraphic = null;

	        this.setTexture(texture, frame);
	        this.setPosition(x, y);
	        this.setSizeToFrame();
	        this.initPipeline(PIPELINE_CONST.ROPE_PIPELINE);
	        this.initPostPipeline();

	        if (Array.isArray(points))
	        {
	            this.resizeArrays(points.length);
	        }

	        this.setPoints(points, colors, alphas);

	        this.updateVertices();
	    },

	    addedToScene: function ()
	    {
	        this.scene.sys.updateList.add(this);
	    },

	    removedFromScene: function ()
	    {
	        this.scene.sys.updateList.remove(this);
	    },

	    preUpdate: function (time, delta)
	    {
	        var prevFrame = this.anims.currentFrame;

	        this.anims.update(time, delta);

	        if (this.anims.currentFrame !== prevFrame)
	        {
	            this.updateUVs();
	            this.updateVertices();
	        }
	    },

	    play: function (key, ignoreIfPlaying, startFrame)
	    {
	        this.anims.play(key, ignoreIfPlaying, startFrame);

	        return this;
	    },

	    setDirty: function ()
	    {
	        this.dirty = true;

	        return this;
	    },

	    setHorizontal: function (points, colors, alphas)
	    {
	        if (points === undefined) { points = this.points.length; }

	        if (this.horizontal)
	        {
	            return this;
	        }

	        this.horizontal = true;

	        return this.setPoints(points, colors, alphas);
	    },

	    setVertical: function (points, colors, alphas)
	    {
	        if (points === undefined) { points = this.points.length; }

	        if (!this.horizontal)
	        {
	            return this;
	        }

	        this.horizontal = false;

	        return this.setPoints(points, colors, alphas);
	    },

	    setTintFill: function (value)
	    {
	        if (value === undefined) { value = false; }

	        this.tintFill = value;

	        return this;
	    },

	    setAlphas: function (alphas, bottomAlpha)
	    {
	        var total = this.points.length;

	        if (total < 1)
	        {
	            return this;
	        }

	        var currentAlphas = this.alphas;

	        if (alphas === undefined)
	        {
	            alphas = [ 1 ];
	        }
	        else if (!Array.isArray(alphas) && bottomAlpha === undefined)
	        {
	            alphas = [ alphas ];
	        }

	        var i;
	        var index = 0;

	        if (bottomAlpha !== undefined)
	        {

	            for (i = 0; i < total; i++)
	            {
	                index = i * 2;

	                currentAlphas[index] = alphas;
	                currentAlphas[index + 1] = bottomAlpha;
	            }
	        }
	        else if (alphas.length === total)
	        {

	            for (i = 0; i < total; i++)
	            {
	                index = i * 2;

	                currentAlphas[index] = alphas[i];
	                currentAlphas[index + 1] = alphas[i];
	            }
	        }
	        else
	        {
	            var prevAlpha = alphas[0];

	            for (i = 0; i < total; i++)
	            {
	                index = i * 2;

	                if (alphas.length > index)
	                {
	                    prevAlpha = alphas[index];
	                }

	                currentAlphas[index] = prevAlpha;

	                if (alphas.length > index + 1)
	                {
	                    prevAlpha = alphas[index + 1];
	                }

	                currentAlphas[index + 1] = prevAlpha;
	            }
	        }

	        return this;

	    },

	    setColors: function (colors)
	    {
	        var total = this.points.length;

	        if (total < 1)
	        {
	            return this;
	        }

	        var currentColors = this.colors;

	        if (colors === undefined)
	        {
	            colors = [ 0xffffff ];
	        }
	        else if (!Array.isArray(colors))
	        {
	            colors = [ colors ];
	        }

	        var i;
	        var index = 0;

	        if (colors.length === total)
	        {

	            for (i = 0; i < total; i++)
	            {
	                index = i * 2;

	                currentColors[index] = colors[i];
	                currentColors[index + 1] = colors[i];
	            }
	        }
	        else
	        {
	            var prevColor = colors[0];

	            for (i = 0; i < total; i++)
	            {
	                index = i * 2;

	                if (colors.length > index)
	                {
	                    prevColor = colors[index];
	                }

	                currentColors[index] = prevColor;

	                if (colors.length > index + 1)
	                {
	                    prevColor = colors[index + 1];
	                }

	                currentColors[index + 1] = prevColor;
	            }
	        }

	        return this;
	    },

	    setPoints: function (points, colors, alphas)
	    {
	        if (points === undefined) { points = 2; }

	        if (typeof points === 'number')
	        {

	            var segments = points;

	            if (segments < 2)
	            {
	                segments = 2;
	            }

	            points = [];

	            var s;
	            var frameSegment;
	            var offset;

	            if (this.horizontal)
	            {
	                offset = -(this.frame.halfWidth);
	                frameSegment = this.frame.width / (segments - 1);

	                for (s = 0; s < segments; s++)
	                {
	                    points.push({ x: offset + s * frameSegment, y: 0 });
	                }
	            }
	            else
	            {
	                offset = -(this.frame.halfHeight);
	                frameSegment = this.frame.height / (segments - 1);

	                for (s = 0; s < segments; s++)
	                {
	                    points.push({ x: 0, y: offset + s * frameSegment });
	                }
	            }
	        }

	        var total = points.length;
	        var currentTotal = this.points.length;

	        if (total < 1)
	        {
	            console.warn('Rope: Not enough points given');

	            return this;
	        }
	        else if (total === 1)
	        {
	            points.unshift({ x: 0, y: 0 });
	            total++;
	        }

	        if (currentTotal !== total)
	        {
	            this.resizeArrays(total);
	        }

	        this.dirty = true;

	        this.points = points;

	        this.updateUVs();

	        if (colors !== undefined && colors !== null)
	        {
	            this.setColors(colors);
	        }

	        if (alphas !== undefined && alphas !== null)
	        {
	            this.setAlphas(alphas);
	        }

	        return this;
	    },

	    updateUVs: function ()
	    {
	        var currentUVs = this.uv;
	        var total = this.points.length;

	        var u0 = this.frame.u0;
	        var v0 = this.frame.v0;
	        var u1 = this.frame.u1;
	        var v1 = this.frame.v1;

	        var partH = (u1 - u0) / (total - 1);
	        var partV = (v1 - v0) / (total - 1);

	        for (var i = 0; i < total; i++)
	        {
	            var index = i * 4;

	            var uv0;
	            var uv1;
	            var uv2;
	            var uv3;

	            if (this.horizontal)
	            {
	                if (this._flipX)
	                {
	                    uv0 = u1 - (i * partH);
	                    uv2 = u1 - (i * partH);
	                }
	                else
	                {
	                    uv0 = u0 + (i * partH);
	                    uv2 = u0 + (i * partH);
	                }

	                if (this._flipY)
	                {
	                    uv1 = v1;
	                    uv3 = v0;
	                }
	                else
	                {
	                    uv1 = v0;
	                    uv3 = v1;
	                }
	            }
	            else
	            {
	                if (this._flipX)
	                {
	                    uv0 = u0;
	                    uv2 = u1;
	                }
	                else
	                {
	                    uv0 = u1;
	                    uv2 = u0;
	                }

	                if (this._flipY)
	                {
	                    uv1 = v1 - (i * partV);
	                    uv3 = v1 - (i * partV);
	                }
	                else
	                {
	                    uv1 = v0 + (i * partV);
	                    uv3 = v0 + (i * partV);
	                }
	            }

	            currentUVs[index + 0] = uv0;
	            currentUVs[index + 1] = uv1;
	            currentUVs[index + 2] = uv2;
	            currentUVs[index + 3] = uv3;
	        }

	        return this;
	    },

	    resizeArrays: function (newSize)
	    {
	        var colors = this.colors;
	        var alphas = this.alphas;

	        this.vertices = new Float32Array(newSize * 4);
	        this.uv = new Float32Array(newSize * 4);

	        colors = new Uint32Array(newSize * 2);
	        alphas = new Float32Array(newSize * 2);

	        for (var i = 0; i < newSize * 2; i++)
	        {
	            colors[i] = 0xffffff;
	            alphas[i] = 1;
	        }

	        this.colors = colors;
	        this.alphas = alphas;

	        this.dirty = true;

	        return this;
	    },

	    updateVertices: function ()
	    {
	        var perp = this._perp;
	        var points = this.points;
	        var vertices = this.vertices;

	        var total = points.length;

	        this.dirty = false;

	        if (total < 1)
	        {
	            return;
	        }

	        var nextPoint;
	        var lastPoint = points[0];

	        var frameSize = (this.horizontal) ? this.frame.halfHeight : this.frame.halfWidth;

	        for (var i = 0; i < total; i++)
	        {
	            var point = points[i];
	            var index = i * 4;

	            if (i < total - 1)
	            {
	                nextPoint = points[i + 1];
	            }
	            else
	            {
	                nextPoint = point;
	            }

	            perp.x = nextPoint.y - lastPoint.y;
	            perp.y = -(nextPoint.x - lastPoint.x);

	            var perpLength = perp.length();

	            perp.x /= perpLength;
	            perp.y /= perpLength;

	            perp.x *= frameSize;
	            perp.y *= frameSize;

	            vertices[index] = point.x + perp.x;
	            vertices[index + 1] = point.y + perp.y;
	            vertices[index + 2] = point.x - perp.x;
	            vertices[index + 3] = point.y - perp.y;

	            lastPoint = point;
	        }

	        return this;
	    },

	    setDebug: function (graphic, callback)
	    {
	        this.debugGraphic = graphic;

	        if (!graphic && !callback)
	        {
	            this.debugCallback = null;
	        }
	        else if (!callback)
	        {
	            this.debugCallback = this.renderDebugVerts;
	        }
	        else
	        {
	            this.debugCallback = callback;
	        }

	        return this;
	    },

	    renderDebugVerts: function (src, meshLength, verts)
	    {
	        var graphic = src.debugGraphic;

	        var px0 = verts[0];
	        var py0 = verts[1];
	        var px1 = verts[2];
	        var py1 = verts[3];

	        graphic.lineBetween(px0, py0, px1, py1);

	        for (var i = 4; i < meshLength; i += 4)
	        {
	            var x0 = verts[i + 0];
	            var y0 = verts[i + 1];
	            var x1 = verts[i + 2];
	            var y1 = verts[i + 3];

	            graphic.lineBetween(px0, py0, x0, y0);
	            graphic.lineBetween(px1, py1, x1, y1);
	            graphic.lineBetween(px1, py1, x0, y0);
	            graphic.lineBetween(x0, y0, x1, y1);

	            px0 = x0;
	            py0 = y0;
	            px1 = x1;
	            py1 = y1;
	        }
	    },

	    preDestroy: function ()
	    {
	        this.anims.destroy();

	        this.anims = undefined;

	        this.points = null;
	        this.vertices = null;
	        this.uv = null;
	        this.colors = null;
	        this.alphas = null;

	        this.debugCallback = null;
	        this.debugGraphic = null;
	    },

	    flipX: {

	        get: function ()
	        {
	            return this._flipX;
	        },

	        set: function (value)
	        {
	            this._flipX = value;

	            return this.updateUVs();
	        }

	    },

	    flipY: {

	        get: function ()
	        {
	            return this._flipY;
	        },

	        set: function (value)
	        {
	            this._flipY = value;

	            return this.updateUVs();
	        }

	    }

	});

	Rope_1 = Rope;
	return Rope_1;
}

var GetTextSize_1;
var hasRequiredGetTextSize;

function requireGetTextSize () {
	if (hasRequiredGetTextSize) return GetTextSize_1;
	hasRequiredGetTextSize = 1;
	var GetTextSize = function (text, size, lines)
	{
	    var canvas = text.canvas;
	    var context = text.context;
	    var style = text.style;

	    var lineWidths = [];
	    var maxLineWidth = 0;
	    var drawnLines = lines.length;

	    if (style.maxLines > 0 && style.maxLines < lines.length)
	    {
	        drawnLines = style.maxLines;
	    }

	    style.syncFont(canvas, context);

	    var letterSpacing = text.letterSpacing;

	    for (var i = 0; i < drawnLines; i++)
	    {
	        var lineWidth = style.strokeThickness;

	        if (letterSpacing === 0)
	        {
	            lineWidth += context.measureText(lines[i]).width;
	        }
	        else
	        {
	            var line = lines[i];

	            for (var j = 0; j < line.length; j++)
	            {
	                lineWidth += context.measureText(line[j]).width;
	            }

	            if (line.length > 1)
	            {
	                lineWidth += letterSpacing * (line.length - 1);
	            }
	        }

	        if (style.wordWrap)
	        {
	            lineWidth -= context.measureText(' ').width;
	        }

	        lineWidths[i] = Math.ceil(lineWidth);
	        maxLineWidth = Math.max(maxLineWidth, lineWidths[i]);
	    }

	    var lineHeight = size.fontSize + style.strokeThickness;
	    var height = lineHeight * drawnLines;
	    var lineSpacing = text.lineSpacing;

	    if (drawnLines > 1)
	    {
	        height += lineSpacing * (drawnLines - 1);
	    }

	    return {
	        width: maxLineWidth,
	        height: height,
	        lines: drawnLines,
	        lineWidths: lineWidths,
	        lineSpacing: lineSpacing,
	        lineHeight: lineHeight
	    };
	};

	GetTextSize_1 = GetTextSize;
	return GetTextSize_1;
}

var TextWebGLRenderer_1;
var hasRequiredTextWebGLRenderer;

function requireTextWebGLRenderer () {
	if (hasRequiredTextWebGLRenderer) return TextWebGLRenderer_1;
	hasRequiredTextWebGLRenderer = 1;
	var Utils = requireUtils$1();

	var TextWebGLRenderer = function (renderer, src, camera, parentMatrix)
	{
	    if (src.width === 0 || src.height === 0)
	    {
	        return;
	    }

	    camera.addToRenderList(src);

	    var frame = src.frame;
	    var width = frame.width;
	    var height = frame.height;
	    var getTint = Utils.getTintAppendFloatAlpha;
	    var pipeline = renderer.pipelines.set(src.pipeline, src);

	    var textureUnit = pipeline.setTexture2D(frame.glTexture, src);

	    pipeline.batchTexture(
	        src,
	        frame.glTexture,
	        width, height,
	        src.x, src.y,
	        width / src.style.resolution, height / src.style.resolution,
	        src.scaleX, src.scaleY,
	        src.rotation,
	        src.flipX, src.flipY,
	        src.scrollFactorX, src.scrollFactorY,
	        src.displayOriginX, src.displayOriginY,
	        0, 0, width, height,
	        getTint(src.tintTopLeft, camera.alpha * src._alphaTL),
	        getTint(src.tintTopRight, camera.alpha * src._alphaTR),
	        getTint(src.tintBottomLeft, camera.alpha * src._alphaBL),
	        getTint(src.tintBottomRight, camera.alpha * src._alphaBR),
	        src.tintFill,
	        0, 0,
	        camera,
	        parentMatrix,
	        false,
	        textureUnit
	    );
	};

	TextWebGLRenderer_1 = TextWebGLRenderer;
	return TextWebGLRenderer_1;
}

var TextCanvasRenderer_1;
var hasRequiredTextCanvasRenderer;

function requireTextCanvasRenderer () {
	if (hasRequiredTextCanvasRenderer) return TextCanvasRenderer_1;
	hasRequiredTextCanvasRenderer = 1;
	var TextCanvasRenderer = function (renderer, src, camera, parentMatrix)
	{
	    if (src.width === 0 || src.height === 0)
	    {
	        return;
	    }

	    camera.addToRenderList(src);

	    renderer.batchSprite(src, src.frame, camera, parentMatrix);
	};

	TextCanvasRenderer_1 = TextCanvasRenderer;
	return TextCanvasRenderer_1;
}

var TextRender;
var hasRequiredTextRender;

function requireTextRender () {
	if (hasRequiredTextRender) return TextRender;
	hasRequiredTextRender = 1;
	var NOOP = requireNOOP();
	var renderWebGL = NOOP;
	var renderCanvas = NOOP;

	if (typeof WEBGL_RENDERER)
	{
	    renderWebGL = requireTextWebGLRenderer();
	}

	if (typeof CANVAS_RENDERER)
	{
	    renderCanvas = requireTextCanvasRenderer();
	}

	TextRender = {

	    renderWebGL: renderWebGL,
	    renderCanvas: renderCanvas

	};
	return TextRender;
}

var MeasureText_1;
var hasRequiredMeasureText;

function requireMeasureText () {
	if (hasRequiredMeasureText) return MeasureText_1;
	hasRequiredMeasureText = 1;
	var CanvasPool = requireCanvasPool();

	var MeasureText = function (textStyle)
	{
	    var canvas = CanvasPool.create(this);
	    var context = canvas.getContext('2d', { willReadFrequently: true });

	    textStyle.syncFont(canvas, context);

	    var metrics = context.measureText(textStyle.testString);

	    if ('actualBoundingBoxAscent' in metrics)
	    {
	        var ascent = metrics.actualBoundingBoxAscent;
	        var descent = metrics.actualBoundingBoxDescent;

	        CanvasPool.remove(canvas);

	        return {
	            ascent: ascent,
	            descent: descent,
	            fontSize: ascent + descent
	        };
	    }

	    var width = Math.ceil(metrics.width * textStyle.baselineX);
	    var baseline = width;
	    var height = 2 * baseline;

	    baseline = baseline * textStyle.baselineY | 0;

	    canvas.width = width;
	    canvas.height = height;

	    context.fillStyle = '#f00';
	    context.fillRect(0, 0, width, height);

	    context.font = textStyle._font;

	    context.textBaseline = 'alphabetic';
	    context.fillStyle = '#000';
	    context.fillText(textStyle.testString, 0, baseline);

	    var output = {
	        ascent: 0,
	        descent: 0,
	        fontSize: 0
	    };

	    var imagedata = context.getImageData(0, 0, width, height);

	    if (!imagedata)
	    {
	        output.ascent = baseline;
	        output.descent = baseline + 6;
	        output.fontSize = output.ascent + output.descent;

	        CanvasPool.remove(canvas);

	        return output;
	    }

	    var pixels = imagedata.data;
	    var numPixels = pixels.length;
	    var line = width * 4;
	    var i;
	    var j;
	    var idx = 0;
	    var stop = false;

	    for (i = 0; i < baseline; i++)
	    {
	        for (j = 0; j < line; j += 4)
	        {
	            if (pixels[idx + j] !== 255)
	            {
	                stop = true;
	                break;
	            }
	        }

	        if (!stop)
	        {
	            idx += line;
	        }
	        else
	        {
	            break;
	        }
	    }

	    output.ascent = baseline - i;

	    idx = numPixels - line;
	    stop = false;

	    for (i = height; i > baseline; i--)
	    {
	        for (j = 0; j < line; j += 4)
	        {
	            if (pixels[idx + j] !== 255)
	            {
	                stop = true;
	                break;
	            }
	        }

	        if (!stop)
	        {
	            idx -= line;
	        }
	        else
	        {
	            break;
	        }
	    }

	    output.descent = (i - baseline);
	    output.fontSize = output.ascent + output.descent;

	    CanvasPool.remove(canvas);

	    return output;
	};

	MeasureText_1 = MeasureText;
	return MeasureText_1;
}

var TextStyle_1;
var hasRequiredTextStyle;

function requireTextStyle () {
	if (hasRequiredTextStyle) return TextStyle_1;
	hasRequiredTextStyle = 1;
	var Class = requireClass();
	var GetAdvancedValue = requireGetAdvancedValue();
	var GetValue = requireGetValue();
	var MeasureText = requireMeasureText();

	var propertyMap = {
	    fontFamily: [ 'fontFamily', 'Courier' ],
	    fontSize: [ 'fontSize', '16px' ],
	    fontStyle: [ 'fontStyle', '' ],
	    backgroundColor: [ 'backgroundColor', null ],
	    color: [ 'color', '#fff' ],
	    stroke: [ 'stroke', '#fff' ],
	    strokeThickness: [ 'strokeThickness', 0 ],
	    shadowOffsetX: [ 'shadow.offsetX', 0 ],
	    shadowOffsetY: [ 'shadow.offsetY', 0 ],
	    shadowColor: [ 'shadow.color', '#000' ],
	    shadowBlur: [ 'shadow.blur', 0 ],
	    shadowStroke: [ 'shadow.stroke', false ],
	    shadowFill: [ 'shadow.fill', false ],
	    align: [ 'align', 'left' ],
	    maxLines: [ 'maxLines', 0 ],
	    fixedWidth: [ 'fixedWidth', 0 ],
	    fixedHeight: [ 'fixedHeight', 0 ],
	    resolution: [ 'resolution', 0 ],
	    rtl: [ 'rtl', false ],
	    testString: [ 'testString', '|MÃ‰qgy' ],
	    baselineX: [ 'baselineX', 1.2 ],
	    baselineY: [ 'baselineY', 1.4 ],
	    wordWrapWidth: [ 'wordWrap.width', null ],
	    wordWrapCallback: [ 'wordWrap.callback', null ],
	    wordWrapCallbackScope: [ 'wordWrap.callbackScope', null ],
	    wordWrapUseAdvanced: [ 'wordWrap.useAdvancedWrap', false ]
	};

	var TextStyle = new Class({

	    initialize:

	    function TextStyle (text, style)
	    {

	        this.parent = text;

	        this.fontFamily;

	        this.fontSize;

	        this.fontStyle;

	        this.backgroundColor;

	        this.color;

	        this.stroke;

	        this.strokeThickness;

	        this.shadowOffsetX;

	        this.shadowOffsetY;

	        this.shadowColor;

	        this.shadowBlur;

	        this.shadowStroke;

	        this.shadowFill;

	        this.align;

	        this.maxLines;

	        this.fixedWidth;

	        this.fixedHeight;

	        this.resolution;

	        this.rtl;

	        this.testString;

	        this.baselineX;

	        this.baselineY;

	        this.wordWrapWidth;

	        this.wordWrapCallback;

	        this.wordWrapCallbackScope;

	        this.wordWrapUseAdvanced;

	        this._font;

	        this.setStyle(style, false, true);
	    },

	    setStyle: function (style, updateText, setDefaults)
	    {
	        if (updateText === undefined) { updateText = true; }
	        if (setDefaults === undefined) { setDefaults = false; }

	        for (var key in propertyMap)
	        {
	            var value = (setDefaults) ? propertyMap[key][1] : this[key];

	            if (key === 'wordWrapCallback' || key === 'wordWrapCallbackScope')
	            {

	                this[key] = GetValue(style, propertyMap[key][0], value);
	            }
	            else if (style && key === 'fontSize' && typeof style.fontSize === 'number')
	            {
	                this[key] = style.fontSize.toString() + 'px';
	            }
	            else
	            {
	                this[key] = GetAdvancedValue(style, propertyMap[key][0], value);
	            }
	        }

	        var font = GetValue(style, 'font', null);

	        if (font !== null)
	        {
	            this.setFont(font, false);
	        }

	        this._font = [ this.fontStyle, this.fontSize, this.fontFamily ].join(' ').trim();

	        var fill = GetValue(style, 'fill', null);

	        if (fill !== null)
	        {
	            this.color = fill;
	        }

	        var metrics = GetValue(style, 'metrics', false);

	        if (metrics)
	        {
	            this.metrics = {
	                ascent: GetValue(metrics, 'ascent', 0),
	                descent: GetValue(metrics, 'descent', 0),
	                fontSize: GetValue(metrics, 'fontSize', 0)
	            };
	        }
	        else if (updateText || !this.metrics)
	        {
	            this.metrics = MeasureText(this);
	        }

	        if (updateText)
	        {
	            return this.parent.updateText();
	        }
	        else
	        {
	            return this.parent;
	        }
	    },

	    syncFont: function (canvas, context)
	    {
	        context.font = this._font;
	    },

	    syncStyle: function (canvas, context)
	    {
	        context.textBaseline = 'alphabetic';

	        context.fillStyle = this.color;
	        context.strokeStyle = this.stroke;

	        context.lineWidth = this.strokeThickness;
	        context.lineCap = 'round';
	        context.lineJoin = 'round';
	    },

	    syncShadow: function (context, enabled)
	    {
	        if (enabled)
	        {
	            context.shadowOffsetX = this.shadowOffsetX;
	            context.shadowOffsetY = this.shadowOffsetY;
	            context.shadowColor = this.shadowColor;
	            context.shadowBlur = this.shadowBlur;
	        }
	        else
	        {
	            context.shadowOffsetX = 0;
	            context.shadowOffsetY = 0;
	            context.shadowColor = 0;
	            context.shadowBlur = 0;
	        }
	    },

	    update: function (recalculateMetrics)
	    {
	        if (recalculateMetrics)
	        {
	            this._font = [ this.fontStyle, this.fontSize, this.fontFamily ].join(' ').trim();

	            this.metrics = MeasureText(this);
	        }

	        return this.parent.updateText();
	    },

	    setFont: function (font, updateText)
	    {
	        if (updateText === undefined) { updateText = true; }

	        var fontFamily = font;
	        var fontSize = '';
	        var fontStyle = '';

	        if (typeof font !== 'string')
	        {
	            fontFamily = GetValue(font, 'fontFamily', 'Courier');
	            fontSize = GetValue(font, 'fontSize', '16px');
	            fontStyle = GetValue(font, 'fontStyle', '');
	        }
	        else
	        {
	            var fontSplit = font.split(' ');

	            var i = 0;

	            fontStyle = (fontSplit.length > 2) ? fontSplit[i++] : '';
	            fontSize = fontSplit[i++] || '16px';
	            fontFamily = fontSplit[i++] || 'Courier';
	        }

	        if (fontFamily !== this.fontFamily || fontSize !== this.fontSize || fontStyle !== this.fontStyle)
	        {
	            this.fontFamily = fontFamily;
	            this.fontSize = fontSize;
	            this.fontStyle = fontStyle;

	            if (updateText)
	            {
	                this.update(true);
	            }
	        }

	        return this.parent;
	    },

	    setFontFamily: function (family)
	    {
	        if (this.fontFamily !== family)
	        {
	            this.fontFamily = family;

	            this.update(true);
	        }

	        return this.parent;
	    },

	    setFontStyle: function (style)
	    {
	        if (this.fontStyle !== style)
	        {
	            this.fontStyle = style;

	            this.update(true);
	        }

	        return this.parent;
	    },

	    setFontSize: function (size)
	    {
	        if (typeof size === 'number')
	        {
	            size = size.toString() + 'px';
	        }

	        if (this.fontSize !== size)
	        {
	            this.fontSize = size;

	            this.update(true);
	        }

	        return this.parent;
	    },

	    setTestString: function (string)
	    {
	        this.testString = string;

	        return this.update(true);
	    },

	    setFixedSize: function (width, height)
	    {
	        this.fixedWidth = width;
	        this.fixedHeight = height;

	        if (width)
	        {
	            this.parent.width = width;
	        }

	        if (height)
	        {
	            this.parent.height = height;
	        }

	        return this.update(false);
	    },

	    setBackgroundColor: function (color)
	    {
	        this.backgroundColor = color;

	        return this.update(false);
	    },

	    setFill: function (color)
	    {
	        this.color = color;

	        return this.update(false);
	    },

	    setColor: function (color)
	    {
	        this.color = color;

	        return this.update(false);
	    },

	    setResolution: function (value)
	    {
	        this.resolution = value;

	        return this.update(false);
	    },

	    setStroke: function (color, thickness)
	    {
	        if (thickness === undefined) { thickness = this.strokeThickness; }

	        if (color === undefined && this.strokeThickness !== 0)
	        {

	            this.strokeThickness = 0;

	            this.update(true);
	        }
	        else if (this.stroke !== color || this.strokeThickness !== thickness)
	        {
	            this.stroke = color;
	            this.strokeThickness = thickness;

	            this.update(true);
	        }

	        return this.parent;
	    },

	    setShadow: function (x, y, color, blur, shadowStroke, shadowFill)
	    {
	        if (x === undefined) { x = 0; }
	        if (y === undefined) { y = 0; }
	        if (color === undefined) { color = '#000'; }
	        if (blur === undefined) { blur = 0; }
	        if (shadowStroke === undefined) { shadowStroke = false; }
	        if (shadowFill === undefined) { shadowFill = true; }

	        this.shadowOffsetX = x;
	        this.shadowOffsetY = y;
	        this.shadowColor = color;
	        this.shadowBlur = blur;
	        this.shadowStroke = shadowStroke;
	        this.shadowFill = shadowFill;

	        return this.update(false);
	    },

	    setShadowOffset: function (x, y)
	    {
	        if (x === undefined) { x = 0; }
	        if (y === undefined) { y = x; }

	        this.shadowOffsetX = x;
	        this.shadowOffsetY = y;

	        return this.update(false);
	    },

	    setShadowColor: function (color)
	    {
	        if (color === undefined) { color = '#000'; }

	        this.shadowColor = color;

	        return this.update(false);
	    },

	    setShadowBlur: function (blur)
	    {
	        if (blur === undefined) { blur = 0; }

	        this.shadowBlur = blur;

	        return this.update(false);
	    },

	    setShadowStroke: function (enabled)
	    {
	        this.shadowStroke = enabled;

	        return this.update(false);
	    },

	    setShadowFill: function (enabled)
	    {
	        this.shadowFill = enabled;

	        return this.update(false);
	    },

	    setWordWrapWidth: function (width, useAdvancedWrap)
	    {
	        if (useAdvancedWrap === undefined) { useAdvancedWrap = false; }

	        this.wordWrapWidth = width;
	        this.wordWrapUseAdvanced = useAdvancedWrap;

	        return this.update(false);
	    },

	    setWordWrapCallback: function (callback, scope)
	    {
	        if (scope === undefined) { scope = null; }

	        this.wordWrapCallback = callback;
	        this.wordWrapCallbackScope = scope;

	        return this.update(false);
	    },

	    setAlign: function (align)
	    {
	        if (align === undefined) { align = 'left'; }

	        this.align = align;

	        return this.update(false);
	    },

	    setMaxLines: function (max)
	    {
	        if (max === undefined) { max = 0; }

	        this.maxLines = max;

	        return this.update(false);
	    },

	    getTextMetrics: function ()
	    {
	        var metrics = this.metrics;

	        return {
	            ascent: metrics.ascent,
	            descent: metrics.descent,
	            fontSize: metrics.fontSize
	        };
	    },

	    toJSON: function ()
	    {
	        var output = {};

	        for (var key in propertyMap)
	        {
	            output[key] = this[key];
	        }

	        output.metrics = this.getTextMetrics();

	        return output;
	    },

	    destroy: function ()
	    {
	        this.parent = undefined;
	    }

	});

	TextStyle_1 = TextStyle;
	return TextStyle_1;
}

var UUID_1;
var hasRequiredUUID;

function requireUUID () {
	if (hasRequiredUUID) return UUID_1;
	hasRequiredUUID = 1;
	var UUID = function ()
	{
	    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c)
	    {
	        var r = Math.random() * 16 | 0;
	        var v = (c === 'x') ? r : (r & 0x3 | 0x8);

	        return v.toString(16);
	    });
	};

	UUID_1 = UUID;
	return UUID_1;
}

var Text_1;
var hasRequiredText;

function requireText () {
	if (hasRequiredText) return Text_1;
	hasRequiredText = 1;
	var AddToDOM = requireAddToDOM();
	var CanvasPool = requireCanvasPool();
	var Class = requireClass();
	var Components = requireComponents$2();
	var GameObject = requireGameObject();
	var GetTextSize = requireGetTextSize();
	var GetValue = requireGetValue();
	var RemoveFromDOM = requireRemoveFromDOM();
	var TextRender = requireTextRender();
	var TextStyle = requireTextStyle();
	var UUID = requireUUID();

	var Text = new Class({

	    Extends: GameObject,

	    Mixins: [
	        Components.Alpha,
	        Components.BlendMode,
	        Components.ComputedSize,
	        Components.Crop,
	        Components.Depth,
	        Components.Flip,
	        Components.GetBounds,
	        Components.Mask,
	        Components.Origin,
	        Components.Pipeline,
	        Components.PostPipeline,
	        Components.ScrollFactor,
	        Components.Tint,
	        Components.Transform,
	        Components.Visible,
	        TextRender
	    ],

	    initialize:

	    function Text (scene, x, y, text, style)
	    {
	        if (x === undefined) { x = 0; }
	        if (y === undefined) { y = 0; }

	        GameObject.call(this, scene, 'Text');

	        this.renderer = scene.sys.renderer;

	        this.setPosition(x, y);
	        this.setOrigin(0, 0);
	        this.initPipeline();
	        this.initPostPipeline(true);

	        this.canvas = CanvasPool.create(this);

	        this.context;

	        this.style = new TextStyle(this, style);

	        this.autoRound = true;

	        this.splitRegExp = /(?:\r\n|\r|\n)/;

	        this._text = undefined;

	        this.padding = { left: 0, right: 0, top: 0, bottom: 0 };

	        this.width = 1;

	        this.height = 1;

	        this.lineSpacing = 0;

	        this.letterSpacing = 0;

	        if (this.style.resolution === 0)
	        {
	            this.style.resolution = 1;
	        }

	        this._crop = this.resetCropObject();

	        this._textureKey = UUID();

	        this.texture = scene.sys.textures.addCanvas(this._textureKey, this.canvas);

	        this.context = this.texture.context;

	        this.frame = this.texture.get();

	        this.frame.source.resolution = this.style.resolution;

	        if (this.renderer && this.renderer.gl)
	        {

	            this.renderer.deleteTexture(this.frame.source.glTexture);

	            this.frame.source.glTexture = null;
	        }

	        this.initRTL();

	        this.setText(text);

	        if (style && style.padding)
	        {
	            this.setPadding(style.padding);
	        }

	        if (style && style.lineSpacing)
	        {
	            this.setLineSpacing(style.lineSpacing);
	        }

	        if (style && style.letterSpacing)
	        {
	            this.setLetterSpacing(style.letterSpacing);
	        }
	    },

	    initRTL: function ()
	    {
	        if (!this.style.rtl)
	        {
	            this.canvas.dir = 'ltr';
	            this.context.direction = 'ltr';
	            return;
	        }

	        this.canvas.dir = 'rtl';

	        this.context.direction = 'rtl';

	        this.canvas.style.display = 'none';

	        AddToDOM(this.canvas, this.scene.sys.canvas);

	        this.originX = 1;
	    },

	    runWordWrap: function (text)
	    {
	        var style = this.style;

	        if (style.wordWrapCallback)
	        {
	            var wrappedLines = style.wordWrapCallback.call(style.wordWrapCallbackScope, text, this);

	            if (Array.isArray(wrappedLines))
	            {
	                wrappedLines = wrappedLines.join('\n');
	            }

	            return wrappedLines;
	        }
	        else if (style.wordWrapWidth)
	        {
	            if (style.wordWrapUseAdvanced)
	            {
	                return this.advancedWordWrap(text, this.context, this.style.wordWrapWidth);
	            }
	            else
	            {
	                return this.basicWordWrap(text, this.context, this.style.wordWrapWidth);
	            }
	        }
	        else
	        {
	            return text;
	        }
	    },

	    advancedWordWrap: function (text, context, wordWrapWidth)
	    {
	        var output = '';

	        var lines = text
	            .replace(/ +/gi, ' ')
	            .split(this.splitRegExp);

	        var linesCount = lines.length;

	        for (var i = 0; i < linesCount; i++)
	        {
	            var line = lines[i];
	            var out = '';

	            line = line.replace(/^ *|\s*$/gi, '');

	            var lineLetterSpacingWidth = line.length * this.letterSpacing;
	            var lineWidth = context.measureText(line).width + lineLetterSpacingWidth;

	            if (lineWidth < wordWrapWidth)
	            {
	                output += line + '\n';
	                continue;
	            }

	            var currentLineWidth = wordWrapWidth;

	            var words = line.split(' ');

	            for (var j = 0; j < words.length; j++)
	            {
	                var word = words[j];
	                var wordWithSpace = word + ' ';
	                var letterSpacingWidth = wordWithSpace.length * this.letterSpacing;
	                var wordWidth = context.measureText(wordWithSpace).width + letterSpacingWidth;

	                if (wordWidth > currentLineWidth)
	                {

	                    if (j === 0)
	                    {

	                        var newWord = wordWithSpace;

	                        while (newWord.length)
	                        {
	                            newWord = newWord.slice(0, -1);
	                            var newLetterSpacingWidth = newWord.length * this.letterSpacing;
	                            wordWidth = context.measureText(newWord).width + newLetterSpacingWidth;

	                            if (wordWidth <= currentLineWidth)
	                            {
	                                break;
	                            }
	                        }

	                        if (!newWord.length)
	                        {
	                            throw new Error('wordWrapWidth < a single character');
	                        }

	                        var secondPart = word.substr(newWord.length);

	                        words[j] = secondPart;

	                        out += newWord;
	                    }

	                    var offset = (words[j].length) ? j : j + 1;

	                    var remainder = words.slice(offset).join(' ').replace(/[ \n]*$/gi, '');

	                    lines.splice(i + 1, 0, remainder);

	                    linesCount = lines.length;
	                    break; 

	                }
	                else
	                {
	                    out += wordWithSpace;
	                    currentLineWidth -= wordWidth;
	                }
	            }

	            output += out.replace(/[ \n]*$/gi, '') + '\n';
	        }

	        output = output.replace(/[\s|\n]*$/gi, '');

	        return output;
	    },

	    basicWordWrap: function (text, context, wordWrapWidth)
	    {
	        var result = '';
	        var lines = text.split(this.splitRegExp);
	        var lastLineIndex = lines.length - 1;
	        var whiteSpaceWidth = context.measureText(' ').width;

	        for (var i = 0; i <= lastLineIndex; i++)
	        {
	            var spaceLeft = wordWrapWidth;
	            var words = lines[i].split(' ');
	            var lastWordIndex = words.length - 1;

	            for (var j = 0; j <= lastWordIndex; j++)
	            {
	                var word = words[j];
	                var letterSpacingWidth = word.length * this.letterSpacing;
	                var wordWidth = context.measureText(word).width + letterSpacingWidth;
	                var wordWidthWithSpace = wordWidth;

	                if (j < lastWordIndex)
	                {
	                    wordWidthWithSpace += whiteSpaceWidth;
	                }

	                if (wordWidthWithSpace > spaceLeft)
	                {

	                    if (j > 0)
	                    {
	                        result += '\n';
	                        spaceLeft = wordWrapWidth;
	                    }
	                }

	                result += word;

	                if (j < lastWordIndex)
	                {
	                    result += ' ';
	                    spaceLeft -= wordWidthWithSpace;
	                }
	                else
	                {
	                    spaceLeft -= wordWidth;
	                }
	            }

	            if (i < lastLineIndex)
	            {
	                result += '\n';
	            }
	        }

	        return result;
	    },

	    getWrappedText: function (text)
	    {
	        if (text === undefined) { text = this._text; }

	        this.style.syncFont(this.canvas, this.context);

	        var wrappedLines = this.runWordWrap(text);

	        return wrappedLines.split(this.splitRegExp);
	    },

	    setText: function (value)
	    {
	        if (!value && value !== 0)
	        {
	            value = '';
	        }

	        if (Array.isArray(value))
	        {
	            value = value.join('\n');
	        }

	        if (value !== this._text)
	        {
	            this._text = value.toString();

	            this.updateText();
	        }

	        return this;
	    },

	    appendText: function (value, addCR)
	    {
	        if (addCR === undefined) { addCR = true; }

	        if (!value && value !== 0)
	        {
	            value = '';
	        }

	        if (Array.isArray(value))
	        {
	            value = value.join('\n');
	        }

	        value = value.toString();

	        var newText = this._text.concat((addCR) ? '\n' + value : value);

	        if (newText !== this._text)
	        {
	            this._text = newText;

	            this.updateText();
	        }

	        return this;
	    },

	    setStyle: function (style)
	    {
	        return this.style.setStyle(style);
	    },

	    setFont: function (font)
	    {
	        return this.style.setFont(font);
	    },

	    setFontFamily: function (family)
	    {
	        return this.style.setFontFamily(family);
	    },

	    setFontSize: function (size)
	    {
	        return this.style.setFontSize(size);
	    },

	    setFontStyle: function (style)
	    {
	        return this.style.setFontStyle(style);
	    },

	    setFixedSize: function (width, height)
	    {
	        return this.style.setFixedSize(width, height);
	    },

	    setBackgroundColor: function (color)
	    {
	        return this.style.setBackgroundColor(color);
	    },

	    setFill: function (fillStyle)
	    {
	        return this.style.setFill(fillStyle);
	    },

	    setColor: function (color)
	    {
	        return this.style.setColor(color);
	    },

	    setStroke: function (color, thickness)
	    {
	        return this.style.setStroke(color, thickness);
	    },

	    setShadow: function (x, y, color, blur, shadowStroke, shadowFill)
	    {
	        return this.style.setShadow(x, y, color, blur, shadowStroke, shadowFill);
	    },

	    setShadowOffset: function (x, y)
	    {
	        return this.style.setShadowOffset(x, y);
	    },

	    setShadowColor: function (color)
	    {
	        return this.style.setShadowColor(color);
	    },

	    setShadowBlur: function (blur)
	    {
	        return this.style.setShadowBlur(blur);
	    },

	    setShadowStroke: function (enabled)
	    {
	        return this.style.setShadowStroke(enabled);
	    },

	    setShadowFill: function (enabled)
	    {
	        return this.style.setShadowFill(enabled);
	    },

	    setWordWrapWidth: function (width, useAdvancedWrap)
	    {
	        return this.style.setWordWrapWidth(width, useAdvancedWrap);
	    },

	    setWordWrapCallback: function (callback, scope)
	    {
	        return this.style.setWordWrapCallback(callback, scope);
	    },

	    setAlign: function (align)
	    {
	        return this.style.setAlign(align);
	    },

	    setResolution: function (value)
	    {
	        return this.style.setResolution(value);
	    },

	    setLineSpacing: function (value)
	    {
	        this.lineSpacing = value;

	        return this.updateText();
	    },

	    setLetterSpacing: function (value)
	    {
	        this.letterSpacing = value;

	        return this.updateText();
	    },

	    setPadding: function (left, top, right, bottom)
	    {
	        if (typeof left === 'object')
	        {
	            var config = left;

	            var x = GetValue(config, 'x', null);

	            if (x !== null)
	            {
	                left = x;
	                right = x;
	            }
	            else
	            {
	                left = GetValue(config, 'left', 0);
	                right = GetValue(config, 'right', left);
	            }

	            var y = GetValue(config, 'y', null);

	            if (y !== null)
	            {
	                top = y;
	                bottom = y;
	            }
	            else
	            {
	                top = GetValue(config, 'top', 0);
	                bottom = GetValue(config, 'bottom', top);
	            }
	        }
	        else
	        {
	            if (left === undefined) { left = 0; }
	            if (top === undefined) { top = left; }
	            if (right === undefined) { right = left; }
	            if (bottom === undefined) { bottom = top; }
	        }

	        this.padding.left = left;
	        this.padding.top = top;
	        this.padding.right = right;
	        this.padding.bottom = bottom;

	        return this.updateText();
	    },

	    setMaxLines: function (max)
	    {
	        return this.style.setMaxLines(max);
	    },

	    setRTL: function (rtl)
	    {
	        if (rtl === undefined) { rtl = true; }

	        var style = this.style;

	        if (style.rtl === rtl)
	        {
	            return this;
	        }

	        style.rtl = rtl;

	        if (rtl)
	        {
	            this.canvas.dir = 'rtl';
	            this.context.direction = 'rtl';
	            this.canvas.style.display = 'none';

	            AddToDOM(this.canvas, this.scene.sys.canvas);
	        }
	        else
	        {
	            this.canvas.dir = 'ltr';
	            this.context.direction = 'ltr';
	        }

	        if (style.align === 'left')
	        {
	            style.align = 'right';
	        }
	        else if (style.align === 'right')
	        {
	            style.align = 'left';
	        }

	        return this;
	    },

	    updateText: function ()
	    {
	        var canvas = this.canvas;
	        var context = this.context;
	        var style = this.style;
	        var resolution = style.resolution;
	        var size = style.metrics;

	        style.syncFont(canvas, context);

	        var outputText = this._text;

	        if (style.wordWrapWidth || style.wordWrapCallback)
	        {
	            outputText = this.runWordWrap(this._text);
	        }

	        var lines = outputText.split(this.splitRegExp);

	        var textSize = GetTextSize(this, size, lines);

	        var padding = this.padding;

	        var textWidth;

	        if (style.fixedWidth === 0)
	        {
	            this.width = textSize.width + padding.left + padding.right;

	            textWidth = textSize.width;
	        }
	        else
	        {
	            this.width = style.fixedWidth;

	            textWidth = this.width - padding.left - padding.right;

	            if (textWidth < textSize.width)
	            {
	                textWidth = textSize.width;
	            }
	        }

	        if (style.fixedHeight === 0)
	        {
	            this.height = textSize.height + padding.top + padding.bottom;
	        }
	        else
	        {
	            this.height = style.fixedHeight;
	        }

	        var w = this.width;
	        var h = this.height;

	        this.updateDisplayOrigin();

	        w *= resolution;
	        h *= resolution;

	        w = Math.max(w, 1);
	        h = Math.max(h, 1);

	        if (canvas.width !== w || canvas.height !== h)
	        {
	            canvas.width = w;
	            canvas.height = h;

	            this.frame.setSize(w, h);

	            style.syncFont(canvas, context);

	            if (style.rtl)
	            {
	                context.direction = 'rtl';
	            }
	        }
	        else
	        {
	            context.clearRect(0, 0, w, h);
	        }

	        context.save();

	        context.scale(resolution, resolution);

	        if (style.backgroundColor)
	        {
	            context.fillStyle = style.backgroundColor;
	            context.fillRect(0, 0, w, h);
	        }

	        style.syncStyle(canvas, context);

	        context.translate(padding.left, padding.top);

	        var linePositionX;
	        var linePositionY;

	        for (var i = 0; i < textSize.lines; i++)
	        {
	            linePositionX = style.strokeThickness / 2;
	            linePositionY = (style.strokeThickness / 2 + i * textSize.lineHeight) + size.ascent;

	            if (i > 0)
	            {
	                linePositionY += (textSize.lineSpacing * i);
	            }

	            if (style.rtl)
	            {
	                linePositionX = w - linePositionX - padding.left - padding.right;
	            }
	            else if (style.align === 'right')
	            {
	                linePositionX += textWidth - textSize.lineWidths[i];
	            }
	            else if (style.align === 'center')
	            {
	                linePositionX += (textWidth - textSize.lineWidths[i]) / 2;
	            }
	            else if (style.align === 'justify')
	            {

	                var minimumLengthToApplyJustification = 0.85;

	                if (textSize.lineWidths[i] / textSize.width >= minimumLengthToApplyJustification)
	                {
	                    var extraSpace = textSize.width - textSize.lineWidths[i];
	                    var spaceSize = context.measureText(' ').width;
	                    var trimmedLine = lines[i].trim();
	                    var array = trimmedLine.split(' ');

	                    extraSpace += (lines[i].length - trimmedLine.length) * spaceSize;

	                    var extraSpaceCharacters = Math.floor(extraSpace / spaceSize);
	                    var idx = 0;

	                    while (extraSpaceCharacters > 0)
	                    {
	                        array[idx] += ' ';
	                        idx = (idx + 1) % (array.length - 1 || 1);
	                        --extraSpaceCharacters;
	                    }

	                    lines[i] = array.join(' ');
	                }
	            }

	            if (this.autoRound)
	            {
	                linePositionX = Math.round(linePositionX);
	                linePositionY = Math.round(linePositionY);
	            }

	            var letterSpacing = this.letterSpacing;

	            if (style.strokeThickness && letterSpacing === 0)
	            {
	                style.syncShadow(context, style.shadowStroke);

	                context.strokeText(lines[i], linePositionX, linePositionY);
	            }

	            if (style.color)
	            {
	                style.syncShadow(context, style.shadowFill);

	                if (letterSpacing !== 0)
	                {
	                    var charPositionX = 0;

	                    var line = lines[i].split('');

	                    for (var l = 0; l < line.length; l++)
	                    {
	                        if (style.strokeThickness)
	                        {
	                            style.syncShadow(context, style.shadowStroke);

	                            context.strokeText(line[l], linePositionX + charPositionX, linePositionY);

	                            style.syncShadow(context, style.shadowFill);
	                        }

	                        context.fillText(line[l], linePositionX + charPositionX, linePositionY);

	                        charPositionX += context.measureText(line[l]).width + letterSpacing;
	                    }
	                }
	                else
	                {
	                    context.fillText(lines[i], linePositionX, linePositionY);
	                }
	            }
	        }

	        context.restore();

	        if (this.renderer && this.renderer.gl)
	        {
	            this.frame.source.glTexture = this.renderer.canvasToTexture(canvas, this.frame.source.glTexture, true);

	            if (typeof WEBGL_DEBUG)
	            {
	                this.frame.glTexture.spectorMetadata = { textureKey: 'Text Game Object' };
	            }
	        }

	        var input = this.input;

	        if (input && !input.customHitArea)
	        {
	            input.hitArea.width = this.width;
	            input.hitArea.height = this.height;
	        }

	        return this;
	    },

	    getTextMetrics: function ()
	    {
	        return this.style.getTextMetrics();
	    },

	    text: {

	        get: function ()
	        {
	            return this._text;
	        },

	        set: function (value)
	        {
	            this.setText(value);
	        }

	    },

	    toJSON: function ()
	    {
	        var out = Components.ToJSON(this);

	        var data = {
	            autoRound: this.autoRound,
	            text: this._text,
	            style: this.style.toJSON(),
	            padding: {
	                left: this.padding.left,
	                right: this.padding.right,
	                top: this.padding.top,
	                bottom: this.padding.bottom
	            }
	        };

	        out.data = data;

	        return out;
	    },

	    preDestroy: function ()
	    {
	        RemoveFromDOM(this.canvas);

	        CanvasPool.remove(this.canvas);

	        var texture = this.texture;

	        if (texture)
	        {
	            texture.destroy();
	        }
	    }

	});

	Text_1 = Text;
	return Text_1;
}

var TileSpriteWebGLRenderer_1;
var hasRequiredTileSpriteWebGLRenderer;

function requireTileSpriteWebGLRenderer () {
	if (hasRequiredTileSpriteWebGLRenderer) return TileSpriteWebGLRenderer_1;
	hasRequiredTileSpriteWebGLRenderer = 1;
	var Utils = requireUtils$1();

	var TileSpriteWebGLRenderer = function (renderer, src, camera, parentMatrix)
	{
	    src.updateCanvas();

	    var width = src.width;
	    var height = src.height;

	    if (width === 0 || height === 0)
	    {
	        return;
	    }

	    camera.addToRenderList(src);

	    var getTint = Utils.getTintAppendFloatAlpha;

	    var pipeline = renderer.pipelines.set(src.pipeline, src);

	    var textureUnit = pipeline.setTexture2D(src.fillPattern, src);

	    pipeline.batchTexture(
	        src,
	        src.fillPattern,
	        src.displayFrame.width * src.tileScaleX, src.displayFrame.height * src.tileScaleY,
	        src.x, src.y,
	        width, height,
	        src.scaleX, src.scaleY,
	        src.rotation,
	        src.flipX, src.flipY,
	        src.scrollFactorX, src.scrollFactorY,
	        src.originX * width, src.originY * height,
	        0, 0, width, height,
	        getTint(src.tintTopLeft, camera.alpha * src._alphaTL),
	        getTint(src.tintTopRight, camera.alpha * src._alphaTR),
	        getTint(src.tintBottomLeft, camera.alpha * src._alphaBL),
	        getTint(src.tintBottomRight, camera.alpha * src._alphaBR),
	        src.tintFill,
	        (src.tilePositionX % src.displayFrame.width) / src.displayFrame.width,
	        (src.tilePositionY % src.displayFrame.height) / src.displayFrame.height,
	        camera,
	        parentMatrix,
	        false,
	        textureUnit
	    );
	};

	TileSpriteWebGLRenderer_1 = TileSpriteWebGLRenderer;
	return TileSpriteWebGLRenderer_1;
}

var TileSpriteCanvasRenderer_1;
var hasRequiredTileSpriteCanvasRenderer;

function requireTileSpriteCanvasRenderer () {
	if (hasRequiredTileSpriteCanvasRenderer) return TileSpriteCanvasRenderer_1;
	hasRequiredTileSpriteCanvasRenderer = 1;
	var TileSpriteCanvasRenderer = function (renderer, src, camera, parentMatrix)
	{
	    src.updateCanvas();

	    camera.addToRenderList(src);

	    renderer.batchSprite(src, src.frame, camera, parentMatrix);
	};

	TileSpriteCanvasRenderer_1 = TileSpriteCanvasRenderer;
	return TileSpriteCanvasRenderer_1;
}

var TileSpriteRender;
var hasRequiredTileSpriteRender;

function requireTileSpriteRender () {
	if (hasRequiredTileSpriteRender) return TileSpriteRender;
	hasRequiredTileSpriteRender = 1;
	var NOOP = requireNOOP();
	var renderWebGL = NOOP;
	var renderCanvas = NOOP;

	if (typeof WEBGL_RENDERER)
	{
	    renderWebGL = requireTileSpriteWebGLRenderer();
	}

	if (typeof CANVAS_RENDERER)
	{
	    renderCanvas = requireTileSpriteCanvasRenderer();
	}

	TileSpriteRender = {

	    renderWebGL: renderWebGL,
	    renderCanvas: renderCanvas

	};
	return TileSpriteRender;
}

var TileSprite_1;
var hasRequiredTileSprite;

function requireTileSprite () {
	if (hasRequiredTileSprite) return TileSprite_1;
	hasRequiredTileSprite = 1;
	var CanvasPool = requireCanvasPool();
	var Class = requireClass();
	var Components = requireComponents$2();
	var GameObject = requireGameObject();
	var GetPowerOfTwo = requireGetPowerOfTwo();
	var Smoothing = requireSmoothing();
	var TileSpriteRender = requireTileSpriteRender();
	var UUID = requireUUID();
	var Vector2 = requireVector2();

	var _FLAG = 8; 

	var TileSprite = new Class({

	    Extends: GameObject,

	    Mixins: [
	        Components.Alpha,
	        Components.BlendMode,
	        Components.ComputedSize,
	        Components.Crop,
	        Components.Depth,
	        Components.Flip,
	        Components.GetBounds,
	        Components.Mask,
	        Components.Origin,
	        Components.Pipeline,
	        Components.PostPipeline,
	        Components.ScrollFactor,
	        Components.Tint,
	        Components.Transform,
	        Components.Visible,
	        TileSpriteRender
	    ],

	    initialize:

	    function TileSprite (scene, x, y, width, height, textureKey, frameKey)
	    {
	        var renderer = scene.sys.renderer;

	        GameObject.call(this, scene, 'TileSprite');

	        var displayTexture = scene.sys.textures.get(textureKey);
	        var displayFrame = displayTexture.get(frameKey);

	        if (displayFrame.source.compressionAlgorithm)
	        {
	            console.warn('TileSprite cannot use compressed texture');
	            displayTexture = scene.sys.textures.get('__MISSING');
	            displayFrame = displayTexture.get();
	        }

	        if (displayTexture.type === 'DynamicTexture')
	        {
	            console.warn('TileSprite cannot use Dynamic Texture');
	            displayTexture = scene.sys.textures.get('__MISSING');
	            displayFrame = displayTexture.get();
	        }

	        if (!width || !height)
	        {
	            width = width ? width : displayFrame.width;
	            height = height ? height : displayFrame.height;
	        }
	        else
	        {
	            width = Math.floor(width);
	            height = Math.floor(height);
	        }

	        this._tilePosition = new Vector2();

	        this._tileScale = new Vector2(1, 1);

	        this.dirty = false;

	        this.renderer = renderer;

	        this.canvas = CanvasPool.create(this, width, height);

	        this.context = this.canvas.getContext('2d', { willReadFrequently: false });

	        this.displayTexture = displayTexture;

	        this.displayFrame = displayFrame;

	        this._crop = this.resetCropObject();

	        this._textureKey = UUID();

	        this.texture = scene.sys.textures.addCanvas(this._textureKey, this.canvas);

	        this.frame = this.texture.get();

	        this.potWidth = GetPowerOfTwo(displayFrame.width);

	        this.potHeight = GetPowerOfTwo(displayFrame.height);

	        this.fillCanvas = CanvasPool.create2D(this, this.potWidth, this.potHeight);

	        this.fillContext = this.fillCanvas.getContext('2d', { willReadFrequently: false });

	        this.fillPattern = null;

	        this.setPosition(x, y);
	        this.setSize(width, height);
	        this.setFrame(frameKey);
	        this.setOriginFromFrame();
	        this.initPipeline();
	        this.initPostPipeline(true);
	    },

	    setTexture: function (key, frame)
	    {
	        this.displayTexture = this.scene.sys.textures.get(key);

	        return this.setFrame(frame);
	    },

	    setFrame: function (frame)
	    {
	        var newFrame = this.displayTexture.get(frame);

	        this.potWidth = GetPowerOfTwo(newFrame.width);
	        this.potHeight = GetPowerOfTwo(newFrame.height);

	        this.canvas.width = 0;

	        if (!newFrame.cutWidth || !newFrame.cutHeight)
	        {
	            this.renderFlags &= ~_FLAG;
	        }
	        else
	        {
	            this.renderFlags |= _FLAG;
	        }

	        this.displayFrame = newFrame;

	        this.dirty = true;

	        this.updateTileTexture();

	        return this;
	    },

	    setTilePosition: function (x, y)
	    {
	        if (x !== undefined)
	        {
	            this.tilePositionX = x;
	        }

	        if (y !== undefined)
	        {
	            this.tilePositionY = y;
	        }

	        return this;
	    },

	    setTileScale: function (x, y)
	    {
	        if (x === undefined) { x = this.tileScaleX; }
	        if (y === undefined) { y = x; }

	        this.tileScaleX = x;
	        this.tileScaleY = y;

	        return this;
	    },

	    updateTileTexture: function ()
	    {
	        if (!this.dirty || !this.renderer)
	        {
	            return;
	        }

	        var frame = this.displayFrame;

	        if (frame.source.isRenderTexture || frame.source.isGLTexture)
	        {
	            console.warn('TileSprites can only use Image or Canvas based textures');

	            this.dirty = false;

	            return;
	        }

	        var ctx = this.fillContext;
	        var canvas = this.fillCanvas;

	        var fw = this.potWidth;
	        var fh = this.potHeight;

	        if (!this.renderer || !this.renderer.gl)
	        {
	            fw = frame.cutWidth;
	            fh = frame.cutHeight;
	        }

	        ctx.clearRect(0, 0, fw, fh);

	        canvas.width = fw;
	        canvas.height = fh;

	        ctx.drawImage(
	            frame.source.image,
	            frame.cutX, frame.cutY,
	            frame.cutWidth, frame.cutHeight,
	            0, 0,
	            fw, fh
	        );

	        if (this.renderer && this.renderer.gl)
	        {
	            this.fillPattern = this.renderer.canvasToTexture(canvas, this.fillPattern);

	            if (typeof WEBGL_DEBUG)
	            {
	                this.fillPattern.spectorMetadata = { textureKey: 'TileSprite Game Object' };
	            }
	        }
	        else
	        {
	            this.fillPattern = ctx.createPattern(canvas, 'repeat');
	        }

	        this.updateCanvas();

	        this.dirty = false;
	    },

	    updateCanvas: function ()
	    {
	        var canvas = this.canvas;

	        if (canvas.width !== this.width || canvas.height !== this.height)
	        {
	            canvas.width = this.width;
	            canvas.height = this.height;

	            this.frame.setSize(this.width, this.height);
	            this.updateDisplayOrigin();

	            this.dirty = true;
	        }

	        if (!this.dirty || this.renderer && this.renderer.gl)
	        {
	            this.dirty = false;
	            return;
	        }

	        var ctx = this.context;

	        if (!this.scene.sys.game.config.antialias)
	        {
	            Smoothing.disable(ctx);
	        }

	        var scaleX = this._tileScale.x;
	        var scaleY = this._tileScale.y;

	        var positionX = this._tilePosition.x;
	        var positionY = this._tilePosition.y;

	        ctx.clearRect(0, 0, this.width, this.height);

	        ctx.save();

	        ctx.scale(scaleX, scaleY);

	        ctx.translate(-positionX, -positionY);

	        ctx.fillStyle = this.fillPattern;

	        ctx.fillRect(positionX, positionY, this.width / scaleX, this.height / scaleY);

	        ctx.restore();

	        this.dirty = false;
	    },

	    preDestroy: function ()
	    {
	        if (this.renderer && this.renderer.gl)
	        {
	            this.renderer.deleteTexture(this.fillPattern);
	        }

	        CanvasPool.remove(this.canvas);
	        CanvasPool.remove(this.fillCanvas);

	        this.fillPattern = null;
	        this.fillContext = null;
	        this.fillCanvas = null;

	        this.displayTexture = null;
	        this.displayFrame = null;

	        var texture = this.texture;

	        if (texture)
	        {
	            texture.destroy();
	        }

	        this.renderer = null;
	    },

	    tilePositionX: {

	        get: function ()
	        {
	            return this._tilePosition.x;
	        },

	        set: function (value)
	        {
	            this._tilePosition.x = value;
	            this.dirty = true;
	        }

	    },

	    tilePositionY: {

	        get: function ()
	        {
	            return this._tilePosition.y;
	        },

	        set: function (value)
	        {
	            this._tilePosition.y = value;
	            this.dirty = true;
	        }

	    },

	    tileScaleX: {

	        get: function ()
	        {
	            return this._tileScale.x;
	        },

	        set: function (value)
	        {
	            this._tileScale.x = value;
	            this.dirty = true;
	        }

	    },

	    tileScaleY: {

	        get: function ()
	        {
	            return this._tileScale.y;
	        },

	        set: function (value)
	        {
	            this._tileScale.y = value;
	            this.dirty = true;
	        }

	    }

	});

	TileSprite_1 = TileSprite;
	return TileSprite_1;
}

var COMPLETE_EVENT$1;
var hasRequiredCOMPLETE_EVENT$1;

function requireCOMPLETE_EVENT$1 () {
	if (hasRequiredCOMPLETE_EVENT$1) return COMPLETE_EVENT$1;
	hasRequiredCOMPLETE_EVENT$1 = 1;
	COMPLETE_EVENT$1 = 'complete';
	return COMPLETE_EVENT$1;
}

var DECODED_EVENT;
var hasRequiredDECODED_EVENT;

function requireDECODED_EVENT () {
	if (hasRequiredDECODED_EVENT) return DECODED_EVENT;
	hasRequiredDECODED_EVENT = 1;
	DECODED_EVENT = 'decoded';
	return DECODED_EVENT;
}

var DECODED_ALL_EVENT;
var hasRequiredDECODED_ALL_EVENT;

function requireDECODED_ALL_EVENT () {
	if (hasRequiredDECODED_ALL_EVENT) return DECODED_ALL_EVENT;
	hasRequiredDECODED_ALL_EVENT = 1;
	DECODED_ALL_EVENT = 'decodedall';
	return DECODED_ALL_EVENT;
}

var DESTROY_EVENT;
var hasRequiredDESTROY_EVENT;

function requireDESTROY_EVENT () {
	if (hasRequiredDESTROY_EVENT) return DESTROY_EVENT;
	hasRequiredDESTROY_EVENT = 1;
	DESTROY_EVENT = 'destroy';
	return DESTROY_EVENT;
}

var DETUNE_EVENT;
var hasRequiredDETUNE_EVENT;

function requireDETUNE_EVENT () {
	if (hasRequiredDETUNE_EVENT) return DETUNE_EVENT;
	hasRequiredDETUNE_EVENT = 1;
	DETUNE_EVENT = 'detune';
	return DETUNE_EVENT;
}

var GLOBAL_DETUNE_EVENT;
var hasRequiredGLOBAL_DETUNE_EVENT;

function requireGLOBAL_DETUNE_EVENT () {
	if (hasRequiredGLOBAL_DETUNE_EVENT) return GLOBAL_DETUNE_EVENT;
	hasRequiredGLOBAL_DETUNE_EVENT = 1;
	GLOBAL_DETUNE_EVENT = 'detune';
	return GLOBAL_DETUNE_EVENT;
}

var GLOBAL_MUTE_EVENT;
var hasRequiredGLOBAL_MUTE_EVENT;

function requireGLOBAL_MUTE_EVENT () {
	if (hasRequiredGLOBAL_MUTE_EVENT) return GLOBAL_MUTE_EVENT;
	hasRequiredGLOBAL_MUTE_EVENT = 1;
	GLOBAL_MUTE_EVENT = 'mute';
	return GLOBAL_MUTE_EVENT;
}

var GLOBAL_RATE_EVENT;
var hasRequiredGLOBAL_RATE_EVENT;

function requireGLOBAL_RATE_EVENT () {
	if (hasRequiredGLOBAL_RATE_EVENT) return GLOBAL_RATE_EVENT;
	hasRequiredGLOBAL_RATE_EVENT = 1;
	GLOBAL_RATE_EVENT = 'rate';
	return GLOBAL_RATE_EVENT;
}

var GLOBAL_VOLUME_EVENT;
var hasRequiredGLOBAL_VOLUME_EVENT;

function requireGLOBAL_VOLUME_EVENT () {
	if (hasRequiredGLOBAL_VOLUME_EVENT) return GLOBAL_VOLUME_EVENT;
	hasRequiredGLOBAL_VOLUME_EVENT = 1;
	GLOBAL_VOLUME_EVENT = 'volume';
	return GLOBAL_VOLUME_EVENT;
}

var LOOP_EVENT;
var hasRequiredLOOP_EVENT;

function requireLOOP_EVENT () {
	if (hasRequiredLOOP_EVENT) return LOOP_EVENT;
	hasRequiredLOOP_EVENT = 1;
	LOOP_EVENT = 'loop';
	return LOOP_EVENT;
}

var LOOPED_EVENT;
var hasRequiredLOOPED_EVENT;

function requireLOOPED_EVENT () {
	if (hasRequiredLOOPED_EVENT) return LOOPED_EVENT;
	hasRequiredLOOPED_EVENT = 1;
	LOOPED_EVENT = 'looped';
	return LOOPED_EVENT;
}

var MUTE_EVENT;
var hasRequiredMUTE_EVENT;

function requireMUTE_EVENT () {
	if (hasRequiredMUTE_EVENT) return MUTE_EVENT;
	hasRequiredMUTE_EVENT = 1;
	MUTE_EVENT = 'mute';
	return MUTE_EVENT;
}

var PAN_EVENT;
var hasRequiredPAN_EVENT;

function requirePAN_EVENT () {
	if (hasRequiredPAN_EVENT) return PAN_EVENT;
	hasRequiredPAN_EVENT = 1;
	PAN_EVENT = 'pan';
	return PAN_EVENT;
}

var PAUSE_ALL_EVENT;
var hasRequiredPAUSE_ALL_EVENT;

function requirePAUSE_ALL_EVENT () {
	if (hasRequiredPAUSE_ALL_EVENT) return PAUSE_ALL_EVENT;
	hasRequiredPAUSE_ALL_EVENT = 1;
	PAUSE_ALL_EVENT = 'pauseall';
	return PAUSE_ALL_EVENT;
}

var PAUSE_EVENT$1;
var hasRequiredPAUSE_EVENT$1;

function requirePAUSE_EVENT$1 () {
	if (hasRequiredPAUSE_EVENT$1) return PAUSE_EVENT$1;
	hasRequiredPAUSE_EVENT$1 = 1;
	PAUSE_EVENT$1 = 'pause';
	return PAUSE_EVENT$1;
}

var PLAY_EVENT;
var hasRequiredPLAY_EVENT;

function requirePLAY_EVENT () {
	if (hasRequiredPLAY_EVENT) return PLAY_EVENT;
	hasRequiredPLAY_EVENT = 1;
	PLAY_EVENT = 'play';
	return PLAY_EVENT;
}

var RATE_EVENT;
var hasRequiredRATE_EVENT;

function requireRATE_EVENT () {
	if (hasRequiredRATE_EVENT) return RATE_EVENT;
	hasRequiredRATE_EVENT = 1;
	RATE_EVENT = 'rate';
	return RATE_EVENT;
}

var RESUME_ALL_EVENT;
var hasRequiredRESUME_ALL_EVENT;

function requireRESUME_ALL_EVENT () {
	if (hasRequiredRESUME_ALL_EVENT) return RESUME_ALL_EVENT;
	hasRequiredRESUME_ALL_EVENT = 1;
	RESUME_ALL_EVENT = 'resumeall';
	return RESUME_ALL_EVENT;
}

var RESUME_EVENT$1;
var hasRequiredRESUME_EVENT$1;

function requireRESUME_EVENT$1 () {
	if (hasRequiredRESUME_EVENT$1) return RESUME_EVENT$1;
	hasRequiredRESUME_EVENT$1 = 1;
	RESUME_EVENT$1 = 'resume';
	return RESUME_EVENT$1;
}

var SEEK_EVENT;
var hasRequiredSEEK_EVENT;

function requireSEEK_EVENT () {
	if (hasRequiredSEEK_EVENT) return SEEK_EVENT;
	hasRequiredSEEK_EVENT = 1;
	SEEK_EVENT = 'seek';
	return SEEK_EVENT;
}

var STOP_ALL_EVENT;
var hasRequiredSTOP_ALL_EVENT;

function requireSTOP_ALL_EVENT () {
	if (hasRequiredSTOP_ALL_EVENT) return STOP_ALL_EVENT;
	hasRequiredSTOP_ALL_EVENT = 1;
	STOP_ALL_EVENT = 'stopall';
	return STOP_ALL_EVENT;
}

var STOP_EVENT;
var hasRequiredSTOP_EVENT;

function requireSTOP_EVENT () {
	if (hasRequiredSTOP_EVENT) return STOP_EVENT;
	hasRequiredSTOP_EVENT = 1;
	STOP_EVENT = 'stop';
	return STOP_EVENT;
}

var UNLOCKED_EVENT;
var hasRequiredUNLOCKED_EVENT;

function requireUNLOCKED_EVENT () {
	if (hasRequiredUNLOCKED_EVENT) return UNLOCKED_EVENT;
	hasRequiredUNLOCKED_EVENT = 1;
	UNLOCKED_EVENT = 'unlocked';
	return UNLOCKED_EVENT;
}

var VOLUME_EVENT;
var hasRequiredVOLUME_EVENT;

function requireVOLUME_EVENT () {
	if (hasRequiredVOLUME_EVENT) return VOLUME_EVENT;
	hasRequiredVOLUME_EVENT = 1;
	VOLUME_EVENT = 'volume';
	return VOLUME_EVENT;
}

var events$5;
var hasRequiredEvents$5;

function requireEvents$5 () {
	if (hasRequiredEvents$5) return events$5;
	hasRequiredEvents$5 = 1;
	events$5 = {

	    COMPLETE: requireCOMPLETE_EVENT$1(),
	    DECODED: requireDECODED_EVENT(),
	    DECODED_ALL: requireDECODED_ALL_EVENT(),
	    DESTROY: requireDESTROY_EVENT(),
	    DETUNE: requireDETUNE_EVENT(),
	    GLOBAL_DETUNE: requireGLOBAL_DETUNE_EVENT(),
	    GLOBAL_MUTE: requireGLOBAL_MUTE_EVENT(),
	    GLOBAL_RATE: requireGLOBAL_RATE_EVENT(),
	    GLOBAL_VOLUME: requireGLOBAL_VOLUME_EVENT(),
	    LOOP: requireLOOP_EVENT(),
	    LOOPED: requireLOOPED_EVENT(),
	    MUTE: requireMUTE_EVENT(),
	    PAN: requirePAN_EVENT(),
	    PAUSE_ALL: requirePAUSE_ALL_EVENT(),
	    PAUSE: requirePAUSE_EVENT$1(),
	    PLAY: requirePLAY_EVENT(),
	    RATE: requireRATE_EVENT(),
	    RESUME_ALL: requireRESUME_ALL_EVENT(),
	    RESUME: requireRESUME_EVENT$1(),
	    SEEK: requireSEEK_EVENT(),
	    STOP_ALL: requireSTOP_ALL_EVENT(),
	    STOP: requireSTOP_EVENT(),
	    UNLOCKED: requireUNLOCKED_EVENT(),
	    VOLUME: requireVOLUME_EVENT()

	};
	return events$5;
}

var VideoWebGLRenderer_1;
var hasRequiredVideoWebGLRenderer;

function requireVideoWebGLRenderer () {
	if (hasRequiredVideoWebGLRenderer) return VideoWebGLRenderer_1;
	hasRequiredVideoWebGLRenderer = 1;
	var VideoWebGLRenderer = function (renderer, src, camera, parentMatrix)
	{
	    if (src.videoTexture)
	    {
	        camera.addToRenderList(src);

	        src.pipeline.batchSprite(src, camera, parentMatrix);
	    }
	};

	VideoWebGLRenderer_1 = VideoWebGLRenderer;
	return VideoWebGLRenderer_1;
}

var VideoCanvasRenderer_1;
var hasRequiredVideoCanvasRenderer;

function requireVideoCanvasRenderer () {
	if (hasRequiredVideoCanvasRenderer) return VideoCanvasRenderer_1;
	hasRequiredVideoCanvasRenderer = 1;
	var VideoCanvasRenderer = function (renderer, src, camera, parentMatrix)
	{
	    if (src.videoTexture)
	    {
	        camera.addToRenderList(src);

	        renderer.batchSprite(src, src.frame, camera, parentMatrix);
	    }
	};

	VideoCanvasRenderer_1 = VideoCanvasRenderer;
	return VideoCanvasRenderer_1;
}

var VideoRender;
var hasRequiredVideoRender;

function requireVideoRender () {
	if (hasRequiredVideoRender) return VideoRender;
	hasRequiredVideoRender = 1;
	var NOOP = requireNOOP();
	var renderWebGL = NOOP;
	var renderCanvas = NOOP;

	if (typeof WEBGL_RENDERER)
	{
	    renderWebGL = requireVideoWebGLRenderer();
	}

	if (typeof CANVAS_RENDERER)
	{
	    renderCanvas = requireVideoCanvasRenderer();
	}

	VideoRender = {

	    renderWebGL: renderWebGL,
	    renderCanvas: renderCanvas

	};
	return VideoRender;
}

var Video_1;
var hasRequiredVideo;

function requireVideo () {
	if (hasRequiredVideo) return Video_1;
	hasRequiredVideo = 1;
	var Clamp = requireClamp();
	var Class = requireClass();
	var Components = requireComponents$2();
	var Events = requireEvents$j();
	var GameEvents = requireEvents$h();
	var GameObject = requireGameObject();
	var MATH_CONST = require_const$c();
	var SoundEvents = requireEvents$5();
	var UUID = requireUUID();
	var VideoRender = requireVideoRender();

	var Video = new Class({

	    Extends: GameObject,

	    Mixins: [
	        Components.Alpha,
	        Components.BlendMode,
	        Components.ComputedSize,
	        Components.Depth,
	        Components.Flip,
	        Components.GetBounds,
	        Components.Mask,
	        Components.Origin,
	        Components.Pipeline,
	        Components.PostPipeline,
	        Components.ScrollFactor,
	        Components.TextureCrop,
	        Components.Tint,
	        Components.Transform,
	        Components.Visible,
	        VideoRender
	    ],

	    initialize:

	    function Video (scene, x, y, key)
	    {
	        GameObject.call(this, scene, 'Video');

	        this.video;

	        this.videoTexture;

	        this.videoTextureSource;

	        this.snapshotTexture;

	        this.flipY = false;

	        this._key = UUID();

	        this.touchLocked = false;

	        this.playWhenUnlocked = false;

	        this.frameReady = false;

	        this.isStalled = false;

	        this.failedPlayAttempts = 0;

	        this.metadata;

	        this.retry = 0;

	        this.retryInterval = 500;

	        this._systemMuted = false;

	        this._codeMuted = false;

	        this._systemPaused = false;

	        this._codePaused = false;

	        this._callbacks = {
	            ended: this.completeHandler.bind(this),
	            legacy: this.legacyPlayHandler.bind(this),
	            playing: this.playingHandler.bind(this),
	            seeked: this.seekedHandler.bind(this),
	            seeking: this.seekingHandler.bind(this),
	            stalled: this.stalledHandler.bind(this),
	            suspend: this.stalledHandler.bind(this),
	            waiting: this.stalledHandler.bind(this)
	        };

	        this._loadCallbackHandler = this.loadErrorHandler.bind(this);

	        this._metadataCallbackHandler = this.metadataHandler.bind(this);

	        this._crop = this.resetCropObject();

	        this.markers = {};

	        this._markerIn = 0;

	        this._markerOut = 0;

	        this._playingMarker = false;

	        this._lastUpdate = 0;

	        this.cacheKey = '';

	        this.isSeeking = false;

	        this._playCalled = false;

	        this._getFrame = false;

	        this._rfvCallbackId = 0;

	        var game = scene.sys.game;

	        this._device = game.device.video;

	        this.setPosition(x, y);
	        this.setSize(256, 256);
	        this.initPipeline();
	        this.initPostPipeline(true);

	        game.events.on(GameEvents.PAUSE, this.globalPause, this);
	        game.events.on(GameEvents.RESUME, this.globalResume, this);

	        var sound = scene.sys.sound;

	        if (sound)
	        {
	            sound.on(SoundEvents.GLOBAL_MUTE, this.globalMute, this);
	        }

	        if (key)
	        {
	            this.load(key);
	        }
	    },

	    addedToScene: function ()
	    {
	        this.scene.sys.updateList.add(this);
	    },

	    removedFromScene: function ()
	    {
	        this.scene.sys.updateList.remove(this);
	    },

	    load: function (key)
	    {
	        var video = this.scene.sys.cache.video.get(key);

	        if (video)
	        {
	            this.cacheKey = key;

	            this.loadHandler(video.url, video.noAudio, video.crossOrigin);
	        }
	        else
	        {
	            console.warn('No video in cache for key: ' + key);
	        }

	        return this;
	    },

	    changeSource: function (key, autoplay, loop, markerIn, markerOut)
	    {
	        if (autoplay === undefined) { autoplay = true; }
	        if (loop === undefined) { loop = false; }

	        if (this.cacheKey !== key)
	        {
	            this.load(key);

	            if (autoplay)
	            {
	                this.play(loop, markerIn, markerOut);
	            }
	        }
	    },

	    getVideoKey: function ()
	    {
	        return this.cacheKey;
	    },

	    loadURL: function (urls, noAudio, crossOrigin)
	    {
	        if (noAudio === undefined) { noAudio = false; }

	        var urlConfig = this._device.getVideoURL(urls);

	        if (!urlConfig)
	        {
	            console.warn('No supported video format found for ' + urls);
	        }
	        else
	        {
	            this.cacheKey = '';

	            this.loadHandler(urlConfig.url, noAudio, crossOrigin);
	        }

	        return this;
	    },

	    loadMediaStream: function (stream, noAudio, crossOrigin)
	    {
	        return this.loadHandler(null, noAudio, crossOrigin, stream);
	    },

	    loadHandler: function (url, noAudio, crossOrigin, stream)
	    {
	        if (!noAudio) { noAudio = false; }

	        var video = this.video;

	        if (video)
	        {

	            this.removeLoadEventHandlers();

	            this.stop();
	        }
	        else
	        {
	            video = document.createElement('video');

	            video.controls = false;

	            video.setAttribute('playsinline', 'playsinline');
	            video.setAttribute('preload', 'auto');
	            video.setAttribute('disablePictureInPicture', 'true');
	        }

	        if (noAudio)
	        {
	            video.muted = true;
	            video.defaultMuted = true;

	            video.setAttribute('autoplay', 'autoplay');
	        }
	        else
	        {
	            video.muted = false;
	            video.defaultMuted = false;

	            video.removeAttribute('autoplay');
	        }

	        if (!crossOrigin)
	        {
	            video.removeAttribute('crossorigin');
	        }
	        else
	        {
	            video.setAttribute('crossorigin', crossOrigin);
	        }

	        if (stream)
	        {
	            if ('srcObject' in video)
	            {
	                try
	                {
	                    video.srcObject = stream;
	                }
	                catch (err)
	                {
	                    if (err.name !== 'TypeError')
	                    {
	                        throw err;
	                    }

	                    video.src = URL.createObjectURL(stream);
	                }
	            }
	            else
	            {
	                video.src = URL.createObjectURL(stream);
	            }
	        }
	        else
	        {
	            video.src = url;
	        }

	        this.retry = 0;
	        this.video = video;

	        this._playCalled = false;

	        video.load();

	        this.addLoadEventHandlers();

	        var texture = this.scene.sys.textures.get(this._key);

	        this.setTexture(texture);

	        return this;
	    },

	    requestVideoFrame: function (now, metadata)
	    {
	        var video = this.video;

	        if (!video)
	        {
	            return;
	        }

	        var width = metadata.width;
	        var height = metadata.height;

	        var texture = this.videoTexture;
	        var textureSource = this.videoTextureSource;
	        var newVideo = (!texture || textureSource.source !== video);

	        if (newVideo)
	        {

	            this._codePaused = video.paused;
	            this._codeMuted = video.muted;

	            if (!texture)
	            {
	                texture = this.scene.sys.textures.create(this._key, video, width, height);

	                texture.add('__BASE', 0, 0, 0, width, height);

	                this.setTexture(texture);

	                this.videoTexture = texture;
	                this.videoTextureSource = texture.source[0];

	                this.videoTextureSource.setFlipY(this.flipY);

	                this.emit(Events.VIDEO_TEXTURE, this, texture);
	            }
	            else
	            {

	                textureSource.source = video;
	                textureSource.width = width;
	                textureSource.height = height;

	                texture.get().setSize(width, height);
	            }

	            this.setSizeToFrame();
	            this.updateDisplayOrigin();
	        }
	        else
	        {
	            textureSource.update();
	        }

	        this.isStalled = false;

	        this.metadata = metadata;

	        var currentTime = metadata.mediaTime;

	        if (newVideo)
	        {
	            this._lastUpdate = currentTime;

	            this.emit(Events.VIDEO_CREATED, this, width, height);

	            if (!this.frameReady)
	            {
	                this.frameReady = true;

	                this.emit(Events.VIDEO_PLAY, this);
	            }
	        }

	        if (this._playingMarker)
	        {
	            if (currentTime >= this._markerOut)
	            {
	                if (video.loop)
	                {
	                    video.currentTime = this._markerIn;

	                    this.emit(Events.VIDEO_LOOP, this);
	                }
	                else
	                {
	                    this.stop(false);

	                    this.emit(Events.VIDEO_COMPLETE, this);
	                }
	            }
	        }
	        else if (currentTime < this._lastUpdate)
	        {
	            this.emit(Events.VIDEO_LOOP, this);
	        }

	        this._lastUpdate = currentTime;

	        if (this._getFrame)
	        {
	            this.removeEventHandlers();

	            video.pause();

	            this._getFrame = false;
	        }
	        else
	        {
	            this._rfvCallbackId = this.video.requestVideoFrameCallback(this.requestVideoFrame.bind(this));
	        }
	    },

	    play: function (loop, markerIn, markerOut)
	    {
	        if (markerIn === undefined) { markerIn = -1; }
	        if (markerOut === undefined) { markerOut = MATH_CONST.MAX_SAFE_INTEGER; }

	        var video = this.video;

	        if (!video || this.isPlaying())
	        {
	            if (!video)
	            {
	                console.warn('Video not loaded');
	            }

	            return this;
	        }

	        if (loop === undefined) { loop = video.loop; }

	        video.loop = loop;

	        this._markerIn = markerIn;
	        this._markerOut = markerOut;
	        this._playingMarker = (markerIn > -1 && markerOut > markerIn && markerOut < MATH_CONST.MAX_SAFE_INTEGER);

	        if (!this._playCalled)
	        {
	            this._getFrame = false;

	            this._rfvCallbackId = video.requestVideoFrameCallback(this.requestVideoFrame.bind(this));

	            this._playCalled = true;

	            this.createPlayPromise();
	        }

	        return this;
	    },

	    getFirstFrame: function ()
	    {
	        var video = this.video;

	        if (!video || this.isPlaying())
	        {
	            if (!video)
	            {
	                console.warn('Video not loaded');
	            }

	            return this;
	        }

	        if (!this._playCalled)
	        {
	            this._getFrame = true;

	            this._rfvCallbackId = video.requestVideoFrameCallback(this.requestVideoFrame.bind(this));

	            this.createPlayPromise();
	        }

	        return this;
	    },

	    addLoadEventHandlers: function ()
	    {
	        var video = this.video;

	        if (video)
	        {
	            video.addEventListener('error', this._loadCallbackHandler);
	            video.addEventListener('abort', this._loadCallbackHandler);
	            video.addEventListener('loadedmetadata', this._metadataCallbackHandler);
	        }
	    },

	    removeLoadEventHandlers: function ()
	    {
	        var video = this.video;

	        if (video)
	        {
	            video.removeEventListener('error', this._loadCallbackHandler);
	            video.removeEventListener('abort', this._loadCallbackHandler);
	        }
	    },

	    addEventHandlers: function ()
	    {
	        var video = this.video;

	        if (video)
	        {
	            var callbacks = this._callbacks;

	            for (var callback in callbacks)
	            {
	                video.addEventListener(callback, callbacks[callback]);
	            }
	        }
	    },

	    removeEventHandlers: function ()
	    {
	        var video = this.video;

	        if (video)
	        {
	            var callbacks = this._callbacks;

	            for (var callback in callbacks)
	            {
	                video.removeEventListener(callback, callbacks[callback]);
	            }
	        }
	    },

	    createPlayPromise: function (catchError)
	    {
	        if (catchError === undefined) { catchError = true; }

	        var video = this.video;

	        var playPromise = video.play();

	        if (playPromise !== undefined)
	        {
	            var success = this.playSuccess.bind(this);
	            var error = this.playError.bind(this);

	            if (!catchError)
	            {
	                var _this = this;

	                error = function ()
	                {
	                    _this.failedPlayAttempts++;
	                };
	            }

	            playPromise.then(success).catch(error);
	        }
	        else
	        {

	            video.addEventListener('playing', this._callbacks.legacy);

	            if (!catchError)
	            {
	                this.failedPlayAttempts++;
	            }
	        }
	    },

	    addMarker: function (key, markerIn, markerOut)
	    {
	        if (!isNaN(markerIn) && markerIn >= 0 && !isNaN(markerOut) && markerOut > markerIn)
	        {
	            this.markers[key] = [ markerIn, markerOut ];
	        }

	        return this;
	    },

	    playMarker: function (key, loop)
	    {
	        var marker = this.markers[key];

	        if (marker)
	        {
	            this.play(loop, marker[0], marker[1]);
	        }

	        return this;
	    },

	    removeMarker: function (key)
	    {
	        delete this.markers[key];

	        return this;
	    },

	    snapshot: function (width, height)
	    {
	        if (width === undefined) { width = this.width; }
	        if (height === undefined) { height = this.height; }

	        return this.snapshotArea(0, 0, this.width, this.height, width, height);
	    },

	    snapshotArea: function (x, y, srcWidth, srcHeight, destWidth, destHeight)
	    {
	        if (x === undefined) { x = 0; }
	        if (y === undefined) { y = 0; }
	        if (srcWidth === undefined) { srcWidth = this.width; }
	        if (srcHeight === undefined) { srcHeight = this.height; }
	        if (destWidth === undefined) { destWidth = srcWidth; }
	        if (destHeight === undefined) { destHeight = srcHeight; }

	        var video = this.video;
	        var snap = this.snapshotTexture;

	        if (!snap)
	        {
	            snap = this.scene.sys.textures.createCanvas(UUID(), destWidth, destHeight);

	            this.snapshotTexture = snap;

	            if (video)
	            {
	                snap.context.drawImage(video, x, y, srcWidth, srcHeight, 0, 0, destWidth, destHeight);
	            }
	        }
	        else
	        {
	            snap.setSize(destWidth, destHeight);

	            if (video)
	            {
	                snap.context.drawImage(video, x, y, srcWidth, srcHeight, 0, 0, destWidth, destHeight);
	            }
	        }

	        return snap.update();
	    },

	    saveSnapshotTexture: function (key)
	    {
	        if (this.snapshotTexture)
	        {
	            this.scene.sys.textures.renameTexture(this.snapshotTexture.key, key);
	        }
	        else
	        {
	            this.snapshotTexture = this.scene.sys.textures.createCanvas(key, this.width, this.height);
	        }

	        return this.snapshotTexture;
	    },

	    playSuccess: function ()
	    {
	        if (!this._playCalled)
	        {

	            return;
	        }

	        this.addEventHandlers();

	        this._codePaused = false;

	        if (this.touchLocked)
	        {
	            this.touchLocked = false;

	            this.emit(Events.VIDEO_UNLOCKED, this);
	        }

	        var sound = this.scene.sys.sound;

	        if (sound && sound.mute)
	        {

	            this.setMute(true);
	        }

	        if (this._markerIn > -1)
	        {
	            this.video.currentTime = this._markerIn;
	        }
	    },

	    playError: function (error)
	    {
	        var name = error.name;

	        if (name === 'NotAllowedError')
	        {
	            this.touchLocked = true;
	            this.playWhenUnlocked = true;
	            this.failedPlayAttempts = 1;

	            this.emit(Events.VIDEO_LOCKED, this);
	        }
	        else if (name === 'NotSupportedError')
	        {
	            this.stop(false);

	            this.emit(Events.VIDEO_UNSUPPORTED, this, error);
	        }
	        else
	        {
	            this.stop(false);

	            this.emit(Events.VIDEO_ERROR, this, error);
	        }
	    },

	    legacyPlayHandler: function ()
	    {
	        var video = this.video;

	        if (video)
	        {
	            this.playSuccess();

	            video.removeEventListener('playing', this._callbacks.legacy);
	        }
	    },

	    playingHandler: function ()
	    {
	        this.isStalled = false;

	        this.emit(Events.VIDEO_PLAYING, this);
	    },

	    loadErrorHandler: function (event)
	    {
	        this.stop(false);

	        this.emit(Events.VIDEO_ERROR, this, event);
	    },

	    metadataHandler: function (event)
	    {
	        this.emit(Events.VIDEO_METADATA, this, event);
	    },

	    setSizeToFrame: function (frame)
	    {
	        if (!frame) { frame = this.frame; }

	        this.width = frame.realWidth;
	        this.height = frame.realHeight;

	        if (this.scaleX !== 1)
	        {
	            this.scaleX = this.displayWidth / this.width;
	        }

	        if (this.scaleY !== 1)
	        {
	            this.scaleY = this.displayHeight / this.height;
	        }

	        var input = this.input;

	        if (input && !input.customHitArea)
	        {
	            input.hitArea.width = this.width;
	            input.hitArea.height = this.height;
	        }

	        return this;
	    },

	    stalledHandler: function (event)
	    {
	        this.isStalled = true;

	        this.emit(Events.VIDEO_STALLED, this, event);
	    },

	    completeHandler: function ()
	    {
	        this._playCalled = false;

	        this.emit(Events.VIDEO_COMPLETE, this);
	    },

	    preUpdate: function (time, delta)
	    {
	        var video = this.video;

	        if (!video || !this._playCalled)
	        {
	            return;
	        }

	        if (this.touchLocked && this.playWhenUnlocked)
	        {
	            this.retry += delta;

	            if (this.retry >= this.retryInterval)
	            {
	                this.createPlayPromise(false);

	                this.retry = 0;
	            }
	        }
	    },

	    seekTo: function (value)
	    {
	        var video = this.video;

	        if (video)
	        {
	            var duration = video.duration;

	            if (duration !== Infinity && !isNaN(duration))
	            {
	                var seekTime = duration * value;

	                this.setCurrentTime(seekTime);
	            }
	        }

	        return this;
	    },

	    getCurrentTime: function ()
	    {
	        return (this.video) ? this.video.currentTime : 0;
	    },

	    setCurrentTime: function (value)
	    {
	        var video = this.video;

	        if (video)
	        {
	            if (typeof value === 'string')
	            {
	                var op = value[0];
	                var num = parseFloat(value.substr(1));

	                if (op === '+')
	                {
	                    value = video.currentTime + num;
	                }
	                else if (op === '-')
	                {
	                    value = video.currentTime - num;
	                }
	            }

	            video.currentTime = value;
	        }

	        return this;
	    },

	    seekingHandler: function ()
	    {
	        this.isSeeking = true;

	        this.emit(Events.VIDEO_SEEKING, this);
	    },

	    seekedHandler: function ()
	    {
	        this.isSeeking = false;

	        this.emit(Events.VIDEO_SEEKED, this);
	    },

	    getProgress: function ()
	    {
	        var video = this.video;

	        if (video)
	        {
	            var duration = video.duration;

	            if (duration !== Infinity && !isNaN(duration))
	            {
	                return video.currentTime / duration;
	            }
	        }

	        return -1;
	    },

	    getDuration: function ()
	    {
	        return (this.video) ? this.video.duration : 0;
	    },

	    setMute: function (value)
	    {
	        if (value === undefined) { value = true; }

	        this._codeMuted = value;

	        var video = this.video;

	        if (video)
	        {
	            video.muted = (this._systemMuted) ? true : value;
	        }

	        return this;
	    },

	    isMuted: function ()
	    {
	        return this._codeMuted;
	    },

	    globalMute: function (soundManager, value)
	    {
	        this._systemMuted = value;

	        var video = this.video;

	        if (video)
	        {
	            video.muted = (this._codeMuted) ? true : value;
	        }
	    },

	    globalPause: function ()
	    {
	        this._systemPaused = true;

	        if (this.video && !this.video.ended)
	        {
	            this.removeEventHandlers();

	            this.video.pause();
	        }
	    },

	    globalResume: function ()
	    {
	        this._systemPaused = false;

	        if (this.video && !this._codePaused && !this.video.ended)
	        {
	            this.createPlayPromise();
	        }
	    },

	    setPaused: function (value)
	    {
	        if (value === undefined) { value = true; }

	        var video = this.video;

	        this._codePaused = value;

	        if (video && !video.ended)
	        {
	            if (value)
	            {
	                if (!video.paused)
	                {
	                    this.removeEventHandlers();

	                    video.pause();
	                }
	            }
	            else if (!value)
	            {
	                if (!this._playCalled)
	                {
	                    this.play();
	                }
	                else if (video.paused && !this._systemPaused)
	                {
	                    this.createPlayPromise();
	                }
	            }
	        }

	        return this;
	    },

	    pause: function ()
	    {
	        return this.setPaused(true);
	    },

	    resume: function ()
	    {
	        return this.setPaused(false);
	    },

	    getVolume: function ()
	    {
	        return (this.video) ? this.video.volume : 1;
	    },

	    setVolume: function (value)
	    {
	        if (value === undefined) { value = 1; }

	        if (this.video)
	        {
	            this.video.volume = Clamp(value, 0, 1);
	        }

	        return this;
	    },

	    getPlaybackRate: function ()
	    {
	        return (this.video) ? this.video.playbackRate : 1;
	    },

	    setPlaybackRate: function (rate)
	    {
	        if (this.video)
	        {
	            this.video.playbackRate = rate;
	        }

	        return this;
	    },

	    getLoop: function ()
	    {
	        return (this.video) ? this.video.loop : false;
	    },

	    setLoop: function (value)
	    {
	        if (value === undefined) { value = true; }

	        if (this.video)
	        {
	            this.video.loop = value;
	        }

	        return this;
	    },

	    isPlaying: function ()
	    {
	        return (this.video) ? !(this.video.paused || this.video.ended) : false;
	    },

	    isPaused: function ()
	    {
	        return ((this.video && this._playCalled && this.video.paused) || this._codePaused || this._systemPaused);
	    },

	    saveTexture: function (key, flipY)
	    {
	        if (flipY === undefined) { flipY = false; }

	        if (this.videoTexture)
	        {
	            this.scene.sys.textures.renameTexture(this._key, key);
	            this.videoTextureSource.setFlipY(flipY);
	        }

	        this._key = key;
	        this.flipY = flipY;

	        return (this.videoTexture) ? true : false;
	    },

	    stop: function (emitStopEvent)
	    {
	        if (emitStopEvent === undefined) { emitStopEvent = true; }

	        var video = this.video;

	        if (video)
	        {
	            this.removeEventHandlers();

	            video.cancelVideoFrameCallback(this._rfvCallbackId);

	            video.pause();
	        }

	        this.retry = 0;
	        this._playCalled = false;

	        if (emitStopEvent)
	        {
	            this.emit(Events.VIDEO_STOP, this);
	        }

	        return this;
	    },

	    removeVideoElement: function ()
	    {
	        var video = this.video;

	        if (!video)
	        {
	            return;
	        }

	        if (video.parentNode)
	        {
	            video.parentNode.removeChild(video);
	        }

	        while (video.hasChildNodes())
	        {
	            video.removeChild(video.firstChild);
	        }

	        video.removeAttribute('autoplay');
	        video.removeAttribute('src');

	        this.video = null;
	    },

	    preDestroy: function ()
	    {
	        this.stop(false);

	        this.removeLoadEventHandlers();

	        this.removeVideoElement();

	        var game = this.scene.sys.game.events;

	        game.off(GameEvents.PAUSE, this.globalPause, this);
	        game.off(GameEvents.RESUME, this.globalResume, this);

	        var sound = this.scene.sys.sound;

	        if (sound)
	        {
	            sound.off(SoundEvents.GLOBAL_MUTE, this.globalMute, this);
	        }
	    }

	});

	Video_1 = Video;
	return Video_1;
}

var Shape_1;
var hasRequiredShape;

function requireShape () {
	if (hasRequiredShape) return Shape_1;
	hasRequiredShape = 1;
	var Class = requireClass();
	var Components = requireComponents$2();
	var GameObject = requireGameObject();
	var Line = requireLine$2();

	var Shape = new Class({

	    Extends: GameObject,

	    Mixins: [
	        Components.AlphaSingle,
	        Components.BlendMode,
	        Components.Depth,
	        Components.GetBounds,
	        Components.Mask,
	        Components.Origin,
	        Components.Pipeline,
	        Components.PostPipeline,
	        Components.ScrollFactor,
	        Components.Transform,
	        Components.Visible
	    ],

	    initialize:

	    function Shape (scene, type, data)
	    {
	        if (type === undefined) { type = 'Shape'; }

	        GameObject.call(this, scene, type);

	        this.geom = data;

	        this.pathData = [];

	        this.pathIndexes = [];

	        this.fillColor = 0xffffff;

	        this.fillAlpha = 1;

	        this.strokeColor = 0xffffff;

	        this.strokeAlpha = 1;

	        this.lineWidth = 1;

	        this.isFilled = false;

	        this.isStroked = false;

	        this.closePath = true;

	        this._tempLine = new Line();

	        this.width = 0;

	        this.height = 0;

	        this.initPipeline();
	        this.initPostPipeline();
	    },

	    setFillStyle: function (color, alpha)
	    {
	        if (alpha === undefined) { alpha = 1; }

	        if (color === undefined)
	        {
	            this.isFilled = false;
	        }
	        else
	        {
	            this.fillColor = color;
	            this.fillAlpha = alpha;
	            this.isFilled = true;
	        }

	        return this;
	    },

	    setStrokeStyle: function (lineWidth, color, alpha)
	    {
	        if (alpha === undefined) { alpha = 1; }

	        if (lineWidth === undefined)
	        {
	            this.isStroked = false;
	        }
	        else
	        {
	            this.lineWidth = lineWidth;
	            this.strokeColor = color;
	            this.strokeAlpha = alpha;
	            this.isStroked = true;
	        }

	        return this;
	    },

	    setClosePath: function (value)
	    {
	        this.closePath = value;

	        return this;
	    },

	    setSize: function (width, height)
	    {
	        this.width = width;
	        this.height = height;

	        return this;
	    },

	    setDisplaySize: function (width, height)
	    {
	        this.displayWidth = width;
	        this.displayHeight = height;

	        return this;
	    },

	    preDestroy: function ()
	    {
	        this.geom = null;
	        this._tempLine = null;
	        this.pathData = [];
	        this.pathIndexes = [];
	    },

	    displayWidth: {

	        get: function ()
	        {
	            return this.scaleX * this.width;
	        },

	        set: function (value)
	        {
	            this.scaleX = value / this.width;
	        }

	    },

	    displayHeight: {

	        get: function ()
	        {
	            return this.scaleY * this.height;
	        },

	        set: function (value)
	        {
	            this.scaleY = value / this.height;
	        }

	    }

	});

	Shape_1 = Shape;
	return Shape_1;
}

var FillPathWebGL_1;
var hasRequiredFillPathWebGL;

function requireFillPathWebGL () {
	if (hasRequiredFillPathWebGL) return FillPathWebGL_1;
	hasRequiredFillPathWebGL = 1;
	var Utils = requireUtils$1();

	var FillPathWebGL = function (pipeline, calcMatrix, src, alpha, dx, dy)
	{
	    var fillTintColor = Utils.getTintAppendFloatAlpha(src.fillColor, src.fillAlpha * alpha);

	    var path = src.pathData;
	    var pathIndexes = src.pathIndexes;

	    for (var i = 0; i < pathIndexes.length; i += 3)
	    {
	        var p0 = pathIndexes[i] * 2;
	        var p1 = pathIndexes[i + 1] * 2;
	        var p2 = pathIndexes[i + 2] * 2;

	        var x0 = path[p0 + 0] - dx;
	        var y0 = path[p0 + 1] - dy;
	        var x1 = path[p1 + 0] - dx;
	        var y1 = path[p1 + 1] - dy;
	        var x2 = path[p2 + 0] - dx;
	        var y2 = path[p2 + 1] - dy;

	        var tx0 = calcMatrix.getX(x0, y0);
	        var ty0 = calcMatrix.getY(x0, y0);

	        var tx1 = calcMatrix.getX(x1, y1);
	        var ty1 = calcMatrix.getY(x1, y1);

	        var tx2 = calcMatrix.getX(x2, y2);
	        var ty2 = calcMatrix.getY(x2, y2);

	        pipeline.batchTri(src, tx0, ty0, tx1, ty1, tx2, ty2, 0, 0, 1, 1, fillTintColor, fillTintColor, fillTintColor, 2);
	    }
	};

	FillPathWebGL_1 = FillPathWebGL;
	return FillPathWebGL_1;
}

var StrokePathWebGL_1;
var hasRequiredStrokePathWebGL;

function requireStrokePathWebGL () {
	if (hasRequiredStrokePathWebGL) return StrokePathWebGL_1;
	hasRequiredStrokePathWebGL = 1;
	var Utils = requireUtils$1();

	var StrokePathWebGL = function (pipeline, src, alpha, dx, dy)
	{
	    var strokeTint = pipeline.strokeTint;
	    var strokeTintColor = Utils.getTintAppendFloatAlpha(src.strokeColor, src.strokeAlpha * alpha);

	    strokeTint.TL = strokeTintColor;
	    strokeTint.TR = strokeTintColor;
	    strokeTint.BL = strokeTintColor;
	    strokeTint.BR = strokeTintColor;

	    var path = src.pathData;
	    var pathLength = path.length - 1;
	    var lineWidth = src.lineWidth;
	    var halfLineWidth = lineWidth / 2;

	    var px1 = path[0] - dx;
	    var py1 = path[1] - dy;

	    if (!src.closePath)
	    {
	        pathLength -= 2;
	    }

	    for (var i = 2; i < pathLength; i += 2)
	    {
	        var px2 = path[i] - dx;
	        var py2 = path[i + 1] - dy;

	        pipeline.batchLine(
	            px1,
	            py1,
	            px2,
	            py2,
	            halfLineWidth,
	            halfLineWidth,
	            lineWidth,
	            i - 2,
	            (src.closePath) ? (i === pathLength - 1) : false
	        );

	        px1 = px2;
	        py1 = py2;
	    }
	};

	StrokePathWebGL_1 = StrokePathWebGL;
	return StrokePathWebGL_1;
}

var ArcWebGLRenderer_1;
var hasRequiredArcWebGLRenderer;

function requireArcWebGLRenderer () {
	if (hasRequiredArcWebGLRenderer) return ArcWebGLRenderer_1;
	hasRequiredArcWebGLRenderer = 1;
	var GetCalcMatrix = requireGetCalcMatrix();
	var FillPathWebGL = requireFillPathWebGL();
	var StrokePathWebGL = requireStrokePathWebGL();

	var ArcWebGLRenderer = function (renderer, src, camera, parentMatrix)
	{
	    camera.addToRenderList(src);

	    var pipeline = renderer.pipelines.set(src.pipeline);

	    var result = GetCalcMatrix(src, camera, parentMatrix);

	    var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);

	    var dx = src._displayOriginX;
	    var dy = src._displayOriginY;

	    var alpha = camera.alpha * src.alpha;

	    renderer.pipelines.preBatch(src);

	    if (src.isFilled)
	    {
	        FillPathWebGL(pipeline, calcMatrix, src, alpha, dx, dy);
	    }

	    if (src.isStroked)
	    {
	        StrokePathWebGL(pipeline, src, alpha, dx, dy);
	    }

	    renderer.pipelines.postBatch(src);
	};

	ArcWebGLRenderer_1 = ArcWebGLRenderer;
	return ArcWebGLRenderer_1;
}

var FillStyleCanvas_1;
var hasRequiredFillStyleCanvas;

function requireFillStyleCanvas () {
	if (hasRequiredFillStyleCanvas) return FillStyleCanvas_1;
	hasRequiredFillStyleCanvas = 1;
	var FillStyleCanvas = function (ctx, src, altColor, altAlpha)
	{
	    var fillColor = (altColor) ? altColor : src.fillColor;
	    var fillAlpha = (altAlpha) ? altAlpha : src.fillAlpha;

	    var red = ((fillColor & 0xFF0000) >>> 16);
	    var green = ((fillColor & 0xFF00) >>> 8);
	    var blue = (fillColor & 0xFF);

	    ctx.fillStyle = 'rgba(' + red + ',' + green + ',' + blue + ',' + fillAlpha + ')';
	};

	FillStyleCanvas_1 = FillStyleCanvas;
	return FillStyleCanvas_1;
}

var LineStyleCanvas_1;
var hasRequiredLineStyleCanvas;

function requireLineStyleCanvas () {
	if (hasRequiredLineStyleCanvas) return LineStyleCanvas_1;
	hasRequiredLineStyleCanvas = 1;
	var LineStyleCanvas = function (ctx, src, altColor, altAlpha)
	{
	    var strokeColor = (altColor) ? altColor : src.strokeColor;
	    var strokeAlpha = (altAlpha) ? altAlpha : src.strokeAlpha;

	    var red = ((strokeColor & 0xFF0000) >>> 16);
	    var green = ((strokeColor & 0xFF00) >>> 8);
	    var blue = (strokeColor & 0xFF);

	    ctx.strokeStyle = 'rgba(' + red + ',' + green + ',' + blue + ',' + strokeAlpha + ')';
	    ctx.lineWidth = src.lineWidth;
	};

	LineStyleCanvas_1 = LineStyleCanvas;
	return LineStyleCanvas_1;
}

var ArcCanvasRenderer_1;
var hasRequiredArcCanvasRenderer;

function requireArcCanvasRenderer () {
	if (hasRequiredArcCanvasRenderer) return ArcCanvasRenderer_1;
	hasRequiredArcCanvasRenderer = 1;
	var DegToRad = requireDegToRad();
	var FillStyleCanvas = requireFillStyleCanvas();
	var LineStyleCanvas = requireLineStyleCanvas();
	var SetTransform = requireSetTransform();

	var ArcCanvasRenderer = function (renderer, src, camera, parentMatrix)
	{
	    camera.addToRenderList(src);

	    var ctx = renderer.currentContext;

	    if (SetTransform(renderer, ctx, src, camera, parentMatrix))
	    {
	        var radius = src.radius;

	        ctx.beginPath();

	        ctx.arc(
	            (radius) - src.originX * (radius * 2),
	            (radius) - src.originY * (radius * 2),
	            radius,
	            DegToRad(src._startAngle),
	            DegToRad(src._endAngle),
	            src.anticlockwise
	        );

	        if (src.closePath)
	        {
	            ctx.closePath();
	        }

	        if (src.isFilled)
	        {
	            FillStyleCanvas(ctx, src);

	            ctx.fill();
	        }

	        if (src.isStroked)
	        {
	            LineStyleCanvas(ctx, src);

	            ctx.stroke();
	        }

	        ctx.restore();
	    }
	};

	ArcCanvasRenderer_1 = ArcCanvasRenderer;
	return ArcCanvasRenderer_1;
}

var ArcRender;
var hasRequiredArcRender;

function requireArcRender () {
	if (hasRequiredArcRender) return ArcRender;
	hasRequiredArcRender = 1;
	var NOOP = requireNOOP();
	var renderWebGL = NOOP;
	var renderCanvas = NOOP;

	if (typeof WEBGL_RENDERER)
	{
	    renderWebGL = requireArcWebGLRenderer();
	}

	if (typeof CANVAS_RENDERER)
	{
	    renderCanvas = requireArcCanvasRenderer();
	}

	ArcRender = {

	    renderWebGL: renderWebGL,
	    renderCanvas: renderCanvas

	};
	return ArcRender;
}

var Arc_1;
var hasRequiredArc;

function requireArc () {
	if (hasRequiredArc) return Arc_1;
	hasRequiredArc = 1;
	var ArcRender = requireArcRender();
	var Class = requireClass();
	var DegToRad = requireDegToRad();
	var Earcut = requireEarcut();
	var GeomCircle = requireCircle$2();
	var MATH_CONST = require_const$c();
	var Shape = requireShape();

	var Arc = new Class({

	    Extends: Shape,

	    Mixins: [
	        ArcRender
	    ],

	    initialize:

	    function Arc (scene, x, y, radius, startAngle, endAngle, anticlockwise, fillColor, fillAlpha)
	    {
	        if (x === undefined) { x = 0; }
	        if (y === undefined) { y = 0; }
	        if (radius === undefined) { radius = 128; }
	        if (startAngle === undefined) { startAngle = 0; }
	        if (endAngle === undefined) { endAngle = 360; }
	        if (anticlockwise === undefined) { anticlockwise = false; }

	        Shape.call(this, scene, 'Arc', new GeomCircle(0, 0, radius));

	        this._startAngle = startAngle;

	        this._endAngle = endAngle;

	        this._anticlockwise = anticlockwise;

	        this._iterations = 0.01;

	        this.setPosition(x, y);

	        var diameter = this.geom.radius * 2;
	        this.setSize(diameter, diameter);

	        if (fillColor !== undefined)
	        {
	            this.setFillStyle(fillColor, fillAlpha);
	        }

	        this.updateDisplayOrigin();
	        this.updateData();
	    },

	    iterations: {

	        get: function ()
	        {
	            return this._iterations;
	        },

	        set: function (value)
	        {
	            this._iterations = value;

	            this.updateData();
	        }

	    },

	    radius: {

	        get: function ()
	        {
	            return this.geom.radius;
	        },

	        set: function (value)
	        {
	            this.geom.radius = value;

	            var diameter = value * 2;
	            this.setSize(diameter, diameter);
	            this.updateDisplayOrigin();
	            this.updateData();
	        }

	    },

	    startAngle: {

	        get: function ()
	        {
	            return this._startAngle;
	        },

	        set: function (value)
	        {
	            this._startAngle = value;

	            this.updateData();
	        }

	    },

	    endAngle: {

	        get: function ()
	        {
	            return this._endAngle;
	        },

	        set: function (value)
	        {
	            this._endAngle = value;

	            this.updateData();
	        }

	    },

	    anticlockwise: {

	        get: function ()
	        {
	            return this._anticlockwise;
	        },

	        set: function (value)
	        {
	            this._anticlockwise = value;

	            this.updateData();
	        }

	    },

	    setRadius: function (value)
	    {
	        this.radius = value;

	        return this;
	    },

	    setIterations: function (value)
	    {
	        if (value === undefined) { value = 0.01; }

	        this.iterations = value;

	        return this;
	    },

	    setStartAngle: function (angle, anticlockwise)
	    {
	        this._startAngle = angle;

	        if (anticlockwise !== undefined)
	        {
	            this._anticlockwise = anticlockwise;
	        }

	        return this.updateData();
	    },

	    setEndAngle: function (angle, anticlockwise)
	    {
	        this._endAngle = angle;

	        if (anticlockwise !== undefined)
	        {
	            this._anticlockwise = anticlockwise;
	        }

	        return this.updateData();
	    },

	    updateData: function ()
	    {
	        var step = this._iterations;
	        var iteration = step;

	        var radius = this.geom.radius;
	        var startAngle = DegToRad(this._startAngle);
	        var endAngle = DegToRad(this._endAngle);
	        var anticlockwise = this._anticlockwise;

	        var x = radius;
	        var y = radius;

	        endAngle -= startAngle;

	        if (anticlockwise)
	        {
	            if (endAngle < -MATH_CONST.PI2)
	            {
	                endAngle = -MATH_CONST.PI2;
	            }
	            else if (endAngle > 0)
	            {
	                endAngle = -MATH_CONST.PI2 + endAngle % MATH_CONST.PI2;
	            }
	        }
	        else if (endAngle > MATH_CONST.PI2)
	        {
	            endAngle = MATH_CONST.PI2;
	        }
	        else if (endAngle < 0)
	        {
	            endAngle = MATH_CONST.PI2 + endAngle % MATH_CONST.PI2;
	        }

	        var path = [ x + Math.cos(startAngle) * radius, y + Math.sin(startAngle) * radius ];

	        var ta;

	        while (iteration < 1)
	        {
	            ta = endAngle * iteration + startAngle;

	            path.push(x + Math.cos(ta) * radius, y + Math.sin(ta) * radius);

	            iteration += step;
	        }

	        ta = endAngle + startAngle;

	        path.push(x + Math.cos(ta) * radius, y + Math.sin(ta) * radius);

	        path.push(x + Math.cos(startAngle) * radius, y + Math.sin(startAngle) * radius);

	        this.pathIndexes = Earcut(path);
	        this.pathData = path;

	        return this;
	    }

	});

	Arc_1 = Arc;
	return Arc_1;
}

var CurveWebGLRenderer_1;
var hasRequiredCurveWebGLRenderer;

function requireCurveWebGLRenderer () {
	if (hasRequiredCurveWebGLRenderer) return CurveWebGLRenderer_1;
	hasRequiredCurveWebGLRenderer = 1;
	var FillPathWebGL = requireFillPathWebGL();
	var GetCalcMatrix = requireGetCalcMatrix();
	var StrokePathWebGL = requireStrokePathWebGL();

	var CurveWebGLRenderer = function (renderer, src, camera, parentMatrix)
	{
	    camera.addToRenderList(src);

	    var pipeline = renderer.pipelines.set(src.pipeline);

	    var result = GetCalcMatrix(src, camera, parentMatrix);

	    var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);

	    var dx = src._displayOriginX + src._curveBounds.x;
	    var dy = src._displayOriginY + src._curveBounds.y;

	    var alpha = camera.alpha * src.alpha;

	    renderer.pipelines.preBatch(src);

	    if (src.isFilled)
	    {
	        FillPathWebGL(pipeline, calcMatrix, src, alpha, dx, dy);
	    }

	    if (src.isStroked)
	    {
	        StrokePathWebGL(pipeline, src, alpha, dx, dy);
	    }

	    renderer.pipelines.postBatch(src);
	};

	CurveWebGLRenderer_1 = CurveWebGLRenderer;
	return CurveWebGLRenderer_1;
}

var CurveCanvasRenderer_1;
var hasRequiredCurveCanvasRenderer;

function requireCurveCanvasRenderer () {
	if (hasRequiredCurveCanvasRenderer) return CurveCanvasRenderer_1;
	hasRequiredCurveCanvasRenderer = 1;
	var FillStyleCanvas = requireFillStyleCanvas();
	var LineStyleCanvas = requireLineStyleCanvas();
	var SetTransform = requireSetTransform();

	var CurveCanvasRenderer = function (renderer, src, camera, parentMatrix)
	{
	    camera.addToRenderList(src);

	    var ctx = renderer.currentContext;

	    if (SetTransform(renderer, ctx, src, camera, parentMatrix))
	    {
	        var dx = src._displayOriginX + src._curveBounds.x;
	        var dy = src._displayOriginY + src._curveBounds.y;

	        var path = src.pathData;
	        var pathLength = path.length - 1;

	        var px1 = path[0] - dx;
	        var py1 = path[1] - dy;

	        ctx.beginPath();

	        ctx.moveTo(px1, py1);

	        if (!src.closePath)
	        {
	            pathLength -= 2;
	        }

	        for (var i = 2; i < pathLength; i += 2)
	        {
	            var px2 = path[i] - dx;
	            var py2 = path[i + 1] - dy;

	            ctx.lineTo(px2, py2);
	        }

	        if (src.closePath)
	        {
	            ctx.closePath();
	        }

	        if (src.isFilled)
	        {
	            FillStyleCanvas(ctx, src);

	            ctx.fill();
	        }

	        if (src.isStroked)
	        {
	            LineStyleCanvas(ctx, src);

	            ctx.stroke();
	        }

	        ctx.restore();
	    }
	};

	CurveCanvasRenderer_1 = CurveCanvasRenderer;
	return CurveCanvasRenderer_1;
}

var CurveRender;
var hasRequiredCurveRender;

function requireCurveRender () {
	if (hasRequiredCurveRender) return CurveRender;
	hasRequiredCurveRender = 1;
	var NOOP = requireNOOP();
	var renderWebGL = NOOP;
	var renderCanvas = NOOP;

	if (typeof WEBGL_RENDERER)
	{
	    renderWebGL = requireCurveWebGLRenderer();
	}

	if (typeof CANVAS_RENDERER)
	{
	    renderCanvas = requireCurveCanvasRenderer();
	}

	CurveRender = {

	    renderWebGL: renderWebGL,
	    renderCanvas: renderCanvas

	};
	return CurveRender;
}

var Curve_1;
var hasRequiredCurve;

function requireCurve () {
	if (hasRequiredCurve) return Curve_1;
	hasRequiredCurve = 1;
	var Class = requireClass();
	var CurveRender = requireCurveRender();
	var Earcut = requireEarcut();
	var Rectangle = requireRectangle$2();
	var Shape = requireShape();

	var Curve = new Class({

	    Extends: Shape,

	    Mixins: [
	        CurveRender
	    ],

	    initialize:

	    function Curve (scene, x, y, curve, fillColor, fillAlpha)
	    {
	        if (x === undefined) { x = 0; }
	        if (y === undefined) { y = 0; }

	        Shape.call(this, scene, 'Curve', curve);

	        this._smoothness = 32;

	        this._curveBounds = new Rectangle();

	        this.closePath = false;

	        this.setPosition(x, y);

	        if (fillColor !== undefined)
	        {
	            this.setFillStyle(fillColor, fillAlpha);
	        }

	        this.updateData();
	    },

	    smoothness: {

	        get: function ()
	        {
	            return this._smoothness;
	        },

	        set: function (value)
	        {
	            this._smoothness = value;

	            this.updateData();
	        }

	    },

	    setSmoothness: function (value)
	    {
	        this._smoothness = value;

	        return this.updateData();
	    },

	    updateData: function ()
	    {
	        var bounds = this._curveBounds;
	        var smoothness = this._smoothness;

	        this.geom.getBounds(bounds, smoothness);

	        this.setSize(bounds.width, bounds.height);
	        this.updateDisplayOrigin();

	        var path = [];
	        var points = this.geom.getPoints(smoothness);

	        for (var i = 0; i < points.length; i++)
	        {
	            path.push(points[i].x, points[i].y);
	        }

	        path.push(points[0].x, points[0].y);

	        this.pathIndexes = Earcut(path);
	        this.pathData = path;

	        return this;
	    }

	});

	Curve_1 = Curve;
	return Curve_1;
}

var EllipseWebGLRenderer_1;
var hasRequiredEllipseWebGLRenderer;

function requireEllipseWebGLRenderer () {
	if (hasRequiredEllipseWebGLRenderer) return EllipseWebGLRenderer_1;
	hasRequiredEllipseWebGLRenderer = 1;
	var FillPathWebGL = requireFillPathWebGL();
	var GetCalcMatrix = requireGetCalcMatrix();
	var StrokePathWebGL = requireStrokePathWebGL();

	var EllipseWebGLRenderer = function (renderer, src, camera, parentMatrix)
	{
	    camera.addToRenderList(src);

	    var pipeline = renderer.pipelines.set(src.pipeline);

	    var result = GetCalcMatrix(src, camera, parentMatrix);

	    var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);

	    var dx = src._displayOriginX;
	    var dy = src._displayOriginY;

	    var alpha = camera.alpha * src.alpha;

	    renderer.pipelines.preBatch(src);

	    if (src.isFilled)
	    {
	        FillPathWebGL(pipeline, calcMatrix, src, alpha, dx, dy);
	    }

	    if (src.isStroked)
	    {
	        StrokePathWebGL(pipeline, src, alpha, dx, dy);
	    }

	    renderer.pipelines.postBatch(src);
	};

	EllipseWebGLRenderer_1 = EllipseWebGLRenderer;
	return EllipseWebGLRenderer_1;
}

var EllipseCanvasRenderer_1;
var hasRequiredEllipseCanvasRenderer;

function requireEllipseCanvasRenderer () {
	if (hasRequiredEllipseCanvasRenderer) return EllipseCanvasRenderer_1;
	hasRequiredEllipseCanvasRenderer = 1;
	var FillStyleCanvas = requireFillStyleCanvas();
	var LineStyleCanvas = requireLineStyleCanvas();
	var SetTransform = requireSetTransform();

	var EllipseCanvasRenderer = function (renderer, src, camera, parentMatrix)
	{
	    camera.addToRenderList(src);

	    var ctx = renderer.currentContext;

	    if (SetTransform(renderer, ctx, src, camera, parentMatrix))
	    {
	        var dx = src._displayOriginX;
	        var dy = src._displayOriginY;

	        var path = src.pathData;
	        var pathLength = path.length - 1;

	        var px1 = path[0] - dx;
	        var py1 = path[1] - dy;

	        ctx.beginPath();

	        ctx.moveTo(px1, py1);

	        if (!src.closePath)
	        {
	            pathLength -= 2;
	        }

	        for (var i = 2; i < pathLength; i += 2)
	        {
	            var px2 = path[i] - dx;
	            var py2 = path[i + 1] - dy;

	            ctx.lineTo(px2, py2);
	        }

	        ctx.closePath();

	        if (src.isFilled)
	        {
	            FillStyleCanvas(ctx, src);

	            ctx.fill();
	        }

	        if (src.isStroked)
	        {
	            LineStyleCanvas(ctx, src);

	            ctx.stroke();
	        }

	        ctx.restore();
	    }
	};

	EllipseCanvasRenderer_1 = EllipseCanvasRenderer;
	return EllipseCanvasRenderer_1;
}

var EllipseRender;
var hasRequiredEllipseRender;

function requireEllipseRender () {
	if (hasRequiredEllipseRender) return EllipseRender;
	hasRequiredEllipseRender = 1;
	var NOOP = requireNOOP();
	var renderWebGL = NOOP;
	var renderCanvas = NOOP;

	if (typeof WEBGL_RENDERER)
	{
	    renderWebGL = requireEllipseWebGLRenderer();
	}

	if (typeof CANVAS_RENDERER)
	{
	    renderCanvas = requireEllipseCanvasRenderer();
	}

	EllipseRender = {

	    renderWebGL: renderWebGL,
	    renderCanvas: renderCanvas

	};
	return EllipseRender;
}

var Ellipse_1;
var hasRequiredEllipse$1;

function requireEllipse$1 () {
	if (hasRequiredEllipse$1) return Ellipse_1;
	hasRequiredEllipse$1 = 1;
	var Class = requireClass();
	var Earcut = requireEarcut();
	var EllipseRender = requireEllipseRender();
	var GeomEllipse = requireEllipse$2();
	var Shape = requireShape();

	var Ellipse = new Class({

	    Extends: Shape,

	    Mixins: [
	        EllipseRender
	    ],

	    initialize:

	    function Ellipse (scene, x, y, width, height, fillColor, fillAlpha)
	    {
	        if (x === undefined) { x = 0; }
	        if (y === undefined) { y = 0; }
	        if (width === undefined) { width = 128; }
	        if (height === undefined) { height = 128; }

	        Shape.call(this, scene, 'Ellipse', new GeomEllipse(width / 2, height / 2, width, height));

	        this._smoothness = 64;

	        this.setPosition(x, y);

	        this.width = width;
	        this.height = height;

	        if (fillColor !== undefined)
	        {
	            this.setFillStyle(fillColor, fillAlpha);
	        }

	        this.updateDisplayOrigin();
	        this.updateData();
	    },

	    smoothness: {

	        get: function ()
	        {
	            return this._smoothness;
	        },

	        set: function (value)
	        {
	            this._smoothness = value;

	            this.updateData();
	        }

	    },

	    setSize: function (width, height)
	    {
	        this.width = width;
	        this.height = height;
	        this.geom.setPosition(width / 2, height / 2);
	        this.geom.setSize(width, height);

	        this.updateDisplayOrigin();

	        return this.updateData();
	    },

	    setSmoothness: function (value)
	    {
	        this._smoothness = value;

	        return this.updateData();
	    },

	    updateData: function ()
	    {
	        var path = [];
	        var points = this.geom.getPoints(this._smoothness);

	        for (var i = 0; i < points.length; i++)
	        {
	            path.push(points[i].x, points[i].y);
	        }

	        path.push(points[0].x, points[0].y);

	        this.pathIndexes = Earcut(path);
	        this.pathData = path;

	        return this;
	    }

	});

	Ellipse_1 = Ellipse;
	return Ellipse_1;
}

var GridWebGLRenderer_1;
var hasRequiredGridWebGLRenderer;

function requireGridWebGLRenderer () {
	if (hasRequiredGridWebGLRenderer) return GridWebGLRenderer_1;
	hasRequiredGridWebGLRenderer = 1;
	var GetCalcMatrix = requireGetCalcMatrix();
	var Utils = requireUtils$1();

	var GridWebGLRenderer = function (renderer, src, camera, parentMatrix)
	{
	    camera.addToRenderList(src);

	    var pipeline = renderer.pipelines.set(src.pipeline);

	    var result = GetCalcMatrix(src, camera, parentMatrix);

	    var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);

	    calcMatrix.translate(-src._displayOriginX, -src._displayOriginY);

	    var alpha = camera.alpha * src.alpha;

	    var width = src.width;
	    var height = src.height;

	    var cellWidth = src.cellWidth;
	    var cellHeight = src.cellHeight;

	    var gridWidth = Math.ceil(width / cellWidth);
	    var gridHeight = Math.ceil(height / cellHeight);

	    var cellWidthA = cellWidth;
	    var cellHeightA = cellHeight;

	    var cellWidthB = cellWidth - ((gridWidth * cellWidth) - width);
	    var cellHeightB = cellHeight - ((gridHeight * cellHeight) - height);

	    var fillTint;
	    var fillTintColor;

	    var showCells = src.showCells;
	    var showAltCells = src.showAltCells;
	    var showOutline = src.showOutline;

	    var x = 0;
	    var y = 0;
	    var r = 0;
	    var cw = 0;
	    var ch = 0;

	    if (showOutline)
	    {

	        cellWidthA--;
	        cellHeightA--;

	        if (cellWidthB === cellWidth)
	        {
	            cellWidthB--;
	        }

	        if (cellHeightB === cellHeight)
	        {
	            cellHeightB--;
	        }
	    }

	    renderer.pipelines.preBatch(src);

	    if (showCells && src.fillAlpha > 0)
	    {
	        fillTint = pipeline.fillTint;
	        fillTintColor = Utils.getTintAppendFloatAlpha(src.fillColor, src.fillAlpha * alpha);

	        fillTint.TL = fillTintColor;
	        fillTint.TR = fillTintColor;
	        fillTint.BL = fillTintColor;
	        fillTint.BR = fillTintColor;

	        for (y = 0; y < gridHeight; y++)
	        {
	            if (showAltCells)
	            {
	                r = y % 2;
	            }

	            for (x = 0; x < gridWidth; x++)
	            {
	                if (showAltCells && r)
	                {
	                    r = 0;
	                    continue;
	                }

	                r++;

	                cw = (x < gridWidth - 1) ? cellWidthA : cellWidthB;
	                ch = (y < gridHeight - 1) ? cellHeightA : cellHeightB;

	                pipeline.batchFillRect(
	                    x * cellWidth,
	                    y * cellHeight,
	                    cw,
	                    ch
	                );
	            }
	        }
	    }

	    if (showAltCells && src.altFillAlpha > 0)
	    {
	        fillTint = pipeline.fillTint;
	        fillTintColor = Utils.getTintAppendFloatAlpha(src.altFillColor, src.altFillAlpha * alpha);

	        fillTint.TL = fillTintColor;
	        fillTint.TR = fillTintColor;
	        fillTint.BL = fillTintColor;
	        fillTint.BR = fillTintColor;

	        for (y = 0; y < gridHeight; y++)
	        {
	            if (showAltCells)
	            {
	                r = y % 2;
	            }

	            for (x = 0; x < gridWidth; x++)
	            {
	                if (showAltCells && !r)
	                {
	                    r = 1;
	                    continue;
	                }

	                r = 0;

	                cw = (x < gridWidth - 1) ? cellWidthA : cellWidthB;
	                ch = (y < gridHeight - 1) ? cellHeightA : cellHeightB;

	                pipeline.batchFillRect(
	                    x * cellWidth,
	                    y * cellHeight,
	                    cw,
	                    ch
	                );
	            }
	        }
	    }

	    if (showOutline && src.outlineFillAlpha > 0)
	    {
	        var strokeTint = pipeline.strokeTint;
	        var color = Utils.getTintAppendFloatAlpha(src.outlineFillColor, src.outlineFillAlpha * alpha);

	        strokeTint.TL = color;
	        strokeTint.TR = color;
	        strokeTint.BL = color;
	        strokeTint.BR = color;

	        for (x = 1; x < gridWidth; x++)
	        {
	            var x1 = x * cellWidth;

	            pipeline.batchLine(x1, 0, x1, height, src.lineWidth, src.lineWidth, 1, 0, false);
	        }

	        for (y = 1; y < gridHeight; y++)
	        {
	            var y1 = y * cellHeight;

	            pipeline.batchLine(0, y1, width, y1, src.lineWidth, src.lineWidth, 1, 0, false);
	        }
	    }

	    renderer.pipelines.postBatch(src);
	};

	GridWebGLRenderer_1 = GridWebGLRenderer;
	return GridWebGLRenderer_1;
}

var GridCanvasRenderer_1;
var hasRequiredGridCanvasRenderer;

function requireGridCanvasRenderer () {
	if (hasRequiredGridCanvasRenderer) return GridCanvasRenderer_1;
	hasRequiredGridCanvasRenderer = 1;
	var FillStyleCanvas = requireFillStyleCanvas();
	var LineStyleCanvas = requireLineStyleCanvas();
	var SetTransform = requireSetTransform();

	var GridCanvasRenderer = function (renderer, src, camera, parentMatrix)
	{
	    camera.addToRenderList(src);

	    var ctx = renderer.currentContext;

	    if (SetTransform(renderer, ctx, src, camera, parentMatrix))
	    {
	        var dx = -src._displayOriginX;
	        var dy = -src._displayOriginY;

	        var alpha = camera.alpha * src.alpha;

	        var width = src.width;
	        var height = src.height;

	        var cellWidth = src.cellWidth;
	        var cellHeight = src.cellHeight;

	        var gridWidth = Math.ceil(width / cellWidth);
	        var gridHeight = Math.ceil(height / cellHeight);

	        var cellWidthA = cellWidth;
	        var cellHeightA = cellHeight;

	        var cellWidthB = cellWidth - ((gridWidth * cellWidth) - width);
	        var cellHeightB = cellHeight - ((gridHeight * cellHeight) - height);

	        var showCells = src.showCells;
	        var showAltCells = src.showAltCells;
	        var showOutline = src.showOutline;

	        var x = 0;
	        var y = 0;
	        var r = 0;
	        var cw = 0;
	        var ch = 0;

	        if (showOutline)
	        {

	            cellWidthA--;
	            cellHeightA--;

	            if (cellWidthB === cellWidth)
	            {
	                cellWidthB--;
	            }

	            if (cellHeightB === cellHeight)
	            {
	                cellHeightB--;
	            }
	        }

	        if (showCells && src.fillAlpha > 0)
	        {
	            FillStyleCanvas(ctx, src);

	            for (y = 0; y < gridHeight; y++)
	            {
	                if (showAltCells)
	                {
	                    r = y % 2;
	                }

	                for (x = 0; x < gridWidth; x++)
	                {
	                    if (showAltCells && r)
	                    {
	                        r = 0;
	                        continue;
	                    }

	                    r++;

	                    cw = (x < gridWidth - 1) ? cellWidthA : cellWidthB;
	                    ch = (y < gridHeight - 1) ? cellHeightA : cellHeightB;

	                    ctx.fillRect(
	                        dx + x * cellWidth,
	                        dy + y * cellHeight,
	                        cw,
	                        ch
	                    );
	                }
	            }
	        }

	        if (showAltCells && src.altFillAlpha > 0)
	        {
	            FillStyleCanvas(ctx, src, src.altFillColor, src.altFillAlpha * alpha);

	            for (y = 0; y < gridHeight; y++)
	            {
	                if (showAltCells)
	                {
	                    r = y % 2;
	                }

	                for (x = 0; x < gridWidth; x++)
	                {
	                    if (showAltCells && !r)
	                    {
	                        r = 1;
	                        continue;
	                    }

	                    r = 0;

	                    cw = (x < gridWidth - 1) ? cellWidthA : cellWidthB;
	                    ch = (y < gridHeight - 1) ? cellHeightA : cellHeightB;

	                    ctx.fillRect(
	                        dx + x * cellWidth,
	                        dy + y * cellHeight,
	                        cw,
	                        ch
	                    );
	                }
	            }
	        }

	        if (showOutline && src.outlineFillAlpha > 0)
	        {
	            LineStyleCanvas(ctx, src, src.outlineFillColor, src.outlineFillAlpha * alpha);

	            for (x = 1; x < gridWidth; x++)
	            {
	                var x1 = x * cellWidth;

	                ctx.beginPath();

	                ctx.moveTo(x1 + dx, dy);
	                ctx.lineTo(x1 + dx, height + dy);

	                ctx.stroke();
	            }

	            for (y = 1; y < gridHeight; y++)
	            {
	                var y1 = y * cellHeight;

	                ctx.beginPath();

	                ctx.moveTo(dx, y1 + dy);
	                ctx.lineTo(dx + width, y1 + dy);

	                ctx.stroke();
	            }
	        }

	        ctx.restore();
	    }
	};

	GridCanvasRenderer_1 = GridCanvasRenderer;
	return GridCanvasRenderer_1;
}

var GridRender;
var hasRequiredGridRender;

function requireGridRender () {
	if (hasRequiredGridRender) return GridRender;
	hasRequiredGridRender = 1;
	var NOOP = requireNOOP();
	var renderWebGL = NOOP;
	var renderCanvas = NOOP;

	if (typeof WEBGL_RENDERER)
	{
	    renderWebGL = requireGridWebGLRenderer();
	}

	if (typeof CANVAS_RENDERER)
	{
	    renderCanvas = requireGridCanvasRenderer();
	}

	GridRender = {

	    renderWebGL: renderWebGL,
	    renderCanvas: renderCanvas

	};
	return GridRender;
}

var Grid_1;
var hasRequiredGrid;

function requireGrid () {
	if (hasRequiredGrid) return Grid_1;
	hasRequiredGrid = 1;
	var Class = requireClass();
	var Shape = requireShape();
	var GridRender = requireGridRender();

	var Grid = new Class({

	    Extends: Shape,

	    Mixins: [
	        GridRender
	    ],

	    initialize:

	    function Grid (scene, x, y, width, height, cellWidth, cellHeight, fillColor, fillAlpha, outlineFillColor, outlineFillAlpha)
	    {
	        if (x === undefined) { x = 0; }
	        if (y === undefined) { y = 0; }
	        if (width === undefined) { width = 128; }
	        if (height === undefined) { height = 128; }
	        if (cellWidth === undefined) { cellWidth = 32; }
	        if (cellHeight === undefined) { cellHeight = 32; }

	        Shape.call(this, scene, 'Grid', null);

	        this.cellWidth = cellWidth;

	        this.cellHeight = cellHeight;

	        this.showCells = true;

	        this.outlineFillColor = 0;

	        this.outlineFillAlpha = 0;

	        this.showOutline = true;

	        this.showAltCells = false;

	        this.altFillColor;

	        this.altFillAlpha;

	        this.setPosition(x, y);
	        this.setSize(width, height);

	        this.setFillStyle(fillColor, fillAlpha);

	        if (outlineFillColor !== undefined)
	        {
	            this.setOutlineStyle(outlineFillColor, outlineFillAlpha);
	        }

	        this.updateDisplayOrigin();
	    },

	    setFillStyle: function (fillColor, fillAlpha)
	    {
	        if (fillAlpha === undefined) { fillAlpha = 1; }

	        if (fillColor === undefined)
	        {
	            this.showCells = false;
	        }
	        else
	        {
	            this.fillColor = fillColor;
	            this.fillAlpha = fillAlpha;
	            this.showCells = true;
	        }

	        return this;
	    },

	    setAltFillStyle: function (fillColor, fillAlpha)
	    {
	        if (fillAlpha === undefined) { fillAlpha = 1; }

	        if (fillColor === undefined)
	        {
	            this.showAltCells = false;
	        }
	        else
	        {
	            this.altFillColor = fillColor;
	            this.altFillAlpha = fillAlpha;
	            this.showAltCells = true;
	        }

	        return this;
	    },

	    setOutlineStyle: function (fillColor, fillAlpha)
	    {
	        if (fillAlpha === undefined) { fillAlpha = 1; }

	        if (fillColor === undefined)
	        {
	            this.showOutline = false;
	        }
	        else
	        {
	            this.outlineFillColor = fillColor;
	            this.outlineFillAlpha = fillAlpha;
	            this.showOutline = true;
	        }

	        return this;
	    }

	});

	Grid_1 = Grid;
	return Grid_1;
}

var IsoBoxWebGLRenderer_1;
var hasRequiredIsoBoxWebGLRenderer;

function requireIsoBoxWebGLRenderer () {
	if (hasRequiredIsoBoxWebGLRenderer) return IsoBoxWebGLRenderer_1;
	hasRequiredIsoBoxWebGLRenderer = 1;
	var GetCalcMatrix = requireGetCalcMatrix();
	var Utils = requireUtils$1();

	var IsoBoxWebGLRenderer = function (renderer, src, camera, parentMatrix)
	{
	    camera.addToRenderList(src);

	    var pipeline = renderer.pipelines.set(src.pipeline);

	    var result = GetCalcMatrix(src, camera, parentMatrix);

	    var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);

	    var size = src.width;
	    var height = src.height;

	    var sizeA = size / 2;
	    var sizeB = size / src.projection;

	    var alpha = camera.alpha * src.alpha;

	    if (!src.isFilled)
	    {
	        return;
	    }

	    var tint;

	    var x0;
	    var y0;

	    var x1;
	    var y1;

	    var x2;
	    var y2;

	    var x3;
	    var y3;

	    renderer.pipelines.preBatch(src);

	    if (src.showTop)
	    {
	        tint = Utils.getTintAppendFloatAlpha(src.fillTop, alpha);

	        x0 = calcMatrix.getX(-sizeA, -height);
	        y0 = calcMatrix.getY(-sizeA, -height);

	        x1 = calcMatrix.getX(0, -sizeB - height);
	        y1 = calcMatrix.getY(0, -sizeB - height);

	        x2 = calcMatrix.getX(sizeA, -height);
	        y2 = calcMatrix.getY(sizeA, -height);

	        x3 = calcMatrix.getX(0, sizeB - height);
	        y3 = calcMatrix.getY(0, sizeB - height);

	        pipeline.batchQuad(src, x0, y0, x1, y1, x2, y2, x3, y3, 0, 0, 1, 1, tint, tint, tint, tint, 2);
	    }

	    if (src.showLeft)
	    {
	        tint = Utils.getTintAppendFloatAlpha(src.fillLeft, alpha);

	        x0 = calcMatrix.getX(-sizeA, 0);
	        y0 = calcMatrix.getY(-sizeA, 0);

	        x1 = calcMatrix.getX(0, sizeB);
	        y1 = calcMatrix.getY(0, sizeB);

	        x2 = calcMatrix.getX(0, sizeB - height);
	        y2 = calcMatrix.getY(0, sizeB - height);

	        x3 = calcMatrix.getX(-sizeA, -height);
	        y3 = calcMatrix.getY(-sizeA, -height);

	        pipeline.batchQuad(src, x0, y0, x1, y1, x2, y2, x3, y3, 0, 0, 1, 1, tint, tint, tint, tint, 2);
	    }

	    if (src.showRight)
	    {
	        tint = Utils.getTintAppendFloatAlpha(src.fillRight, alpha);

	        x0 = calcMatrix.getX(sizeA, 0);
	        y0 = calcMatrix.getY(sizeA, 0);

	        x1 = calcMatrix.getX(0, sizeB);
	        y1 = calcMatrix.getY(0, sizeB);

	        x2 = calcMatrix.getX(0, sizeB - height);
	        y2 = calcMatrix.getY(0, sizeB - height);

	        x3 = calcMatrix.getX(sizeA, -height);
	        y3 = calcMatrix.getY(sizeA, -height);

	        pipeline.batchQuad(src, x0, y0, x1, y1, x2, y2, x3, y3, 0, 0, 1, 1, tint, tint, tint, tint, 2);
	    }

	    renderer.pipelines.postBatch(src);
	};

	IsoBoxWebGLRenderer_1 = IsoBoxWebGLRenderer;
	return IsoBoxWebGLRenderer_1;
}

var IsoBoxCanvasRenderer_1;
var hasRequiredIsoBoxCanvasRenderer;

function requireIsoBoxCanvasRenderer () {
	if (hasRequiredIsoBoxCanvasRenderer) return IsoBoxCanvasRenderer_1;
	hasRequiredIsoBoxCanvasRenderer = 1;
	var FillStyleCanvas = requireFillStyleCanvas();
	var SetTransform = requireSetTransform();

	var IsoBoxCanvasRenderer = function (renderer, src, camera, parentMatrix)
	{
	    camera.addToRenderList(src);

	    var ctx = renderer.currentContext;

	    if (SetTransform(renderer, ctx, src, camera, parentMatrix) && src.isFilled)
	    {
	        var size = src.width;
	        var height = src.height;

	        var sizeA = size / 2;
	        var sizeB = size / src.projection;

	        if (src.showTop)
	        {
	            FillStyleCanvas(ctx, src, src.fillTop);

	            ctx.beginPath();

	            ctx.moveTo(-sizeA, -height);
	            ctx.lineTo(0, -sizeB - height);
	            ctx.lineTo(sizeA, -height);
	            ctx.lineTo(sizeA, -1);
	            ctx.lineTo(0, sizeB - 1);
	            ctx.lineTo(-sizeA, -1);
	            ctx.lineTo(-sizeA, -height);

	            ctx.fill();
	        }

	        if (src.showLeft)
	        {
	            FillStyleCanvas(ctx, src, src.fillLeft);

	            ctx.beginPath();

	            ctx.moveTo(-sizeA, 0);
	            ctx.lineTo(0, sizeB);
	            ctx.lineTo(0, sizeB - height);
	            ctx.lineTo(-sizeA, -height);
	            ctx.lineTo(-sizeA, 0);

	            ctx.fill();
	        }

	        if (src.showRight)
	        {
	            FillStyleCanvas(ctx, src, src.fillRight);

	            ctx.beginPath();

	            ctx.moveTo(sizeA, 0);
	            ctx.lineTo(0, sizeB);
	            ctx.lineTo(0, sizeB - height);
	            ctx.lineTo(sizeA, -height);
	            ctx.lineTo(sizeA, 0);

	            ctx.fill();
	        }

	        ctx.restore();
	    }
	};

	IsoBoxCanvasRenderer_1 = IsoBoxCanvasRenderer;
	return IsoBoxCanvasRenderer_1;
}

var IsoBoxRender;
var hasRequiredIsoBoxRender;

function requireIsoBoxRender () {
	if (hasRequiredIsoBoxRender) return IsoBoxRender;
	hasRequiredIsoBoxRender = 1;
	var NOOP = requireNOOP();
	var renderWebGL = NOOP;
	var renderCanvas = NOOP;

	if (typeof WEBGL_RENDERER)
	{
	    renderWebGL = requireIsoBoxWebGLRenderer();
	}

	if (typeof CANVAS_RENDERER)
	{
	    renderCanvas = requireIsoBoxCanvasRenderer();
	}

	IsoBoxRender = {

	    renderWebGL: renderWebGL,
	    renderCanvas: renderCanvas

	};
	return IsoBoxRender;
}

var IsoBox_1;
var hasRequiredIsoBox;

function requireIsoBox () {
	if (hasRequiredIsoBox) return IsoBox_1;
	hasRequiredIsoBox = 1;
	var IsoBoxRender = requireIsoBoxRender();
	var Class = requireClass();
	var Shape = requireShape();

	var IsoBox = new Class({

	    Extends: Shape,

	    Mixins: [
	        IsoBoxRender
	    ],

	    initialize:

	    function IsoBox (scene, x, y, size, height, fillTop, fillLeft, fillRight)
	    {
	        if (x === undefined) { x = 0; }
	        if (y === undefined) { y = 0; }
	        if (size === undefined) { size = 48; }
	        if (height === undefined) { height = 32; }
	        if (fillTop === undefined) { fillTop = 0xeeeeee; }
	        if (fillLeft === undefined) { fillLeft = 0x999999; }
	        if (fillRight === undefined) { fillRight = 0xcccccc; }

	        Shape.call(this, scene, 'IsoBox', null);

	        this.projection = 4;

	        this.fillTop = fillTop;

	        this.fillLeft = fillLeft;

	        this.fillRight = fillRight;

	        this.showTop = true;

	        this.showLeft = true;

	        this.showRight = true;

	        this.isFilled = true;

	        this.setPosition(x, y);
	        this.setSize(size, height);

	        this.updateDisplayOrigin();
	    },

	    setProjection: function (value)
	    {
	        this.projection = value;

	        return this;
	    },

	    setFaces: function (showTop, showLeft, showRight)
	    {
	        if (showTop === undefined) { showTop = true; }
	        if (showLeft === undefined) { showLeft = true; }
	        if (showRight === undefined) { showRight = true; }

	        this.showTop = showTop;
	        this.showLeft = showLeft;
	        this.showRight = showRight;

	        return this;
	    },

	    setFillStyle: function (fillTop, fillLeft, fillRight)
	    {
	        this.fillTop = fillTop;
	        this.fillLeft = fillLeft;
	        this.fillRight = fillRight;

	        this.isFilled = true;

	        return this;
	    }

	});

	IsoBox_1 = IsoBox;
	return IsoBox_1;
}

var IsoTriangleWebGLRenderer_1;
var hasRequiredIsoTriangleWebGLRenderer;

function requireIsoTriangleWebGLRenderer () {
	if (hasRequiredIsoTriangleWebGLRenderer) return IsoTriangleWebGLRenderer_1;
	hasRequiredIsoTriangleWebGLRenderer = 1;
	var GetCalcMatrix = requireGetCalcMatrix();
	var Utils = requireUtils$1();

	var IsoTriangleWebGLRenderer = function (renderer, src, camera, parentMatrix)
	{
	    camera.addToRenderList(src);

	    var pipeline = renderer.pipelines.set(src.pipeline);

	    var result = GetCalcMatrix(src, camera, parentMatrix);

	    var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);

	    var size = src.width;
	    var height = src.height;

	    var sizeA = size / 2;
	    var sizeB = size / src.projection;

	    var reversed = src.isReversed;

	    var alpha = camera.alpha * src.alpha;

	    if (!src.isFilled)
	    {
	        return;
	    }

	    renderer.pipelines.preBatch(src);

	    var tint;

	    var x0;
	    var y0;

	    var x1;
	    var y1;

	    var x2;
	    var y2;

	    if (src.showTop && reversed)
	    {
	        tint = Utils.getTintAppendFloatAlpha(src.fillTop, alpha);

	        x0 = calcMatrix.getX(-sizeA, -height);
	        y0 = calcMatrix.getY(-sizeA, -height);

	        x1 = calcMatrix.getX(0, -sizeB - height);
	        y1 = calcMatrix.getY(0, -sizeB - height);

	        x2 = calcMatrix.getX(sizeA, -height);
	        y2 = calcMatrix.getY(sizeA, -height);

	        var x3 = calcMatrix.getX(0, sizeB - height);
	        var y3 = calcMatrix.getY(0, sizeB - height);

	        pipeline.batchQuad(src, x0, y0, x1, y1, x2, y2, x3, y3, 0, 0, 1, 1, tint, tint, tint, tint, 2);
	    }

	    if (src.showLeft)
	    {
	        tint = Utils.getTintAppendFloatAlpha(src.fillLeft, alpha);

	        if (reversed)
	        {
	            x0 = calcMatrix.getX(-sizeA, -height);
	            y0 = calcMatrix.getY(-sizeA, -height);

	            x1 = calcMatrix.getX(0, sizeB);
	            y1 = calcMatrix.getY(0, sizeB);

	            x2 = calcMatrix.getX(0, sizeB - height);
	            y2 = calcMatrix.getY(0, sizeB - height);
	        }
	        else
	        {
	            x0 = calcMatrix.getX(-sizeA, 0);
	            y0 = calcMatrix.getY(-sizeA, 0);

	            x1 = calcMatrix.getX(0, sizeB);
	            y1 = calcMatrix.getY(0, sizeB);

	            x2 = calcMatrix.getX(0, sizeB - height);
	            y2 = calcMatrix.getY(0, sizeB - height);
	        }

	        pipeline.batchTri(src, x0, y0, x1, y1, x2, y2, 0, 0, 1, 1, tint, tint, tint, 2);
	    }

	    if (src.showRight)
	    {
	        tint = Utils.getTintAppendFloatAlpha(src.fillRight, alpha);

	        if (reversed)
	        {
	            x0 = calcMatrix.getX(sizeA, -height);
	            y0 = calcMatrix.getY(sizeA, -height);

	            x1 = calcMatrix.getX(0, sizeB);
	            y1 = calcMatrix.getY(0, sizeB);

	            x2 = calcMatrix.getX(0, sizeB - height);
	            y2 = calcMatrix.getY(0, sizeB - height);
	        }
	        else
	        {
	            x0 = calcMatrix.getX(sizeA, 0);
	            y0 = calcMatrix.getY(sizeA, 0);

	            x1 = calcMatrix.getX(0, sizeB);
	            y1 = calcMatrix.getY(0, sizeB);

	            x2 = calcMatrix.getX(0, sizeB - height);
	            y2 = calcMatrix.getY(0, sizeB - height);
	        }

	        pipeline.batchTri(src, x0, y0, x1, y1, x2, y2, 0, 0, 1, 1, tint, tint, tint, 2);
	    }

	    renderer.pipelines.postBatch(src);
	};

	IsoTriangleWebGLRenderer_1 = IsoTriangleWebGLRenderer;
	return IsoTriangleWebGLRenderer_1;
}

var IsoTriangleCanvasRenderer_1;
var hasRequiredIsoTriangleCanvasRenderer;

function requireIsoTriangleCanvasRenderer () {
	if (hasRequiredIsoTriangleCanvasRenderer) return IsoTriangleCanvasRenderer_1;
	hasRequiredIsoTriangleCanvasRenderer = 1;
	var FillStyleCanvas = requireFillStyleCanvas();
	var SetTransform = requireSetTransform();

	var IsoTriangleCanvasRenderer = function (renderer, src, camera, parentMatrix)
	{
	    camera.addToRenderList(src);

	    var ctx = renderer.currentContext;

	    if (SetTransform(renderer, ctx, src, camera, parentMatrix) && src.isFilled)
	    {
	        var size = src.width;
	        var height = src.height;

	        var sizeA = size / 2;
	        var sizeB = size / src.projection;

	        var reversed = src.isReversed;

	        if (src.showTop && reversed)
	        {
	            FillStyleCanvas(ctx, src, src.fillTop);

	            ctx.beginPath();

	            ctx.moveTo(-sizeA, -height);
	            ctx.lineTo(0, -sizeB - height);
	            ctx.lineTo(sizeA, -height);
	            ctx.lineTo(0, sizeB - height);

	            ctx.fill();
	        }

	        if (src.showLeft)
	        {
	            FillStyleCanvas(ctx, src, src.fillLeft);

	            ctx.beginPath();

	            if (reversed)
	            {
	                ctx.moveTo(-sizeA, -height);
	                ctx.lineTo(0, sizeB);
	                ctx.lineTo(0, sizeB - height);
	            }
	            else
	            {
	                ctx.moveTo(-sizeA, 0);
	                ctx.lineTo(0, sizeB);
	                ctx.lineTo(0, sizeB - height);
	            }

	            ctx.fill();
	        }

	        if (src.showRight)
	        {
	            FillStyleCanvas(ctx, src, src.fillRight);

	            ctx.beginPath();

	            if (reversed)
	            {
	                ctx.moveTo(sizeA, -height);
	                ctx.lineTo(0, sizeB);
	                ctx.lineTo(0, sizeB - height);
	            }
	            else
	            {
	                ctx.moveTo(sizeA, 0);
	                ctx.lineTo(0, sizeB);
	                ctx.lineTo(0, sizeB - height);
	            }

	            ctx.fill();
	        }

	        ctx.restore();
	    }
	};

	IsoTriangleCanvasRenderer_1 = IsoTriangleCanvasRenderer;
	return IsoTriangleCanvasRenderer_1;
}

var IsoTriangleRender;
var hasRequiredIsoTriangleRender;

function requireIsoTriangleRender () {
	if (hasRequiredIsoTriangleRender) return IsoTriangleRender;
	hasRequiredIsoTriangleRender = 1;
	var NOOP = requireNOOP();
	var renderWebGL = NOOP;
	var renderCanvas = NOOP;

	if (typeof WEBGL_RENDERER)
	{
	    renderWebGL = requireIsoTriangleWebGLRenderer();
	}

	if (typeof CANVAS_RENDERER)
	{
	    renderCanvas = requireIsoTriangleCanvasRenderer();
	}

	IsoTriangleRender = {

	    renderWebGL: renderWebGL,
	    renderCanvas: renderCanvas

	};
	return IsoTriangleRender;
}

var IsoTriangle_1;
var hasRequiredIsoTriangle;

function requireIsoTriangle () {
	if (hasRequiredIsoTriangle) return IsoTriangle_1;
	hasRequiredIsoTriangle = 1;
	var Class = requireClass();
	var IsoTriangleRender = requireIsoTriangleRender();
	var Shape = requireShape();

	var IsoTriangle = new Class({

	    Extends: Shape,

	    Mixins: [
	        IsoTriangleRender
	    ],

	    initialize:

	    function IsoTriangle (scene, x, y, size, height, reversed, fillTop, fillLeft, fillRight)
	    {
	        if (x === undefined) { x = 0; }
	        if (y === undefined) { y = 0; }
	        if (size === undefined) { size = 48; }
	        if (height === undefined) { height = 32; }
	        if (reversed === undefined) { reversed = false; }
	        if (fillTop === undefined) { fillTop = 0xeeeeee; }
	        if (fillLeft === undefined) { fillLeft = 0x999999; }
	        if (fillRight === undefined) { fillRight = 0xcccccc; }

	        Shape.call(this, scene, 'IsoTriangle', null);

	        this.projection = 4;

	        this.fillTop = fillTop;

	        this.fillLeft = fillLeft;

	        this.fillRight = fillRight;

	        this.showTop = true;

	        this.showLeft = true;

	        this.showRight = true;

	        this.isReversed = reversed;

	        this.isFilled = true;

	        this.setPosition(x, y);
	        this.setSize(size, height);

	        this.updateDisplayOrigin();
	    },

	    setProjection: function (value)
	    {
	        this.projection = value;

	        return this;
	    },

	    setReversed: function (reversed)
	    {
	        this.isReversed = reversed;

	        return this;
	    },

	    setFaces: function (showTop, showLeft, showRight)
	    {
	        if (showTop === undefined) { showTop = true; }
	        if (showLeft === undefined) { showLeft = true; }
	        if (showRight === undefined) { showRight = true; }

	        this.showTop = showTop;
	        this.showLeft = showLeft;
	        this.showRight = showRight;

	        return this;
	    },

	    setFillStyle: function (fillTop, fillLeft, fillRight)
	    {
	        this.fillTop = fillTop;
	        this.fillLeft = fillLeft;
	        this.fillRight = fillRight;

	        this.isFilled = true;

	        return this;
	    }

	});

	IsoTriangle_1 = IsoTriangle;
	return IsoTriangle_1;
}

var LineWebGLRenderer_1;
var hasRequiredLineWebGLRenderer;

function requireLineWebGLRenderer () {
	if (hasRequiredLineWebGLRenderer) return LineWebGLRenderer_1;
	hasRequiredLineWebGLRenderer = 1;
	var GetCalcMatrix = requireGetCalcMatrix();
	var Utils = requireUtils$1();

	var LineWebGLRenderer = function (renderer, src, camera, parentMatrix)
	{
	    camera.addToRenderList(src);

	    var pipeline = renderer.pipelines.set(src.pipeline);

	    var result = GetCalcMatrix(src, camera, parentMatrix);

	    pipeline.calcMatrix.copyFrom(result.calc);

	    var dx = src._displayOriginX;
	    var dy = src._displayOriginY;
	    var alpha = camera.alpha * src.alpha;

	    renderer.pipelines.preBatch(src);

	    if (src.isStroked)
	    {
	        var strokeTint = pipeline.strokeTint;
	        var color = Utils.getTintAppendFloatAlpha(src.strokeColor, src.strokeAlpha * alpha);

	        strokeTint.TL = color;
	        strokeTint.TR = color;
	        strokeTint.BL = color;
	        strokeTint.BR = color;

	        pipeline.batchLine(
	            src.geom.x1 - dx,
	            src.geom.y1 - dy,
	            src.geom.x2 - dx,
	            src.geom.y2 - dy,
	            src._startWidth / 2,
	            src._endWidth / 2,
	            1,
	            0,
	            false,
	            result.sprite,
	            result.camera
	        );
	    }

	    renderer.pipelines.postBatch(src);
	};

	LineWebGLRenderer_1 = LineWebGLRenderer;
	return LineWebGLRenderer_1;
}

var LineCanvasRenderer_1;
var hasRequiredLineCanvasRenderer;

function requireLineCanvasRenderer () {
	if (hasRequiredLineCanvasRenderer) return LineCanvasRenderer_1;
	hasRequiredLineCanvasRenderer = 1;
	var LineStyleCanvas = requireLineStyleCanvas();
	var SetTransform = requireSetTransform();

	var LineCanvasRenderer = function (renderer, src, camera, parentMatrix)
	{
	    camera.addToRenderList(src);

	    var ctx = renderer.currentContext;

	    if (SetTransform(renderer, ctx, src, camera, parentMatrix))
	    {
	        var dx = src._displayOriginX;
	        var dy = src._displayOriginY;

	        if (src.isStroked)
	        {
	            LineStyleCanvas(ctx, src);

	            ctx.beginPath();

	            ctx.moveTo(src.geom.x1 - dx, src.geom.y1 - dy);
	            ctx.lineTo(src.geom.x2 - dx, src.geom.y2 - dy);

	            ctx.stroke();
	        }

	        ctx.restore();
	    }
	};

	LineCanvasRenderer_1 = LineCanvasRenderer;
	return LineCanvasRenderer_1;
}

var LineRender;
var hasRequiredLineRender;

function requireLineRender () {
	if (hasRequiredLineRender) return LineRender;
	hasRequiredLineRender = 1;
	var NOOP = requireNOOP();
	var renderWebGL = NOOP;
	var renderCanvas = NOOP;

	if (typeof WEBGL_RENDERER)
	{
	    renderWebGL = requireLineWebGLRenderer();
	}

	if (typeof CANVAS_RENDERER)
	{
	    renderCanvas = requireLineCanvasRenderer();
	}

	LineRender = {

	    renderWebGL: renderWebGL,
	    renderCanvas: renderCanvas

	};
	return LineRender;
}

var Line_1;
var hasRequiredLine$1;

function requireLine$1 () {
	if (hasRequiredLine$1) return Line_1;
	hasRequiredLine$1 = 1;
	var Class = requireClass();
	var Shape = requireShape();
	var GeomLine = requireLine$2();
	var LineRender = requireLineRender();

	var Line = new Class({

	    Extends: Shape,

	    Mixins: [
	        LineRender
	    ],

	    initialize:

	    function Line (scene, x, y, x1, y1, x2, y2, strokeColor, strokeAlpha)
	    {
	        if (x === undefined) { x = 0; }
	        if (y === undefined) { y = 0; }
	        if (x1 === undefined) { x1 = 0; }
	        if (y1 === undefined) { y1 = 0; }
	        if (x2 === undefined) { x2 = 128; }
	        if (y2 === undefined) { y2 = 0; }

	        Shape.call(this, scene, 'Line', new GeomLine(x1, y1, x2, y2));

	        var width = Math.max(1, this.geom.right - this.geom.left);
	        var height = Math.max(1, this.geom.bottom - this.geom.top);

	        this.lineWidth = 1;

	        this._startWidth = 1;

	        this._endWidth = 1;

	        this.setPosition(x, y);
	        this.setSize(width, height);

	        if (strokeColor !== undefined)
	        {
	            this.setStrokeStyle(1, strokeColor, strokeAlpha);
	        }

	        this.updateDisplayOrigin();
	    },

	    setLineWidth: function (startWidth, endWidth)
	    {
	        if (endWidth === undefined) { endWidth = startWidth; }

	        this._startWidth = startWidth;
	        this._endWidth = endWidth;

	        this.lineWidth = startWidth;

	        return this;
	    },

	    setTo: function (x1, y1, x2, y2)
	    {
	        this.geom.setTo(x1, y1, x2, y2);

	        return this;
	    }

	});

	Line_1 = Line;
	return Line_1;
}

var PolygonWebGLRenderer_1;
var hasRequiredPolygonWebGLRenderer;

function requirePolygonWebGLRenderer () {
	if (hasRequiredPolygonWebGLRenderer) return PolygonWebGLRenderer_1;
	hasRequiredPolygonWebGLRenderer = 1;
	var FillPathWebGL = requireFillPathWebGL();
	var GetCalcMatrix = requireGetCalcMatrix();
	var StrokePathWebGL = requireStrokePathWebGL();

	var PolygonWebGLRenderer = function (renderer, src, camera, parentMatrix)
	{
	    camera.addToRenderList(src);

	    var pipeline = renderer.pipelines.set(src.pipeline);

	    var result = GetCalcMatrix(src, camera, parentMatrix);

	    var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);

	    var dx = src._displayOriginX;
	    var dy = src._displayOriginY;

	    var alpha = camera.alpha * src.alpha;

	    renderer.pipelines.preBatch(src);

	    if (src.isFilled)
	    {
	        FillPathWebGL(pipeline, calcMatrix, src, alpha, dx, dy);
	    }

	    if (src.isStroked)
	    {
	        StrokePathWebGL(pipeline, src, alpha, dx, dy);
	    }

	    renderer.pipelines.postBatch(src);
	};

	PolygonWebGLRenderer_1 = PolygonWebGLRenderer;
	return PolygonWebGLRenderer_1;
}

var PolygonCanvasRenderer_1;
var hasRequiredPolygonCanvasRenderer;

function requirePolygonCanvasRenderer () {
	if (hasRequiredPolygonCanvasRenderer) return PolygonCanvasRenderer_1;
	hasRequiredPolygonCanvasRenderer = 1;
	var FillStyleCanvas = requireFillStyleCanvas();
	var LineStyleCanvas = requireLineStyleCanvas();
	var SetTransform = requireSetTransform();

	var PolygonCanvasRenderer = function (renderer, src, camera, parentMatrix)
	{
	    camera.addToRenderList(src);

	    var ctx = renderer.currentContext;

	    if (SetTransform(renderer, ctx, src, camera, parentMatrix))
	    {
	        var dx = src._displayOriginX;
	        var dy = src._displayOriginY;

	        var path = src.pathData;
	        var pathLength = path.length - 1;

	        var px1 = path[0] - dx;
	        var py1 = path[1] - dy;

	        ctx.beginPath();

	        ctx.moveTo(px1, py1);

	        if (!src.closePath)
	        {
	            pathLength -= 2;
	        }

	        for (var i = 2; i < pathLength; i += 2)
	        {
	            var px2 = path[i] - dx;
	            var py2 = path[i + 1] - dy;

	            ctx.lineTo(px2, py2);
	        }

	        if (src.closePath)
	        {
	            ctx.closePath();
	        }

	        if (src.isFilled)
	        {
	            FillStyleCanvas(ctx, src);

	            ctx.fill();
	        }

	        if (src.isStroked)
	        {
	            LineStyleCanvas(ctx, src);

	            ctx.stroke();
	        }

	        ctx.restore();
	    }
	};

	PolygonCanvasRenderer_1 = PolygonCanvasRenderer;
	return PolygonCanvasRenderer_1;
}

var PolygonRender;
var hasRequiredPolygonRender;

function requirePolygonRender () {
	if (hasRequiredPolygonRender) return PolygonRender;
	hasRequiredPolygonRender = 1;
	var NOOP = requireNOOP();
	var renderWebGL = NOOP;
	var renderCanvas = NOOP;

	if (typeof WEBGL_RENDERER)
	{
	    renderWebGL = requirePolygonWebGLRenderer();
	}

	if (typeof CANVAS_RENDERER)
	{
	    renderCanvas = requirePolygonCanvasRenderer();
	}

	PolygonRender = {

	    renderWebGL: renderWebGL,
	    renderCanvas: renderCanvas

	};
	return PolygonRender;
}

var GetAABB_1;
var hasRequiredGetAABB;

function requireGetAABB () {
	if (hasRequiredGetAABB) return GetAABB_1;
	hasRequiredGetAABB = 1;
	var Rectangle = requireRectangle$2();

	var GetAABB = function (polygon, out)
	{
	    if (out === undefined) { out = new Rectangle(); }

	    var minX = Infinity;
	    var minY = Infinity;
	    var maxX = -minX;
	    var maxY = -minY;
	    var p;

	    for (var i = 0; i < polygon.points.length; i++)
	    {
	        p = polygon.points[i];

	        minX = Math.min(minX, p.x);
	        minY = Math.min(minY, p.y);
	        maxX = Math.max(maxX, p.x);
	        maxY = Math.max(maxY, p.y);
	    }

	    out.x = minX;
	    out.y = minY;
	    out.width = maxX - minX;
	    out.height = maxY - minY;

	    return out;
	};

	GetAABB_1 = GetAABB;
	return GetAABB_1;
}

var Contains_1$1;
var hasRequiredContains$1;

function requireContains$1 () {
	if (hasRequiredContains$1) return Contains_1$1;
	hasRequiredContains$1 = 1;
	var Contains = function (polygon, x, y)
	{
	    var inside = false;

	    for (var i = -1, j = polygon.points.length - 1; ++i < polygon.points.length; j = i)
	    {
	        var ix = polygon.points[i].x;
	        var iy = polygon.points[i].y;

	        var jx = polygon.points[j].x;
	        var jy = polygon.points[j].y;

	        if (((iy <= y && y < jy) || (jy <= y && y < iy)) && (x < (jx - ix) * (y - iy) / (jy - iy) + ix))
	        {
	            inside = !inside;
	        }
	    }

	    return inside;
	};

	Contains_1$1 = Contains;
	return Contains_1$1;
}

var Perimeter_1$1;
var hasRequiredPerimeter$1;

function requirePerimeter$1 () {
	if (hasRequiredPerimeter$1) return Perimeter_1$1;
	hasRequiredPerimeter$1 = 1;
	var Length = requireLength();
	var Line = requireLine$2();

	var Perimeter = function (polygon)
	{
	    var points = polygon.points;
	    var perimeter = 0;

	    for (var i = 0; i < points.length; i++)
	    {
	        var pointA = points[i];
	        var pointB = points[(i + 1) % points.length];
	        var line = new Line(
	            pointA.x,
	            pointA.y,
	            pointB.x,
	            pointB.y
	        );

	        perimeter += Length(line);
	    }

	    return perimeter;
	};

	Perimeter_1$1 = Perimeter;
	return Perimeter_1$1;
}

var GetPoints_1$1;
var hasRequiredGetPoints$1;

function requireGetPoints$1 () {
	if (hasRequiredGetPoints$1) return GetPoints_1$1;
	hasRequiredGetPoints$1 = 1;
	var Length = requireLength();
	var Line = requireLine$2();
	var Perimeter = requirePerimeter$1();

	var GetPoints = function (polygon, quantity, stepRate, out)
	{
	    if (out === undefined) { out = []; }

	    var points = polygon.points;
	    var perimeter = Perimeter(polygon);

	    if (!quantity && stepRate > 0)
	    {
	        quantity = perimeter / stepRate;
	    }

	    for (var i = 0; i < quantity; i++)
	    {
	        var position = perimeter * (i / quantity);
	        var accumulatedPerimeter = 0;

	        for (var j = 0; j < points.length; j++)
	        {
	            var pointA = points[j];
	            var pointB = points[(j + 1) % points.length];
	            var line = new Line(
	                pointA.x,
	                pointA.y,
	                pointB.x,
	                pointB.y
	            );
	            var length = Length(line);

	            if (position < accumulatedPerimeter || position > accumulatedPerimeter + length)
	            {
	                accumulatedPerimeter += length;
	                continue;
	            }

	            var point = line.getPoint((position - accumulatedPerimeter) / length);
	            out.push(point);

	            break;
	        }
	    }

	    return out;
	};

	GetPoints_1$1 = GetPoints;
	return GetPoints_1$1;
}

var Polygon_1$1;
var hasRequiredPolygon$2;

function requirePolygon$2 () {
	if (hasRequiredPolygon$2) return Polygon_1$1;
	hasRequiredPolygon$2 = 1;
	var Class = requireClass();
	var Contains = requireContains$1();
	var GetPoints = requireGetPoints$1();
	var GEOM_CONST = require_const$d();

	var Polygon = new Class({

	    initialize:

	    function Polygon (points)
	    {

	        this.type = GEOM_CONST.POLYGON;

	        this.area = 0;

	        this.points = [];

	        if (points)
	        {
	            this.setTo(points);
	        }
	    },

	    contains: function (x, y)
	    {
	        return Contains(this, x, y);
	    },

	    setTo: function (points)
	    {
	        this.area = 0;
	        this.points = [];

	        if (typeof points === 'string')
	        {
	            points = points.split(' ');
	        }

	        if (!Array.isArray(points))
	        {
	            return this;
	        }

	        var p;

	        for (var i = 0; i < points.length; i++)
	        {
	            p = { x: 0, y: 0 };

	            if (typeof points[i] === 'number' || typeof points[i] === 'string')
	            {
	                p.x = parseFloat(points[i]);
	                p.y = parseFloat(points[i + 1]);
	                i++;
	            }
	            else if (Array.isArray(points[i]))
	            {

	                p.x = points[i][0];
	                p.y = points[i][1];
	            }
	            else
	            {
	                p.x = points[i].x;
	                p.y = points[i].y;
	            }

	            this.points.push(p);
	        }

	        this.calculateArea();

	        return this;
	    },

	    calculateArea: function ()
	    {
	        if (this.points.length < 3)
	        {
	            this.area = 0;

	            return this.area;
	        }

	        var sum = 0;
	        var p1;
	        var p2;

	        for (var i = 0; i < this.points.length - 1; i++)
	        {
	            p1 = this.points[i];
	            p2 = this.points[i + 1];

	            sum += (p2.x - p1.x) * (p1.y + p2.y);
	        }

	        p1 = this.points[0];
	        p2 = this.points[this.points.length - 1];

	        sum += (p1.x - p2.x) * (p2.y + p1.y);

	        this.area = -sum * 0.5;

	        return this.area;
	    },

	    getPoints: function (quantity, step, output)
	    {
	        return GetPoints(this, quantity, step, output);
	    }

	});

	Polygon_1$1 = Polygon;
	return Polygon_1$1;
}

var Smooth_1;
var hasRequiredSmooth;

function requireSmooth () {
	if (hasRequiredSmooth) return Smooth_1;
	hasRequiredSmooth = 1;
	var copy = function (out, a)
	{
	    out[0] = a[0];
	    out[1] = a[1];

	    return out;
	};

	var Smooth = function (polygon)
	{
	    var i;
	    var points = [];
	    var data = polygon.points;

	    for (i = 0; i < data.length; i++)
	    {
	        points.push([ data[i].x, data[i].y ]);
	    }

	    var output = [];

	    if (points.length > 0)
	    {
	        output.push(copy([ 0, 0 ], points[0]));
	    }

	    for (i = 0; i < points.length - 1; i++)
	    {
	        var p0 = points[i];
	        var p1 = points[i + 1];
	        var p0x = p0[0];
	        var p0y = p0[1];
	        var p1x = p1[0];
	        var p1y = p1[1];

	        output.push([ 0.85 * p0x + 0.15 * p1x, 0.85 * p0y + 0.15 * p1y ]);
	        output.push([ 0.15 * p0x + 0.85 * p1x, 0.15 * p0y + 0.85 * p1y ]);
	    }

	    if (points.length > 1)
	    {
	        output.push(copy([ 0, 0 ], points[points.length - 1]));
	    }

	    return polygon.setTo(output);
	};

	Smooth_1 = Smooth;
	return Smooth_1;
}

var Polygon_1;
var hasRequiredPolygon$1;

function requirePolygon$1 () {
	if (hasRequiredPolygon$1) return Polygon_1;
	hasRequiredPolygon$1 = 1;
	var PolygonRender = requirePolygonRender();
	var Class = requireClass();
	var Earcut = requireEarcut();
	var GetAABB = requireGetAABB();
	var GeomPolygon = requirePolygon$2();
	var Shape = requireShape();
	var Smooth = requireSmooth();

	var Polygon = new Class({

	    Extends: Shape,

	    Mixins: [
	        PolygonRender
	    ],

	    initialize:

	    function Polygon (scene, x, y, points, fillColor, fillAlpha)
	    {
	        if (x === undefined) { x = 0; }
	        if (y === undefined) { y = 0; }

	        Shape.call(this, scene, 'Polygon', new GeomPolygon(points));

	        var bounds = GetAABB(this.geom);

	        this.setPosition(x, y);
	        this.setSize(bounds.width, bounds.height);

	        if (fillColor !== undefined)
	        {
	            this.setFillStyle(fillColor, fillAlpha);
	        }

	        this.updateDisplayOrigin();
	        this.updateData();
	    },

	    smooth: function (iterations)
	    {
	        if (iterations === undefined) { iterations = 1; }

	        for (var i = 0; i < iterations; i++)
	        {
	            Smooth(this.geom);
	        }

	        return this.updateData();
	    },

	    setTo: function (points)
	    {
	        this.geom.setTo(points);

	        var bounds = GetAABB(this.geom);

	        this.setSize(bounds.width, bounds.height);

	        this.updateDisplayOrigin();

	        return this.updateData();
	    },

	    updateData: function ()
	    {
	        var path = [];
	        var points = this.geom.points;

	        for (var i = 0; i < points.length; i++)
	        {
	            path.push(points[i].x, points[i].y);
	        }

	        path.push(points[0].x, points[0].y);

	        this.pathIndexes = Earcut(path);
	        this.pathData = path;

	        return this;
	    }

	});

	Polygon_1 = Polygon;
	return Polygon_1;
}

var RectangleWebGLRenderer_1;
var hasRequiredRectangleWebGLRenderer;

function requireRectangleWebGLRenderer () {
	if (hasRequiredRectangleWebGLRenderer) return RectangleWebGLRenderer_1;
	hasRequiredRectangleWebGLRenderer = 1;
	var FillPathWebGL = requireFillPathWebGL();
	var GetCalcMatrix = requireGetCalcMatrix();
	var StrokePathWebGL = requireStrokePathWebGL();
	var Utils = requireUtils$1();

	var RectangleWebGLRenderer = function (renderer, src, camera, parentMatrix)
	{
	    camera.addToRenderList(src);

	    var pipeline = renderer.pipelines.set(src.pipeline);
	    var result = GetCalcMatrix(src, camera, parentMatrix);

	    pipeline.calcMatrix.copyFrom(result.calc);

	    var dx = src._displayOriginX;
	    var dy = src._displayOriginY;
	    var alpha = camera.alpha * src.alpha;

	    renderer.pipelines.preBatch(src);

	    if (src.isRounded && src.isFilled)
	    {
	        FillPathWebGL(pipeline, result.calc, src, alpha, dx, dy);
	    }
	    else if (src.isFilled)
	    {
	        var fillTint = pipeline.fillTint;
	        var fillTintColor = Utils.getTintAppendFloatAlpha(src.fillColor, src.fillAlpha * alpha);

	        fillTint.TL = fillTintColor;
	        fillTint.TR = fillTintColor;
	        fillTint.BL = fillTintColor;
	        fillTint.BR = fillTintColor;

	        pipeline.batchFillRect(
	            -dx,
	            -dy,
	            src.width,
	            src.height
	        );
	    }

	    if (src.isStroked)
	    {
	        StrokePathWebGL(pipeline, src, alpha, dx, dy);
	    }

	    renderer.pipelines.postBatch(src);
	};

	RectangleWebGLRenderer_1 = RectangleWebGLRenderer;
	return RectangleWebGLRenderer_1;
}

var RectangleCanvasRenderer_1;
var hasRequiredRectangleCanvasRenderer;

function requireRectangleCanvasRenderer () {
	if (hasRequiredRectangleCanvasRenderer) return RectangleCanvasRenderer_1;
	hasRequiredRectangleCanvasRenderer = 1;
	var FillStyleCanvas = requireFillStyleCanvas();
	var LineStyleCanvas = requireLineStyleCanvas();
	var SetTransform = requireSetTransform();

	var DrawRoundedRect = function (ctx, x, y, width, height, radius)
	{

	    var maxRadius = Math.min(width / 2, height / 2);
	    var r = Math.min(radius, maxRadius);

	    if (r === 0)
	    {

	        ctx.rect(x, y, width, height);
	        return;
	    }

	    ctx.moveTo(x + r, y);

	    ctx.lineTo(x + width - r, y);
	    ctx.arcTo(x + width, y, x + width, y + r, r);

	    ctx.lineTo(x + width, y + height - r);
	    ctx.arcTo(x + width, y + height, x + width - r, y + height, r);

	    ctx.lineTo(x + r, y + height);
	    ctx.arcTo(x, y + height, x, y + height - r, r);

	    ctx.lineTo(x, y + r);
	    ctx.arcTo(x, y, x + r, y, r);

	    ctx.closePath();
	};

	var RectangleCanvasRenderer = function (renderer, src, camera, parentMatrix)
	{
	    camera.addToRenderList(src);

	    var ctx = renderer.currentContext;

	    if (SetTransform(renderer, ctx, src, camera, parentMatrix))
	    {
	        var dx = src._displayOriginX;
	        var dy = src._displayOriginY;

	        if (src.isFilled)
	        {
	            FillStyleCanvas(ctx, src);

	            if (src.isRounded)
	            {
	                ctx.beginPath();
	                DrawRoundedRect(ctx, -dx, -dy, src.width, src.height, src.radius);
	                ctx.fill();
	            }
	            else
	            {
	                ctx.fillRect(
	                    -dx,
	                    -dy,
	                    src.width,
	                    src.height
	                );
	            }
	        }

	        if (src.isStroked)
	        {
	            LineStyleCanvas(ctx, src);

	            ctx.beginPath();

	            if (src.isRounded)
	            {
	                DrawRoundedRect(ctx, -dx, -dy, src.width, src.height, src.radius);
	            }
	            else
	            {
	                ctx.rect(
	                    -dx,
	                    -dy,
	                    src.width,
	                    src.height
	                );
	            }

	            ctx.stroke();
	        }

	        ctx.restore();
	    }
	};

	RectangleCanvasRenderer_1 = RectangleCanvasRenderer;
	return RectangleCanvasRenderer_1;
}

var RectangleRender;
var hasRequiredRectangleRender;

function requireRectangleRender () {
	if (hasRequiredRectangleRender) return RectangleRender;
	hasRequiredRectangleRender = 1;
	var NOOP = requireNOOP();
	var renderWebGL = NOOP;
	var renderCanvas = NOOP;

	if (typeof WEBGL_RENDERER)
	{
	    renderWebGL = requireRectangleWebGLRenderer();
	}

	if (typeof CANVAS_RENDERER)
	{
	    renderCanvas = requireRectangleCanvasRenderer();
	}

	RectangleRender = {

	    renderWebGL: renderWebGL,
	    renderCanvas: renderCanvas

	};
	return RectangleRender;
}

var Rectangle_1;
var hasRequiredRectangle$1;

function requireRectangle$1 () {
	if (hasRequiredRectangle$1) return Rectangle_1;
	hasRequiredRectangle$1 = 1;
	var Class = requireClass();
	var Earcut = requireEarcut();
	var GeomRectangle = requireRectangle$2();
	var Shape = requireShape();
	var RectangleRender = requireRectangleRender();

	var Rectangle = new Class({

	    Extends: Shape,

	    Mixins: [
	        RectangleRender
	    ],

	    initialize:

	    function Rectangle (scene, x, y, width, height, fillColor, fillAlpha)
	    {
	        if (x === undefined) { x = 0; }
	        if (y === undefined) { y = 0; }
	        if (width === undefined) { width = 128; }
	        if (height === undefined) { height = 128; }

	        Shape.call(this, scene, 'Rectangle', new GeomRectangle(0, 0, width, height));

	        this.radius = 20;

	        this.isRounded = false;

	        this.setPosition(x, y);
	        this.setSize(width, height);

	        if (fillColor !== undefined)
	        {
	            this.setFillStyle(fillColor, fillAlpha);
	        }

	        this.updateDisplayOrigin();
	        this.updateData();
	    },

	    setRounded: function (radius)
	    {
	        if (radius === undefined) { radius = 16; }

	        this.radius = radius;
	        this.isRounded = radius > 0;

	        return this.updateRoundedData();
	    },

	    setSize: function (width, height)
	    {
	        this.width = width;
	        this.height = height;

	        this.geom.setSize(width, height);

	        this.updateData();

	        this.updateDisplayOrigin();

	        var input = this.input;

	        if (input && !input.customHitArea)
	        {
	            input.hitArea.width = width;
	            input.hitArea.height = height;
	        }

	        return this;
	    },

	    updateData: function ()
	    {
	        if (this.isRounded)
	        {
	            return this.updateRoundedData();
	        }

	        var path = [];
	        var rect = this.geom;
	        var line = this._tempLine;

	        rect.getLineA(line);

	        path.push(line.x1, line.y1, line.x2, line.y2);

	        rect.getLineB(line);

	        path.push(line.x2, line.y2);

	        rect.getLineC(line);

	        path.push(line.x2, line.y2);

	        rect.getLineD(line);

	        path.push(line.x2, line.y2);

	        this.pathData = path;

	        return this;
	    },

	    updateRoundedData: function ()
	    {
	        var path = [];
	        var halfWidth = this.width / 2;
	        var halfHeight = this.height / 2;

	        var maxRadius = Math.min(halfWidth, halfHeight);
	        var radius = Math.min(this.radius, maxRadius);

	        var x = halfWidth;
	        var y = halfHeight;

	        var segments = Math.max(1, Math.floor(radius / 5));

	        this.arcTo(path, x - halfWidth + radius, y - halfHeight + radius, radius, Math.PI, Math.PI * 1.5, segments);

	        path.push(x + halfWidth - radius, y - halfHeight);

	        this.arcTo(path, x + halfWidth - radius, y - halfHeight + radius, radius, Math.PI * 1.5, Math.PI * 2, segments);

	        path.push(x + halfWidth, y + halfHeight - radius);

	        this.arcTo(path, x + halfWidth - radius, y + halfHeight - radius, radius, 0, Math.PI * 0.5, segments);

	        path.push(x - halfWidth + radius, y + halfHeight);

	        this.arcTo(path, x - halfWidth + radius, y + halfHeight - radius, radius, Math.PI * 0.5, Math.PI, segments);

	        path.push(x - halfWidth, y - halfHeight + radius);

	        this.pathIndexes = Earcut(path);
	        this.pathData = path;

	        return this;
	    },

	    arcTo: function (path, centerX, centerY, radius, startAngle, endAngle, segments)
	    {
	        var angleInc = (endAngle - startAngle) / segments;

	        for (var i = 0; i <= segments; i++)
	        {
	            var angle = startAngle + (angleInc * i);

	            path.push(
	                centerX + Math.cos(angle) * radius,
	                centerY + Math.sin(angle) * radius
	            );
	        }
	    }

	});

	Rectangle_1 = Rectangle;
	return Rectangle_1;
}

var StarWebGLRenderer_1;
var hasRequiredStarWebGLRenderer;

function requireStarWebGLRenderer () {
	if (hasRequiredStarWebGLRenderer) return StarWebGLRenderer_1;
	hasRequiredStarWebGLRenderer = 1;
	var FillPathWebGL = requireFillPathWebGL();
	var GetCalcMatrix = requireGetCalcMatrix();
	var StrokePathWebGL = requireStrokePathWebGL();

	var StarWebGLRenderer = function (renderer, src, camera, parentMatrix)
	{
	    camera.addToRenderList(src);

	    var pipeline = renderer.pipelines.set(src.pipeline);

	    var result = GetCalcMatrix(src, camera, parentMatrix);

	    var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);

	    var dx = src._displayOriginX;
	    var dy = src._displayOriginY;

	    var alpha = camera.alpha * src.alpha;

	    renderer.pipelines.preBatch(src);

	    if (src.isFilled)
	    {
	        FillPathWebGL(pipeline, calcMatrix, src, alpha, dx, dy);
	    }

	    if (src.isStroked)
	    {
	        StrokePathWebGL(pipeline, src, alpha, dx, dy);
	    }

	    renderer.pipelines.postBatch(src);
	};

	StarWebGLRenderer_1 = StarWebGLRenderer;
	return StarWebGLRenderer_1;
}

var StarCanvasRenderer_1;
var hasRequiredStarCanvasRenderer;

function requireStarCanvasRenderer () {
	if (hasRequiredStarCanvasRenderer) return StarCanvasRenderer_1;
	hasRequiredStarCanvasRenderer = 1;
	var FillStyleCanvas = requireFillStyleCanvas();
	var LineStyleCanvas = requireLineStyleCanvas();
	var SetTransform = requireSetTransform();

	var StarCanvasRenderer = function (renderer, src, camera, parentMatrix)
	{
	    camera.addToRenderList(src);

	    var ctx = renderer.currentContext;

	    if (SetTransform(renderer, ctx, src, camera, parentMatrix))
	    {
	        var dx = src._displayOriginX;
	        var dy = src._displayOriginY;

	        var path = src.pathData;
	        var pathLength = path.length - 1;

	        var px1 = path[0] - dx;
	        var py1 = path[1] - dy;

	        ctx.beginPath();

	        ctx.moveTo(px1, py1);

	        if (!src.closePath)
	        {
	            pathLength -= 2;
	        }

	        for (var i = 2; i < pathLength; i += 2)
	        {
	            var px2 = path[i] - dx;
	            var py2 = path[i + 1] - dy;

	            ctx.lineTo(px2, py2);
	        }

	        ctx.closePath();

	        if (src.isFilled)
	        {
	            FillStyleCanvas(ctx, src);

	            ctx.fill();
	        }

	        if (src.isStroked)
	        {
	            LineStyleCanvas(ctx, src);

	            ctx.stroke();
	        }

	        ctx.restore();
	    }
	};

	StarCanvasRenderer_1 = StarCanvasRenderer;
	return StarCanvasRenderer_1;
}

var StarRender;
var hasRequiredStarRender;

function requireStarRender () {
	if (hasRequiredStarRender) return StarRender;
	hasRequiredStarRender = 1;
	var NOOP = requireNOOP();
	var renderWebGL = NOOP;
	var renderCanvas = NOOP;

	if (typeof WEBGL_RENDERER)
	{
	    renderWebGL = requireStarWebGLRenderer();
	}

	if (typeof CANVAS_RENDERER)
	{
	    renderCanvas = requireStarCanvasRenderer();
	}

	StarRender = {

	    renderWebGL: renderWebGL,
	    renderCanvas: renderCanvas

	};
	return StarRender;
}

var Star_1;
var hasRequiredStar;

function requireStar () {
	if (hasRequiredStar) return Star_1;
	hasRequiredStar = 1;
	var StarRender = requireStarRender();
	var Class = requireClass();
	var Earcut = requireEarcut();
	var Shape = requireShape();

	var Star = new Class({

	    Extends: Shape,

	    Mixins: [
	        StarRender
	    ],

	    initialize:

	    function Star (scene, x, y, points, innerRadius, outerRadius, fillColor, fillAlpha)
	    {
	        if (x === undefined) { x = 0; }
	        if (y === undefined) { y = 0; }
	        if (points === undefined) { points = 5; }
	        if (innerRadius === undefined) { innerRadius = 32; }
	        if (outerRadius === undefined) { outerRadius = 64; }

	        Shape.call(this, scene, 'Star', null);

	        this._points = points;

	        this._innerRadius = innerRadius;

	        this._outerRadius = outerRadius;

	        this.setPosition(x, y);
	        this.setSize(outerRadius * 2, outerRadius * 2);

	        if (fillColor !== undefined)
	        {
	            this.setFillStyle(fillColor, fillAlpha);
	        }

	        this.updateDisplayOrigin();
	        this.updateData();
	    },

	    setPoints: function (value)
	    {
	        this._points = value;

	        return this.updateData();
	    },

	    setInnerRadius: function (value)
	    {
	        this._innerRadius = value;

	        return this.updateData();
	    },

	    setOuterRadius: function (value)
	    {
	        this._outerRadius = value;

	        return this.updateData();
	    },

	    points: {

	        get: function ()
	        {
	            return this._points;
	        },

	        set: function (value)
	        {
	            this._points = value;

	            this.updateData();
	        }

	    },

	    innerRadius: {

	        get: function ()
	        {
	            return this._innerRadius;
	        },

	        set: function (value)
	        {
	            this._innerRadius = value;

	            this.updateData();
	        }

	    },

	    outerRadius: {

	        get: function ()
	        {
	            return this._outerRadius;
	        },

	        set: function (value)
	        {
	            this._outerRadius = value;

	            this.updateData();
	        }

	    },

	    updateData: function ()
	    {
	        var path = [];

	        var points = this._points;
	        var innerRadius = this._innerRadius;
	        var outerRadius = this._outerRadius;

	        var rot = Math.PI / 2 * 3;
	        var step = Math.PI / points;

	        var x = outerRadius;
	        var y = outerRadius;

	        path.push(x, y + -outerRadius);

	        for (var i = 0; i < points; i++)
	        {
	            path.push(x + Math.cos(rot) * outerRadius, y + Math.sin(rot) * outerRadius);

	            rot += step;

	            path.push(x + Math.cos(rot) * innerRadius, y + Math.sin(rot) * innerRadius);

	            rot += step;
	        }

	        path.push(x, y + -outerRadius);

	        this.pathIndexes = Earcut(path);
	        this.pathData = path;

	        return this;
	    }

	});

	Star_1 = Star;
	return Star_1;
}

var Contains_1;
var hasRequiredContains;

function requireContains () {
	if (hasRequiredContains) return Contains_1;
	hasRequiredContains = 1;
	var Contains = function (triangle, x, y)
	{
	    var v0x = triangle.x3 - triangle.x1;
	    var v0y = triangle.y3 - triangle.y1;

	    var v1x = triangle.x2 - triangle.x1;
	    var v1y = triangle.y2 - triangle.y1;

	    var v2x = x - triangle.x1;
	    var v2y = y - triangle.y1;

	    var dot00 = (v0x * v0x) + (v0y * v0y);
	    var dot01 = (v0x * v1x) + (v0y * v1y);
	    var dot02 = (v0x * v2x) + (v0y * v2y);
	    var dot11 = (v1x * v1x) + (v1y * v1y);
	    var dot12 = (v1x * v2x) + (v1y * v2y);

	    var b = ((dot00 * dot11) - (dot01 * dot01));
	    var inv = (b === 0) ? 0 : (1 / b);
	    var u = ((dot11 * dot02) - (dot01 * dot12)) * inv;
	    var v = ((dot00 * dot12) - (dot01 * dot02)) * inv;

	    return (u >= 0 && v >= 0 && (u + v < 1));
	};

	Contains_1 = Contains;
	return Contains_1;
}

var GetPoint_1;
var hasRequiredGetPoint;

function requireGetPoint () {
	if (hasRequiredGetPoint) return GetPoint_1;
	hasRequiredGetPoint = 1;
	var Point = requirePoint$1();
	var Length = requireLength();

	var GetPoint = function (triangle, position, out)
	{
	    if (out === undefined) { out = new Point(); }

	    var line1 = triangle.getLineA();
	    var line2 = triangle.getLineB();
	    var line3 = triangle.getLineC();

	    if (position <= 0 || position >= 1)
	    {
	        out.x = line1.x1;
	        out.y = line1.y1;

	        return out;
	    }

	    var length1 = Length(line1);
	    var length2 = Length(line2);
	    var length3 = Length(line3);

	    var perimeter = length1 + length2 + length3;

	    var p = perimeter * position;
	    var localPosition = 0;

	    if (p < length1)
	    {

	        localPosition = p / length1;

	        out.x = line1.x1 + (line1.x2 - line1.x1) * localPosition;
	        out.y = line1.y1 + (line1.y2 - line1.y1) * localPosition;
	    }
	    else if (p > length1 + length2)
	    {

	        p -= length1 + length2;
	        localPosition = p / length3;

	        out.x = line3.x1 + (line3.x2 - line3.x1) * localPosition;
	        out.y = line3.y1 + (line3.y2 - line3.y1) * localPosition;
	    }
	    else
	    {

	        p -= length1;
	        localPosition = p / length2;

	        out.x = line2.x1 + (line2.x2 - line2.x1) * localPosition;
	        out.y = line2.y1 + (line2.y2 - line2.y1) * localPosition;
	    }

	    return out;
	};

	GetPoint_1 = GetPoint;
	return GetPoint_1;
}

var GetPoints_1;
var hasRequiredGetPoints;

function requireGetPoints () {
	if (hasRequiredGetPoints) return GetPoints_1;
	hasRequiredGetPoints = 1;
	var Length = requireLength();
	var Point = requirePoint$1();

	var GetPoints = function (triangle, quantity, stepRate, out)
	{
	    if (out === undefined) { out = []; }

	    var line1 = triangle.getLineA();
	    var line2 = triangle.getLineB();
	    var line3 = triangle.getLineC();

	    var length1 = Length(line1);
	    var length2 = Length(line2);
	    var length3 = Length(line3);

	    var perimeter = length1 + length2 + length3;

	    if (!quantity && stepRate > 0)
	    {
	        quantity = perimeter / stepRate;
	    }

	    for (var i = 0; i < quantity; i++)
	    {
	        var p = perimeter * (i / quantity);
	        var localPosition = 0;

	        var point = new Point();

	        if (p < length1)
	        {

	            localPosition = p / length1;

	            point.x = line1.x1 + (line1.x2 - line1.x1) * localPosition;
	            point.y = line1.y1 + (line1.y2 - line1.y1) * localPosition;
	        }
	        else if (p > length1 + length2)
	        {

	            p -= length1 + length2;
	            localPosition = p / length3;

	            point.x = line3.x1 + (line3.x2 - line3.x1) * localPosition;
	            point.y = line3.y1 + (line3.y2 - line3.y1) * localPosition;
	        }
	        else
	        {

	            p -= length1;
	            localPosition = p / length2;

	            point.x = line2.x1 + (line2.x2 - line2.x1) * localPosition;
	            point.y = line2.y1 + (line2.y2 - line2.y1) * localPosition;
	        }

	        out.push(point);
	    }

	    return out;
	};

	GetPoints_1 = GetPoints;
	return GetPoints_1;
}

var Triangle_1$1;
var hasRequiredTriangle$2;

function requireTriangle$2 () {
	if (hasRequiredTriangle$2) return Triangle_1$1;
	hasRequiredTriangle$2 = 1;
	var Class = requireClass();
	var Contains = requireContains();
	var GetPoint = requireGetPoint();
	var GetPoints = requireGetPoints();
	var GEOM_CONST = require_const$d();
	var Line = requireLine$2();
	var Random = requireRandom$1();

	var Triangle = new Class({

	    initialize:

	    function Triangle (x1, y1, x2, y2, x3, y3)
	    {
	        if (x1 === undefined) { x1 = 0; }
	        if (y1 === undefined) { y1 = 0; }
	        if (x2 === undefined) { x2 = 0; }
	        if (y2 === undefined) { y2 = 0; }
	        if (x3 === undefined) { x3 = 0; }
	        if (y3 === undefined) { y3 = 0; }

	        this.type = GEOM_CONST.TRIANGLE;

	        this.x1 = x1;

	        this.y1 = y1;

	        this.x2 = x2;

	        this.y2 = y2;

	        this.x3 = x3;

	        this.y3 = y3;
	    },

	    contains: function (x, y)
	    {
	        return Contains(this, x, y);
	    },

	    getPoint: function (position, output)
	    {
	        return GetPoint(this, position, output);
	    },

	    getPoints: function (quantity, stepRate, output)
	    {
	        return GetPoints(this, quantity, stepRate, output);
	    },

	    getRandomPoint: function (point)
	    {
	        return Random(this, point);
	    },

	    setTo: function (x1, y1, x2, y2, x3, y3)
	    {
	        if (x1 === undefined) { x1 = 0; }
	        if (y1 === undefined) { y1 = 0; }
	        if (x2 === undefined) { x2 = 0; }
	        if (y2 === undefined) { y2 = 0; }
	        if (x3 === undefined) { x3 = 0; }
	        if (y3 === undefined) { y3 = 0; }

	        this.x1 = x1;
	        this.y1 = y1;

	        this.x2 = x2;
	        this.y2 = y2;

	        this.x3 = x3;
	        this.y3 = y3;

	        return this;
	    },

	    getLineA: function (line)
	    {
	        if (line === undefined) { line = new Line(); }

	        line.setTo(this.x1, this.y1, this.x2, this.y2);

	        return line;
	    },

	    getLineB: function (line)
	    {
	        if (line === undefined) { line = new Line(); }

	        line.setTo(this.x2, this.y2, this.x3, this.y3);

	        return line;
	    },

	    getLineC: function (line)
	    {
	        if (line === undefined) { line = new Line(); }

	        line.setTo(this.x3, this.y3, this.x1, this.y1);

	        return line;
	    },

	    left: {

	        get: function ()
	        {
	            return Math.min(this.x1, this.x2, this.x3);
	        },

	        set: function (value)
	        {
	            var diff = 0;

	            if (this.x1 <= this.x2 && this.x1 <= this.x3)
	            {
	                diff = this.x1 - value;
	            }
	            else if (this.x2 <= this.x1 && this.x2 <= this.x3)
	            {
	                diff = this.x2 - value;
	            }
	            else
	            {
	                diff = this.x3 - value;
	            }

	            this.x1 -= diff;
	            this.x2 -= diff;
	            this.x3 -= diff;
	        }

	    },

	    right: {

	        get: function ()
	        {
	            return Math.max(this.x1, this.x2, this.x3);
	        },

	        set: function (value)
	        {
	            var diff = 0;

	            if (this.x1 >= this.x2 && this.x1 >= this.x3)
	            {
	                diff = this.x1 - value;
	            }
	            else if (this.x2 >= this.x1 && this.x2 >= this.x3)
	            {
	                diff = this.x2 - value;
	            }
	            else
	            {
	                diff = this.x3 - value;
	            }

	            this.x1 -= diff;
	            this.x2 -= diff;
	            this.x3 -= diff;
	        }

	    },

	    top: {

	        get: function ()
	        {
	            return Math.min(this.y1, this.y2, this.y3);
	        },

	        set: function (value)
	        {
	            var diff = 0;

	            if (this.y1 <= this.y2 && this.y1 <= this.y3)
	            {
	                diff = this.y1 - value;
	            }
	            else if (this.y2 <= this.y1 && this.y2 <= this.y3)
	            {
	                diff = this.y2 - value;
	            }
	            else
	            {
	                diff = this.y3 - value;
	            }

	            this.y1 -= diff;
	            this.y2 -= diff;
	            this.y3 -= diff;
	        }

	    },

	    bottom: {

	        get: function ()
	        {
	            return Math.max(this.y1, this.y2, this.y3);
	        },

	        set: function (value)
	        {
	            var diff = 0;

	            if (this.y1 >= this.y2 && this.y1 >= this.y3)
	            {
	                diff = this.y1 - value;
	            }
	            else if (this.y2 >= this.y1 && this.y2 >= this.y3)
	            {
	                diff = this.y2 - value;
	            }
	            else
	            {
	                diff = this.y3 - value;
	            }

	            this.y1 -= diff;
	            this.y2 -= diff;
	            this.y3 -= diff;
	        }

	    }

	});

	Triangle_1$1 = Triangle;
	return Triangle_1$1;
}

var TriangleWebGLRenderer_1;
var hasRequiredTriangleWebGLRenderer;

function requireTriangleWebGLRenderer () {
	if (hasRequiredTriangleWebGLRenderer) return TriangleWebGLRenderer_1;
	hasRequiredTriangleWebGLRenderer = 1;
	var GetCalcMatrix = requireGetCalcMatrix();
	var StrokePathWebGL = requireStrokePathWebGL();
	var Utils = requireUtils$1();

	var TriangleWebGLRenderer = function (renderer, src, camera, parentMatrix)
	{
	    camera.addToRenderList(src);

	    var pipeline = renderer.pipelines.set(src.pipeline);

	    var result = GetCalcMatrix(src, camera, parentMatrix);

	    pipeline.calcMatrix.copyFrom(result.calc);

	    var dx = src._displayOriginX;
	    var dy = src._displayOriginY;
	    var alpha = camera.alpha * src.alpha;

	    renderer.pipelines.preBatch(src);

	    if (src.isFilled)
	    {
	        var fillTint = pipeline.fillTint;
	        var fillTintColor = Utils.getTintAppendFloatAlpha(src.fillColor, src.fillAlpha * alpha);

	        fillTint.TL = fillTintColor;
	        fillTint.TR = fillTintColor;
	        fillTint.BL = fillTintColor;
	        fillTint.BR = fillTintColor;

	        var x1 = src.geom.x1 - dx;
	        var y1 = src.geom.y1 - dy;
	        var x2 = src.geom.x2 - dx;
	        var y2 = src.geom.y2 - dy;
	        var x3 = src.geom.x3 - dx;
	        var y3 = src.geom.y3 - dy;

	        pipeline.batchFillTriangle(
	            x1,
	            y1,
	            x2,
	            y2,
	            x3,
	            y3,
	            result.sprite,
	            result.camera
	        );
	    }

	    if (src.isStroked)
	    {
	        StrokePathWebGL(pipeline, src, alpha, dx, dy);
	    }

	    renderer.pipelines.postBatch(src);
	};

	TriangleWebGLRenderer_1 = TriangleWebGLRenderer;
	return TriangleWebGLRenderer_1;
}

var TriangleCanvasRenderer_1;
var hasRequiredTriangleCanvasRenderer;

function requireTriangleCanvasRenderer () {
	if (hasRequiredTriangleCanvasRenderer) return TriangleCanvasRenderer_1;
	hasRequiredTriangleCanvasRenderer = 1;
	var FillStyleCanvas = requireFillStyleCanvas();
	var LineStyleCanvas = requireLineStyleCanvas();
	var SetTransform = requireSetTransform();

	var TriangleCanvasRenderer = function (renderer, src, camera, parentMatrix)
	{
	    camera.addToRenderList(src);

	    var ctx = renderer.currentContext;

	    if (SetTransform(renderer, ctx, src, camera, parentMatrix))
	    {
	        var dx = src._displayOriginX;
	        var dy = src._displayOriginY;

	        var x1 = src.geom.x1 - dx;
	        var y1 = src.geom.y1 - dy;
	        var x2 = src.geom.x2 - dx;
	        var y2 = src.geom.y2 - dy;
	        var x3 = src.geom.x3 - dx;
	        var y3 = src.geom.y3 - dy;

	        ctx.beginPath();

	        ctx.moveTo(x1, y1);
	        ctx.lineTo(x2, y2);
	        ctx.lineTo(x3, y3);

	        ctx.closePath();

	        if (src.isFilled)
	        {
	            FillStyleCanvas(ctx, src);

	            ctx.fill();
	        }

	        if (src.isStroked)
	        {
	            LineStyleCanvas(ctx, src);

	            ctx.stroke();
	        }

	        ctx.restore();
	    }
	};

	TriangleCanvasRenderer_1 = TriangleCanvasRenderer;
	return TriangleCanvasRenderer_1;
}

var TriangleRender;
var hasRequiredTriangleRender;

function requireTriangleRender () {
	if (hasRequiredTriangleRender) return TriangleRender;
	hasRequiredTriangleRender = 1;
	var NOOP = requireNOOP();
	var renderWebGL = NOOP;
	var renderCanvas = NOOP;

	if (typeof WEBGL_RENDERER)
	{
	    renderWebGL = requireTriangleWebGLRenderer();
	}

	if (typeof CANVAS_RENDERER)
	{
	    renderCanvas = requireTriangleCanvasRenderer();
	}

	TriangleRender = {

	    renderWebGL: renderWebGL,
	    renderCanvas: renderCanvas

	};
	return TriangleRender;
}

var Triangle_1;
var hasRequiredTriangle$1;

function requireTriangle$1 () {
	if (hasRequiredTriangle$1) return Triangle_1;
	hasRequiredTriangle$1 = 1;
	var Class = requireClass();
	var Shape = requireShape();
	var GeomTriangle = requireTriangle$2();
	var TriangleRender = requireTriangleRender();

	var Triangle = new Class({

	    Extends: Shape,

	    Mixins: [
	        TriangleRender
	    ],

	    initialize:

	    function Triangle (scene, x, y, x1, y1, x2, y2, x3, y3, fillColor, fillAlpha)
	    {
	        if (x === undefined) { x = 0; }
	        if (y === undefined) { y = 0; }
	        if (x1 === undefined) { x1 = 0; }
	        if (y1 === undefined) { y1 = 128; }
	        if (x2 === undefined) { x2 = 64; }
	        if (y2 === undefined) { y2 = 0; }
	        if (x3 === undefined) { x3 = 128; }
	        if (y3 === undefined) { y3 = 128; }

	        Shape.call(this, scene, 'Triangle', new GeomTriangle(x1, y1, x2, y2, x3, y3));

	        var width = this.geom.right - this.geom.left;
	        var height = this.geom.bottom - this.geom.top;

	        this.setPosition(x, y);
	        this.setSize(width, height);

	        if (fillColor !== undefined)
	        {
	            this.setFillStyle(fillColor, fillAlpha);
	        }

	        this.updateDisplayOrigin();
	        this.updateData();
	    },

	    setTo: function (x1, y1, x2, y2, x3, y3)
	    {
	        this.geom.setTo(x1, y1, x2, y2, x3, y3);

	        return this.updateData();
	    },

	    updateData: function ()
	    {
	        var path = [];
	        var tri = this.geom;
	        var line = this._tempLine;

	        tri.getLineA(line);

	        path.push(line.x1, line.y1, line.x2, line.y2);

	        tri.getLineB(line);

	        path.push(line.x2, line.y2);

	        tri.getLineC(line);

	        path.push(line.x2, line.y2);

	        this.pathData = path;

	        return this;
	    }

	});

	Triangle_1 = Triangle;
	return Triangle_1;
}

var BlitterFactory = {};

var hasRequiredBlitterFactory;

function requireBlitterFactory () {
	if (hasRequiredBlitterFactory) return BlitterFactory;
	hasRequiredBlitterFactory = 1;
	var Blitter = requireBlitter();
	var GameObjectFactory = requireGameObjectFactory();

	GameObjectFactory.register('blitter', function (x, y, texture, frame)
	{
	    return this.displayList.add(new Blitter(this.scene, x, y, texture, frame));
	});
	return BlitterFactory;
}

var ContainerFactory = {};

var hasRequiredContainerFactory;

function requireContainerFactory () {
	if (hasRequiredContainerFactory) return ContainerFactory;
	hasRequiredContainerFactory = 1;
	var Container = requireContainer();
	var GameObjectFactory = requireGameObjectFactory();

	GameObjectFactory.register('container', function (x, y, children)
	{
	    return this.displayList.add(new Container(this.scene, x, y, children));
	});
	return ContainerFactory;
}

var DOMElementFactory = {};

var hasRequiredDOMElementFactory;

function requireDOMElementFactory () {
	if (hasRequiredDOMElementFactory) return DOMElementFactory;
	hasRequiredDOMElementFactory = 1;
	var DOMElement = requireDOMElement();
	var GameObjectFactory = requireGameObjectFactory();

	GameObjectFactory.register('dom', function (x, y, element, style, innerText)
	{
	    var gameObject = new DOMElement(this.scene, x, y, element, style, innerText);

	    this.displayList.add(gameObject);

	    return gameObject;
	});
	return DOMElementFactory;
}

var DynamicBitmapTextFactory = {};

var hasRequiredDynamicBitmapTextFactory;

function requireDynamicBitmapTextFactory () {
	if (hasRequiredDynamicBitmapTextFactory) return DynamicBitmapTextFactory;
	hasRequiredDynamicBitmapTextFactory = 1;
	var DynamicBitmapText = requireDynamicBitmapText();
	var GameObjectFactory = requireGameObjectFactory();

	GameObjectFactory.register('dynamicBitmapText', function (x, y, font, text, size)
	{
	    return this.displayList.add(new DynamicBitmapText(this.scene, x, y, font, text, size));
	});
	return DynamicBitmapTextFactory;
}

var ExternFactory = {};

var hasRequiredExternFactory;

function requireExternFactory () {
	if (hasRequiredExternFactory) return ExternFactory;
	hasRequiredExternFactory = 1;
	var Extern = requireExtern();
	var GameObjectFactory = requireGameObjectFactory();

	GameObjectFactory.register('extern', function ()
	{
	    var extern = new Extern(this.scene);

	    this.displayList.add(extern);

	    return extern;
	});
	return ExternFactory;
}

var GraphicsFactory = {};

var hasRequiredGraphicsFactory;

function requireGraphicsFactory () {
	if (hasRequiredGraphicsFactory) return GraphicsFactory;
	hasRequiredGraphicsFactory = 1;
	var Graphics = requireGraphics();
	var GameObjectFactory = requireGameObjectFactory();

	GameObjectFactory.register('graphics', function (config)
	{
	    return this.displayList.add(new Graphics(this.scene, config));
	});
	return GraphicsFactory;
}

var GroupFactory = {};

var hasRequiredGroupFactory;

function requireGroupFactory () {
	if (hasRequiredGroupFactory) return GroupFactory;
	hasRequiredGroupFactory = 1;
	var Group = requireGroup();
	var GameObjectFactory = requireGameObjectFactory();

	GameObjectFactory.register('group', function (children, config)
	{
	    return this.updateList.add(new Group(this.scene, children, config));
	});
	return GroupFactory;
}

var ImageFactory = {};

var hasRequiredImageFactory;

function requireImageFactory () {
	if (hasRequiredImageFactory) return ImageFactory;
	hasRequiredImageFactory = 1;
	var Image = requireImage$1();
	var GameObjectFactory = requireGameObjectFactory();

	GameObjectFactory.register('image', function (x, y, texture, frame)
	{
	    return this.displayList.add(new Image(this.scene, x, y, texture, frame));
	});
	return ImageFactory;
}

var LayerFactory = {};

var hasRequiredLayerFactory;

function requireLayerFactory () {
	if (hasRequiredLayerFactory) return LayerFactory;
	hasRequiredLayerFactory = 1;
	var Layer = requireLayer();
	var GameObjectFactory = requireGameObjectFactory();

	GameObjectFactory.register('layer', function (children)
	{
	    return this.displayList.add(new Layer(this.scene, children));
	});
	return LayerFactory;
}

var ParticleEmitterFactory = {};

var hasRequiredParticleEmitterFactory;

function requireParticleEmitterFactory () {
	if (hasRequiredParticleEmitterFactory) return ParticleEmitterFactory;
	hasRequiredParticleEmitterFactory = 1;
	var GameObjectFactory = requireGameObjectFactory();
	var ParticleEmitter = requireParticleEmitter();

	GameObjectFactory.register('particles', function (x, y, texture, config)
	{
	    if (x !== undefined && typeof x === 'string')
	    {
	        console.warn('ParticleEmitterManager was removed.');
	    }

	    return this.displayList.add(new ParticleEmitter(this.scene, x, y, texture, config));
	});
	return ParticleEmitterFactory;
}

var PathFollowerFactory = {};

var hasRequiredPathFollowerFactory;

function requirePathFollowerFactory () {
	if (hasRequiredPathFollowerFactory) return PathFollowerFactory;
	hasRequiredPathFollowerFactory = 1;
	var GameObjectFactory = requireGameObjectFactory();
	var PathFollower = requirePathFollower();

	GameObjectFactory.register('follower', function (path, x, y, key, frame)
	{
	    var sprite = new PathFollower(this.scene, path, x, y, key, frame);

	    this.displayList.add(sprite);
	    this.updateList.add(sprite);

	    return sprite;
	});
	return PathFollowerFactory;
}

var RenderTextureFactory = {};

var hasRequiredRenderTextureFactory;

function requireRenderTextureFactory () {
	if (hasRequiredRenderTextureFactory) return RenderTextureFactory;
	hasRequiredRenderTextureFactory = 1;
	var GameObjectFactory = requireGameObjectFactory();
	var RenderTexture = requireRenderTexture();

	GameObjectFactory.register('renderTexture', function (x, y, width, height)
	{
	    return this.displayList.add(new RenderTexture(this.scene, x, y, width, height));
	});
	return RenderTextureFactory;
}

var RopeFactory = {};

var hasRequiredRopeFactory;

function requireRopeFactory () {
	if (hasRequiredRopeFactory) return RopeFactory;
	hasRequiredRopeFactory = 1;
	var Rope = requireRope();
	var GameObjectFactory = requireGameObjectFactory();

	if (typeof WEBGL_RENDERER)
	{
	    GameObjectFactory.register('rope', function (x, y, texture, frame, points, horizontal, colors, alphas)
	    {
	        return this.displayList.add(new Rope(this.scene, x, y, texture, frame, points, horizontal, colors, alphas));
	    });
	}
	return RopeFactory;
}

var SpriteFactory = {};

var hasRequiredSpriteFactory;

function requireSpriteFactory () {
	if (hasRequiredSpriteFactory) return SpriteFactory;
	hasRequiredSpriteFactory = 1;
	var GameObjectFactory = requireGameObjectFactory();
	var Sprite = requireSprite();

	GameObjectFactory.register('sprite', function (x, y, texture, frame)
	{
	    return this.displayList.add(new Sprite(this.scene, x, y, texture, frame));
	});
	return SpriteFactory;
}

var BitmapTextFactory = {};

var hasRequiredBitmapTextFactory;

function requireBitmapTextFactory () {
	if (hasRequiredBitmapTextFactory) return BitmapTextFactory;
	hasRequiredBitmapTextFactory = 1;
	var BitmapText = requireBitmapText();
	var GameObjectFactory = requireGameObjectFactory();

	GameObjectFactory.register('bitmapText', function (x, y, font, text, size, align)
	{
	    return this.displayList.add(new BitmapText(this.scene, x, y, font, text, size, align));
	});
	return BitmapTextFactory;
}

var TextFactory = {};

var hasRequiredTextFactory;

function requireTextFactory () {
	if (hasRequiredTextFactory) return TextFactory;
	hasRequiredTextFactory = 1;
	var Text = requireText();
	var GameObjectFactory = requireGameObjectFactory();

	GameObjectFactory.register('text', function (x, y, text, style)
	{
	    return this.displayList.add(new Text(this.scene, x, y, text, style));
	});
	return TextFactory;
}

var TileSpriteFactory = {};

var hasRequiredTileSpriteFactory;

function requireTileSpriteFactory () {
	if (hasRequiredTileSpriteFactory) return TileSpriteFactory;
	hasRequiredTileSpriteFactory = 1;
	var TileSprite = requireTileSprite();
	var GameObjectFactory = requireGameObjectFactory();

	GameObjectFactory.register('tileSprite', function (x, y, width, height, texture, frame)
	{
	    return this.displayList.add(new TileSprite(this.scene, x, y, width, height, texture, frame));
	});
	return TileSpriteFactory;
}

var ZoneFactory = {};

var hasRequiredZoneFactory;

function requireZoneFactory () {
	if (hasRequiredZoneFactory) return ZoneFactory;
	hasRequiredZoneFactory = 1;
	var Zone = requireZone();
	var GameObjectFactory = requireGameObjectFactory();

	GameObjectFactory.register('zone', function (x, y, width, height)
	{
	    return this.displayList.add(new Zone(this.scene, x, y, width, height));
	});
	return ZoneFactory;
}

var VideoFactory = {};

var hasRequiredVideoFactory;

function requireVideoFactory () {
	if (hasRequiredVideoFactory) return VideoFactory;
	hasRequiredVideoFactory = 1;
	var Video = requireVideo();
	var GameObjectFactory = requireGameObjectFactory();

	GameObjectFactory.register('video', function (x, y, key)
	{
	    return this.displayList.add(new Video(this.scene, x, y, key));
	});
	return VideoFactory;
}

var ArcFactory = {};

var hasRequiredArcFactory;

function requireArcFactory () {
	if (hasRequiredArcFactory) return ArcFactory;
	hasRequiredArcFactory = 1;
	var Arc = requireArc();
	var GameObjectFactory = requireGameObjectFactory();

	GameObjectFactory.register('arc', function (x, y, radius, startAngle, endAngle, anticlockwise, fillColor, fillAlpha)
	{
	    return this.displayList.add(new Arc(this.scene, x, y, radius, startAngle, endAngle, anticlockwise, fillColor, fillAlpha));
	});

	GameObjectFactory.register('circle', function (x, y, radius, fillColor, fillAlpha)
	{
	    return this.displayList.add(new Arc(this.scene, x, y, radius, 0, 360, false, fillColor, fillAlpha));
	});
	return ArcFactory;
}

var CurveFactory = {};

var hasRequiredCurveFactory;

function requireCurveFactory () {
	if (hasRequiredCurveFactory) return CurveFactory;
	hasRequiredCurveFactory = 1;
	var GameObjectFactory = requireGameObjectFactory();
	var Curve = requireCurve();

	GameObjectFactory.register('curve', function (x, y, curve, fillColor, fillAlpha)
	{
	    return this.displayList.add(new Curve(this.scene, x, y, curve, fillColor, fillAlpha));
	});
	return CurveFactory;
}

var EllipseFactory = {};

var hasRequiredEllipseFactory;

function requireEllipseFactory () {
	if (hasRequiredEllipseFactory) return EllipseFactory;
	hasRequiredEllipseFactory = 1;
	var Ellipse = requireEllipse$1();
	var GameObjectFactory = requireGameObjectFactory();

	GameObjectFactory.register('ellipse', function (x, y, width, height, fillColor, fillAlpha)
	{
	    return this.displayList.add(new Ellipse(this.scene, x, y, width, height, fillColor, fillAlpha));
	});
	return EllipseFactory;
}

var GridFactory = {};

var hasRequiredGridFactory;

function requireGridFactory () {
	if (hasRequiredGridFactory) return GridFactory;
	hasRequiredGridFactory = 1;
	var GameObjectFactory = requireGameObjectFactory();
	var Grid = requireGrid();

	GameObjectFactory.register('grid', function (x, y, width, height, cellWidth, cellHeight, fillColor, fillAlpha, outlineFillColor, outlineFillAlpha)
	{
	    return this.displayList.add(new Grid(this.scene, x, y, width, height, cellWidth, cellHeight, fillColor, fillAlpha, outlineFillColor, outlineFillAlpha));
	});
	return GridFactory;
}

var IsoBoxFactory = {};

var hasRequiredIsoBoxFactory;

function requireIsoBoxFactory () {
	if (hasRequiredIsoBoxFactory) return IsoBoxFactory;
	hasRequiredIsoBoxFactory = 1;
	var GameObjectFactory = requireGameObjectFactory();
	var IsoBox = requireIsoBox();

	GameObjectFactory.register('isobox', function (x, y, size, height, fillTop, fillLeft, fillRight)
	{
	    return this.displayList.add(new IsoBox(this.scene, x, y, size, height, fillTop, fillLeft, fillRight));
	});
	return IsoBoxFactory;
}

var IsoTriangleFactory = {};

var hasRequiredIsoTriangleFactory;

function requireIsoTriangleFactory () {
	if (hasRequiredIsoTriangleFactory) return IsoTriangleFactory;
	hasRequiredIsoTriangleFactory = 1;
	var GameObjectFactory = requireGameObjectFactory();
	var IsoTriangle = requireIsoTriangle();

	GameObjectFactory.register('isotriangle', function (x, y, size, height, reversed, fillTop, fillLeft, fillRight)
	{
	    return this.displayList.add(new IsoTriangle(this.scene, x, y, size, height, reversed, fillTop, fillLeft, fillRight));
	});
	return IsoTriangleFactory;
}

var LineFactory = {};

var hasRequiredLineFactory;

function requireLineFactory () {
	if (hasRequiredLineFactory) return LineFactory;
	hasRequiredLineFactory = 1;
	var GameObjectFactory = requireGameObjectFactory();
	var Line = requireLine$1();

	GameObjectFactory.register('line', function (x, y, x1, y1, x2, y2, strokeColor, strokeAlpha)
	{
	    return this.displayList.add(new Line(this.scene, x, y, x1, y1, x2, y2, strokeColor, strokeAlpha));
	});
	return LineFactory;
}

var PolygonFactory = {};

var hasRequiredPolygonFactory;

function requirePolygonFactory () {
	if (hasRequiredPolygonFactory) return PolygonFactory;
	hasRequiredPolygonFactory = 1;
	var GameObjectFactory = requireGameObjectFactory();
	var Polygon = requirePolygon$1();

	GameObjectFactory.register('polygon', function (x, y, points, fillColor, fillAlpha)
	{
	    return this.displayList.add(new Polygon(this.scene, x, y, points, fillColor, fillAlpha));
	});
	return PolygonFactory;
}

var RectangleFactory = {};

var hasRequiredRectangleFactory;

function requireRectangleFactory () {
	if (hasRequiredRectangleFactory) return RectangleFactory;
	hasRequiredRectangleFactory = 1;
	var GameObjectFactory = requireGameObjectFactory();
	var Rectangle = requireRectangle$1();

	GameObjectFactory.register('rectangle', function (x, y, width, height, fillColor, fillAlpha)
	{
	    return this.displayList.add(new Rectangle(this.scene, x, y, width, height, fillColor, fillAlpha));
	});
	return RectangleFactory;
}

var StarFactory = {};

var hasRequiredStarFactory;

function requireStarFactory () {
	if (hasRequiredStarFactory) return StarFactory;
	hasRequiredStarFactory = 1;
	var Star = requireStar();
	var GameObjectFactory = requireGameObjectFactory();

	GameObjectFactory.register('star', function (x, y, points, innerRadius, outerRadius, fillColor, fillAlpha)
	{
	    return this.displayList.add(new Star(this.scene, x, y, points, innerRadius, outerRadius, fillColor, fillAlpha));
	});
	return StarFactory;
}

var TriangleFactory = {};

var hasRequiredTriangleFactory;

function requireTriangleFactory () {
	if (hasRequiredTriangleFactory) return TriangleFactory;
	hasRequiredTriangleFactory = 1;
	var GameObjectFactory = requireGameObjectFactory();
	var Triangle = requireTriangle$1();

	GameObjectFactory.register('triangle', function (x, y, x1, y1, x2, y2, x3, y3, fillColor, fillAlpha)
	{
	    return this.displayList.add(new Triangle(this.scene, x, y, x1, y1, x2, y2, x3, y3, fillColor, fillAlpha));
	});
	return TriangleFactory;
}

var BlitterCreator = {};

var hasRequiredBlitterCreator;

function requireBlitterCreator () {
	if (hasRequiredBlitterCreator) return BlitterCreator;
	hasRequiredBlitterCreator = 1;
	var Blitter = requireBlitter();
	var BuildGameObject = requireBuildGameObject();
	var GameObjectCreator = requireGameObjectCreator();
	var GetAdvancedValue = requireGetAdvancedValue();

	GameObjectCreator.register('blitter', function (config, addToScene)
	{
	    if (config === undefined) { config = {}; }

	    var key = GetAdvancedValue(config, 'key', null);
	    var frame = GetAdvancedValue(config, 'frame', null);

	    var blitter = new Blitter(this.scene, 0, 0, key, frame);

	    if (addToScene !== undefined)
	    {
	        config.add = addToScene;
	    }

	    BuildGameObject(this.scene, blitter, config);

	    return blitter;
	});
	return BlitterCreator;
}

var ContainerCreator = {};

var hasRequiredContainerCreator;

function requireContainerCreator () {
	if (hasRequiredContainerCreator) return ContainerCreator;
	hasRequiredContainerCreator = 1;
	var BuildGameObject = requireBuildGameObject();
	var Container = requireContainer();
	var GameObjectCreator = requireGameObjectCreator();
	var GetAdvancedValue = requireGetAdvancedValue();
	var GetFastValue = requireGetFastValue();

	GameObjectCreator.register('container', function (config, addToScene)
	{
	    if (config === undefined) { config = {}; }

	    var x = GetAdvancedValue(config, 'x', 0);
	    var y = GetAdvancedValue(config, 'y', 0);
	    var children = GetFastValue(config, 'children', null);

	    var container = new Container(this.scene, x, y, children);

	    if (addToScene !== undefined)
	    {
	        config.add = addToScene;
	    }

	    BuildGameObject(this.scene, container, config);

	    return container;
	});
	return ContainerCreator;
}

var DynamicBitmapTextCreator = {};

var hasRequiredDynamicBitmapTextCreator;

function requireDynamicBitmapTextCreator () {
	if (hasRequiredDynamicBitmapTextCreator) return DynamicBitmapTextCreator;
	hasRequiredDynamicBitmapTextCreator = 1;
	var BitmapText = requireDynamicBitmapText();
	var BuildGameObject = requireBuildGameObject();
	var GameObjectCreator = requireGameObjectCreator();
	var GetAdvancedValue = requireGetAdvancedValue();

	GameObjectCreator.register('dynamicBitmapText', function (config, addToScene)
	{
	    if (config === undefined) { config = {}; }

	    var font = GetAdvancedValue(config, 'font', '');
	    var text = GetAdvancedValue(config, 'text', '');
	    var size = GetAdvancedValue(config, 'size', false);

	    var bitmapText = new BitmapText(this.scene, 0, 0, font, text, size);

	    if (addToScene !== undefined)
	    {
	        config.add = addToScene;
	    }

	    BuildGameObject(this.scene, bitmapText, config);

	    return bitmapText;
	});
	return DynamicBitmapTextCreator;
}

var GraphicsCreator = {};

var hasRequiredGraphicsCreator;

function requireGraphicsCreator () {
	if (hasRequiredGraphicsCreator) return GraphicsCreator;
	hasRequiredGraphicsCreator = 1;
	var GameObjectCreator = requireGameObjectCreator();
	var Graphics = requireGraphics();

	GameObjectCreator.register('graphics', function (config, addToScene)
	{
	    if (config === undefined) { config = {}; }

	    if (addToScene !== undefined)
	    {
	        config.add = addToScene;
	    }

	    var graphics = new Graphics(this.scene, config);

	    if (config.add)
	    {
	        this.scene.sys.displayList.add(graphics);
	    }

	    return graphics;
	});
	return GraphicsCreator;
}

var GroupCreator = {};

var hasRequiredGroupCreator;

function requireGroupCreator () {
	if (hasRequiredGroupCreator) return GroupCreator;
	hasRequiredGroupCreator = 1;
	var GameObjectCreator = requireGameObjectCreator();
	var Group = requireGroup();

	GameObjectCreator.register('group', function (config)
	{
	    return new Group(this.scene, null, config);
	});
	return GroupCreator;
}

var ImageCreator = {};

var hasRequiredImageCreator;

function requireImageCreator () {
	if (hasRequiredImageCreator) return ImageCreator;
	hasRequiredImageCreator = 1;
	var BuildGameObject = requireBuildGameObject();
	var GameObjectCreator = requireGameObjectCreator();
	var GetAdvancedValue = requireGetAdvancedValue();
	var Image = requireImage$1();

	GameObjectCreator.register('image', function (config, addToScene)
	{
	    if (config === undefined) { config = {}; }

	    var key = GetAdvancedValue(config, 'key', null);
	    var frame = GetAdvancedValue(config, 'frame', null);

	    var image = new Image(this.scene, 0, 0, key, frame);

	    if (addToScene !== undefined)
	    {
	        config.add = addToScene;
	    }

	    BuildGameObject(this.scene, image, config);

	    return image;
	});
	return ImageCreator;
}

var LayerCreator = {};

var hasRequiredLayerCreator;

function requireLayerCreator () {
	if (hasRequiredLayerCreator) return LayerCreator;
	hasRequiredLayerCreator = 1;
	var BuildGameObject = requireBuildGameObject();
	var Layer = requireLayer();
	var GameObjectCreator = requireGameObjectCreator();
	var GetAdvancedValue = requireGetAdvancedValue();

	GameObjectCreator.register('layer', function (config, addToScene)
	{
	    if (config === undefined) { config = {}; }

	    var children = GetAdvancedValue(config, 'children', null);

	    var layer = new Layer(this.scene, children);

	    if (addToScene !== undefined)
	    {
	        config.add = addToScene;
	    }

	    BuildGameObject(this.scene, layer, config);

	    return layer;
	});
	return LayerCreator;
}

var ParticleEmitterCreator = {};

var hasRequiredParticleEmitterCreator;

function requireParticleEmitterCreator () {
	if (hasRequiredParticleEmitterCreator) return ParticleEmitterCreator;
	hasRequiredParticleEmitterCreator = 1;
	var BuildGameObject = requireBuildGameObject();
	var GameObjectCreator = requireGameObjectCreator();
	var GetAdvancedValue = requireGetAdvancedValue();
	var GetFastValue = requireGetFastValue();
	var ParticleEmitter = requireParticleEmitter();

	GameObjectCreator.register('particles', function (config, addToScene)
	{
	    if (config === undefined) { config = {}; }

	    var key = GetAdvancedValue(config, 'key', null);
	    var emitterConfig = GetFastValue(config, 'config', null);

	    var emitter = new ParticleEmitter(this.scene, 0, 0, key);

	    if (addToScene !== undefined)
	    {
	        config.add = addToScene;
	    }

	    BuildGameObject(this.scene, emitter, config);

	    if (emitterConfig)
	    {
	        emitter.setConfig(emitterConfig);
	    }

	    return emitter;
	});
	return ParticleEmitterCreator;
}

var RenderTextureCreator = {};

var hasRequiredRenderTextureCreator;

function requireRenderTextureCreator () {
	if (hasRequiredRenderTextureCreator) return RenderTextureCreator;
	hasRequiredRenderTextureCreator = 1;
	var BuildGameObject = requireBuildGameObject();
	var GameObjectCreator = requireGameObjectCreator();
	var GetAdvancedValue = requireGetAdvancedValue();
	var RenderTexture = requireRenderTexture();

	GameObjectCreator.register('renderTexture', function (config, addToScene)
	{
	    if (config === undefined) { config = {}; }

	    var x = GetAdvancedValue(config, 'x', 0);
	    var y = GetAdvancedValue(config, 'y', 0);
	    var width = GetAdvancedValue(config, 'width', 32);
	    var height = GetAdvancedValue(config, 'height', 32);

	    var renderTexture = new RenderTexture(this.scene, x, y, width, height);

	    if (addToScene !== undefined)
	    {
	        config.add = addToScene;
	    }

	    BuildGameObject(this.scene, renderTexture, config);

	    return renderTexture;
	});
	return RenderTextureCreator;
}

var RopeCreator = {};

var hasRequiredRopeCreator;

function requireRopeCreator () {
	if (hasRequiredRopeCreator) return RopeCreator;
	hasRequiredRopeCreator = 1;
	var BuildGameObject = requireBuildGameObject();
	var GameObjectCreator = requireGameObjectCreator();
	var GetAdvancedValue = requireGetAdvancedValue();
	var GetValue = requireGetValue();
	var Rope = requireRope();

	GameObjectCreator.register('rope', function (config, addToScene)
	{
	    if (config === undefined) { config = {}; }

	    var key = GetAdvancedValue(config, 'key', null);
	    var frame = GetAdvancedValue(config, 'frame', null);
	    var horizontal = GetAdvancedValue(config, 'horizontal', true);
	    var points = GetValue(config, 'points', undefined);
	    var colors = GetValue(config, 'colors', undefined);
	    var alphas = GetValue(config, 'alphas', undefined);

	    var rope = new Rope(this.scene, 0, 0, key, frame, points, horizontal, colors, alphas);

	    if (addToScene !== undefined)
	    {
	        config.add = addToScene;
	    }

	    BuildGameObject(this.scene, rope, config);

	    return rope;
	});
	return RopeCreator;
}

var SpriteCreator = {};

var hasRequiredSpriteCreator;

function requireSpriteCreator () {
	if (hasRequiredSpriteCreator) return SpriteCreator;
	hasRequiredSpriteCreator = 1;
	var BuildGameObject = requireBuildGameObject();
	var BuildGameObjectAnimation = requireBuildGameObjectAnimation();
	var GameObjectCreator = requireGameObjectCreator();
	var GetAdvancedValue = requireGetAdvancedValue();
	var Sprite = requireSprite();

	GameObjectCreator.register('sprite', function (config, addToScene)
	{
	    if (config === undefined) { config = {}; }

	    var key = GetAdvancedValue(config, 'key', null);
	    var frame = GetAdvancedValue(config, 'frame', null);

	    var sprite = new Sprite(this.scene, 0, 0, key, frame);

	    if (addToScene !== undefined)
	    {
	        config.add = addToScene;
	    }

	    BuildGameObject(this.scene, sprite, config);

	    BuildGameObjectAnimation(sprite, config);

	    return sprite;
	});
	return SpriteCreator;
}

var BitmapTextCreator = {};

var hasRequiredBitmapTextCreator;

function requireBitmapTextCreator () {
	if (hasRequiredBitmapTextCreator) return BitmapTextCreator;
	hasRequiredBitmapTextCreator = 1;
	var BitmapText = requireBitmapText();
	var BuildGameObject = requireBuildGameObject();
	var GameObjectCreator = requireGameObjectCreator();
	var GetAdvancedValue = requireGetAdvancedValue();
	var GetValue = requireGetValue();

	GameObjectCreator.register('bitmapText', function (config, addToScene)
	{
	    if (config === undefined) { config = {}; }

	    var font = GetValue(config, 'font', '');
	    var text = GetAdvancedValue(config, 'text', '');
	    var size = GetAdvancedValue(config, 'size', false);
	    var align = GetValue(config, 'align', 0);

	    var bitmapText = new BitmapText(this.scene, 0, 0, font, text, size, align);

	    if (addToScene !== undefined)
	    {
	        config.add = addToScene;
	    }

	    BuildGameObject(this.scene, bitmapText, config);

	    return bitmapText;
	});
	return BitmapTextCreator;
}

var TextCreator = {};

var hasRequiredTextCreator;

function requireTextCreator () {
	if (hasRequiredTextCreator) return TextCreator;
	hasRequiredTextCreator = 1;
	var BuildGameObject = requireBuildGameObject();
	var GameObjectCreator = requireGameObjectCreator();
	var GetAdvancedValue = requireGetAdvancedValue();
	var Text = requireText();

	GameObjectCreator.register('text', function (config, addToScene)
	{
	    if (config === undefined) { config = {}; }

	    var content = GetAdvancedValue(config, 'text', '');
	    var style = GetAdvancedValue(config, 'style', null);

	    var padding = GetAdvancedValue(config, 'padding', null);

	    if (padding !== null)
	    {
	        style.padding = padding;
	    }

	    var text = new Text(this.scene, 0, 0, content, style);

	    if (addToScene !== undefined)
	    {
	        config.add = addToScene;
	    }

	    BuildGameObject(this.scene, text, config);

	    text.autoRound = GetAdvancedValue(config, 'autoRound', true);
	    text.resolution = GetAdvancedValue(config, 'resolution', 1);

	    return text;
	});
	return TextCreator;
}

var TileSpriteCreator = {};

var hasRequiredTileSpriteCreator;

function requireTileSpriteCreator () {
	if (hasRequiredTileSpriteCreator) return TileSpriteCreator;
	hasRequiredTileSpriteCreator = 1;
	var BuildGameObject = requireBuildGameObject();
	var GameObjectCreator = requireGameObjectCreator();
	var GetAdvancedValue = requireGetAdvancedValue();
	var TileSprite = requireTileSprite();

	GameObjectCreator.register('tileSprite', function (config, addToScene)
	{
	    if (config === undefined) { config = {}; }

	    var x = GetAdvancedValue(config, 'x', 0);
	    var y = GetAdvancedValue(config, 'y', 0);
	    var width = GetAdvancedValue(config, 'width', 512);
	    var height = GetAdvancedValue(config, 'height', 512);
	    var key = GetAdvancedValue(config, 'key', '');
	    var frame = GetAdvancedValue(config, 'frame', '');

	    var tile = new TileSprite(this.scene, x, y, width, height, key, frame);

	    if (addToScene !== undefined)
	    {
	        config.add = addToScene;
	    }

	    BuildGameObject(this.scene, tile, config);

	    return tile;
	});
	return TileSpriteCreator;
}

var ZoneCreator = {};

var hasRequiredZoneCreator;

function requireZoneCreator () {
	if (hasRequiredZoneCreator) return ZoneCreator;
	hasRequiredZoneCreator = 1;
	var GameObjectCreator = requireGameObjectCreator();
	var GetAdvancedValue = requireGetAdvancedValue();
	var Zone = requireZone();

	GameObjectCreator.register('zone', function (config)
	{
	    var x = GetAdvancedValue(config, 'x', 0);
	    var y = GetAdvancedValue(config, 'y', 0);
	    var width = GetAdvancedValue(config, 'width', 1);
	    var height = GetAdvancedValue(config, 'height', width);

	    return new Zone(this.scene, x, y, width, height);
	});
	return ZoneCreator;
}

var VideoCreator = {};

var hasRequiredVideoCreator;

function requireVideoCreator () {
	if (hasRequiredVideoCreator) return VideoCreator;
	hasRequiredVideoCreator = 1;
	var BuildGameObject = requireBuildGameObject();
	var GameObjectCreator = requireGameObjectCreator();
	var GetAdvancedValue = requireGetAdvancedValue();
	var Video = requireVideo();

	GameObjectCreator.register('video', function (config, addToScene)
	{
	    if (config === undefined) { config = {}; }

	    var key = GetAdvancedValue(config, 'key', null);

	    var video = new Video(this.scene, 0, 0, key);

	    if (addToScene !== undefined)
	    {
	        config.add = addToScene;
	    }

	    BuildGameObject(this.scene, video, config);

	    return video;
	});
	return VideoCreator;
}

var SetValue_1;
var hasRequiredSetValue;

function requireSetValue () {
	if (hasRequiredSetValue) return SetValue_1;
	hasRequiredSetValue = 1;
	var SetValue = function (source, key, value)
	{
	    if (!source || typeof source === 'number')
	    {
	        return false;
	    }
	    else if (source.hasOwnProperty(key))
	    {
	        source[key] = value;

	        return true;
	    }
	    else if (key.indexOf('.') !== -1)
	    {
	        var keys = key.split('.');
	        var parent = source;
	        var prev = source;

	        for (var i = 0; i < keys.length; i++)
	        {
	            if (parent.hasOwnProperty(keys[i]))
	            {

	                prev = parent;
	                parent = parent[keys[i]];
	            }
	            else
	            {
	                return false;
	            }
	        }

	        prev[keys[keys.length - 1]] = value;

	        return true;
	    }

	    return false;
	};

	SetValue_1 = SetValue;
	return SetValue_1;
}

var ShaderWebGLRenderer_1;
var hasRequiredShaderWebGLRenderer;

function requireShaderWebGLRenderer () {
	if (hasRequiredShaderWebGLRenderer) return ShaderWebGLRenderer_1;
	hasRequiredShaderWebGLRenderer = 1;
	var GetCalcMatrix = requireGetCalcMatrix();

	var ShaderWebGLRenderer = function (renderer, src, camera, parentMatrix)
	{
	    if (!src.shader)
	    {
	        return;
	    }

	    camera.addToRenderList(src);

	    renderer.pipelines.clear();

	    if (src.renderToTexture)
	    {
	        src.load();
	        src.flush();
	    }
	    else
	    {
	        var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;

	        if (renderer.width !== src._rendererWidth || renderer.height !== src._rendererHeight)
	        {
	            src.projOrtho(0, renderer.width, renderer.height, 0);
	        }

	        src.load(calcMatrix.matrix);
	        src.flush();
	    }

	    renderer.pipelines.rebind();
	};

	ShaderWebGLRenderer_1 = ShaderWebGLRenderer;
	return ShaderWebGLRenderer_1;
}

var ShaderCanvasRenderer_1;
var hasRequiredShaderCanvasRenderer;

function requireShaderCanvasRenderer () {
	if (hasRequiredShaderCanvasRenderer) return ShaderCanvasRenderer_1;
	hasRequiredShaderCanvasRenderer = 1;
	var ShaderCanvasRenderer = function ()
	{
	};

	ShaderCanvasRenderer_1 = ShaderCanvasRenderer;
	return ShaderCanvasRenderer_1;
}

var ShaderRender;
var hasRequiredShaderRender;

function requireShaderRender () {
	if (hasRequiredShaderRender) return ShaderRender;
	hasRequiredShaderRender = 1;
	var NOOP = requireNOOP();
	var renderWebGL = NOOP;
	var renderCanvas = NOOP;

	if (typeof WEBGL_RENDERER)
	{
	    renderWebGL = requireShaderWebGLRenderer();
	}

	if (typeof CANVAS_RENDERER)
	{
	    renderCanvas = requireShaderCanvasRenderer();
	}

	ShaderRender = {

	    renderWebGL: renderWebGL,
	    renderCanvas: renderCanvas

	};
	return ShaderRender;
}

var Shader_1;
var hasRequiredShader;

function requireShader () {
	if (hasRequiredShader) return Shader_1;
	hasRequiredShader = 1;
	var Class = requireClass();
	var Components = requireComponents$2();
	var GameObject = requireGameObject();
	var GetFastValue = requireGetFastValue();
	var Extend = requireExtend$1();
	var SetValue = requireSetValue();
	var ShaderRender = requireShaderRender();
	var TransformMatrix = requireTransformMatrix();
	var ArrayEach = requireEach();
	var RenderEvents = requireEvents$d();

	var Shader = new Class({

	    Extends: GameObject,

	    Mixins: [
	        Components.ComputedSize,
	        Components.Depth,
	        Components.GetBounds,
	        Components.Mask,
	        Components.Origin,
	        Components.ScrollFactor,
	        Components.Transform,
	        Components.Visible,
	        ShaderRender
	    ],

	    initialize:

	    function Shader (scene, key, x, y, width, height, textures, textureData)
	    {
	        if (x === undefined) { x = 0; }
	        if (y === undefined) { y = 0; }
	        if (width === undefined) { width = 128; }
	        if (height === undefined) { height = 128; }

	        GameObject.call(this, scene, 'Shader');

	        this.blendMode = -1;

	        this.shader;

	        var renderer = scene.sys.renderer;

	        this.renderer = renderer;

	        this.gl = renderer.gl;

	        this.vertexData = new ArrayBuffer(6 * (Float32Array.BYTES_PER_ELEMENT * 2));

	        this.vertexBuffer = renderer.createVertexBuffer(this.vertexData.byteLength, this.gl.STREAM_DRAW);

	        this._deferSetShader = null;

	        this._deferProjOrtho = null;

	        this.program = null;

	        this.bytes = new Uint8Array(this.vertexData);

	        this.vertexViewF32 = new Float32Array(this.vertexData);

	        this._tempMatrix1 = new TransformMatrix();

	        this._tempMatrix2 = new TransformMatrix();

	        this._tempMatrix3 = new TransformMatrix();

	        this.viewMatrix = new Float32Array([ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ]);

	        this.projectionMatrix = new Float32Array([ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ]);

	        this.uniforms = {};

	        this.pointer = null;

	        this._rendererWidth = renderer.width;

	        this._rendererHeight = renderer.height;

	        this._textureCount = 0;

	        this.framebuffer = null;

	        this.glTexture = null;

	        this.renderToTexture = false;

	        this.texture = null;

	        this.setPosition(x, y);
	        this.setSize(width, height);
	        this.setOrigin(0.5, 0.5);
	        this.setShader(key, textures, textureData);

	        this.renderer.on(RenderEvents.RESTORE_WEBGL, this.onContextRestored, this);
	    },

	    willRender: function (camera)
	    {
	        if (this.renderToTexture)
	        {
	            return true;
	        }
	        else
	        {
	            return !(GameObject.RENDER_MASK !== this.renderFlags || (this.cameraFilter !== 0 && (this.cameraFilter & camera.id)));
	        }
	    },

	    setRenderToTexture: function (key, flipY)
	    {

	        if (!this.renderToTexture)
	        {
	            var width = this.width;
	            var height = this.height;
	            var renderer = this.renderer;

	            this.glTexture = renderer.createTextureFromSource(null, width, height, 0);

	            this.framebuffer = renderer.createFramebuffer(width, height, this.glTexture, false);

	            this._rendererWidth = width;
	            this._rendererHeight = height;

	            this.renderToTexture = true;

	            this.projOrtho(0, this.width, this.height, 0);

	            if (key)
	            {
	                this.texture = this.scene.sys.textures.addGLTexture(key, this.glTexture);
	            }
	        }

	        if (this.shader)
	        {
	            renderer.pipelines.clear();

	            this.load();
	            this.flush();

	            renderer.pipelines.rebind();
	        }

	        return this;
	    },

	    setShader: function (key, textures, textureData)
	    {
	        if (this.renderer.contextLost)
	        {
	            this._deferSetShader = { key: key, textures: textures, textureData: textureData };
	            return this;
	        }

	        if (textures === undefined) { textures = []; }

	        if (typeof key === 'string')
	        {
	            var cache = this.scene.sys.cache.shader;

	            if (!cache.has(key))
	            {
	                console.warn('Shader missing: ' + key);
	                return this;
	            }

	            this.shader = cache.get(key);
	        }
	        else
	        {
	            this.shader = key;
	        }

	        var gl = this.gl;
	        var renderer = this.renderer;

	        if (this.program)
	        {
	            renderer.deleteProgram(this.program);
	        }

	        var program = renderer.createProgram(this.shader.vertexSrc, this.shader.fragmentSrc);

	        gl.uniformMatrix4fv(gl.getUniformLocation(program.webGLProgram, 'uViewMatrix'), false, this.viewMatrix);
	        gl.uniformMatrix4fv(gl.getUniformLocation(program.webGLProgram, 'uProjectionMatrix'), false, this.projectionMatrix);
	        gl.uniform2f(gl.getUniformLocation(program.webGLProgram, 'uResolution'), this.width, this.height);

	        this.program = program;

	        var d = new Date();

	        var defaultUniforms = {
	            resolution: { type: '2f', value: { x: this.width, y: this.height } },
	            time: { type: '1f', value: 0 },
	            mouse: { type: '2f', value: { x: this.width / 2, y: this.height / 2 } },
	            date: { type: '4fv', value: [ d.getFullYear(), d.getMonth(), d.getDate(), d.getHours() * 60 * 60 + d.getMinutes() * 60 + d.getSeconds() ] },
	            sampleRate: { type: '1f', value: 44100.0 },
	            iChannel0: { type: 'sampler2D', value: null, textureData: { repeat: true } },
	            iChannel1: { type: 'sampler2D', value: null, textureData: { repeat: true } },
	            iChannel2: { type: 'sampler2D', value: null, textureData: { repeat: true } },
	            iChannel3: { type: 'sampler2D', value: null, textureData: { repeat: true } }
	        };

	        if (this.shader.uniforms)
	        {
	            this.uniforms = Extend(true, {}, this.shader.uniforms, defaultUniforms);
	        }
	        else
	        {
	            this.uniforms = defaultUniforms;
	        }

	        for (var i = 0; i < 4; i++)
	        {
	            if (textures[i])
	            {
	                this.setSampler2D('iChannel' + i, textures[i], i, textureData);
	            }
	        }

	        this.initUniforms();

	        this.projOrtho(0, this._rendererWidth, this._rendererHeight, 0);

	        return this;
	    },

	    setPointer: function (pointer)
	    {
	        this.pointer = pointer;

	        return this;
	    },

	    projOrtho: function (left, right, bottom, top)
	    {
	        if (this.renderer.contextLost)
	        {
	            this._deferProjOrtho = { left: left, right: right, bottom: bottom, top: top };
	            return;
	        }

	        var near = -1000;
	        var far = 1000;

	        var leftRight = 1 / (left - right);
	        var bottomTop = 1 / (bottom - top);
	        var nearFar = 1 / (near - far);

	        var pm = this.projectionMatrix;

	        pm[0] = -2 * leftRight;
	        pm[5] = -2 * bottomTop;
	        pm[10] = 2 * nearFar;
	        pm[12] = (left + right) * leftRight;
	        pm[13] = (top + bottom) * bottomTop;
	        pm[14] = (far + near) * nearFar;

	        var program = this.program;

	        var gl = this.gl;
	        var renderer = this.renderer;

	        renderer.setProgram(program);

	        gl.uniformMatrix4fv(gl.getUniformLocation(program.webGLProgram, 'uProjectionMatrix'), false, this.projectionMatrix);

	        this._rendererWidth = right;
	        this._rendererHeight = bottom;
	    },

	    initUniforms: function ()
	    {
	        var map = this.renderer.glFuncMap;
	        var program = this.program;

	        this._textureCount = 0;

	        for (var key in this.uniforms)
	        {
	            var uniform = this.uniforms[key];

	            var type = uniform.type;
	            var data = map[type];

	            uniform.uniformLocation = this.renderer.createUniformLocation(program, key);

	            if (type !== 'sampler2D')
	            {
	                uniform.glMatrix = data.matrix;
	                uniform.glValueLength = data.length;
	                uniform.glFunc = data.func;
	            }
	        }
	    },

	    setSampler2DBuffer: function (uniformKey, texture, width, height, textureIndex, textureData)
	    {
	        if (textureIndex === undefined) { textureIndex = 0; }
	        if (textureData === undefined) { textureData = {}; }

	        var uniform = this.uniforms[uniformKey];

	        uniform.value = texture;

	        textureData.width = width;
	        textureData.height = height;

	        uniform.textureData = textureData;

	        this._textureCount = textureIndex;

	        this.initSampler2D(uniform);

	        return this;
	    },

	    setSampler2D: function (uniformKey, textureKey, textureIndex, textureData)
	    {
	        if (textureIndex === undefined) { textureIndex = 0; }

	        var textureManager = this.scene.sys.textures;

	        if (textureManager.exists(textureKey))
	        {
	            var frame = textureManager.getFrame(textureKey);

	            if (frame.glTexture && frame.glTexture.isRenderTexture)
	            {
	                return this.setSampler2DBuffer(uniformKey, frame.glTexture, frame.width, frame.height, textureIndex, textureData);
	            }

	            var uniform = this.uniforms[uniformKey];
	            var source = frame.source;

	            uniform.textureKey = textureKey;
	            uniform.source = source.image;
	            uniform.value = frame.glTexture;

	            if (source.isGLTexture)
	            {
	                if (!textureData)
	                {
	                    textureData = {};
	                }

	                textureData.width = source.width;
	                textureData.height = source.height;
	            }

	            if (textureData)
	            {
	                uniform.textureData = textureData;
	            }

	            this._textureCount = textureIndex;

	            this.initSampler2D(uniform);
	        }

	        return this;
	    },

	    setUniform: function (key, value)
	    {
	        SetValue(this.uniforms, key, value);

	        return this;
	    },

	    getUniform: function (key)
	    {
	        return GetFastValue(this.uniforms, key, null);
	    },

	    setChannel0: function (textureKey, textureData)
	    {
	        return this.setSampler2D('iChannel0', textureKey, 0, textureData);
	    },

	    setChannel1: function (textureKey, textureData)
	    {
	        return this.setSampler2D('iChannel1', textureKey, 1, textureData);
	    },

	    setChannel2: function (textureKey, textureData)
	    {
	        return this.setSampler2D('iChannel2', textureKey, 2, textureData);
	    },

	    setChannel3: function (textureKey, textureData)
	    {
	        return this.setSampler2D('iChannel3', textureKey, 3, textureData);
	    },

	    initSampler2D: function (uniform)
	    {
	        if (!uniform.value)
	        {
	            return;
	        }

	        var data = uniform.textureData;

	        if (data && !uniform.value.isRenderTexture)
	        {
	            var gl = this.gl;
	            var wrapper = uniform.value;

	            var magFilter = gl[GetFastValue(data, 'magFilter', 'linear').toUpperCase()];
	            var minFilter = gl[GetFastValue(data, 'minFilter', 'linear').toUpperCase()];
	            var wrapS = gl[GetFastValue(data, 'wrapS', 'repeat').toUpperCase()];
	            var wrapT = gl[GetFastValue(data, 'wrapT', 'repeat').toUpperCase()];
	            var format = gl[GetFastValue(data, 'format', 'rgba').toUpperCase()];
	            var flipY = GetFastValue(data, 'flipY', false);
	            var width = GetFastValue(data, 'width', wrapper.width);
	            var height = GetFastValue(data, 'height', wrapper.height);
	            var source = GetFastValue(data, 'source', wrapper.pixels);

	            if (data.repeat)
	            {
	                wrapS = gl.REPEAT;
	                wrapT = gl.REPEAT;
	            }

	            if (data.width)
	            {

	                source = null;
	            }

	            wrapper.update(source, width, height, flipY, wrapS, wrapT, minFilter, magFilter, format);
	        }

	        this.renderer.setProgram(this.program);

	        this._textureCount++;
	    },

	    syncUniforms: function ()
	    {
	        var gl = this.gl;

	        var uniforms = this.uniforms;
	        var uniform;
	        var length;
	        var glFunc;
	        var location;
	        var value;
	        var textureCount = 0;

	        for (var key in uniforms)
	        {
	            uniform = uniforms[key];

	            glFunc = uniform.glFunc;
	            length = uniform.glValueLength;
	            location = uniform.uniformLocation;
	            value = uniform.value;

	            if (value === null)
	            {
	                continue;
	            }

	            if (length === 1)
	            {
	                if (uniform.glMatrix)
	                {
	                    glFunc.call(gl, location.webGLUniformLocation, uniform.transpose, value);
	                }
	                else
	                {
	                    glFunc.call(gl, location.webGLUniformLocation, value);
	                }
	            }
	            else if (length === 2)
	            {
	                glFunc.call(gl, location.webGLUniformLocation, value.x, value.y);
	            }
	            else if (length === 3)
	            {
	                glFunc.call(gl, location.webGLUniformLocation, value.x, value.y, value.z);
	            }
	            else if (length === 4)
	            {
	                glFunc.call(gl, location.webGLUniformLocation, value.x, value.y, value.z, value.w);
	            }
	            else if (uniform.type === 'sampler2D')
	            {
	                gl.activeTexture(gl.TEXTURE0 + textureCount);

	                gl.bindTexture(gl.TEXTURE_2D, value.webGLTexture);

	                gl.uniform1i(location.webGLUniformLocation, textureCount);

	                textureCount++;
	            }
	        }
	    },

	    load: function (matrix2D)
	    {

	        var gl = this.gl;
	        var width = this.width;
	        var height = this.height;
	        var renderer = this.renderer;
	        var program = this.program;
	        var vm = this.viewMatrix;

	        if (!this.renderToTexture)
	        {
	            var x = -this._displayOriginX;
	            var y = -this._displayOriginY;

	            vm[0] = matrix2D[0];
	            vm[1] = matrix2D[1];
	            vm[4] = matrix2D[2];
	            vm[5] = matrix2D[3];
	            vm[8] = matrix2D[4];
	            vm[9] = matrix2D[5];
	            vm[12] = vm[0] * x + vm[4] * y;
	            vm[13] = vm[1] * x + vm[5] * y;
	        }

	        gl.useProgram(program.webGLProgram);

	        gl.uniformMatrix4fv(gl.getUniformLocation(program.webGLProgram, 'uViewMatrix'), false, vm);
	        gl.uniformMatrix4fv(gl.getUniformLocation(program.webGLProgram, 'uProjectionMatrix'), false, this.projectionMatrix);
	        gl.uniform2f(gl.getUniformLocation(program.webGLProgram, 'uResolution'), this.width, this.height);

	        var uniforms = this.uniforms;
	        var res = uniforms.resolution;

	        res.value.x = width;
	        res.value.y = height;

	        uniforms.time.value = renderer.game.loop.getDuration();

	        var pointer = this.pointer;

	        if (pointer)
	        {
	            var mouse = uniforms.mouse;

	            var px = pointer.x / width;
	            var py = 1 - pointer.y / height;

	            mouse.value.x = px.toFixed(2);
	            mouse.value.y = py.toFixed(2);
	        }

	        this.syncUniforms();
	    },

	    flush: function ()
	    {

	        var width = this.width;
	        var height = this.height;
	        var program = this.program;

	        var gl = this.gl;
	        var vertexBuffer = this.vertexBuffer;
	        var renderer = this.renderer;
	        var vertexSize = Float32Array.BYTES_PER_ELEMENT * 2;

	        if (this.renderToTexture)
	        {
	            renderer.setFramebuffer(this.framebuffer);

	            gl.clearColor(0, 0, 0, 0);

	            gl.clear(gl.COLOR_BUFFER_BIT);
	        }

	        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer.webGLBuffer);

	        var location = gl.getAttribLocation(program.webGLProgram, 'inPosition');

	        if (location !== -1)
	        {
	            gl.enableVertexAttribArray(location);

	            gl.vertexAttribPointer(location, 2, gl.FLOAT, false, vertexSize, 0);
	        }

	        var vf = this.vertexViewF32;

	        vf[3] = height;
	        vf[4] = width;
	        vf[5] = height;
	        vf[8] = width;
	        vf[9] = height;
	        vf[10] = width;

	        var vertexCount = 6;

	        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.bytes.subarray(0, vertexCount * vertexSize));

	        gl.drawArrays(gl.TRIANGLES, 0, vertexCount);

	        if (this.renderToTexture)
	        {
	            renderer.setFramebuffer(null, false);
	        }
	    },

	    setAlpha: function ()
	    {
	    },

	    setBlendMode: function ()
	    {
	    },

	    onContextRestored: function ()
	    {
	        if (this._deferSetShader !== null)
	        {
	            var key = this._deferSetShader.key;
	            var textures = this._deferSetShader.textures;
	            var textureData = this._deferSetShader.textureData;
	            this._deferSetShader = null;
	            this.setShader(key, textures, textureData);
	        }

	        if (this._deferProjOrtho !== null)
	        {
	            var left = this._deferProjOrtho.left;
	            var right = this._deferProjOrtho.right;
	            var bottom = this._deferProjOrtho.bottom;
	            var top = this._deferProjOrtho.top;
	            this._deferProjOrtho = null;
	            this.projOrtho(left, right, bottom, top);
	        }
	    },

	    preDestroy: function ()
	    {
	        var renderer = this.renderer;

	        renderer.off(RenderEvents.RESTORE_WEBGL, this.onContextRestored, this);
	        renderer.deleteProgram(this.program);
	        renderer.deleteBuffer(this.vertexBuffer);

	        if (this.renderToTexture)
	        {
	            renderer.deleteFramebuffer(this.framebuffer);

	            this.texture.destroy();

	            this.framebuffer = null;
	            this.glTexture = null;
	            this.texture = null;
	        }

	        ArrayEach(this.uniforms, function (uniform)
	        {
	            renderer.deleteUniformLocation(uniform.uniformLocation);
	            uniform.uniformLocation = null;
	        });
	    }

	});

	Shader_1 = Shader;
	return Shader_1;
}

var Face_1;
var hasRequiredFace;

function requireFace () {
	if (hasRequiredFace) return Face_1;
	hasRequiredFace = 1;
	var Class = requireClass();
	var Rectangle = requireRectangle$2();
	var Vector2 = requireVector2();

	function GetLength (x1, y1, x2, y2)
	{
	    var x = x1 - x2;
	    var y = y1 - y2;
	    var magnitude = (x * x) + (y * y);

	    return Math.sqrt(magnitude);
	}

	var Face = new Class({

	    initialize:

	    function Face (vertex1, vertex2, vertex3)
	    {

	        this.vertex1 = vertex1;

	        this.vertex2 = vertex2;

	        this.vertex3 = vertex3;

	        this.bounds = new Rectangle();

	        this._inCenter = new Vector2();
	    },

	    getInCenter: function (local)
	    {
	        if (local === undefined) { local = true; }

	        var v1 = this.vertex1;
	        var v2 = this.vertex2;
	        var v3 = this.vertex3;

	        var v1x;
	        var v1y;

	        var v2x;
	        var v2y;

	        var v3x;
	        var v3y;

	        if (local)
	        {
	            v1x = v1.x;
	            v1y = v1.y;

	            v2x = v2.x;
	            v2y = v2.y;

	            v3x = v3.x;
	            v3y = v3.y;
	        }
	        else
	        {
	            v1x = v1.vx;
	            v1y = v1.vy;

	            v2x = v2.vx;
	            v2y = v2.vy;

	            v3x = v3.vx;
	            v3y = v3.vy;
	        }

	        var d1 = GetLength(v3x, v3y, v2x, v2y);
	        var d2 = GetLength(v1x, v1y, v3x, v3y);
	        var d3 = GetLength(v2x, v2y, v1x, v1y);

	        var p = d1 + d2 + d3;

	        return this._inCenter.set(
	            (v1x * d1 + v2x * d2 + v3x * d3) / p,
	            (v1y * d1 + v2y * d2 + v3y * d3) / p
	        );
	    },

	    contains: function (x, y, calcMatrix)
	    {
	        var vertex1 = this.vertex1;
	        var vertex2 = this.vertex2;
	        var vertex3 = this.vertex3;

	        var v1x = vertex1.vx;
	        var v1y = vertex1.vy;

	        var v2x = vertex2.vx;
	        var v2y = vertex2.vy;

	        var v3x = vertex3.vx;
	        var v3y = vertex3.vy;

	        if (calcMatrix)
	        {
	            var a = calcMatrix.a;
	            var b = calcMatrix.b;
	            var c = calcMatrix.c;
	            var d = calcMatrix.d;
	            var e = calcMatrix.e;
	            var f = calcMatrix.f;

	            v1x = vertex1.vx * a + vertex1.vy * c + e;
	            v1y = vertex1.vx * b + vertex1.vy * d + f;

	            v2x = vertex2.vx * a + vertex2.vy * c + e;
	            v2y = vertex2.vx * b + vertex2.vy * d + f;

	            v3x = vertex3.vx * a + vertex3.vy * c + e;
	            v3y = vertex3.vx * b + vertex3.vy * d + f;
	        }

	        var t0x = v3x - v1x;
	        var t0y = v3y - v1y;

	        var t1x = v2x - v1x;
	        var t1y = v2y - v1y;

	        var t2x = x - v1x;
	        var t2y = y - v1y;

	        var dot00 = (t0x * t0x) + (t0y * t0y);
	        var dot01 = (t0x * t1x) + (t0y * t1y);
	        var dot02 = (t0x * t2x) + (t0y * t2y);
	        var dot11 = (t1x * t1x) + (t1y * t1y);
	        var dot12 = (t1x * t2x) + (t1y * t2y);

	        var bc = ((dot00 * dot11) - (dot01 * dot01));
	        var inv = (bc === 0) ? 0 : (1 / bc);
	        var u = ((dot11 * dot02) - (dot01 * dot12)) * inv;
	        var v = ((dot00 * dot12) - (dot01 * dot02)) * inv;

	        return (u >= 0 && v >= 0 && (u + v < 1));
	    },

	    isCounterClockwise: function (z)
	    {
	        var v1 = this.vertex1;
	        var v2 = this.vertex2;
	        var v3 = this.vertex3;

	        var d = (v2.vx - v1.vx) * (v3.vy - v1.vy) - (v2.vy - v1.vy) * (v3.vx - v1.vx);

	        return (z <= 0) ? d >= 0 : d < 0;
	    },

	    load: function (F32, U32, offset, textureUnit, tintEffect)
	    {
	        offset = this.vertex1.load(F32, U32, offset, textureUnit, tintEffect);
	        offset = this.vertex2.load(F32, U32, offset, textureUnit, tintEffect);
	        offset = this.vertex3.load(F32, U32, offset, textureUnit, tintEffect);

	        return offset;
	    },

	    transformCoordinatesLocal: function (transformMatrix, width, height, cameraZ)
	    {
	        this.vertex1.transformCoordinatesLocal(transformMatrix, width, height, cameraZ);
	        this.vertex2.transformCoordinatesLocal(transformMatrix, width, height, cameraZ);
	        this.vertex3.transformCoordinatesLocal(transformMatrix, width, height, cameraZ);

	        return this;
	    },

	    updateBounds: function ()
	    {
	        var v1 = this.vertex1;
	        var v2 = this.vertex2;
	        var v3 = this.vertex3;

	        var bounds = this.bounds;

	        bounds.x = Math.min(v1.vx, v2.vx, v3.vx);
	        bounds.y = Math.min(v1.vy, v2.vy, v3.vy);
	        bounds.width = Math.max(v1.vx, v2.vx, v3.vx) - bounds.x;
	        bounds.height = Math.max(v1.vy, v2.vy, v3.vy) - bounds.y;

	        return this;
	    },

	    isInView: function (camera, hideCCW, z, alpha, a, b, c, d, e, f, roundPixels)
	    {
	        this.update(alpha, a, b, c, d, e, f, roundPixels);

	        var v1 = this.vertex1;
	        var v2 = this.vertex2;
	        var v3 = this.vertex3;

	        if (v1.ta <= 0 && v2.ta <= 0 && v3.ta <= 0)
	        {
	            return false;
	        }

	        if (hideCCW && !this.isCounterClockwise(z))
	        {
	            return false;
	        }

	        var bounds = this.bounds;

	        bounds.x = Math.min(v1.tx, v2.tx, v3.tx);
	        bounds.y = Math.min(v1.ty, v2.ty, v3.ty);
	        bounds.width = Math.max(v1.tx, v2.tx, v3.tx) - bounds.x;
	        bounds.height = Math.max(v1.ty, v2.ty, v3.ty) - bounds.y;

	        var cr = camera.x + camera.width;
	        var cb = camera.y + camera.height;

	        if (bounds.width <= 0 || bounds.height <= 0 || camera.width <= 0 || camera.height <= 0)
	        {
	            return false;
	        }

	        return !(bounds.right < camera.x || bounds.bottom < camera.y || bounds.x > cr || bounds.y > cb);
	    },

	    scrollUV: function (x, y)
	    {
	        this.vertex1.scrollUV(x, y);
	        this.vertex2.scrollUV(x, y);
	        this.vertex3.scrollUV(x, y);

	        return this;
	    },

	    scaleUV: function (x, y)
	    {
	        this.vertex1.scaleUV(x, y);
	        this.vertex2.scaleUV(x, y);
	        this.vertex3.scaleUV(x, y);

	        return this;
	    },

	    setColor: function (color)
	    {
	        this.vertex1.color = color;
	        this.vertex2.color = color;
	        this.vertex3.color = color;

	        return this;
	    },

	    update: function (alpha, a, b, c, d, e, f, roundPixels)
	    {
	        this.vertex1.update(a, b, c, d, e, f, roundPixels, alpha);
	        this.vertex2.update(a, b, c, d, e, f, roundPixels, alpha);
	        this.vertex3.update(a, b, c, d, e, f, roundPixels, alpha);

	        return this;
	    },

	    translate: function (x, y)
	    {
	        if (y === undefined) { y = 0; }

	        var v1 = this.vertex1;
	        var v2 = this.vertex2;
	        var v3 = this.vertex3;

	        v1.x += x;
	        v1.y += y;

	        v2.x += x;
	        v2.y += y;

	        v3.x += x;
	        v3.y += y;

	        return this;
	    },

	    x: {

	        get: function ()
	        {
	            return this.getInCenter().x;
	        },

	        set: function (value)
	        {
	            var current = this.getInCenter();

	            this.translate(value - current.x, 0);
	        }

	    },

	    y: {

	        get: function ()
	        {
	            return this.getInCenter().y;
	        },

	        set: function (value)
	        {
	            var current = this.getInCenter();

	            this.translate(0, value - current.y);
	        }

	    },

	    alpha: {

	        get: function ()
	        {
	            var v1 = this.vertex1;
	            var v2 = this.vertex2;
	            var v3 = this.vertex3;

	            return (v1.alpha + v2.alpha + v3.alpha) / 3;
	        },

	        set: function (value)
	        {
	            this.vertex1.alpha = value;
	            this.vertex2.alpha = value;
	            this.vertex3.alpha = value;
	        }

	    },

	    depth: {

	        get: function ()
	        {
	            var v1 = this.vertex1;
	            var v2 = this.vertex2;
	            var v3 = this.vertex3;

	            return (v1.vz + v2.vz + v3.vz) / 3;
	        }

	    },

	    destroy: function ()
	    {
	        this.vertex1 = null;
	        this.vertex2 = null;
	        this.vertex3 = null;
	    }

	});

	Face_1 = Face;
	return Face_1;
}

var Vertex_1;
var hasRequiredVertex;

function requireVertex () {
	if (hasRequiredVertex) return Vertex_1;
	hasRequiredVertex = 1;
	var Class = requireClass();
	var Utils = requireUtils$1();
	var Vector3 = requireVector3();

	var Vertex = new Class({

	    Extends: Vector3,

	    initialize:

	    function Vertex (x, y, z, u, v, color, alpha, nx, ny, nz)
	    {
	        if (color === undefined) { color = 0xffffff; }
	        if (alpha === undefined) { alpha = 1; }
	        if (nx === undefined) { nx = 0; }
	        if (ny === undefined) { ny = 0; }
	        if (nz === undefined) { nz = 0; }

	        Vector3.call(this, x, y, z);

	        this.vx = 0;

	        this.vy = 0;

	        this.vz = 0;

	        this.nx = nx;

	        this.ny = ny;

	        this.nz = nz;

	        this.u = u;

	        this.v = v;

	        this.color = color;

	        this.alpha = alpha;

	        this.tx = 0;

	        this.ty = 0;

	        this.ta = 0;

	        this.tu = u;

	        this.tv = v;
	    },

	    setUVs: function (u, v)
	    {
	        this.u = u;
	        this.v = v;

	        this.tu = u;
	        this.tv = v;

	        return this;
	    },

	    scrollUV: function (x, y)
	    {
	        this.tu += x;
	        this.tv += y;

	        return this;
	    },

	    scaleUV: function (x, y)
	    {
	        this.tu = this.u * x;
	        this.tv = this.v * y;

	        return this;
	    },

	    transformCoordinatesLocal: function (transformMatrix, width, height, cameraZ)
	    {
	        var x = this.x;
	        var y = this.y;
	        var z = this.z;

	        var m = transformMatrix.val;

	        var tx = (x * m[0]) + (y * m[4]) + (z * m[8]) + m[12];
	        var ty = (x * m[1]) + (y * m[5]) + (z * m[9]) + m[13];
	        var tz = (x * m[2]) + (y * m[6]) + (z * m[10]) + m[14];
	        var tw = (x * m[3]) + (y * m[7]) + (z * m[11]) + m[15];

	        this.vx = (tx / tw) * width;
	        this.vy = -(ty / tw) * height;

	        if (cameraZ <= 0)
	        {
	            this.vz = (tz / tw);
	        }
	        else
	        {
	            this.vz = -(tz / tw);
	        }
	    },

	    resize: function (x, y, width, height, originX, originY)
	    {
	        this.x = x;
	        this.y = y;

	        this.vx = this.x * width;
	        this.vy = -this.y * height;
	        this.vz = 0;

	        if (originX < 0.5)
	        {
	            this.vx += width * (0.5 - originX);
	        }
	        else if (originX > 0.5)
	        {
	            this.vx -= width * (originX - 0.5);
	        }

	        if (originY < 0.5)
	        {
	            this.vy += height * (0.5 - originY);
	        }
	        else if (originY > 0.5)
	        {
	            this.vy -= height * (originY - 0.5);
	        }

	        return this;
	    },

	    update: function (a, b, c, d, e, f, roundPixels, alpha)
	    {
	        var tx = this.vx * a + this.vy * c + e;
	        var ty = this.vx * b + this.vy * d + f;

	        if (roundPixels)
	        {
	            tx = Math.round(tx);
	            ty = Math.round(ty);
	        }

	        this.tx = tx;
	        this.ty = ty;
	        this.ta = this.alpha * alpha;

	        return this;
	    },

	    load: function (F32, U32, offset, textureUnit, tintEffect)
	    {
	        F32[++offset] = this.tx;
	        F32[++offset] = this.ty;
	        F32[++offset] = this.tu;
	        F32[++offset] = this.tv;
	        F32[++offset] = textureUnit;
	        F32[++offset] = tintEffect;
	        U32[++offset] = Utils.getTintAppendFloatAlpha(this.color, this.ta);

	        return offset;
	    }

	});

	Vertex_1 = Vertex;
	return Vertex_1;
}

var GenerateObjVerts_1;
var hasRequiredGenerateObjVerts;

function requireGenerateObjVerts () {
	if (hasRequiredGenerateObjVerts) return GenerateObjVerts_1;
	hasRequiredGenerateObjVerts = 1;
	var Face = requireFace();
	var Matrix4 = requireMatrix4();
	var Vector3 = requireVector3();
	var Vertex = requireVertex();

	var tempPosition = new Vector3();
	var tempRotation = new Vector3();
	var tempMatrix = new Matrix4();

	var GenerateObjVerts = function (data, mesh, scale, x, y, z, rotateX, rotateY, rotateZ, zIsUp)
	{
	    if (scale === undefined) { scale = 1; }
	    if (x === undefined) { x = 0; }
	    if (y === undefined) { y = 0; }
	    if (z === undefined) { z = 0; }
	    if (rotateX === undefined) { rotateX = 0; }
	    if (rotateY === undefined) { rotateY = 0; }
	    if (rotateZ === undefined) { rotateZ = 0; }
	    if (zIsUp === undefined) { zIsUp = true; }

	    var result = {
	        faces: [],
	        verts: []
	    };

	    var materials = data.materials;

	    tempPosition.set(x, y, z);
	    tempRotation.set(rotateX, rotateY, rotateZ);
	    tempMatrix.fromRotationXYTranslation(tempRotation, tempPosition, zIsUp);

	    for (var m = 0; m < data.models.length; m++)
	    {
	        var model = data.models[m];

	        var vertices = model.vertices;
	        var textureCoords = model.textureCoords;
	        var faces = model.faces;

	        for (var i = 0; i < faces.length; i++)
	        {
	            var face = faces[i];

	            var v1 = face.vertices[0];
	            var v2 = face.vertices[1];
	            var v3 = face.vertices[2];

	            var m1 = vertices[v1.vertexIndex];
	            var m2 = vertices[v2.vertexIndex];
	            var m3 = vertices[v3.vertexIndex];

	            var t1 = v1.textureCoordsIndex;
	            var t2 = v2.textureCoordsIndex;
	            var t3 = v3.textureCoordsIndex;

	            var uv1 = (t1 === -1) ? { u: 0, v: 1 } : textureCoords[t1];
	            var uv2 = (t2 === -1) ? { u: 0, v: 0 } : textureCoords[t2];
	            var uv3 = (t3 === -1) ? { u: 1, v: 1 } : textureCoords[t3];

	            var color = 0xffffff;

	            if (face.material !== '' && materials[face.material])
	            {
	                color = materials[face.material];
	            }

	            var vert1 = new Vertex(m1.x * scale, m1.y * scale, m1.z * scale, uv1.u, uv1.v, color).transformMat4(tempMatrix);
	            var vert2 = new Vertex(m2.x * scale, m2.y * scale, m2.z * scale, uv2.u, uv2.v, color).transformMat4(tempMatrix);
	            var vert3 = new Vertex(m3.x * scale, m3.y * scale, m3.z * scale, uv3.u, uv3.v, color).transformMat4(tempMatrix);

	            result.verts.push(vert1, vert2, vert3);
	            result.faces.push(new Face(vert1, vert2, vert3));
	        }
	    }

	    if (mesh)
	    {
	        mesh.faces = mesh.faces.concat(result.faces);
	        mesh.vertices = mesh.vertices.concat(result.verts);
	    }

	    return result;
	};

	GenerateObjVerts_1 = GenerateObjVerts;
	return GenerateObjVerts_1;
}

var GenerateVerts_1;
var hasRequiredGenerateVerts;

function requireGenerateVerts () {
	if (hasRequiredGenerateVerts) return GenerateVerts_1;
	hasRequiredGenerateVerts = 1;
	var Face = requireFace();
	var Vertex = requireVertex();

	var GenerateVerts = function (vertices, uvs, indicies, containsZ, normals, colors, alphas, flipUV)
	{
	    if (containsZ === undefined) { containsZ = false; }
	    if (colors === undefined) { colors = 0xffffff; }
	    if (alphas === undefined) { alphas = 1; }
	    if (flipUV === undefined) { flipUV = false; }

	    if (vertices.length !== uvs.length && !containsZ)
	    {
	        console.warn('GenerateVerts: vertices and uvs count not equal');
	        return;
	    }

	    var result = {
	        faces: [],
	        vertices: []
	    };

	    var i;

	    var x;
	    var y;
	    var z;

	    var u;
	    var v;

	    var color;
	    var alpha;

	    var normalX;
	    var normalY;
	    var normalZ;

	    var iInc = (containsZ) ? 3 : 2;

	    var isColorArray = Array.isArray(colors);
	    var isAlphaArray = Array.isArray(alphas);

	    if (Array.isArray(indicies) && indicies.length > 0)
	    {
	        for (i = 0; i < indicies.length; i++)
	        {
	            var index1 = indicies[i];
	            var index2 = indicies[i] * 2;
	            var index3 = indicies[i] * iInc;

	            x = vertices[index3];
	            y = vertices[index3 + 1];
	            z = (containsZ) ? vertices[index3 + 2] : 0;

	            u = uvs[index2];
	            v = uvs[index2 + 1];

	            if (flipUV)
	            {
	                v = 1 - v;
	            }

	            color = (isColorArray) ? colors[index1] : colors;
	            alpha = (isAlphaArray) ? alphas[index1] : alphas;

	            normalX = 0;
	            normalY = 0;
	            normalZ = 0;

	            if (normals)
	            {
	                normalX = normals[index3];
	                normalY = normals[index3 + 1];
	                normalZ = (containsZ) ? normals[index3 + 2] : 0;
	            }

	            result.vertices.push(new Vertex(x, y, z, u, v, color, alpha, normalX, normalY, normalZ));
	        }
	    }
	    else
	    {
	        var uvIndex = 0;
	        var colorIndex = 0;

	        for (i = 0; i < vertices.length; i += iInc)
	        {
	            x = vertices[i];
	            y = vertices[i + 1];
	            z = (containsZ) ? vertices[i + 2] : 0;

	            u = uvs[uvIndex];
	            v = uvs[uvIndex + 1];

	            color = (isColorArray) ? colors[colorIndex] : colors;
	            alpha = (isAlphaArray) ? alphas[colorIndex] : alphas;

	            normalX = 0;
	            normalY = 0;
	            normalZ = 0;

	            if (normals)
	            {
	                normalX = normals[i];
	                normalY = normals[i + 1];
	                normalZ = (containsZ) ? normals[i + 2] : 0;
	            }

	            result.vertices.push(new Vertex(x, y, z, u, v, color, alpha, normalX, normalY, normalZ));

	            uvIndex += 2;
	            colorIndex++;
	        }
	    }

	    for (i = 0; i < result.vertices.length; i += 3)
	    {
	        var vert1 = result.vertices[i];
	        var vert2 = result.vertices[i + 1];
	        var vert3 = result.vertices[i + 2];

	        result.faces.push(new Face(vert1, vert2, vert3));
	    }

	    return result;
	};

	GenerateVerts_1 = GenerateVerts;
	return GenerateVerts_1;
}

var MeshWebGLRenderer_1;
var hasRequiredMeshWebGLRenderer;

function requireMeshWebGLRenderer () {
	if (hasRequiredMeshWebGLRenderer) return MeshWebGLRenderer_1;
	hasRequiredMeshWebGLRenderer = 1;
	var GetCalcMatrix = requireGetCalcMatrix();

	var MeshWebGLRenderer = function (renderer, src, camera, parentMatrix)
	{
	    var faces = src.faces;
	    var totalFaces = faces.length;

	    if (totalFaces === 0)
	    {
	        return;
	    }

	    camera.addToRenderList(src);

	    var pipeline = renderer.pipelines.set(src.pipeline, src);

	    var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;

	    renderer.pipelines.preBatch(src);

	    var textureUnit = pipeline.setGameObject(src);

	    var F32 = pipeline.vertexViewF32;
	    var U32 = pipeline.vertexViewU32;

	    var vertexOffset = (pipeline.vertexCount * pipeline.currentShader.vertexComponentCount) - 1;

	    var tintEffect = src.tintFill;

	    var debugFaces = [];
	    var debugCallback = src.debugCallback;

	    var a = calcMatrix.a;
	    var b = calcMatrix.b;
	    var c = calcMatrix.c;
	    var d = calcMatrix.d;
	    var e = calcMatrix.e;
	    var f = calcMatrix.f;

	    var z = src.viewPosition.z;

	    var hideCCW = src.hideCCW;
	    var roundPixels = camera.roundPixels;
	    var alpha = camera.alpha * src.alpha;

	    var totalFacesRendered = 0;

	    for (var i = 0; i < totalFaces; i++)
	    {
	        var face = faces[i];

	        if (!face.isInView(camera, hideCCW, z, alpha, a, b, c, d, e, f, roundPixels))
	        {
	            continue;
	        }

	        if (pipeline.shouldFlush(3))
	        {
	            pipeline.flush();

	            textureUnit = pipeline.setGameObject(src);

	            vertexOffset = (pipeline.vertexCount * pipeline.currentShader.vertexComponentCount) - 1;
	        }

	        vertexOffset = face.load(F32, U32, vertexOffset, textureUnit, tintEffect);

	        totalFacesRendered++;

	        pipeline.vertexCount += 3;

	        pipeline.currentBatch.count = (pipeline.vertexCount - pipeline.currentBatch.start);

	        if (debugCallback)
	        {
	            debugFaces.push(face);
	        }
	    }

	    src.totalFrame += totalFacesRendered;

	    if (debugCallback)
	    {
	        debugCallback.call(src, src, debugFaces);
	    }

	    renderer.pipelines.postBatch(src);
	};

	MeshWebGLRenderer_1 = MeshWebGLRenderer;
	return MeshWebGLRenderer_1;
}

var MeshCanvasRenderer_1;
var hasRequiredMeshCanvasRenderer;

function requireMeshCanvasRenderer () {
	if (hasRequiredMeshCanvasRenderer) return MeshCanvasRenderer_1;
	hasRequiredMeshCanvasRenderer = 1;
	var MeshCanvasRenderer = function ()
	{
	};

	MeshCanvasRenderer_1 = MeshCanvasRenderer;
	return MeshCanvasRenderer_1;
}

var MeshRender;
var hasRequiredMeshRender;

function requireMeshRender () {
	if (hasRequiredMeshRender) return MeshRender;
	hasRequiredMeshRender = 1;
	var NOOP = requireNOOP();
	var renderWebGL = NOOP;
	var renderCanvas = NOOP;

	if (typeof WEBGL_RENDERER)
	{
	    renderWebGL = requireMeshWebGLRenderer();
	}

	if (typeof CANVAS_RENDERER)
	{
	    renderCanvas = requireMeshCanvasRenderer();
	}

	MeshRender = {

	    renderWebGL: renderWebGL,
	    renderCanvas: renderCanvas

	};
	return MeshRender;
}

var Mesh_1;
var hasRequiredMesh$1;

function requireMesh$1 () {
	if (hasRequiredMesh$1) return Mesh_1;
	hasRequiredMesh$1 = 1;
	var Class = requireClass();
	var Components = requireComponents$2();
	var DegToRad = requireDegToRad();
	var Face = requireFace();
	var GameObject = requireGameObject();
	var GenerateObjVerts = requireGenerateObjVerts();
	var GenerateVerts = requireGenerateVerts();
	var GetCalcMatrix = requireGetCalcMatrix();
	var Matrix4 = requireMatrix4();
	var MeshRender = requireMeshRender();
	var RadToDeg = requireRadToDeg();
	var StableSort = requireStableSort();
	var Vector3 = requireVector3();
	var Vertex = requireVertex();

	var Mesh = new Class({

	    Extends: GameObject,

	    Mixins: [
	        Components.AlphaSingle,
	        Components.BlendMode,
	        Components.Depth,
	        Components.Mask,
	        Components.Pipeline,
	        Components.PostPipeline,
	        Components.ScrollFactor,
	        Components.Size,
	        Components.Texture,
	        Components.Transform,
	        Components.Visible,
	        MeshRender
	    ],

	    initialize:

	    function Mesh (scene, x, y, texture, frame, vertices, uvs, indicies, containsZ, normals, colors, alphas)
	    {
	        if (x === undefined) { x = 0; }
	        if (y === undefined) { y = 0; }
	        if (texture === undefined) { texture = '__WHITE'; }

	        GameObject.call(this, scene, 'Mesh');

	        this.faces = [];

	        this.vertices = [];

	        this.tintFill = false;

	        this.debugCallback = null;

	        this.debugGraphic = null;

	        this.hideCCW = true;

	        this.modelPosition = new Vector3();

	        this.modelScale = new Vector3(1, 1, 1);

	        this.modelRotation = new Vector3();

	        this.dirtyCache = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];

	        this.transformMatrix = new Matrix4();

	        this.viewPosition = new Vector3();

	        this.viewMatrix = new Matrix4();

	        this.projectionMatrix = new Matrix4();

	        this.totalRendered = 0;

	        this.totalFrame = 0;

	        this.ignoreDirtyCache = false;

	        this.fov;

	        this.displayOriginX = 0;
	        this.displayOriginY = 0;

	        var renderer = scene.sys.renderer;

	        this.setPosition(x, y);
	        this.setTexture(texture, frame);
	        this.setSize(renderer.width, renderer.height);
	        this.initPipeline();
	        this.initPostPipeline();

	        this.setPerspective(renderer.width, renderer.height);

	        if (vertices)
	        {
	            this.addVertices(vertices, uvs, indicies, containsZ, normals, colors, alphas);
	        }
	    },

	    addedToScene: function ()
	    {
	        this.scene.sys.updateList.add(this);
	    },

	    removedFromScene: function ()
	    {
	        this.scene.sys.updateList.remove(this);
	    },

	    panX: function (v)
	    {
	        this.viewPosition.addScale(Vector3.LEFT, v);

	        this.dirtyCache[10] = 1;

	        return this;
	    },

	    panY: function (v)
	    {
	        this.viewPosition.y += Vector3.DOWN.y * v;

	        this.dirtyCache[10] = 1;

	        return this;
	    },

	    panZ: function (amount)
	    {
	        this.viewPosition.z += amount;

	        this.dirtyCache[10] = 1;

	        return this;
	    },

	    setPerspective: function (width, height, fov, near, far)
	    {
	        if (fov === undefined) { fov = 45; }
	        if (near === undefined) { near = 0.01; }
	        if (far === undefined) { far = 1000; }

	        this.fov = fov;

	        this.projectionMatrix.perspective(DegToRad(fov), width / height, near, far);

	        this.dirtyCache[10] = 1;
	        this.dirtyCache[11] = 0;

	        return this;
	    },

	    setOrtho: function (scaleX, scaleY, near, far)
	    {
	        if (scaleX === undefined) { scaleX = this.scene.sys.renderer.getAspectRatio(); }
	        if (scaleY === undefined) { scaleY = 1; }
	        if (near === undefined) { near = -1000; }
	        if (far === undefined) { far = 1000; }

	        this.fov = 0;

	        this.projectionMatrix.ortho(-scaleX, scaleX, -scaleY, scaleY, near, far);

	        this.dirtyCache[10] = 1;
	        this.dirtyCache[11] = 1;

	        return this;
	    },

	    clear: function ()
	    {
	        this.faces.forEach(function (face)
	        {
	            face.destroy();
	        });

	        this.faces = [];
	        this.vertices = [];

	        return this;
	    },

	    addVerticesFromObj: function (key, scale, x, y, z, rotateX, rotateY, rotateZ, zIsUp)
	    {
	        var data = this.scene.sys.cache.obj.get(key);
	        var parsedData;

	        if (data)
	        {
	            parsedData = GenerateObjVerts(data, this, scale, x, y, z, rotateX, rotateY, rotateZ, zIsUp);
	        }

	        if (!parsedData || parsedData.verts.length === 0)
	        {
	            console.warn('Mesh.addVerticesFromObj data empty:', key);
	        }

	        return this;
	    },

	    sortByDepth: function (faceA, faceB)
	    {
	        return faceA.depth - faceB.depth;
	    },

	    depthSort: function ()
	    {
	        StableSort(this.faces, this.sortByDepth);

	        return this;
	    },

	    addVertex: function (x, y, z, u, v, color, alpha)
	    {
	        var vert = new Vertex(x, y, z, u, v, color, alpha);

	        this.vertices.push(vert);

	        return vert;
	    },

	    addFace: function (vertex1, vertex2, vertex3)
	    {
	        var face = new Face(vertex1, vertex2, vertex3);

	        this.faces.push(face);

	        this.dirtyCache[9] = -1;

	        return face;
	    },

	    addVertices: function (vertices, uvs, indicies, containsZ, normals, colors, alphas)
	    {
	        var result = GenerateVerts(vertices, uvs, indicies, containsZ, normals, colors, alphas);

	        if (result)
	        {
	            this.faces = this.faces.concat(result.faces);
	            this.vertices = this.vertices.concat(result.vertices);
	        }
	        else
	        {
	            console.warn('Mesh.addVertices data empty or invalid');
	        }

	        this.dirtyCache[9] = -1;

	        return this;
	    },

	    getFaceCount: function ()
	    {
	        return this.faces.length;
	    },

	    getVertexCount: function ()
	    {
	        return this.vertices.length;
	    },

	    getFace: function (index)
	    {
	        return this.faces[index];
	    },

	    hasFaceAt: function (x, y, camera)
	    {
	        if (camera === undefined) { camera = this.scene.sys.cameras.main; }

	        var calcMatrix = GetCalcMatrix(this, camera).calc;

	        var faces = this.faces;

	        for (var i = 0; i < faces.length; i++)
	        {
	            var face = faces[i];

	            if (face.contains(x, y, calcMatrix))
	            {
	                return true;
	            }
	        }

	        return false;
	    },

	    getFaceAt: function (x, y, camera)
	    {
	        if (camera === undefined) { camera = this.scene.sys.cameras.main; }

	        var calcMatrix = GetCalcMatrix(this, camera).calc;

	        var faces = this.faces;
	        var results = [];

	        for (var i = 0; i < faces.length; i++)
	        {
	            var face = faces[i];

	            if (face.contains(x, y, calcMatrix))
	            {
	                results.push(face);
	            }
	        }

	        return StableSort(results, this.sortByDepth);
	    },

	    setDebug: function (graphic, callback)
	    {
	        this.debugGraphic = graphic;

	        if (!graphic && !callback)
	        {
	            this.debugCallback = null;
	        }
	        else if (!callback)
	        {
	            this.debugCallback = this.renderDebug;
	        }
	        else
	        {
	            this.debugCallback = callback;
	        }

	        return this;
	    },

	    isDirty: function ()
	    {
	        var position = this.modelPosition;
	        var rotation = this.modelRotation;
	        var scale = this.modelScale;
	        var dirtyCache = this.dirtyCache;

	        var px = position.x;
	        var py = position.y;
	        var pz = position.z;

	        var rx = rotation.x;
	        var ry = rotation.y;
	        var rz = rotation.z;

	        var sx = scale.x;
	        var sy = scale.y;
	        var sz = scale.z;

	        var faces = this.getFaceCount();

	        var pxCached = dirtyCache[0];
	        var pyCached = dirtyCache[1];
	        var pzCached = dirtyCache[2];

	        var rxCached = dirtyCache[3];
	        var ryCached = dirtyCache[4];
	        var rzCached = dirtyCache[5];

	        var sxCached = dirtyCache[6];
	        var syCached = dirtyCache[7];
	        var szCached = dirtyCache[8];

	        var fCached = dirtyCache[9];

	        dirtyCache[0] = px;
	        dirtyCache[1] = py;
	        dirtyCache[2] = pz;

	        dirtyCache[3] = rx;
	        dirtyCache[4] = ry;
	        dirtyCache[5] = rz;

	        dirtyCache[6] = sx;
	        dirtyCache[7] = sy;
	        dirtyCache[8] = sz;

	        dirtyCache[9] = faces;

	        return (
	            pxCached !== px || pyCached !== py || pzCached !== pz ||
	            rxCached !== rx || ryCached !== ry || rzCached !== rz ||
	            sxCached !== sx || syCached !== sy || szCached !== sz ||
	            fCached !== faces
	        );
	    },

	    preUpdate: function ()
	    {
	        this.totalRendered = this.totalFrame;
	        this.totalFrame = 0;

	        var dirty = this.dirtyCache;

	        if (!this.ignoreDirtyCache && !dirty[10] && !this.isDirty())
	        {

	            return;
	        }

	        var width = this.width;
	        var height = this.height;

	        var viewMatrix = this.viewMatrix;
	        var viewPosition = this.viewPosition;

	        if (dirty[10])
	        {
	            viewMatrix.identity();
	            viewMatrix.translate(viewPosition);
	            viewMatrix.invert();

	            dirty[10] = 0;
	        }

	        var transformMatrix = this.transformMatrix;

	        transformMatrix.setWorldMatrix(
	            this.modelRotation,
	            this.modelPosition,
	            this.modelScale,
	            this.viewMatrix,
	            this.projectionMatrix
	        );

	        var z = viewPosition.z;

	        var faces = this.faces;

	        for (var i = 0; i < faces.length; i++)
	        {
	            faces[i].transformCoordinatesLocal(transformMatrix, width, height, z);
	        }

	        this.depthSort();
	    },

	    renderDebug: function (src, faces)
	    {
	        var graphic = src.debugGraphic;

	        for (var i = 0; i < faces.length; i++)
	        {
	            var face = faces[i];

	            var x0 = face.vertex1.tx;
	            var y0 = face.vertex1.ty;
	            var x1 = face.vertex2.tx;
	            var y1 = face.vertex2.ty;
	            var x2 = face.vertex3.tx;
	            var y2 = face.vertex3.ty;

	            graphic.strokeTriangle(x0, y0, x1, y1, x2, y2);
	        }
	    },

	    preDestroy: function ()
	    {
	        this.clear();

	        this.debugCallback = null;
	        this.debugGraphic = null;
	    },

	    clearTint: function ()
	    {
	        return this.setTint();
	    },

	    setInteractive: function (config)
	    {
	        if (config === undefined) { config = {}; }

	        var hitAreaCallback = function (area, x, y)
	        {
	            var faces = this.faces;

	            for (var i = 0; i < faces.length; i++)
	            {
	                var face = faces[i];

	                if (face.contains(x, y))
	                {
	                    return true;
	                }
	            }

	            return false;
	        }.bind(this);

	        this.scene.sys.input.enable(this, config, hitAreaCallback);

	        return this;
	    },

	    setTint: function (tint)
	    {
	        if (tint === undefined) { tint = 0xffffff; }

	        var vertices = this.vertices;

	        for (var i = 0; i < vertices.length; i++)
	        {
	            vertices[i].color = tint;
	        }

	        return this;
	    },

	    uvScroll: function (x, y)
	    {
	        var faces = this.faces;

	        for (var i = 0; i < faces.length; i++)
	        {
	            faces[i].scrollUV(x, y);
	        }

	        return this;
	    },

	    uvScale: function (x, y)
	    {
	        var faces = this.faces;

	        for (var i = 0; i < faces.length; i++)
	        {
	            faces[i].scaleUV(x, y);
	        }

	        return this;
	    },

	    tint: {

	        set: function (value)
	        {
	            this.setTint(value);
	        }
	    },

	    rotateX: {

	        get: function ()
	        {
	            return RadToDeg(this.modelRotation.x);
	        },

	        set: function (value)
	        {
	            this.modelRotation.x = DegToRad(value);
	        }

	    },

	    rotateY: {

	        get: function ()
	        {
	            return RadToDeg(this.modelRotation.y);
	        },

	        set: function (value)
	        {
	            this.modelRotation.y = DegToRad(value);
	        }

	    },

	    rotateZ: {

	        get: function ()
	        {
	            return RadToDeg(this.modelRotation.z);
	        },

	        set: function (value)
	        {
	            this.modelRotation.z = DegToRad(value);
	        }

	    }

	});

	Mesh_1 = Mesh;
	return Mesh_1;
}

var NineSliceWebGLRenderer_1;
var hasRequiredNineSliceWebGLRenderer;

function requireNineSliceWebGLRenderer () {
	if (hasRequiredNineSliceWebGLRenderer) return NineSliceWebGLRenderer_1;
	hasRequiredNineSliceWebGLRenderer = 1;
	var GetCalcMatrix = requireGetCalcMatrix();
	var Utils = requireUtils$1();

	var NineSliceWebGLRenderer = function (renderer, src, camera, parentMatrix)
	{
	    var verts = src.vertices;
	    var totalVerts = verts.length;

	    if (totalVerts === 0)
	    {
	        return;
	    }

	    camera.addToRenderList(src);

	    var pipeline = renderer.pipelines.set(src.pipeline, src);

	    var calcMatrix = GetCalcMatrix(src, camera, parentMatrix, false).calc;

	    renderer.pipelines.preBatch(src);

	    var textureUnit = pipeline.setGameObject(src);

	    var F32 = pipeline.vertexViewF32;
	    var U32 = pipeline.vertexViewU32;

	    var vertexOffset = (pipeline.vertexCount * pipeline.currentShader.vertexComponentCount) - 1;

	    var roundPixels = camera.roundPixels;

	    var tintEffect = src.tintFill;
	    var alpha = camera.alpha * src.alpha;
	    var color = Utils.getTintAppendFloatAlpha(src.tint, alpha);

	    var available = pipeline.vertexAvailable();
	    var flushCount = -1;

	    if (available < totalVerts)
	    {
	        flushCount = available;
	    }

	    for (var i = 0; i < totalVerts; i++)
	    {
	        var vert = verts[i];

	        if (i === flushCount)
	        {
	            pipeline.flush();

	            textureUnit = pipeline.setGameObject(src);

	            vertexOffset = 0;
	        }

	        F32[++vertexOffset] = calcMatrix.getXRound(vert.vx, vert.vy, roundPixels);
	        F32[++vertexOffset] = calcMatrix.getYRound(vert.vx, vert.vy, roundPixels);
	        F32[++vertexOffset] = vert.u;
	        F32[++vertexOffset] = vert.v;
	        F32[++vertexOffset] = textureUnit;
	        F32[++vertexOffset] = tintEffect;
	        U32[++vertexOffset] = color;

	        pipeline.vertexCount++;

	        pipeline.currentBatch.count = (pipeline.vertexCount - pipeline.currentBatch.start);
	    }

	    renderer.pipelines.postBatch(src);
	};

	NineSliceWebGLRenderer_1 = NineSliceWebGLRenderer;
	return NineSliceWebGLRenderer_1;
}

var NineSliceRender;
var hasRequiredNineSliceRender;

function requireNineSliceRender () {
	if (hasRequiredNineSliceRender) return NineSliceRender;
	hasRequiredNineSliceRender = 1;
	var NOOP = requireNOOP();
	var renderWebGL = NOOP;
	var renderCanvas = NOOP;

	if (typeof WEBGL_RENDERER)
	{
	    renderWebGL = requireNineSliceWebGLRenderer();
	}

	NineSliceRender = {

	    renderWebGL: renderWebGL,
	    renderCanvas: renderCanvas

	};
	return NineSliceRender;
}

var NineSlice_1;
var hasRequiredNineSlice;

function requireNineSlice () {
	if (hasRequiredNineSlice) return NineSlice_1;
	hasRequiredNineSlice = 1;
	var Class = requireClass();
	var Components = requireComponents$2();
	var GameObject = requireGameObject();
	var NineSliceRender = requireNineSliceRender();
	var Vertex = requireVertex();

	var NineSlice = new Class({

	    Extends: GameObject,

	    Mixins: [
	        Components.AlphaSingle,
	        Components.BlendMode,
	        Components.Depth,
	        Components.GetBounds,
	        Components.Mask,
	        Components.Origin,
	        Components.Pipeline,
	        Components.PostPipeline,
	        Components.ScrollFactor,
	        Components.Texture,
	        Components.Transform,
	        Components.Visible,
	        NineSliceRender
	    ],

	    initialize:

	    function NineSlice (scene, x, y, texture, frame, width, height, leftWidth, rightWidth, topHeight, bottomHeight)
	    {

	        GameObject.call(this, scene, 'NineSlice');

	        this._width;

	        this._height;

	        this._originX = 0.5;

	        this._originY = 0.5;

	        this._sizeComponent = true;

	        this.vertices = [];

	        this.leftWidth;

	        this.rightWidth;

	        this.topHeight;

	        this.bottomHeight;

	        this.tint = 0xffffff;

	        this.tintFill = false;

	        var textureFrame = scene.textures.getFrame(texture, frame);

	        this.is3Slice = (!topHeight && !bottomHeight);

	        if (textureFrame && textureFrame.scale9)
	        {

	            this.is3Slice = textureFrame.is3Slice;
	        }

	        var size = this.is3Slice ? 18 : 54;

	        for (var i = 0; i < size; i++)
	        {
	            this.vertices.push(new Vertex());
	        }

	        this.setPosition(x, y);

	        this.setTexture(texture, frame);

	        this.setSlices(width, height, leftWidth, rightWidth, topHeight, bottomHeight, false);

	        this.updateDisplayOrigin();

	        this.initPipeline();
	        this.initPostPipeline();
	    },

	    setSlices: function (width, height, leftWidth, rightWidth, topHeight, bottomHeight, skipScale9)
	    {
	        if (leftWidth === undefined) { leftWidth = 10; }
	        if (rightWidth === undefined) { rightWidth = 10; }
	        if (topHeight === undefined) { topHeight = 0; }
	        if (bottomHeight === undefined) { bottomHeight = 0; }

	        if (skipScale9 === undefined) { skipScale9 = false; }

	        var frame = this.frame;

	        var sliceChange = false;

	        if (this.is3Slice && skipScale9 && topHeight !== 0 && bottomHeight !== 0)
	        {
	            sliceChange = true;
	        }

	        if (sliceChange)
	        {
	            console.warn('Cannot change 9 slice to 3 slice');
	        }
	        else
	        {
	            if (frame && frame.scale9 && !skipScale9)
	            {
	                var data = frame.data.scale9Borders;

	                var x = data.x;
	                var y = data.y;

	                leftWidth = x;
	                rightWidth = frame.width - data.w - x;
	                topHeight = y;
	                bottomHeight = frame.height - data.h - y;

	                if (width === undefined)
	                {
	                    width = frame.width;
	                }

	                if (height === undefined)
	                {
	                    height = frame.height;
	                }
	            }
	            else
	            {
	                if (width === undefined) { width = 256; }
	                if (height === undefined) { height = 256; }
	            }

	            this._width = width;
	            this._height = height;

	            this.leftWidth = leftWidth;
	            this.rightWidth = rightWidth;
	            this.topHeight = topHeight;
	            this.bottomHeight = bottomHeight;

	            if (this.is3Slice)
	            {
	                height = frame.height;

	                this._height = height;
	                this.topHeight = height;
	                this.bottomHeight = 0;
	            }

	            this.updateVertices();
	            this.updateUVs();
	        }

	        return this;
	    },

	    updateUVs: function ()
	    {
	        var left = this.leftWidth;
	        var right = this.rightWidth;
	        var top = this.topHeight;
	        var bot = this.bottomHeight;

	        var width = this.frame.width;
	        var height = this.frame.height;

	        this.updateQuadUVs(0, 0, 0, left / width, top / height);
	        this.updateQuadUVs(6, left / width, 0, 1 - (right / width), top / height);
	        this.updateQuadUVs(12, 1 - (right / width), 0, 1, top / height);

	        if (!this.is3Slice)
	        {
	            this.updateQuadUVs(18, 0, top / height, left / width, 1 - (bot / height));
	            this.updateQuadUVs(24, left / width, top / height, 1 - right / width, 1 - (bot / height));
	            this.updateQuadUVs(30, 1 - right / width, top / height, 1, 1 - (bot / height));
	            this.updateQuadUVs(36, 0, 1 - bot / height, left / width, 1);
	            this.updateQuadUVs(42, left / width, 1 - bot / height, 1 - right / width, 1);
	            this.updateQuadUVs(48, 1 - right / width, 1 - bot / height, 1, 1);
	        }
	    },

	    updateVertices: function ()
	    {
	        var left = this.leftWidth;
	        var right = this.rightWidth;
	        var top = this.topHeight;
	        var bot = this.bottomHeight;

	        var width = this.width;
	        var height = this.height;

	        this.updateQuad(0, -0.5, 0.5, -0.5 + (left / width), 0.5 - (top / height));
	        this.updateQuad(6, -0.5 + (left / width), 0.5, 0.5 - (right / width), 0.5 - (top / height));
	        this.updateQuad(12, 0.5 - (right / width), 0.5, 0.5, 0.5 - (top / height));

	        if (!this.is3Slice)
	        {
	            this.updateQuad(18, -0.5, 0.5 - (top / height), -0.5 + (left / width), -0.5 + (bot / height));
	            this.updateQuad(24, -0.5 + (left / width), 0.5 - (top / height), 0.5 - (right / width), -0.5 + (bot / height));
	            this.updateQuad(30, 0.5 - (right / width), 0.5 - (top / height), 0.5, -0.5 + (bot / height));
	            this.updateQuad(36, -0.5, -0.5 + (bot / height), -0.5 + (left / width), -0.5);
	            this.updateQuad(42, -0.5 + (left / width), -0.5 + (bot / height), 0.5 - (right / width), -0.5);
	            this.updateQuad(48, 0.5 - (right / width), -0.5 + (bot / height), 0.5, -0.5);
	        }
	    },

	    updateQuad: function (offset, x1, y1, x2, y2)
	    {
	        var width = this.width;
	        var height = this.height;
	        var originX = this.originX;
	        var originY = this.originY;

	        var verts = this.vertices;

	        verts[offset + 0].resize(x1, y1, width, height, originX, originY);
	        verts[offset + 1].resize(x1, y2, width, height, originX, originY);
	        verts[offset + 2].resize(x2, y1, width, height, originX, originY);
	        verts[offset + 3].resize(x1, y2, width, height, originX, originY);
	        verts[offset + 4].resize(x2, y2, width, height, originX, originY);
	        verts[offset + 5].resize(x2, y1, width, height, originX, originY);
	    },

	    updateQuadUVs: function (offset, u1, v1, u2, v2)
	    {
	        var verts = this.vertices;

	        var frame = this.frame;

	        var fu1 = frame.u0;
	        var fv1 = frame.v0;
	        var fu2 = frame.u1;
	        var fv2 = frame.v1;

	        if (fu1 !== 0 || fu2 !== 1)
	        {

	            var udiff = fu2 - fu1;
	            u1 = fu1 + u1 * udiff;
	            u2 = fu1 + u2 * udiff;
	        }

	        if (fv1 !== 0 || fv2 !== 1)
	        {

	            var vdiff = fv2 - fv1;
	            v1 = fv1 + v1 * vdiff;
	            v2 = fv1 + v2 * vdiff;
	        }

	        verts[offset + 0].setUVs(u1, v1);
	        verts[offset + 1].setUVs(u1, v2);
	        verts[offset + 2].setUVs(u2, v1);
	        verts[offset + 3].setUVs(u1, v2);
	        verts[offset + 4].setUVs(u2, v2);
	        verts[offset + 5].setUVs(u2, v1);
	    },

	    clearTint: function ()
	    {
	        this.setTint(0xffffff);

	        return this;
	    },

	    setTint: function (color)
	    {
	        if (color === undefined) { color = 0xffffff; }

	        this.tint = color;

	        this.tintFill = false;

	        return this;
	    },

	    setTintFill: function (color)
	    {
	        this.setTint(color);

	        this.tintFill = true;

	        return this;
	    },

	    isTinted: {

	        get: function ()
	        {
	            return (this.tint !== 0xffffff);
	        }

	    },

	    width: {

	        get: function ()
	        {
	            return this._width;
	        },

	        set: function (value)
	        {
	            this._width = Math.max(value, this.leftWidth + this.rightWidth);

	            this.updateVertices();
	        }

	    },

	    height: {

	        get: function ()
	        {
	            return this._height;
	        },

	        set: function (value)
	        {
	            if (!this.is3Slice)
	            {
	                this._height = Math.max(value, this.topHeight + this.bottomHeight);

	                this.updateVertices();
	            }
	        }

	    },

	    displayWidth: {

	        get: function ()
	        {
	            return this.scaleX * this.width;
	        },

	        set: function (value)
	        {
	            this.scaleX = value / this.width;
	        }

	    },

	    displayHeight: {

	        get: function ()
	        {
	            return this.scaleY * this.height;
	        },

	        set: function (value)
	        {
	            this.scaleY = value / this.height;
	        }

	    },

	    setSize: function (width, height)
	    {
	        this.width = width;
	        this.height = height;

	        this.updateDisplayOrigin();

	        var input = this.input;

	        if (input && !input.customHitArea)
	        {
	            input.hitArea.width = this.width;
	            input.hitArea.height = this.height;
	        }

	        return this;
	    },

	    setDisplaySize: function (width, height)
	    {
	        this.displayWidth = width;
	        this.displayHeight = height;

	        return this;
	    },

	    originX: {

	        get: function ()
	        {
	            return this._originX;
	        },

	        set: function (value)
	        {
	            this._originX = value;
	            this.updateVertices();
	        }

	    },

	    originY: {

	        get: function ()
	        {
	            return this._originY;
	        },

	        set: function (value)
	        {
	            this._originY = value;
	            this.updateVertices();
	        }

	    },

	    setOrigin: function (x, y)
	    {
	        if (x === undefined) { x = 0.5; }
	        if (y === undefined) { y = x; }

	        this._originX = x;
	        this._originY = y;

	        this.updateVertices();

	        return this.updateDisplayOrigin();
	    },

	    setSizeToFrame: function ()
	    {
	        if (this.is3Slice)
	        {
	            var height = this.frame.height;

	            this._height = height;
	            this.topHeight = height;
	            this.bottomHeight = 0;
	        }

	        this.updateUVs();

	        return this;
	    },

	    preDestroy: function ()
	    {
	        this.vertices = [];
	    }

	});

	NineSlice_1 = NineSlice;
	return NineSlice_1;
}

var PointLightWebGLRenderer_1;
var hasRequiredPointLightWebGLRenderer;

function requirePointLightWebGLRenderer () {
	if (hasRequiredPointLightWebGLRenderer) return PointLightWebGLRenderer_1;
	hasRequiredPointLightWebGLRenderer = 1;
	var GetCalcMatrix = requireGetCalcMatrix();

	var PointLightWebGLRenderer = function (renderer, src, camera, parentMatrix)
	{
	    camera.addToRenderList(src);

	    var pipeline = renderer.pipelines.set(src.pipeline);

	    var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;

	    var width = src.width;
	    var height = src.height;

	    var x = -src._radius;
	    var y = -src._radius;

	    var xw = x + width;
	    var yh = y + height;

	    var lightX = calcMatrix.getX(0, 0);
	    var lightY = calcMatrix.getY(0, 0);

	    var tx0 = calcMatrix.getX(x, y);
	    var ty0 = calcMatrix.getY(x, y);

	    var tx1 = calcMatrix.getX(x, yh);
	    var ty1 = calcMatrix.getY(x, yh);

	    var tx2 = calcMatrix.getX(xw, yh);
	    var ty2 = calcMatrix.getY(xw, yh);

	    var tx3 = calcMatrix.getX(xw, y);
	    var ty3 = calcMatrix.getY(xw, y);

	    renderer.pipelines.preBatch(src);

	    pipeline.batchPointLight(src, camera, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, lightX, lightY);

	    renderer.pipelines.postBatch(src);
	};

	PointLightWebGLRenderer_1 = PointLightWebGLRenderer;
	return PointLightWebGLRenderer_1;
}

var PointLightRender;
var hasRequiredPointLightRender;

function requirePointLightRender () {
	if (hasRequiredPointLightRender) return PointLightRender;
	hasRequiredPointLightRender = 1;
	var NOOP = requireNOOP();
	var renderWebGL = NOOP;
	var renderCanvas = NOOP;

	if (typeof WEBGL_RENDERER)
	{
	    renderWebGL = requirePointLightWebGLRenderer();
	}

	PointLightRender = {

	    renderWebGL: renderWebGL,
	    renderCanvas: renderCanvas

	};
	return PointLightRender;
}

var PointLight_1;
var hasRequiredPointLight;

function requirePointLight () {
	if (hasRequiredPointLight) return PointLight_1;
	hasRequiredPointLight = 1;
	var Class = requireClass();
	var Components = requireComponents$2();
	var GameObject = requireGameObject();
	var IntegerToColor = requireIntegerToColor();
	var PIPELINES_CONST = require_const$9();
	var Render = requirePointLightRender();

	var PointLight = new Class({

	    Extends: GameObject,

	    Mixins: [
	        Components.AlphaSingle,
	        Components.BlendMode,
	        Components.Depth,
	        Components.Mask,
	        Components.Pipeline,
	        Components.PostPipeline,
	        Components.ScrollFactor,
	        Components.Transform,
	        Components.Visible,
	        Render
	    ],

	    initialize:

	    function PointLight (scene, x, y, color, radius, intensity, attenuation)
	    {
	        if (color === undefined) { color = 0xffffff; }
	        if (radius === undefined) { radius = 128; }
	        if (intensity === undefined) { intensity = 1; }
	        if (attenuation === undefined) { attenuation = 0.1; }

	        GameObject.call(this, scene, 'PointLight');

	        this.initPipeline(PIPELINES_CONST.POINTLIGHT_PIPELINE);
	        this.initPostPipeline();

	        this.setPosition(x, y);

	        this.color = IntegerToColor(color);

	        this.intensity = intensity;

	        this.attenuation = attenuation;

	        this.width = radius * 2;
	        this.height = radius * 2;

	        this._radius = radius;
	    },

	    radius: {

	        get: function ()
	        {
	            return this._radius;
	        },

	        set: function (value)
	        {
	            this._radius = value;
	            this.width = value * 2;
	            this.height = value * 2;
	        }

	    },

	    originX: {

	        get: function ()
	        {
	            return 0.5;
	        }

	    },

	    originY: {

	        get: function ()
	        {
	            return 0.5;
	        }

	    },

	    displayOriginX: {

	        get: function ()
	        {
	            return this._radius;
	        }

	    },

	    displayOriginY: {

	        get: function ()
	        {
	            return this._radius;
	        }

	    }

	});

	PointLight_1 = PointLight;
	return PointLight_1;
}

var GenerateGridVerts_1;
var hasRequiredGenerateGridVerts;

function requireGenerateGridVerts () {
	if (hasRequiredGenerateGridVerts) return GenerateGridVerts_1;
	hasRequiredGenerateGridVerts = 1;
	var Face = requireFace();
	var GetFastValue = requireGetFastValue();
	var Matrix4 = requireMatrix4();
	var Vector3 = requireVector3();
	var Vertex = requireVertex();

	var tempPosition = new Vector3();
	var tempRotation = new Vector3();
	var tempMatrix = new Matrix4();

	var GenerateGridVerts = function (config)
	{
	    var mesh = GetFastValue(config, 'mesh');
	    var texture = GetFastValue(config, 'texture', null);
	    var frame = GetFastValue(config, 'frame');
	    var width = GetFastValue(config, 'width', 1);
	    var height = GetFastValue(config, 'height', width);
	    var widthSegments = GetFastValue(config, 'widthSegments', 1);
	    var heightSegments = GetFastValue(config, 'heightSegments', widthSegments);
	    var posX = GetFastValue(config, 'x', 0);
	    var posY = GetFastValue(config, 'y', 0);
	    var posZ = GetFastValue(config, 'z', 0);
	    var rotateX = GetFastValue(config, 'rotateX', 0);
	    var rotateY = GetFastValue(config, 'rotateY', 0);
	    var rotateZ = GetFastValue(config, 'rotateZ', 0);
	    var zIsUp = GetFastValue(config, 'zIsUp', true);
	    var isOrtho = GetFastValue(config, 'isOrtho', (mesh) ? mesh.dirtyCache[11] : false);
	    var colors = GetFastValue(config, 'colors', [ 0xffffff ]);
	    var alphas = GetFastValue(config, 'alphas', [ 1 ]);
	    var tile = GetFastValue(config, 'tile', false);
	    var flipY = GetFastValue(config, 'flipY', false);

	    var widthSet = GetFastValue(config, 'width', null);

	    var result = {
	        faces: [],
	        verts: []
	    };

	    tempPosition.set(posX, posY, posZ);
	    tempRotation.set(rotateX, rotateY, rotateZ);
	    tempMatrix.fromRotationXYTranslation(tempRotation, tempPosition, zIsUp);

	    var textureFrame;

	    if (!texture && mesh)
	    {
	        texture = mesh.texture;

	        if (!frame)
	        {
	            textureFrame = mesh.frame;
	        }
	    }
	    else if (mesh && typeof(texture) === 'string')
	    {
	        texture = mesh.scene.sys.textures.get(texture);
	    }
	    else if (!texture)
	    {

	        return result;
	    }

	    if (!textureFrame)
	    {
	        textureFrame = texture.get(frame);
	    }

	    if (!widthSet && isOrtho && texture && mesh)
	    {
	        width = textureFrame.width / mesh.height;
	        height = textureFrame.height / mesh.height;
	    }

	    var halfWidth = width / 2;
	    var halfHeight = height / 2;

	    var gridX = Math.floor(widthSegments);
	    var gridY = Math.floor(heightSegments);

	    var gridX1 = gridX + 1;
	    var gridY1 = gridY + 1;

	    var segmentWidth = width / gridX;
	    var segmentHeight = height / gridY;

	    var uvs = [];
	    var vertices = [];

	    var ix;
	    var iy;

	    var frameU0 = 0;
	    var frameU1 = 1;
	    var frameV0 = 0;
	    var frameV1 = 1;

	    if (textureFrame)
	    {
	        frameU0 = textureFrame.u0;
	        frameU1 = textureFrame.u1;

	        if (!flipY)
	        {
	            frameV0 = textureFrame.v0;
	            frameV1 = textureFrame.v1;
	        }
	        else
	        {
	            frameV0 = textureFrame.v1;
	            frameV1 = textureFrame.v0;
	        }
	    }

	    var frameU = frameU1 - frameU0;
	    var frameV = frameV1 - frameV0;

	    for (iy = 0; iy < gridY1; iy++)
	    {
	        var y = iy * segmentHeight - halfHeight;

	        for (ix = 0; ix < gridX1; ix++)
	        {
	            var x = ix * segmentWidth - halfWidth;

	            vertices.push(x, -y);

	            var tu = frameU0 + frameU * (ix / gridX);
	            var tv = frameV0 + frameV * (iy / gridY);

	            uvs.push(tu, tv);
	        }
	    }

	    if (!Array.isArray(colors))
	    {
	        colors = [ colors ];
	    }

	    if (!Array.isArray(alphas))
	    {
	        alphas = [ alphas ];
	    }

	    var alphaIndex = 0;
	    var colorIndex = 0;

	    for (iy = 0; iy < gridY; iy++)
	    {
	        for (ix = 0; ix < gridX; ix++)
	        {
	            var a = (ix + gridX1 * iy) * 2;
	            var b = (ix + gridX1 * (iy + 1)) * 2;
	            var c = ((ix + 1) + gridX1 * (iy + 1)) * 2;
	            var d = ((ix + 1) + gridX1 * iy) * 2;

	            var color = colors[colorIndex];
	            var alpha = alphas[alphaIndex];

	            var vert1 = new Vertex(vertices[a], vertices[a + 1], 0, uvs[a], uvs[a + 1], color, alpha).transformMat4(tempMatrix);
	            var vert2 = new Vertex(vertices[b], vertices[b + 1], 0, uvs[b], uvs[b + 1], color, alpha).transformMat4(tempMatrix);
	            var vert3 = new Vertex(vertices[d], vertices[d + 1], 0, uvs[d], uvs[d + 1], color, alpha).transformMat4(tempMatrix);
	            var vert4 = new Vertex(vertices[b], vertices[b + 1], 0, uvs[b], uvs[b + 1], color, alpha).transformMat4(tempMatrix);
	            var vert5 = new Vertex(vertices[c], vertices[c + 1], 0, uvs[c], uvs[c + 1], color, alpha).transformMat4(tempMatrix);
	            var vert6 = new Vertex(vertices[d], vertices[d + 1], 0, uvs[d], uvs[d + 1], color, alpha).transformMat4(tempMatrix);

	            if (tile)
	            {
	                vert1.setUVs(frameU0, frameV1);
	                vert2.setUVs(frameU0, frameV0);
	                vert3.setUVs(frameU1, frameV1);
	                vert4.setUVs(frameU0, frameV0);
	                vert5.setUVs(frameU1, frameV0);
	                vert6.setUVs(frameU1, frameV1);
	            }

	            colorIndex++;

	            if (colorIndex === colors.length)
	            {
	                colorIndex = 0;
	            }

	            alphaIndex++;

	            if (alphaIndex === alphas.length)
	            {
	                alphaIndex = 0;
	            }

	            result.verts.push(vert1, vert2, vert3, vert4, vert5, vert6);

	            result.faces.push(
	                new Face(vert1, vert2, vert3),
	                new Face(vert4, vert5, vert6)
	            );
	        }
	    }

	    if (mesh)
	    {
	        mesh.faces = mesh.faces.concat(result.faces);
	        mesh.vertices = mesh.vertices.concat(result.verts);
	    }

	    return result;
	};

	GenerateGridVerts_1 = GenerateGridVerts;
	return GenerateGridVerts_1;
}

var Plane_1;
var hasRequiredPlane;

function requirePlane () {
	if (hasRequiredPlane) return Plane_1;
	hasRequiredPlane = 1;
	var AnimationState = requireAnimationState();
	var Class = requireClass();
	var GenerateGridVerts = requireGenerateGridVerts();
	var IntegerToRGB = requireIntegerToRGB();
	var Mesh = requireMesh$1();
	var UUID = requireUUID();

	var Plane = new Class({

	    Extends: Mesh,

	    initialize:

	    function Plane (scene, x, y, texture, frame, width, height, tile)
	    {
	        if (!texture) { texture = '__DEFAULT'; }

	        Mesh.call(this, scene, x, y, texture, frame);

	        this.type = 'Plane';

	        this.anims = new AnimationState(this);

	        this.gridWidth;

	        this.gridHeight;

	        this.isTiled;

	        this._checkerboard = null;

	        this.hideCCW = false;

	        this.setGridSize(width, height, tile);
	        this.setSizeToFrame(false);
	        this.setViewHeight();
	    },

	    originX: {

	        get: function ()
	        {
	            return 0.5;
	        }

	    },

	    originY: {

	        get: function ()
	        {
	            return 0.5;
	        }

	    },

	    setGridSize: function (width, height, tile)
	    {
	        if (width === undefined) { width = 8; }
	        if (height === undefined) { height = 8; }
	        if (tile === undefined) { tile = false; }

	        var flipY = false;

	        if (tile)
	        {
	            flipY = true;
	        }

	        this.gridWidth = width;
	        this.gridHeight = height;
	        this.isTiled = tile;

	        this.clear();

	        GenerateGridVerts({
	            mesh: this,
	            widthSegments: width,
	            heightSegments: height,
	            isOrtho: false,
	            tile: tile,
	            flipY: flipY
	        });

	        return this;
	    },

	    setSizeToFrame: function (resetUV)
	    {
	        if (resetUV === undefined) { resetUV = true; }

	        var frame = this.frame;

	        this.setPerspective(this.width / frame.width, this.height / frame.height);

	        if (this._checkerboard && this._checkerboard !== this.texture)
	        {
	            this.removeCheckerboard();
	        }

	        if (!resetUV)
	        {
	            return this;
	        }

	        var gridX = this.gridWidth;
	        var gridY = this.gridHeight;

	        var verts = this.vertices;

	        var frameU0 = frame.u0;
	        var frameU1 = frame.u1;
	        var frameV0 = frame.v0;
	        var frameV1 = frame.v1;

	        var x;
	        var y;
	        var i = 0;

	        if (this.isTiled)
	        {

	            frameV0 = frame.v1;
	            frameV1 = frame.v0;

	            for (y = 0; y < gridY; y++)
	            {
	                for (x = 0; x < gridX; x++)
	                {
	                    verts[i++].setUVs(frameU0, frameV1);
	                    verts[i++].setUVs(frameU0, frameV0);
	                    verts[i++].setUVs(frameU1, frameV1);
	                    verts[i++].setUVs(frameU0, frameV0);
	                    verts[i++].setUVs(frameU1, frameV0);
	                    verts[i++].setUVs(frameU1, frameV1);
	                }
	            }
	        }
	        else
	        {
	            var gridX1 = gridX + 1;
	            var gridY1 = gridY + 1;

	            var frameU = frameU1 - frameU0;
	            var frameV = frameV1 - frameV0;

	            var uvs = [];

	            for (y = 0; y < gridY1; y++)
	            {
	                for (x = 0; x < gridX1; x++)
	                {
	                    var tu = frameU0 + frameU * (x / gridX);
	                    var tv = frameV0 + frameV * (y / gridY);

	                    uvs.push(tu, tv);
	                }
	            }

	            for (y = 0; y < gridY; y++)
	            {
	                for (x = 0; x < gridX; x++)
	                {
	                    var a = (x + gridX1 * y) * 2;
	                    var b = (x + gridX1 * (y + 1)) * 2;
	                    var c = ((x + 1) + gridX1 * (y + 1)) * 2;
	                    var d = ((x + 1) + gridX1 * y) * 2;

	                    verts[i++].setUVs(uvs[a], uvs[a + 1]);
	                    verts[i++].setUVs(uvs[b], uvs[b + 1]);
	                    verts[i++].setUVs(uvs[d], uvs[d + 1]);
	                    verts[i++].setUVs(uvs[b], uvs[b + 1]);
	                    verts[i++].setUVs(uvs[c], uvs[c + 1]);
	                    verts[i++].setUVs(uvs[d], uvs[d + 1]);
	                }
	            }
	        }

	        return this;
	    },

	    setViewHeight: function (value)
	    {
	        if (value === undefined) { value = this.frame.height; }

	        var vFOV = this.fov * (Math.PI / 180);

	        this.viewPosition.z = (this.height / value) / (Math.tan(vFOV / 2));

	        this.dirtyCache[10] = 1;
	    },

	    createCheckerboard: function (color1, color2, alpha1, alpha2, height)
	    {
	        if (color1 === undefined) { color1 = 0xffffff; }
	        if (color2 === undefined) { color2 = 0x0000ff; }
	        if (alpha1 === undefined) { alpha1 = 255; }
	        if (alpha2 === undefined) { alpha2 = 255; }
	        if (height === undefined) { height = 128; }

	        var c1 = IntegerToRGB(color1);
	        var c2 = IntegerToRGB(color2);

	        var colors = [];

	        for (var h = 0; h < 16; h++)
	        {
	            for (var w = 0; w < 16; w++)
	            {
	                if ((h < 8 && w < 8) || (h > 7 && w > 7))
	                {
	                    colors.push(c1.r, c1.g, c1.b, alpha1);
	                }
	                else
	                {
	                    colors.push(c2.r, c2.g, c2.b, alpha2);
	                }
	            }
	        }

	        var texture = this.scene.sys.textures.addUint8Array(UUID(), new Uint8Array(colors), 16, 16);

	        this.removeCheckerboard();

	        this.setTexture(texture);

	        this.setSizeToFrame();

	        this.setViewHeight(height);

	        return this;
	    },

	    removeCheckerboard: function ()
	    {
	        if (this._checkerboard)
	        {
	            this._checkerboard.destroy();

	            this._checkerboard = null;
	        }
	    },

	    play: function (key, ignoreIfPlaying)
	    {
	        return this.anims.play(key, ignoreIfPlaying);
	    },

	    playReverse: function (key, ignoreIfPlaying)
	    {
	        return this.anims.playReverse(key, ignoreIfPlaying);
	    },

	    playAfterDelay: function (key, delay)
	    {
	        return this.anims.playAfterDelay(key, delay);
	    },

	    playAfterRepeat: function (key, repeatCount)
	    {
	        return this.anims.playAfterRepeat(key, repeatCount);
	    },

	    stop: function ()
	    {
	        return this.anims.stop();
	    },

	    stopAfterDelay: function (delay)
	    {
	        return this.anims.stopAfterDelay(delay);
	    },

	    stopAfterRepeat: function (repeatCount)
	    {
	        return this.anims.stopAfterRepeat(repeatCount);
	    },

	    stopOnFrame: function (frame)
	    {
	        return this.anims.stopOnFrame(frame);
	    },

	    preUpdate: function (time, delta)
	    {
	        Mesh.prototype.preUpdate.call(this, time, delta);

	        this.anims.update(time, delta);
	    },

	    preDestroy: function ()
	    {
	        this.clear();
	        this.removeCheckerboard();

	        this.anims.destroy();

	        this.anims = undefined;

	        this.debugCallback = null;
	        this.debugGraphic = null;
	    }

	});

	Plane_1 = Plane;
	return Plane_1;
}

var ShaderFactory = {};

var hasRequiredShaderFactory;

function requireShaderFactory () {
	if (hasRequiredShaderFactory) return ShaderFactory;
	hasRequiredShaderFactory = 1;
	var Shader = requireShader();
	var GameObjectFactory = requireGameObjectFactory();

	if (typeof WEBGL_RENDERER)
	{
	    GameObjectFactory.register('shader', function (key, x, y, width, height, textures, textureData)
	    {
	        return this.displayList.add(new Shader(this.scene, key, x, y, width, height, textures, textureData));
	    });
	}
	return ShaderFactory;
}

var MeshFactory = {};

var hasRequiredMeshFactory;

function requireMeshFactory () {
	if (hasRequiredMeshFactory) return MeshFactory;
	hasRequiredMeshFactory = 1;
	var Mesh = requireMesh$1();
	var GameObjectFactory = requireGameObjectFactory();

	if (typeof WEBGL_RENDERER)
	{
	    GameObjectFactory.register('mesh', function (x, y, texture, frame, vertices, uvs, indicies, containsZ, normals, colors, alphas)
	    {
	        return this.displayList.add(new Mesh(this.scene, x, y, texture, frame, vertices, uvs, indicies, containsZ, normals, colors, alphas));
	    });
	}
	return MeshFactory;
}

var NineSliceFactory = {};

var hasRequiredNineSliceFactory;

function requireNineSliceFactory () {
	if (hasRequiredNineSliceFactory) return NineSliceFactory;
	hasRequiredNineSliceFactory = 1;
	var NineSlice = requireNineSlice();
	var GameObjectFactory = requireGameObjectFactory();

	if (typeof WEBGL_RENDERER)
	{
	    GameObjectFactory.register('nineslice', function (x, y, texture, frame, width, height, leftWidth, rightWidth, topHeight, bottomHeight)
	    {
	        return this.displayList.add(new NineSlice(this.scene, x, y, texture, frame, width, height, leftWidth, rightWidth, topHeight, bottomHeight));
	    });
	}
	return NineSliceFactory;
}

var PointLightFactory = {};

var hasRequiredPointLightFactory;

function requirePointLightFactory () {
	if (hasRequiredPointLightFactory) return PointLightFactory;
	hasRequiredPointLightFactory = 1;
	var GameObjectFactory = requireGameObjectFactory();
	var PointLight = requirePointLight();

	GameObjectFactory.register('pointlight', function (x, y, color, radius, intensity, attenuation)
	{
	    return this.displayList.add(new PointLight(this.scene, x, y, color, radius, intensity, attenuation));
	});
	return PointLightFactory;
}

var PlaneFactory = {};

var hasRequiredPlaneFactory;

function requirePlaneFactory () {
	if (hasRequiredPlaneFactory) return PlaneFactory;
	hasRequiredPlaneFactory = 1;
	var Plane = requirePlane();
	var GameObjectFactory = requireGameObjectFactory();

	GameObjectFactory.register('plane', function (x, y, texture, frame, width, height, tile)
	{
	    return this.displayList.add(new Plane(this.scene, x, y, texture, frame, width, height, tile));
	});
	return PlaneFactory;
}

var ShaderCreator = {};

var hasRequiredShaderCreator;

function requireShaderCreator () {
	if (hasRequiredShaderCreator) return ShaderCreator;
	hasRequiredShaderCreator = 1;
	var BuildGameObject = requireBuildGameObject();
	var GameObjectCreator = requireGameObjectCreator();
	var GetAdvancedValue = requireGetAdvancedValue();
	var Shader = requireShader();

	GameObjectCreator.register('shader', function (config, addToScene)
	{
	    if (config === undefined) { config = {}; }

	    var key = GetAdvancedValue(config, 'key', null);
	    var x = GetAdvancedValue(config, 'x', 0);
	    var y = GetAdvancedValue(config, 'y', 0);
	    var width = GetAdvancedValue(config, 'width', 128);
	    var height = GetAdvancedValue(config, 'height', 128);

	    var shader = new Shader(this.scene, key, x, y, width, height);

	    if (addToScene !== undefined)
	    {
	        config.add = addToScene;
	    }

	    BuildGameObject(this.scene, shader, config);

	    return shader;
	});
	return ShaderCreator;
}

var MeshCreator = {};

var hasRequiredMeshCreator;

function requireMeshCreator () {
	if (hasRequiredMeshCreator) return MeshCreator;
	hasRequiredMeshCreator = 1;
	var BuildGameObject = requireBuildGameObject();
	var GameObjectCreator = requireGameObjectCreator();
	var GetAdvancedValue = requireGetAdvancedValue();
	var GetValue = requireGetValue();
	var Mesh = requireMesh$1();

	GameObjectCreator.register('mesh', function (config, addToScene)
	{
	    if (config === undefined) { config = {}; }

	    var key = GetAdvancedValue(config, 'key', null);
	    var frame = GetAdvancedValue(config, 'frame', null);
	    var vertices = GetValue(config, 'vertices', []);
	    var uvs = GetValue(config, 'uvs', []);
	    var indicies = GetValue(config, 'indicies', []);
	    var containsZ = GetValue(config, 'containsZ', false);
	    var normals = GetValue(config, 'normals', []);
	    var colors = GetValue(config, 'colors', 0xffffff);
	    var alphas = GetValue(config, 'alphas', 1);

	    var mesh = new Mesh(this.scene, 0, 0, key, frame, vertices, uvs, indicies, containsZ, normals, colors, alphas);

	    if (addToScene !== undefined)
	    {
	        config.add = addToScene;
	    }

	    BuildGameObject(this.scene, mesh, config);

	    return mesh;
	});
	return MeshCreator;
}

var NineSliceCreator = {};

var hasRequiredNineSliceCreator;

function requireNineSliceCreator () {
	if (hasRequiredNineSliceCreator) return NineSliceCreator;
	hasRequiredNineSliceCreator = 1;
	var BuildGameObject = requireBuildGameObject();
	var GameObjectCreator = requireGameObjectCreator();
	var GetAdvancedValue = requireGetAdvancedValue();
	var GetValue = requireGetValue();
	var NineSlice = requireNineSlice();

	GameObjectCreator.register('nineslice', function (config, addToScene)
	{
	    if (config === undefined) { config = {}; }

	    var key = GetAdvancedValue(config, 'key', null);
	    var frame = GetAdvancedValue(config, 'frame', null);
	    var width = GetValue(config, 'width', 256);
	    var height = GetValue(config, 'height', 256);
	    var leftWidth = GetValue(config, 'leftWidth', 10);
	    var rightWidth = GetValue(config, 'rightWidth', 10);
	    var topHeight = GetValue(config, 'topHeight', 0);
	    var bottomHeight = GetValue(config, 'bottomHeight', 0);

	    var nineslice = new NineSlice(this.scene, 0, 0, key, frame, width, height, leftWidth, rightWidth, topHeight, bottomHeight);

	    if (addToScene !== undefined)
	    {
	        config.add = addToScene;
	    }

	    BuildGameObject(this.scene, nineslice, config);

	    return nineslice;
	});
	return NineSliceCreator;
}

var PointLightCreator = {};

var hasRequiredPointLightCreator;

function requirePointLightCreator () {
	if (hasRequiredPointLightCreator) return PointLightCreator;
	hasRequiredPointLightCreator = 1;
	var BuildGameObject = requireBuildGameObject();
	var GameObjectCreator = requireGameObjectCreator();
	var GetAdvancedValue = requireGetAdvancedValue();
	var PointLight = requirePointLight();

	GameObjectCreator.register('pointlight', function (config, addToScene)
	{
	    if (config === undefined) { config = {}; }

	    var color = GetAdvancedValue(config, 'color', 0xffffff);
	    var radius = GetAdvancedValue(config, 'radius', 128);
	    var intensity = GetAdvancedValue(config, 'intensity', 1);
	    var attenuation = GetAdvancedValue(config, 'attenuation', 0.1);

	    var layer = new PointLight(this.scene, 0, 0, color, radius, intensity, attenuation);

	    if (addToScene !== undefined)
	    {
	        config.add = addToScene;
	    }

	    BuildGameObject(this.scene, layer, config);

	    return layer;
	});
	return PointLightCreator;
}

var PlaneCreator = {};

var hasRequiredPlaneCreator;

function requirePlaneCreator () {
	if (hasRequiredPlaneCreator) return PlaneCreator;
	hasRequiredPlaneCreator = 1;
	var BuildGameObject = requireBuildGameObject();
	var BuildGameObjectAnimation = requireBuildGameObjectAnimation();
	var GameObjectCreator = requireGameObjectCreator();
	var GetAdvancedValue = requireGetAdvancedValue();
	var GetValue = requireGetValue();
	var Plane = requirePlane();

	GameObjectCreator.register('plane', function (config, addToScene)
	{
	    if (config === undefined) { config = {}; }

	    var key = GetAdvancedValue(config, 'key', null);
	    var frame = GetAdvancedValue(config, 'frame', null);
	    var width = GetValue(config, 'width', 8);
	    var height = GetValue(config, 'height', 8);
	    var tile = GetValue(config, 'tile', false);

	    var plane = new Plane(this.scene, 0, 0, key, frame, width, height, tile);

	    if (addToScene !== undefined)
	    {
	        config.add = addToScene;
	    }

	    var checkerboard = GetValue(config, 'checkerboard', null);

	    if (checkerboard)
	    {
	        var color1 = GetValue(checkerboard, 'color1', 0xffffff);
	        var color2 = GetValue(checkerboard, 'color2', 0x0000ff);
	        var alpha1 = GetValue(checkerboard, 'alpha1', 255);
	        var alpha2 = GetValue(checkerboard, 'alpha2', 255);
	        var checkheight = GetValue(checkerboard, 'height', 128);

	        plane.createCheckerboard(color1, color2, alpha1, alpha2, checkheight);
	    }

	    BuildGameObject(this.scene, plane, config);

	    BuildGameObjectAnimation(plane, config);

	    return plane;
	});
	return PlaneCreator;
}

var Light_1;
var hasRequiredLight;

function requireLight () {
	if (hasRequiredLight) return Light_1;
	hasRequiredLight = 1;
	var Circle = requireCircle$2();
	var Class = requireClass();
	var Components = requireComponents$2();
	var RGB = requireRGB();
	var Utils = requireUtils$1();

	var Light = new Class({

	    Extends: Circle,

	    Mixins: [
	        Components.Origin,
	        Components.ScrollFactor,
	        Components.Visible
	    ],

	    initialize:

	    function Light (x, y, radius, r, g, b, intensity)
	    {
	        Circle.call(this, x, y, radius);

	        this.color = new RGB(r, g, b);

	        this.intensity = intensity;

	        this.renderFlags = 15;

	        this.cameraFilter = 0;

	        this.setScrollFactor(1, 1);
	        this.setOrigin();
	        this.setDisplayOrigin(radius);
	    },

	    displayWidth: {

	        get: function ()
	        {
	            return this.diameter;
	        },

	        set: function (value)
	        {
	            this.diameter = value;
	        }

	    },

	    displayHeight: {

	        get: function ()
	        {
	            return this.diameter;
	        },

	        set: function (value)
	        {
	            this.diameter = value;
	        }

	    },

	    width: {

	        get: function ()
	        {
	            return this.diameter;
	        },

	        set: function (value)
	        {
	            this.diameter = value;
	        }

	    },

	    height: {

	        get: function ()
	        {
	            return this.diameter;
	        },

	        set: function (value)
	        {
	            this.diameter = value;
	        }

	    },

	    willRender: function (camera)
	    {
	        return !(Light.RENDER_MASK !== this.renderFlags || (this.cameraFilter !== 0 && (this.cameraFilter & camera.id)));
	    },

	    setColor: function (rgb)
	    {
	        var color = Utils.getFloatsFromUintRGB(rgb);

	        this.color.set(color[0], color[1], color[2]);

	        return this;
	    },

	    setIntensity: function (intensity)
	    {
	        this.intensity = intensity;

	        return this;
	    },

	    setRadius: function (radius)
	    {
	        this.radius = radius;

	        return this;
	    }

	});

	Light.RENDER_MASK = 15;

	Light_1 = Light;
	return Light_1;
}

var CircleToRectangle_1;
var hasRequiredCircleToRectangle;

function requireCircleToRectangle () {
	if (hasRequiredCircleToRectangle) return CircleToRectangle_1;
	hasRequiredCircleToRectangle = 1;
	var CircleToRectangle = function (circle, rect)
	{
	    var halfWidth = rect.width / 2;
	    var halfHeight = rect.height / 2;

	    var cx = Math.abs(circle.x - rect.x - halfWidth);
	    var cy = Math.abs(circle.y - rect.y - halfHeight);
	    var xDist = halfWidth + circle.radius;
	    var yDist = halfHeight + circle.radius;

	    if (cx > xDist || cy > yDist)
	    {
	        return false;
	    }
	    else if (cx <= halfWidth || cy <= halfHeight)
	    {
	        return true;
	    }
	    else
	    {
	        var xCornerDist = cx - halfWidth;
	        var yCornerDist = cy - halfHeight;
	        var xCornerDistSq = xCornerDist * xCornerDist;
	        var yCornerDistSq = yCornerDist * yCornerDist;
	        var maxCornerDistSq = circle.radius * circle.radius;

	        return (xCornerDistSq + yCornerDistSq <= maxCornerDistSq);
	    }
	};

	CircleToRectangle_1 = CircleToRectangle;
	return CircleToRectangle_1;
}

var LightsManager_1;
var hasRequiredLightsManager;

function requireLightsManager () {
	if (hasRequiredLightsManager) return LightsManager_1;
	hasRequiredLightsManager = 1;
	var CircleToRectangle = requireCircleToRectangle();
	var Class = requireClass();
	var DistanceBetween = requireDistanceBetween();
	var Light = requireLight();
	var PointLight = requirePointLight();
	var RGB = requireRGB();
	var SpliceOne = requireSpliceOne();
	var StableSort = requireStableSort();
	var Utils = requireUtils$1();

	var LightsManager = new Class({

	    initialize:

	    function LightsManager ()
	    {

	        this.lights = [];

	        this.ambientColor = new RGB(0.1, 0.1, 0.1);

	        this.active = false;

	        this.maxLights = -1;

	        this.visibleLights = 0;
	    },

	    addPointLight: function (x, y, color, radius, intensity, attenuation)
	    {
	        return this.systems.displayList.add(new PointLight(this.scene, x, y, color, radius, intensity, attenuation));
	    },

	    enable: function ()
	    {
	        if (this.maxLights === -1)
	        {
	            this.maxLights = this.systems.renderer.config.maxLights;
	        }

	        this.active = true;

	        return this;
	    },

	    disable: function ()
	    {
	        this.active = false;

	        return this;
	    },

	    getLights: function (camera)
	    {
	        var lights = this.lights;
	        var worldView = camera.worldView;

	        var visibleLights = [];

	        for (var i = 0; i < lights.length; i++)
	        {
	            var light = lights[i];

	            if (light.willRender(camera) && CircleToRectangle(light, worldView))
	            {
	                visibleLights.push({
	                    light: light,
	                    distance: DistanceBetween(light.x, light.y, worldView.centerX, worldView.centerY)
	                });
	            }
	        }

	        if (visibleLights.length > this.maxLights)
	        {

	            StableSort(visibleLights, this.sortByDistance);

	            visibleLights = visibleLights.slice(0, this.maxLights);
	        }

	        this.visibleLights = visibleLights.length;

	        return visibleLights;
	    },

	    sortByDistance: function (a, b)
	    {
	        return (a.distance >= b.distance);
	    },

	    setAmbientColor: function (rgb)
	    {
	        var color = Utils.getFloatsFromUintRGB(rgb);

	        this.ambientColor.set(color[0], color[1], color[2]);

	        return this;
	    },

	    getMaxVisibleLights: function ()
	    {
	        return this.maxLights;
	    },

	    getLightCount: function ()
	    {
	        return this.lights.length;
	    },

	    addLight: function (x, y, radius, rgb, intensity)
	    {
	        if (x === undefined) { x = 0; }
	        if (y === undefined) { y = 0; }
	        if (radius === undefined) { radius = 128; }
	        if (rgb === undefined) { rgb = 0xffffff; }
	        if (intensity === undefined) { intensity = 1; }

	        var color = Utils.getFloatsFromUintRGB(rgb);

	        var light = new Light(x, y, radius, color[0], color[1], color[2], intensity);

	        this.lights.push(light);

	        return light;
	    },

	    removeLight: function (light)
	    {
	        var index = this.lights.indexOf(light);

	        if (index >= 0)
	        {
	            SpliceOne(this.lights, index);
	        }

	        return this;
	    },

	    shutdown: function ()
	    {
	        this.lights.length = 0;
	    },

	    destroy: function ()
	    {
	        this.shutdown();
	    }

	});

	LightsManager_1 = LightsManager;
	return LightsManager_1;
}

var LightsPlugin_1;
var hasRequiredLightsPlugin;

function requireLightsPlugin () {
	if (hasRequiredLightsPlugin) return LightsPlugin_1;
	hasRequiredLightsPlugin = 1;
	var Class = requireClass();
	var LightsManager = requireLightsManager();
	var PluginCache = requirePluginCache();
	var SceneEvents = requireEvents$l();

	var LightsPlugin = new Class({

	    Extends: LightsManager,

	    initialize:

	    function LightsPlugin (scene)
	    {

	        this.scene = scene;

	        this.systems = scene.sys;

	        if (!scene.sys.settings.isBooted)
	        {
	            scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
	        }

	        LightsManager.call(this);
	    },

	    boot: function ()
	    {
	        var eventEmitter = this.systems.events;

	        eventEmitter.on(SceneEvents.SHUTDOWN, this.shutdown, this);
	        eventEmitter.on(SceneEvents.DESTROY, this.destroy, this);
	    },

	    destroy: function ()
	    {
	        this.shutdown();

	        this.scene = undefined;
	        this.systems = undefined;
	    }

	});

	PluginCache.register('LightsPlugin', LightsPlugin, 'lights');

	LightsPlugin_1 = LightsPlugin;
	return LightsPlugin_1;
}

var gameobjects;
var hasRequiredGameobjects;

function requireGameobjects () {
	if (hasRequiredGameobjects) return gameobjects;
	hasRequiredGameobjects = 1;
	var GameObjects = {

	    Events: requireEvents$j(),

	    DisplayList: requireDisplayList(),
	    GameObjectCreator: requireGameObjectCreator(),
	    GameObjectFactory: requireGameObjectFactory(),
	    UpdateList: requireUpdateList(),

	    Components: requireComponents$2(),
	    GetCalcMatrix: requireGetCalcMatrix(),

	    BuildGameObject: requireBuildGameObject(),
	    BuildGameObjectAnimation: requireBuildGameObjectAnimation(),
	    GameObject: requireGameObject(),
	    BitmapText: requireBitmapText(),
	    Blitter: requireBlitter(),
	    Bob: requireBob(),
	    Container: requireContainer(),
	    DOMElement: requireDOMElement(),
	    DynamicBitmapText: requireDynamicBitmapText(),
	    Extern: requireExtern(),
	    Graphics: requireGraphics(),
	    Group: requireGroup(),
	    Image: requireImage$1(),
	    Layer: requireLayer(),
	    Particles: requireParticles(),
	    PathFollower: requirePathFollower(),
	    RenderTexture: requireRenderTexture(),
	    RetroFont: requireRetroFont(),
	    Rope: requireRope(),
	    Sprite: requireSprite(),

	    Text: requireText(),
	    GetTextSize: requireGetTextSize(),
	    MeasureText: requireMeasureText(),
	    TextStyle: requireTextStyle(),

	    TileSprite: requireTileSprite(),
	    Zone: requireZone(),
	    Video: requireVideo(),

	    Shape: requireShape(),
	    Arc: requireArc(),
	    Curve: requireCurve(),
	    Ellipse: requireEllipse$1(),
	    Grid: requireGrid(),
	    IsoBox: requireIsoBox(),
	    IsoTriangle: requireIsoTriangle(),
	    Line: requireLine$1(),
	    Polygon: requirePolygon$1(),
	    Rectangle: requireRectangle$1(),
	    Star: requireStar(),
	    Triangle: requireTriangle$1(),

	    Factories: {
	        Blitter: requireBlitterFactory(),
	        Container: requireContainerFactory(),
	        DOMElement: requireDOMElementFactory(),
	        DynamicBitmapText: requireDynamicBitmapTextFactory(),
	        Extern: requireExternFactory(),
	        Graphics: requireGraphicsFactory(),
	        Group: requireGroupFactory(),
	        Image: requireImageFactory(),
	        Layer: requireLayerFactory(),
	        Particles: requireParticleEmitterFactory(),
	        PathFollower: requirePathFollowerFactory(),
	        RenderTexture: requireRenderTextureFactory(),
	        Rope: requireRopeFactory(),
	        Sprite: requireSpriteFactory(),
	        StaticBitmapText: requireBitmapTextFactory(),
	        Text: requireTextFactory(),
	        TileSprite: requireTileSpriteFactory(),
	        Zone: requireZoneFactory(),
	        Video: requireVideoFactory(),

	        Arc: requireArcFactory(),
	        Curve: requireCurveFactory(),
	        Ellipse: requireEllipseFactory(),
	        Grid: requireGridFactory(),
	        IsoBox: requireIsoBoxFactory(),
	        IsoTriangle: requireIsoTriangleFactory(),
	        Line: requireLineFactory(),
	        Polygon: requirePolygonFactory(),
	        Rectangle: requireRectangleFactory(),
	        Star: requireStarFactory(),
	        Triangle: requireTriangleFactory()
	    },

	    Creators: {
	        Blitter: requireBlitterCreator(),
	        Container: requireContainerCreator(),
	        DynamicBitmapText: requireDynamicBitmapTextCreator(),
	        Graphics: requireGraphicsCreator(),
	        Group: requireGroupCreator(),
	        Image: requireImageCreator(),
	        Layer: requireLayerCreator(),
	        Particles: requireParticleEmitterCreator(),
	        RenderTexture: requireRenderTextureCreator(),
	        Rope: requireRopeCreator(),
	        Sprite: requireSpriteCreator(),
	        StaticBitmapText: requireBitmapTextCreator(),
	        Text: requireTextCreator(),
	        TileSprite: requireTileSpriteCreator(),
	        Zone: requireZoneCreator(),
	        Video: requireVideoCreator()
	    }

	};

	if (typeof WEBGL_RENDERER)
	{
	    GameObjects.Shader = requireShader();
	    GameObjects.Mesh = requireMesh$1();
	    GameObjects.NineSlice = requireNineSlice();
	    GameObjects.PointLight = requirePointLight();
	    GameObjects.Plane = requirePlane();

	    GameObjects.Factories.Shader = requireShaderFactory();
	    GameObjects.Factories.Mesh = requireMeshFactory();
	    GameObjects.Factories.NineSlice = requireNineSliceFactory();
	    GameObjects.Factories.PointLight = requirePointLightFactory();
	    GameObjects.Factories.Plane = requirePlaneFactory();

	    GameObjects.Creators.Shader = requireShaderCreator();
	    GameObjects.Creators.Mesh = requireMeshCreator();
	    GameObjects.Creators.NineSlice = requireNineSliceCreator();
	    GameObjects.Creators.PointLight = requirePointLightCreator();
	    GameObjects.Creators.Plane = requirePlaneCreator();

	    GameObjects.Light = requireLight();
	    GameObjects.LightsManager = requireLightsManager();
	    GameObjects.LightsPlugin = requireLightsPlugin();
	}

	gameobjects = GameObjects;
	return gameobjects;
}

var Area_1$3;
var hasRequiredArea$3;

function requireArea$3 () {
	if (hasRequiredArea$3) return Area_1$3;
	hasRequiredArea$3 = 1;
	var Area = function (circle)
	{
	    return (circle.radius > 0) ? Math.PI * circle.radius * circle.radius : 0;
	};

	Area_1$3 = Area;
	return Area_1$3;
}

var Clone_1$6;
var hasRequiredClone$6;

function requireClone$6 () {
	if (hasRequiredClone$6) return Clone_1$6;
	hasRequiredClone$6 = 1;
	var Circle = requireCircle$2();

	var Clone = function (source)
	{
	    return new Circle(source.x, source.y, source.radius);
	};

	Clone_1$6 = Clone;
	return Clone_1$6;
}

var ContainsPoint_1$4;
var hasRequiredContainsPoint$4;

function requireContainsPoint$4 () {
	if (hasRequiredContainsPoint$4) return ContainsPoint_1$4;
	hasRequiredContainsPoint$4 = 1;
	var Contains = requireContains$4();

	var ContainsPoint = function (circle, point)
	{
	    return Contains(circle, point.x, point.y);
	};

	ContainsPoint_1$4 = ContainsPoint;
	return ContainsPoint_1$4;
}

var ContainsRect_1$2;
var hasRequiredContainsRect$2;

function requireContainsRect$2 () {
	if (hasRequiredContainsRect$2) return ContainsRect_1$2;
	hasRequiredContainsRect$2 = 1;
	var Contains = requireContains$4();

	var ContainsRect = function (circle, rect)
	{
	    return (
	        Contains(circle, rect.x, rect.y) &&
	        Contains(circle, rect.right, rect.y) &&
	        Contains(circle, rect.x, rect.bottom) &&
	        Contains(circle, rect.right, rect.bottom)
	    );
	};

	ContainsRect_1$2 = ContainsRect;
	return ContainsRect_1$2;
}

var CopyFrom_1$4;
var hasRequiredCopyFrom$4;

function requireCopyFrom$4 () {
	if (hasRequiredCopyFrom$4) return CopyFrom_1$4;
	hasRequiredCopyFrom$4 = 1;
	var CopyFrom = function (source, dest)
	{
	    return dest.setTo(source.x, source.y, source.radius);
	};

	CopyFrom_1$4 = CopyFrom;
	return CopyFrom_1$4;
}

var Equals_1$5;
var hasRequiredEquals$5;

function requireEquals$5 () {
	if (hasRequiredEquals$5) return Equals_1$5;
	hasRequiredEquals$5 = 1;
	var Equals = function (circle, toCompare)
	{
	    return (
	        circle.x === toCompare.x &&
	        circle.y === toCompare.y &&
	        circle.radius === toCompare.radius
	    );
	};

	Equals_1$5 = Equals;
	return Equals_1$5;
}

var GetBounds_1$1;
var hasRequiredGetBounds$1;

function requireGetBounds$1 () {
	if (hasRequiredGetBounds$1) return GetBounds_1$1;
	hasRequiredGetBounds$1 = 1;
	var Rectangle = requireRectangle$2();

	var GetBounds = function (circle, out)
	{
	    if (out === undefined) { out = new Rectangle(); }

	    out.x = circle.left;
	    out.y = circle.top;
	    out.width = circle.diameter;
	    out.height = circle.diameter;

	    return out;
	};

	GetBounds_1$1 = GetBounds;
	return GetBounds_1$1;
}

var Offset_1$4;
var hasRequiredOffset$4;

function requireOffset$4 () {
	if (hasRequiredOffset$4) return Offset_1$4;
	hasRequiredOffset$4 = 1;
	var Offset = function (circle, x, y)
	{
	    circle.x += x;
	    circle.y += y;

	    return circle;
	};

	Offset_1$4 = Offset;
	return Offset_1$4;
}

var OffsetPoint_1$2;
var hasRequiredOffsetPoint$2;

function requireOffsetPoint$2 () {
	if (hasRequiredOffsetPoint$2) return OffsetPoint_1$2;
	hasRequiredOffsetPoint$2 = 1;
	var OffsetPoint = function (circle, point)
	{
	    circle.x += point.x;
	    circle.y += point.y;

	    return circle;
	};

	OffsetPoint_1$2 = OffsetPoint;
	return OffsetPoint_1$2;
}

var circle;
var hasRequiredCircle;

function requireCircle () {
	if (hasRequiredCircle) return circle;
	hasRequiredCircle = 1;
	var Circle = requireCircle$2();

	Circle.Area = requireArea$3();
	Circle.Circumference = requireCircumference$1();
	Circle.CircumferencePoint = requireCircumferencePoint$1();
	Circle.Clone = requireClone$6();
	Circle.Contains = requireContains$4();
	Circle.ContainsPoint = requireContainsPoint$4();
	Circle.ContainsRect = requireContainsRect$2();
	Circle.CopyFrom = requireCopyFrom$4();
	Circle.Equals = requireEquals$5();
	Circle.GetBounds = requireGetBounds$1();
	Circle.GetPoint = requireGetPoint$4();
	Circle.GetPoints = requireGetPoints$5();
	Circle.Offset = requireOffset$4();
	Circle.OffsetPoint = requireOffsetPoint$2();
	Circle.Random = requireRandom$5();

	circle = Circle;
	return circle;
}

var Area_1$2;
var hasRequiredArea$2;

function requireArea$2 () {
	if (hasRequiredArea$2) return Area_1$2;
	hasRequiredArea$2 = 1;
	var Area = function (ellipse)
	{
	    if (ellipse.isEmpty())
	    {
	        return 0;
	    }

	    return (ellipse.getMajorRadius() * ellipse.getMinorRadius() * Math.PI);
	};

	Area_1$2 = Area;
	return Area_1$2;
}

var Clone_1$5;
var hasRequiredClone$5;

function requireClone$5 () {
	if (hasRequiredClone$5) return Clone_1$5;
	hasRequiredClone$5 = 1;
	var Ellipse = requireEllipse$2();

	var Clone = function (source)
	{
	    return new Ellipse(source.x, source.y, source.width, source.height);
	};

	Clone_1$5 = Clone;
	return Clone_1$5;
}

var ContainsPoint_1$3;
var hasRequiredContainsPoint$3;

function requireContainsPoint$3 () {
	if (hasRequiredContainsPoint$3) return ContainsPoint_1$3;
	hasRequiredContainsPoint$3 = 1;
	var Contains = requireContains$2();

	var ContainsPoint = function (ellipse, point)
	{
	    return Contains(ellipse, point.x, point.y);
	};

	ContainsPoint_1$3 = ContainsPoint;
	return ContainsPoint_1$3;
}

var ContainsRect_1$1;
var hasRequiredContainsRect$1;

function requireContainsRect$1 () {
	if (hasRequiredContainsRect$1) return ContainsRect_1$1;
	hasRequiredContainsRect$1 = 1;
	var Contains = requireContains$2();

	var ContainsRect = function (ellipse, rect)
	{
	    return (
	        Contains(ellipse, rect.x, rect.y) &&
	        Contains(ellipse, rect.right, rect.y) &&
	        Contains(ellipse, rect.x, rect.bottom) &&
	        Contains(ellipse, rect.right, rect.bottom)
	    );
	};

	ContainsRect_1$1 = ContainsRect;
	return ContainsRect_1$1;
}

var CopyFrom_1$3;
var hasRequiredCopyFrom$3;

function requireCopyFrom$3 () {
	if (hasRequiredCopyFrom$3) return CopyFrom_1$3;
	hasRequiredCopyFrom$3 = 1;
	var CopyFrom = function (source, dest)
	{
	    return dest.setTo(source.x, source.y, source.width, source.height);
	};

	CopyFrom_1$3 = CopyFrom;
	return CopyFrom_1$3;
}

var Equals_1$4;
var hasRequiredEquals$4;

function requireEquals$4 () {
	if (hasRequiredEquals$4) return Equals_1$4;
	hasRequiredEquals$4 = 1;
	var Equals = function (ellipse, toCompare)
	{
	    return (
	        ellipse.x === toCompare.x &&
	        ellipse.y === toCompare.y &&
	        ellipse.width === toCompare.width &&
	        ellipse.height === toCompare.height
	    );
	};

	Equals_1$4 = Equals;
	return Equals_1$4;
}

var GetBounds_1;
var hasRequiredGetBounds;

function requireGetBounds () {
	if (hasRequiredGetBounds) return GetBounds_1;
	hasRequiredGetBounds = 1;
	var Rectangle = requireRectangle$2();

	var GetBounds = function (ellipse, out)
	{
	    if (out === undefined) { out = new Rectangle(); }

	    out.x = ellipse.left;
	    out.y = ellipse.top;
	    out.width = ellipse.width;
	    out.height = ellipse.height;

	    return out;
	};

	GetBounds_1 = GetBounds;
	return GetBounds_1;
}

var Offset_1$3;
var hasRequiredOffset$3;

function requireOffset$3 () {
	if (hasRequiredOffset$3) return Offset_1$3;
	hasRequiredOffset$3 = 1;
	var Offset = function (ellipse, x, y)
	{
	    ellipse.x += x;
	    ellipse.y += y;

	    return ellipse;
	};

	Offset_1$3 = Offset;
	return Offset_1$3;
}

var OffsetPoint_1$1;
var hasRequiredOffsetPoint$1;

function requireOffsetPoint$1 () {
	if (hasRequiredOffsetPoint$1) return OffsetPoint_1$1;
	hasRequiredOffsetPoint$1 = 1;
	var OffsetPoint = function (ellipse, point)
	{
	    ellipse.x += point.x;
	    ellipse.y += point.y;

	    return ellipse;
	};

	OffsetPoint_1$1 = OffsetPoint;
	return OffsetPoint_1$1;
}

var ellipse;
var hasRequiredEllipse;

function requireEllipse () {
	if (hasRequiredEllipse) return ellipse;
	hasRequiredEllipse = 1;
	var Ellipse = requireEllipse$2();

	Ellipse.Area = requireArea$2();
	Ellipse.Circumference = requireCircumference();
	Ellipse.CircumferencePoint = requireCircumferencePoint();
	Ellipse.Clone = requireClone$5();
	Ellipse.Contains = requireContains$2();
	Ellipse.ContainsPoint = requireContainsPoint$3();
	Ellipse.ContainsRect = requireContainsRect$1();
	Ellipse.CopyFrom = requireCopyFrom$3();
	Ellipse.Equals = requireEquals$4();
	Ellipse.GetBounds = requireGetBounds();
	Ellipse.GetPoint = requireGetPoint$1();
	Ellipse.GetPoints = requireGetPoints$2();
	Ellipse.Offset = requireOffset$3();
	Ellipse.OffsetPoint = requireOffsetPoint$1();
	Ellipse.Random = requireRandom$2();

	ellipse = Ellipse;
	return ellipse;
}

var CircleToCircle_1;
var hasRequiredCircleToCircle;

function requireCircleToCircle () {
	if (hasRequiredCircleToCircle) return CircleToCircle_1;
	hasRequiredCircleToCircle = 1;
	var DistanceBetween = requireDistanceBetween();

	var CircleToCircle = function (circleA, circleB)
	{
	    return (DistanceBetween(circleA.x, circleA.y, circleB.x, circleB.y) <= (circleA.radius + circleB.radius));
	};

	CircleToCircle_1 = CircleToCircle;
	return CircleToCircle_1;
}

var GetCircleToCircle_1;
var hasRequiredGetCircleToCircle;

function requireGetCircleToCircle () {
	if (hasRequiredGetCircleToCircle) return GetCircleToCircle_1;
	hasRequiredGetCircleToCircle = 1;
	var Point = requirePoint$1();
	var CircleToCircle = requireCircleToCircle();

	var GetCircleToCircle = function (circleA, circleB, out)
	{
	    if (out === undefined) { out = []; }

	    if (CircleToCircle(circleA, circleB))
	    {
	        var x0 = circleA.x;
	        var y0 = circleA.y;
	        var r0 = circleA.radius;

	        var x1 = circleB.x;
	        var y1 = circleB.y;
	        var r1 = circleB.radius;

	        var coefficientA, coefficientB, coefficientC, lambda, x;

	        if (y0 === y1)
	        {
	            x = ((r1 * r1) - (r0 * r0) - (x1 * x1) + (x0 * x0)) / (2 * (x0 - x1));

	            coefficientA = 1;
	            coefficientB = -2 * y1;
	            coefficientC = (x1 * x1) + (x * x) - (2 * x1 * x) + (y1 * y1) - (r1 * r1);

	            lambda = (coefficientB * coefficientB) - (4 * coefficientA * coefficientC);

	            if (lambda === 0)
	            {
	                out.push(new Point(x, (-coefficientB / (2 * coefficientA))));
	            }
	            else if (lambda > 0)
	            {
	                out.push(new Point(x, (-coefficientB + Math.sqrt(lambda)) / (2 * coefficientA)));
	                out.push(new Point(x, (-coefficientB - Math.sqrt(lambda)) / (2 * coefficientA)));
	            }
	        }
	        else
	        {
	            var v1 = (x0 - x1) / (y0 - y1);
	            var n = (r1 * r1 - r0 * r0 - x1 * x1 + x0 * x0 - y1 * y1 + y0 * y0) / (2 * (y0 - y1));

	            coefficientA = (v1 * v1) + 1;
	            coefficientB = (2 * y0 * v1) - (2 * n * v1) - (2 * x0);
	            coefficientC = (x0 * x0) + (y0 * y0) + (n * n) - (r0 * r0) - (2 * y0 * n);

	            lambda = (coefficientB * coefficientB) - (4 * coefficientA * coefficientC);

	            if (lambda === 0)
	            {
	                x = (-coefficientB / (2 * coefficientA));
	                out.push(new Point(x, (n - (x * v1))));
	            }
	            else if (lambda > 0)
	            {
	                x = (-coefficientB + Math.sqrt(lambda)) / (2 * coefficientA);
	                out.push(new Point(x, (n - (x * v1))));
	                x = (-coefficientB - Math.sqrt(lambda)) / (2 * coefficientA);
	                out.push(new Point(x, (n - (x * v1))));
	            }
	        }
	    }

	    return out;
	};

	GetCircleToCircle_1 = GetCircleToCircle;
	return GetCircleToCircle_1;
}

var LineToCircle_1;
var hasRequiredLineToCircle;

function requireLineToCircle () {
	if (hasRequiredLineToCircle) return LineToCircle_1;
	hasRequiredLineToCircle = 1;
	var Contains = requireContains$4();
	var Point = requirePoint$1();

	var tmp = new Point();

	var LineToCircle = function (line, circle, nearest)
	{
	    if (nearest === undefined) { nearest = tmp; }

	    if (Contains(circle, line.x1, line.y1))
	    {
	        nearest.x = line.x1;
	        nearest.y = line.y1;

	        return true;
	    }

	    if (Contains(circle, line.x2, line.y2))
	    {
	        nearest.x = line.x2;
	        nearest.y = line.y2;

	        return true;
	    }

	    var dx = line.x2 - line.x1;
	    var dy = line.y2 - line.y1;

	    var lcx = circle.x - line.x1;
	    var lcy = circle.y - line.y1;

	    var dLen2 = (dx * dx) + (dy * dy);
	    var px = dx;
	    var py = dy;

	    if (dLen2 > 0)
	    {
	        var dp = ((lcx * dx) + (lcy * dy)) / dLen2;

	        px *= dp;
	        py *= dp;
	    }

	    nearest.x = line.x1 + px;
	    nearest.y = line.y1 + py;

	    var pLen2 = (px * px) + (py * py);

	    return (
	        pLen2 <= dLen2 &&
	        ((px * dx) + (py * dy)) >= 0 &&
	        Contains(circle, nearest.x, nearest.y)
	    );
	};

	LineToCircle_1 = LineToCircle;
	return LineToCircle_1;
}

var GetLineToCircle_1;
var hasRequiredGetLineToCircle;

function requireGetLineToCircle () {
	if (hasRequiredGetLineToCircle) return GetLineToCircle_1;
	hasRequiredGetLineToCircle = 1;
	var Point = requirePoint$1();
	var LineToCircle = requireLineToCircle();

	var GetLineToCircle = function (line, circle, out)
	{
	    if (out === undefined) { out = []; }

	    if (LineToCircle(line, circle))
	    {
	        var lx1 = line.x1;
	        var ly1 = line.y1;

	        var lx2 = line.x2;
	        var ly2 = line.y2;

	        var cx = circle.x;
	        var cy = circle.y;
	        var cr = circle.radius;

	        var lDirX = lx2 - lx1;
	        var lDirY = ly2 - ly1;
	        var oDirX = lx1 - cx;
	        var oDirY = ly1 - cy;

	        var coefficientA = lDirX * lDirX + lDirY * lDirY;
	        var coefficientB = 2 * (lDirX * oDirX + lDirY * oDirY);
	        var coefficientC = oDirX * oDirX + oDirY * oDirY - cr * cr;

	        var lambda = (coefficientB * coefficientB) - (4 * coefficientA * coefficientC);

	        var x, y;

	        if (lambda === 0)
	        {
	            var root = -coefficientB / (2 * coefficientA);
	            x = lx1 + root * lDirX;
	            y = ly1 + root * lDirY;
	            if (root >= 0 && root <= 1)
	            {
	                out.push(new Point(x, y));
	            }
	        }
	        else if (lambda > 0)
	        {
	            var root1 = (-coefficientB - Math.sqrt(lambda)) / (2 * coefficientA);
	            x = lx1 + root1 * lDirX;
	            y = ly1 + root1 * lDirY;
	            if (root1 >= 0 && root1 <= 1)
	            {
	                out.push(new Point(x, y));
	            }

	            var root2 = (-coefficientB + Math.sqrt(lambda)) / (2 * coefficientA);
	            x = lx1 + root2 * lDirX;
	            y = ly1 + root2 * lDirY;
	            if (root2 >= 0 && root2 <= 1)
	            {
	                out.push(new Point(x, y));
	            }
	        }
	    }

	    return out;
	};

	GetLineToCircle_1 = GetLineToCircle;
	return GetLineToCircle_1;
}

var GetCircleToRectangle_1;
var hasRequiredGetCircleToRectangle;

function requireGetCircleToRectangle () {
	if (hasRequiredGetCircleToRectangle) return GetCircleToRectangle_1;
	hasRequiredGetCircleToRectangle = 1;
	var GetLineToCircle = requireGetLineToCircle();
	var CircleToRectangle = requireCircleToRectangle();

	var GetCircleToRectangle = function (circle, rect, out)
	{
	    if (out === undefined) { out = []; }

	    if (CircleToRectangle(circle, rect))
	    {
	        var lineA = rect.getLineA();
	        var lineB = rect.getLineB();
	        var lineC = rect.getLineC();
	        var lineD = rect.getLineD();

	        GetLineToCircle(lineA, circle, out);
	        GetLineToCircle(lineB, circle, out);
	        GetLineToCircle(lineC, circle, out);
	        GetLineToCircle(lineD, circle, out);
	    }

	    return out;
	};

	GetCircleToRectangle_1 = GetCircleToRectangle;
	return GetCircleToRectangle_1;
}

var GetLineToLine_1;
var hasRequiredGetLineToLine;

function requireGetLineToLine () {
	if (hasRequiredGetLineToLine) return GetLineToLine_1;
	hasRequiredGetLineToLine = 1;
	var Vector3 = requireVector3();

	var GetLineToLine = function (line1, line2, isRay, out)
	{
	    if (isRay === undefined) { isRay = false; }

	    var x1 = line1.x1;
	    var y1 = line1.y1;
	    var x2 = line1.x2;
	    var y2 = line1.y2;

	    var x3 = line2.x1;
	    var y3 = line2.y1;
	    var x4 = line2.x2;
	    var y4 = line2.y2;

	    var dx1 = x2 - x1;
	    var dy1 = y2 - y1;

	    var dx2 = x4 - x3;
	    var dy2 = y4 - y3;

	    var denom = (dx1 * dy2 - dy1 * dx2);

	    if (denom === 0)
	    {
	        return null;
	    }

	    var t;
	    var u;
	    var s;

	    if (isRay)
	    {
	        t = (dx1 * (y3 - y1) + dy1 * (x1 - x3)) / (dx2 * dy1 - dy2 * dx1);

	        if (dx1 !== 0)
	        {
	            u = (x3 + dx2 * t - x1) / dx1;
	        }
	        else if (dy1 !== 0)
	        {
	            u = (y3 + dy2 * t - y1) / dy1;
	        }
	        else
	        {
	            return null; 
	        }

	        if (u < 0 || t < 0 || t > 1)
	        {
	            return null;
	        }

	        s = u;
	    }
	    else
	    {
	        t = ((x3 - x1) * dy2 - (y3 - y1) * dx2) / denom;
	        u = ((y1 - y3) * dx1 - (x1 - x3) * dy1) / denom;

	        if (t < 0 || t > 1 || u < 0 || u > 1)
	        {
	            return null;
	        }

	        s = t;
	    }

	    if (out === undefined)
	    {
	        out = new Vector3();
	    }

	    return out.set(
	        x1 + dx1 * s,
	        y1 + dy1 * s,
	        s
	    );
	};

	GetLineToLine_1 = GetLineToLine;
	return GetLineToLine_1;
}

var GetLineToPoints_1;
var hasRequiredGetLineToPoints;

function requireGetLineToPoints () {
	if (hasRequiredGetLineToPoints) return GetLineToPoints_1;
	hasRequiredGetLineToPoints = 1;
	var GetLineToLine = requireGetLineToLine();
	var Line = requireLine$2();
	var Vector3 = requireVector3();

	var segment = new Line();

	var tempIntersect = new Vector3();

	var GetLineToPoints = function (line, points, isRay, out)
	{
	    if (isRay === undefined) { isRay = false; }
	    if (out === undefined) { out = new Vector3(); }

	    var closestIntersect = false;

	    out.set();
	    tempIntersect.set();

	    var prev = points[points.length - 1];

	    for (var i = 0; i < points.length; i++)
	    {
	        var current = points[i];

	        segment.setTo(prev.x, prev.y, current.x, current.y);

	        prev = current;

	        if (GetLineToLine(line, segment, isRay, tempIntersect))
	        {
	            if (!closestIntersect || tempIntersect.z < out.z)
	            {
	                out.copy(tempIntersect);

	                closestIntersect = true;
	            }
	        }
	    }

	    return (closestIntersect) ? out : null;
	};

	GetLineToPoints_1 = GetLineToPoints;
	return GetLineToPoints_1;
}

var GetLineToPolygon_1;
var hasRequiredGetLineToPolygon;

function requireGetLineToPolygon () {
	if (hasRequiredGetLineToPolygon) return GetLineToPolygon_1;
	hasRequiredGetLineToPolygon = 1;
	var Vector3 = requireVector3();
	var Vector4 = requireVector4();
	var GetLineToPoints = requireGetLineToPoints();

	var tempIntersect = new Vector3();

	var GetLineToPolygon = function (line, polygons, isRay, out)
	{
	    if (out === undefined) { out = new Vector4(); }

	    if (!Array.isArray(polygons))
	    {
	        polygons = [ polygons ];
	    }

	    var closestIntersect = false;

	    out.set();
	    tempIntersect.set();

	    for (var i = 0; i < polygons.length; i++)
	    {
	        if (GetLineToPoints(line, polygons[i].points, isRay, tempIntersect))
	        {
	            if (!closestIntersect || tempIntersect.z < out.z)
	            {
	                out.set(tempIntersect.x, tempIntersect.y, tempIntersect.z, i);

	                closestIntersect = true;
	            }
	        }
	    }

	    return (closestIntersect) ? out : null;
	};

	GetLineToPolygon_1 = GetLineToPolygon;
	return GetLineToPolygon_1;
}

var LineToLine_1;
var hasRequiredLineToLine;

function requireLineToLine () {
	if (hasRequiredLineToLine) return LineToLine_1;
	hasRequiredLineToLine = 1;
	var LineToLine = function (line1, line2, out)
	{
	    var x1 = line1.x1;
	    var y1 = line1.y1;
	    var x2 = line1.x2;
	    var y2 = line1.y2;

	    var x3 = line2.x1;
	    var y3 = line2.y1;
	    var x4 = line2.x2;
	    var y4 = line2.y2;

	    if ((x1 === x2 && y1 === y2) || (x3 === x4 && y3 === y4))
	    {
	        return false;
	    }

	    var denom = ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));

	    if (denom === 0)
	    {

	        return false;
	    }

	    var ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
	    var ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;

	    if (ua < 0 || ua > 1 || ub < 0 || ub > 1)
	    {
	        return false;
	    }
	    else
	    {
	        if (out)
	        {
	            out.x = x1 + ua * (x2 - x1);
	            out.y = y1 + ua * (y2 - y1);
	        }

	        return true;
	    }
	};

	LineToLine_1 = LineToLine;
	return LineToLine_1;
}

var LineToRectangle_1;
var hasRequiredLineToRectangle;

function requireLineToRectangle () {
	if (hasRequiredLineToRectangle) return LineToRectangle_1;
	hasRequiredLineToRectangle = 1;
	var LineToRectangle = function (line, rect)
	{
	    var x1 = line.x1;
	    var y1 = line.y1;

	    var x2 = line.x2;
	    var y2 = line.y2;

	    var bx1 = rect.x;
	    var by1 = rect.y;
	    var bx2 = rect.right;
	    var by2 = rect.bottom;

	    var t = 0;

	    if ((x1 >= bx1 && x1 <= bx2 && y1 >= by1 && y1 <= by2) ||
	        (x2 >= bx1 && x2 <= bx2 && y2 >= by1 && y2 <= by2))
	    {
	        return true;
	    }

	    if (x1 < bx1 && x2 >= bx1)
	    {

	        t = y1 + (y2 - y1) * (bx1 - x1) / (x2 - x1);

	        if (t > by1 && t <= by2)
	        {
	            return true;
	        }
	    }
	    else if (x1 > bx2 && x2 <= bx2)
	    {

	        t = y1 + (y2 - y1) * (bx2 - x1) / (x2 - x1);

	        if (t >= by1 && t <= by2)
	        {
	            return true;
	        }
	    }

	    if (y1 < by1 && y2 >= by1)
	    {

	        t = x1 + (x2 - x1) * (by1 - y1) / (y2 - y1);

	        if (t >= bx1 && t <= bx2)
	        {
	            return true;
	        }
	    }
	    else if (y1 > by2 && y2 <= by2)
	    {

	        t = x1 + (x2 - x1) * (by2 - y1) / (y2 - y1);

	        if (t >= bx1 && t <= bx2)
	        {
	            return true;
	        }
	    }

	    return false;
	};

	LineToRectangle_1 = LineToRectangle;
	return LineToRectangle_1;
}

var GetLineToRectangle_1;
var hasRequiredGetLineToRectangle;

function requireGetLineToRectangle () {
	if (hasRequiredGetLineToRectangle) return GetLineToRectangle_1;
	hasRequiredGetLineToRectangle = 1;
	var Point = requirePoint$1();
	var LineToLine = requireLineToLine();
	var LineToRectangle = requireLineToRectangle();

	var GetLineToRectangle = function (line, rect, out)
	{
	    if (out === undefined) { out = []; }

	    if (LineToRectangle(line, rect))
	    {
	        var lineA = rect.getLineA();
	        var lineB = rect.getLineB();
	        var lineC = rect.getLineC();
	        var lineD = rect.getLineD();

	        var output = [ new Point(), new Point(), new Point(), new Point() ];

	        var result = [
	            LineToLine(lineA, line, output[0]),
	            LineToLine(lineB, line, output[1]),
	            LineToLine(lineC, line, output[2]),
	            LineToLine(lineD, line, output[3])
	        ];

	        for (var i = 0; i < 4; i++)
	        {
	            if (result[i]) { out.push(output[i]); }
	        }
	    }

	    return out;
	};

	GetLineToRectangle_1 = GetLineToRectangle;
	return GetLineToRectangle_1;
}

var GetRaysFromPointToPolygon_1;
var hasRequiredGetRaysFromPointToPolygon;

function requireGetRaysFromPointToPolygon () {
	if (hasRequiredGetRaysFromPointToPolygon) return GetRaysFromPointToPolygon_1;
	hasRequiredGetRaysFromPointToPolygon = 1;
	var Vector4 = requireVector4();
	var GetLineToPolygon = requireGetLineToPolygon();
	var Line = requireLine$2();

	var segment = new Line();

	function CheckIntersects (angle, x, y, polygons, intersects)
	{
	    var dx = Math.cos(angle);
	    var dy = Math.sin(angle);

	    segment.setTo(x, y, x + dx, y + dy);

	    var closestIntersect = GetLineToPolygon(segment, polygons, true);

	    if (closestIntersect)
	    {
	        intersects.push(new Vector4(closestIntersect.x, closestIntersect.y, angle, closestIntersect.w));
	    }
	}

	function SortIntersects (a, b)
	{
	    return a.z - b.z;
	}

	var GetRaysFromPointToPolygon = function (x, y, polygons)
	{
	    if (!Array.isArray(polygons))
	    {
	        polygons = [ polygons ];
	    }

	    var intersects = [];
	    var angles = [];

	    for (var i = 0; i < polygons.length; i++)
	    {
	        var points = polygons[i].points;

	        for (var p = 0; p < points.length; p++)
	        {
	            var angle = Math.atan2(points[p].y - y, points[p].x - x);

	            if (angles.indexOf(angle) === -1)
	            {

	                CheckIntersects(angle, x, y, polygons, intersects);
	                CheckIntersects(angle - 0.00001, x, y, polygons, intersects);
	                CheckIntersects(angle + 0.00001, x, y, polygons, intersects);

	                angles.push(angle);
	            }
	        }
	    }

	    return intersects.sort(SortIntersects);
	};

	GetRaysFromPointToPolygon_1 = GetRaysFromPointToPolygon;
	return GetRaysFromPointToPolygon_1;
}

var GetRectangleIntersection_1;
var hasRequiredGetRectangleIntersection;

function requireGetRectangleIntersection () {
	if (hasRequiredGetRectangleIntersection) return GetRectangleIntersection_1;
	hasRequiredGetRectangleIntersection = 1;
	var Rectangle = requireRectangle$2();
	var RectangleToRectangle = requireRectangleToRectangle();

	var GetRectangleIntersection = function (rectA, rectB, output)
	{
	    if (output === undefined) { output = new Rectangle(); }

	    if (RectangleToRectangle(rectA, rectB))
	    {
	        output.x = Math.max(rectA.x, rectB.x);
	        output.y = Math.max(rectA.y, rectB.y);
	        output.width = Math.min(rectA.right, rectB.right) - output.x;
	        output.height = Math.min(rectA.bottom, rectB.bottom) - output.y;
	    }

	    return output;
	};

	GetRectangleIntersection_1 = GetRectangleIntersection;
	return GetRectangleIntersection_1;
}

var GetRectangleToRectangle_1;
var hasRequiredGetRectangleToRectangle;

function requireGetRectangleToRectangle () {
	if (hasRequiredGetRectangleToRectangle) return GetRectangleToRectangle_1;
	hasRequiredGetRectangleToRectangle = 1;
	var GetLineToRectangle = requireGetLineToRectangle();
	var RectangleToRectangle = requireRectangleToRectangle();

	var GetRectangleToRectangle = function (rectA, rectB, out)
	{
	    if (out === undefined) { out = []; }

	    if (RectangleToRectangle(rectA, rectB))
	    {
	        var lineA = rectA.getLineA();
	        var lineB = rectA.getLineB();
	        var lineC = rectA.getLineC();
	        var lineD = rectA.getLineD();

	        GetLineToRectangle(lineA, rectB, out);
	        GetLineToRectangle(lineB, rectB, out);
	        GetLineToRectangle(lineC, rectB, out);
	        GetLineToRectangle(lineD, rectB, out);
	    }

	    return out;
	};

	GetRectangleToRectangle_1 = GetRectangleToRectangle;
	return GetRectangleToRectangle_1;
}

var ContainsArray_1;
var hasRequiredContainsArray;

function requireContainsArray () {
	if (hasRequiredContainsArray) return ContainsArray_1;
	hasRequiredContainsArray = 1;
	var ContainsArray = function (triangle, points, returnFirst, out)
	{
	    if (returnFirst === undefined) { returnFirst = false; }
	    if (out === undefined) { out = []; }

	    var v0x = triangle.x3 - triangle.x1;
	    var v0y = triangle.y3 - triangle.y1;

	    var v1x = triangle.x2 - triangle.x1;
	    var v1y = triangle.y2 - triangle.y1;

	    var dot00 = (v0x * v0x) + (v0y * v0y);
	    var dot01 = (v0x * v1x) + (v0y * v1y);
	    var dot11 = (v1x * v1x) + (v1y * v1y);

	    var b = ((dot00 * dot11) - (dot01 * dot01));
	    var inv = (b === 0) ? 0 : (1 / b);

	    var u;
	    var v;
	    var v2x;
	    var v2y;
	    var dot02;
	    var dot12;

	    var x1 = triangle.x1;
	    var y1 = triangle.y1;

	    for (var i = 0; i < points.length; i++)
	    {
	        v2x = points[i].x - x1;
	        v2y = points[i].y - y1;

	        dot02 = (v0x * v2x) + (v0y * v2y);
	        dot12 = (v1x * v2x) + (v1y * v2y);

	        u = ((dot11 * dot02) - (dot01 * dot12)) * inv;
	        v = ((dot00 * dot12) - (dot01 * dot02)) * inv;

	        if (u >= 0 && v >= 0 && (u + v < 1))
	        {
	            out.push({ x: points[i].x, y: points[i].y });

	            if (returnFirst)
	            {
	                break;
	            }
	        }
	    }

	    return out;
	};

	ContainsArray_1 = ContainsArray;
	return ContainsArray_1;
}

var Decompose_1$1;
var hasRequiredDecompose$1;

function requireDecompose$1 () {
	if (hasRequiredDecompose$1) return Decompose_1$1;
	hasRequiredDecompose$1 = 1;
	var Decompose = function (rect, out)
	{
	    if (out === undefined) { out = []; }

	    out.push({ x: rect.x, y: rect.y });
	    out.push({ x: rect.right, y: rect.y });
	    out.push({ x: rect.right, y: rect.bottom });
	    out.push({ x: rect.x, y: rect.bottom });

	    return out;
	};

	Decompose_1$1 = Decompose;
	return Decompose_1$1;
}

var RectangleToTriangle_1;
var hasRequiredRectangleToTriangle;

function requireRectangleToTriangle () {
	if (hasRequiredRectangleToTriangle) return RectangleToTriangle_1;
	hasRequiredRectangleToTriangle = 1;
	var LineToLine = requireLineToLine();
	var Contains = requireContains$3();
	var ContainsArray = requireContainsArray();
	var Decompose = requireDecompose$1();

	var RectangleToTriangle = function (rect, triangle)
	{

	    if (
	        triangle.left > rect.right ||
	        triangle.right < rect.left ||
	        triangle.top > rect.bottom ||
	        triangle.bottom < rect.top)
	    {
	        return false;
	    }

	    var triA = triangle.getLineA();
	    var triB = triangle.getLineB();
	    var triC = triangle.getLineC();

	    if (Contains(rect, triA.x1, triA.y1) || Contains(rect, triA.x2, triA.y2))
	    {
	        return true;
	    }

	    if (Contains(rect, triB.x1, triB.y1) || Contains(rect, triB.x2, triB.y2))
	    {
	        return true;
	    }

	    if (Contains(rect, triC.x1, triC.y1) || Contains(rect, triC.x2, triC.y2))
	    {
	        return true;
	    }

	    var rectA = rect.getLineA();
	    var rectB = rect.getLineB();
	    var rectC = rect.getLineC();
	    var rectD = rect.getLineD();

	    if (LineToLine(triA, rectA) || LineToLine(triA, rectB) || LineToLine(triA, rectC) || LineToLine(triA, rectD))
	    {
	        return true;
	    }

	    if (LineToLine(triB, rectA) || LineToLine(triB, rectB) || LineToLine(triB, rectC) || LineToLine(triB, rectD))
	    {
	        return true;
	    }

	    if (LineToLine(triC, rectA) || LineToLine(triC, rectB) || LineToLine(triC, rectC) || LineToLine(triC, rectD))
	    {
	        return true;
	    }

	    var points = Decompose(rect);
	    var within = ContainsArray(triangle, points, true);

	    return (within.length > 0);
	};

	RectangleToTriangle_1 = RectangleToTriangle;
	return RectangleToTriangle_1;
}

var GetRectangleToTriangle_1;
var hasRequiredGetRectangleToTriangle;

function requireGetRectangleToTriangle () {
	if (hasRequiredGetRectangleToTriangle) return GetRectangleToTriangle_1;
	hasRequiredGetRectangleToTriangle = 1;
	var RectangleToTriangle = requireRectangleToTriangle();
	var GetLineToRectangle = requireGetLineToRectangle();

	var GetRectangleToTriangle = function (rect, triangle, out)
	{
	    if (out === undefined) { out = []; }

	    if (RectangleToTriangle(rect, triangle))
	    {
	        var lineA = triangle.getLineA();
	        var lineB = triangle.getLineB();
	        var lineC = triangle.getLineC();

	        GetLineToRectangle(lineA, rect, out);
	        GetLineToRectangle(lineB, rect, out);
	        GetLineToRectangle(lineC, rect, out);
	    }

	    return out;
	};

	GetRectangleToTriangle_1 = GetRectangleToTriangle;
	return GetRectangleToTriangle_1;
}

var TriangleToCircle_1;
var hasRequiredTriangleToCircle;

function requireTriangleToCircle () {
	if (hasRequiredTriangleToCircle) return TriangleToCircle_1;
	hasRequiredTriangleToCircle = 1;
	var LineToCircle = requireLineToCircle();
	var Contains = requireContains();

	var TriangleToCircle = function (triangle, circle)
	{

	    if (
	        triangle.left > circle.right ||
	        triangle.right < circle.left ||
	        triangle.top > circle.bottom ||
	        triangle.bottom < circle.top)
	    {
	        return false;
	    }

	    if (Contains(triangle, circle.x, circle.y))
	    {
	        return true;
	    }

	    if (LineToCircle(triangle.getLineA(), circle))
	    {
	        return true;
	    }

	    if (LineToCircle(triangle.getLineB(), circle))
	    {
	        return true;
	    }

	    if (LineToCircle(triangle.getLineC(), circle))
	    {
	        return true;
	    }

	    return false;
	};

	TriangleToCircle_1 = TriangleToCircle;
	return TriangleToCircle_1;
}

var GetTriangleToCircle_1;
var hasRequiredGetTriangleToCircle;

function requireGetTriangleToCircle () {
	if (hasRequiredGetTriangleToCircle) return GetTriangleToCircle_1;
	hasRequiredGetTriangleToCircle = 1;
	var GetLineToCircle = requireGetLineToCircle();
	var TriangleToCircle = requireTriangleToCircle();

	var GetTriangleToCircle = function (triangle, circle, out)
	{
	    if (out === undefined) { out = []; }

	    if (TriangleToCircle(triangle, circle))
	    {
	        var lineA = triangle.getLineA();
	        var lineB = triangle.getLineB();
	        var lineC = triangle.getLineC();

	        GetLineToCircle(lineA, circle, out);
	        GetLineToCircle(lineB, circle, out);
	        GetLineToCircle(lineC, circle, out);
	    }

	    return out;
	};

	GetTriangleToCircle_1 = GetTriangleToCircle;
	return GetTriangleToCircle_1;
}

var TriangleToLine_1;
var hasRequiredTriangleToLine;

function requireTriangleToLine () {
	if (hasRequiredTriangleToLine) return TriangleToLine_1;
	hasRequiredTriangleToLine = 1;
	var LineToLine = requireLineToLine();

	var TriangleToLine = function (triangle, line)
	{

	    if (triangle.contains(line.x1, line.y1) || triangle.contains(line.x2, line.y2))
	    {
	        return true;
	    }

	    if (LineToLine(triangle.getLineA(), line))
	    {
	        return true;
	    }

	    if (LineToLine(triangle.getLineB(), line))
	    {
	        return true;
	    }

	    if (LineToLine(triangle.getLineC(), line))
	    {
	        return true;
	    }

	    return false;
	};

	TriangleToLine_1 = TriangleToLine;
	return TriangleToLine_1;
}

var GetTriangleToLine_1;
var hasRequiredGetTriangleToLine;

function requireGetTriangleToLine () {
	if (hasRequiredGetTriangleToLine) return GetTriangleToLine_1;
	hasRequiredGetTriangleToLine = 1;
	var Point = requirePoint$1();
	var TriangleToLine = requireTriangleToLine();
	var LineToLine = requireLineToLine();

	var GetTriangleToLine = function (triangle, line, out)
	{
	    if (out === undefined) { out = []; }

	    if (TriangleToLine(triangle, line))
	    {
	        var lineA = triangle.getLineA();
	        var lineB = triangle.getLineB();
	        var lineC = triangle.getLineC();

	        var output = [ new Point(), new Point(), new Point() ];

	        var result = [
	            LineToLine(lineA, line, output[0]),
	            LineToLine(lineB, line, output[1]),
	            LineToLine(lineC, line, output[2])
	        ];

	        for (var i = 0; i < 3; i++)
	        {
	            if (result[i]) { out.push(output[i]); }
	        }
	    }

	    return out;
	};

	GetTriangleToLine_1 = GetTriangleToLine;
	return GetTriangleToLine_1;
}

var Decompose_1;
var hasRequiredDecompose;

function requireDecompose () {
	if (hasRequiredDecompose) return Decompose_1;
	hasRequiredDecompose = 1;
	var Decompose = function (triangle, out)
	{
	    if (out === undefined) { out = []; }

	    out.push({ x: triangle.x1, y: triangle.y1 });
	    out.push({ x: triangle.x2, y: triangle.y2 });
	    out.push({ x: triangle.x3, y: triangle.y3 });

	    return out;
	};

	Decompose_1 = Decompose;
	return Decompose_1;
}

var TriangleToTriangle_1;
var hasRequiredTriangleToTriangle;

function requireTriangleToTriangle () {
	if (hasRequiredTriangleToTriangle) return TriangleToTriangle_1;
	hasRequiredTriangleToTriangle = 1;
	var ContainsArray = requireContainsArray();
	var Decompose = requireDecompose();
	var LineToLine = requireLineToLine();

	var TriangleToTriangle = function (triangleA, triangleB)
	{

	    if (
	        triangleA.left > triangleB.right ||
	        triangleA.right < triangleB.left ||
	        triangleA.top > triangleB.bottom ||
	        triangleA.bottom < triangleB.top)
	    {
	        return false;
	    }

	    var lineAA = triangleA.getLineA();
	    var lineAB = triangleA.getLineB();
	    var lineAC = triangleA.getLineC();

	    var lineBA = triangleB.getLineA();
	    var lineBB = triangleB.getLineB();
	    var lineBC = triangleB.getLineC();

	    if (LineToLine(lineAA, lineBA) || LineToLine(lineAA, lineBB) || LineToLine(lineAA, lineBC))
	    {
	        return true;
	    }

	    if (LineToLine(lineAB, lineBA) || LineToLine(lineAB, lineBB) || LineToLine(lineAB, lineBC))
	    {
	        return true;
	    }

	    if (LineToLine(lineAC, lineBA) || LineToLine(lineAC, lineBB) || LineToLine(lineAC, lineBC))
	    {
	        return true;
	    }

	    var points = Decompose(triangleA);
	    var within = ContainsArray(triangleB, points, true);

	    if (within.length > 0)
	    {
	        return true;
	    }

	    points = Decompose(triangleB);
	    within = ContainsArray(triangleA, points, true);

	    if (within.length > 0)
	    {
	        return true;
	    }

	    return false;
	};

	TriangleToTriangle_1 = TriangleToTriangle;
	return TriangleToTriangle_1;
}

var GetTriangleToTriangle_1;
var hasRequiredGetTriangleToTriangle;

function requireGetTriangleToTriangle () {
	if (hasRequiredGetTriangleToTriangle) return GetTriangleToTriangle_1;
	hasRequiredGetTriangleToTriangle = 1;
	var TriangleToTriangle = requireTriangleToTriangle();
	var GetTriangleToLine = requireGetTriangleToLine();

	var GetTriangleToTriangle = function (triangleA, triangleB, out)
	{
	    if (out === undefined) { out = []; }

	    if (TriangleToTriangle(triangleA, triangleB))
	    {
	        var lineA = triangleB.getLineA();
	        var lineB = triangleB.getLineB();
	        var lineC = triangleB.getLineC();

	        GetTriangleToLine(triangleA, lineA, out);
	        GetTriangleToLine(triangleA, lineB, out);
	        GetTriangleToLine(triangleA, lineC, out);
	    }

	    return out;
	};

	GetTriangleToTriangle_1 = GetTriangleToTriangle;
	return GetTriangleToTriangle_1;
}

var PointToLine_1;
var hasRequiredPointToLine;

function requirePointToLine () {
	if (hasRequiredPointToLine) return PointToLine_1;
	hasRequiredPointToLine = 1;
	var PointToLine = function (point, line, lineThickness)
	{
	    if (lineThickness === undefined) { lineThickness = 1; }

	    var x1 = line.x1;
	    var y1 = line.y1;

	    var x2 = line.x2;
	    var y2 = line.y2;

	    var px = point.x;
	    var py = point.y;

	    var L2 = (((x2 - x1) * (x2 - x1)) + ((y2 - y1) * (y2 - y1)));

	    if (L2 === 0)
	    {
	        return false;
	    }

	    var r = (((px - x1) * (x2 - x1)) + ((py - y1) * (y2 - y1))) / L2;

	    if (r < 0)
	    {

	        return (Math.sqrt(((x1 - px) * (x1 - px)) + ((y1 - py) * (y1 - py))) <= lineThickness);
	    }
	    else if ((r >= 0) && (r <= 1))
	    {

	        var s = (((y1 - py) * (x2 - x1)) - ((x1 - px) * (y2 - y1))) / L2;

	        return (Math.abs(s) * Math.sqrt(L2) <= lineThickness);
	    }
	    else
	    {

	        return (Math.sqrt(((x2 - px) * (x2 - px)) + ((y2 - py) * (y2 - py))) <= lineThickness);
	    }
	};

	PointToLine_1 = PointToLine;
	return PointToLine_1;
}

var PointToLineSegment_1;
var hasRequiredPointToLineSegment;

function requirePointToLineSegment () {
	if (hasRequiredPointToLineSegment) return PointToLineSegment_1;
	hasRequiredPointToLineSegment = 1;
	var PointToLine = requirePointToLine();

	var PointToLineSegment = function (point, line)
	{
	    if (!PointToLine(point, line))
	    {
	        return false;
	    }

	    var xMin = Math.min(line.x1, line.x2);
	    var xMax = Math.max(line.x1, line.x2);
	    var yMin = Math.min(line.y1, line.y2);
	    var yMax = Math.max(line.y1, line.y2);

	    return ((point.x >= xMin && point.x <= xMax) && (point.y >= yMin && point.y <= yMax));
	};

	PointToLineSegment_1 = PointToLineSegment;
	return PointToLineSegment_1;
}

var RectangleToValues_1;
var hasRequiredRectangleToValues;

function requireRectangleToValues () {
	if (hasRequiredRectangleToValues) return RectangleToValues_1;
	hasRequiredRectangleToValues = 1;
	var RectangleToValues = function (rect, left, right, top, bottom, tolerance)
	{
	    if (tolerance === undefined) { tolerance = 0; }

	    return !(
	        left > rect.right + tolerance ||
	        right < rect.left - tolerance ||
	        top > rect.bottom + tolerance ||
	        bottom < rect.top - tolerance
	    );
	};

	RectangleToValues_1 = RectangleToValues;
	return RectangleToValues_1;
}

var intersects;
var hasRequiredIntersects;

function requireIntersects () {
	if (hasRequiredIntersects) return intersects;
	hasRequiredIntersects = 1;
	intersects = {

	    CircleToCircle: requireCircleToCircle(),
	    CircleToRectangle: requireCircleToRectangle(),
	    GetCircleToCircle: requireGetCircleToCircle(),
	    GetCircleToRectangle: requireGetCircleToRectangle(),
	    GetLineToCircle: requireGetLineToCircle(),
	    GetLineToLine: requireGetLineToLine(),
	    GetLineToPoints: requireGetLineToPoints(),
	    GetLineToPolygon: requireGetLineToPolygon(),
	    GetLineToRectangle: requireGetLineToRectangle(),
	    GetRaysFromPointToPolygon: requireGetRaysFromPointToPolygon(),
	    GetRectangleIntersection: requireGetRectangleIntersection(),
	    GetRectangleToRectangle: requireGetRectangleToRectangle(),
	    GetRectangleToTriangle: requireGetRectangleToTriangle(),
	    GetTriangleToCircle: requireGetTriangleToCircle(),
	    GetTriangleToLine: requireGetTriangleToLine(),
	    GetTriangleToTriangle: requireGetTriangleToTriangle(),
	    LineToCircle: requireLineToCircle(),
	    LineToLine: requireLineToLine(),
	    LineToRectangle: requireLineToRectangle(),
	    PointToLine: requirePointToLine(),
	    PointToLineSegment: requirePointToLineSegment(),
	    RectangleToRectangle: requireRectangleToRectangle(),
	    RectangleToTriangle: requireRectangleToTriangle(),
	    RectangleToValues: requireRectangleToValues(),
	    TriangleToCircle: requireTriangleToCircle(),
	    TriangleToLine: requireTriangleToLine(),
	    TriangleToTriangle: requireTriangleToTriangle()

	};
	return intersects;
}

var Angle_1;
var hasRequiredAngle;

function requireAngle () {
	if (hasRequiredAngle) return Angle_1;
	hasRequiredAngle = 1;
	var Angle = function (line)
	{
	    return Math.atan2(line.y2 - line.y1, line.x2 - line.x1);
	};

	Angle_1 = Angle;
	return Angle_1;
}

var CenterOn_1$1;
var hasRequiredCenterOn$1;

function requireCenterOn$1 () {
	if (hasRequiredCenterOn$1) return CenterOn_1$1;
	hasRequiredCenterOn$1 = 1;
	var CenterOn = function (line, x, y)
	{
	    var tx = x - ((line.x1 + line.x2) / 2);
	    var ty = y - ((line.y1 + line.y2) / 2);

	    line.x1 += tx;
	    line.y1 += ty;

	    line.x2 += tx;
	    line.y2 += ty;

	    return line;
	};

	CenterOn_1$1 = CenterOn;
	return CenterOn_1$1;
}

var Clone_1$4;
var hasRequiredClone$4;

function requireClone$4 () {
	if (hasRequiredClone$4) return Clone_1$4;
	hasRequiredClone$4 = 1;
	var Line = requireLine$2();

	var Clone = function (source)
	{
	    return new Line(source.x1, source.y1, source.x2, source.y2);
	};

	Clone_1$4 = Clone;
	return Clone_1$4;
}

var CopyFrom_1$2;
var hasRequiredCopyFrom$2;

function requireCopyFrom$2 () {
	if (hasRequiredCopyFrom$2) return CopyFrom_1$2;
	hasRequiredCopyFrom$2 = 1;
	var CopyFrom = function (source, dest)
	{
	    return dest.setTo(source.x1, source.y1, source.x2, source.y2);
	};

	CopyFrom_1$2 = CopyFrom;
	return CopyFrom_1$2;
}

var Equals_1$3;
var hasRequiredEquals$3;

function requireEquals$3 () {
	if (hasRequiredEquals$3) return Equals_1$3;
	hasRequiredEquals$3 = 1;
	var Equals = function (line, toCompare)
	{
	    return (
	        line.x1 === toCompare.x1 &&
	        line.y1 === toCompare.y1 &&
	        line.x2 === toCompare.x2 &&
	        line.y2 === toCompare.y2
	    );
	};

	Equals_1$3 = Equals;
	return Equals_1$3;
}

var Extend_1;
var hasRequiredExtend;

function requireExtend () {
	if (hasRequiredExtend) return Extend_1;
	hasRequiredExtend = 1;
	var Length = requireLength();

	var Extend = function (line, left, right)
	{
	    if (right === undefined) { right = left; }

	    var length = Length(line);

	    var slopX = line.x2 - line.x1;
	    var slopY = line.y2 - line.y1;

	    if (left)
	    {
	        line.x1 = line.x1 - slopX / length * left;
	        line.y1 = line.y1 - slopY / length * left;
	    }

	    if (right)
	    {
	        line.x2 = line.x2 + slopX / length * right;
	        line.y2 = line.y2 + slopY / length * right;
	    }

	    return line;
	};

	Extend_1 = Extend;
	return Extend_1;
}

var GetMidPoint_1;
var hasRequiredGetMidPoint;

function requireGetMidPoint () {
	if (hasRequiredGetMidPoint) return GetMidPoint_1;
	hasRequiredGetMidPoint = 1;
	var Point = requirePoint$1();

	var GetMidPoint = function (line, out)
	{
	    if (out === undefined) { out = new Point(); }

	    out.x = (line.x1 + line.x2) / 2;
	    out.y = (line.y1 + line.y2) / 2;

	    return out;
	};

	GetMidPoint_1 = GetMidPoint;
	return GetMidPoint_1;
}

var GetNearestPoint_1;
var hasRequiredGetNearestPoint;

function requireGetNearestPoint () {
	if (hasRequiredGetNearestPoint) return GetNearestPoint_1;
	hasRequiredGetNearestPoint = 1;
	var Point = requirePoint$1();

	var GetNearestPoint = function (line, point, out)
	{
	    if (out === undefined) { out = new Point(); }

	    var x1 = line.x1;
	    var y1 = line.y1;

	    var x2 = line.x2;
	    var y2 = line.y2;

	    var L2 = (((x2 - x1) * (x2 - x1)) + ((y2 - y1) * (y2 - y1)));

	    if (L2 === 0)
	    {
	        return out;
	    }

	    var r = (((point.x - x1) * (x2 - x1)) + ((point.y - y1) * (y2 - y1))) / L2;

	    out.x = x1 + (r * (x2 - x1));
	    out.y = y1 + (r * (y2 - y1));

	    return out;
	};

	GetNearestPoint_1 = GetNearestPoint;
	return GetNearestPoint_1;
}

var GetNormal_1;
var hasRequiredGetNormal;

function requireGetNormal () {
	if (hasRequiredGetNormal) return GetNormal_1;
	hasRequiredGetNormal = 1;
	var MATH_CONST = require_const$c();
	var Angle = requireAngle();
	var Point = requirePoint$1();

	var GetNormal = function (line, out)
	{
	    if (out === undefined) { out = new Point(); }

	    var a = Angle(line) - MATH_CONST.TAU;

	    out.x = Math.cos(a);
	    out.y = Math.sin(a);

	    return out;
	};

	GetNormal_1 = GetNormal;
	return GetNormal_1;
}

var GetShortestDistance_1;
var hasRequiredGetShortestDistance;

function requireGetShortestDistance () {
	if (hasRequiredGetShortestDistance) return GetShortestDistance_1;
	hasRequiredGetShortestDistance = 1;
	var GetShortestDistance = function (line, point)
	{
	    var x1 = line.x1;
	    var y1 = line.y1;

	    var x2 = line.x2;
	    var y2 = line.y2;

	    var L2 = (((x2 - x1) * (x2 - x1)) + ((y2 - y1) * (y2 - y1)));

	    if (L2 === 0)
	    {
	        return false;
	    }

	    var s = (((y1 - point.y) * (x2 - x1)) - ((x1 - point.x) * (y2 - y1))) / L2;

	    return Math.abs(s) * Math.sqrt(L2);
	};

	GetShortestDistance_1 = GetShortestDistance;
	return GetShortestDistance_1;
}

var Height_1;
var hasRequiredHeight;

function requireHeight () {
	if (hasRequiredHeight) return Height_1;
	hasRequiredHeight = 1;
	var Height = function (line)
	{
	    return Math.abs(line.y1 - line.y2);
	};

	Height_1 = Height;
	return Height_1;
}

var NormalAngle_1;
var hasRequiredNormalAngle;

function requireNormalAngle () {
	if (hasRequiredNormalAngle) return NormalAngle_1;
	hasRequiredNormalAngle = 1;
	var MATH_CONST = require_const$c();
	var Wrap = requireWrap$1();
	var Angle = requireAngle();

	var NormalAngle = function (line)
	{
	    var angle = Angle(line) - MATH_CONST.TAU;

	    return Wrap(angle, -Math.PI, Math.PI);
	};

	NormalAngle_1 = NormalAngle;
	return NormalAngle_1;
}

var NormalX_1;
var hasRequiredNormalX;

function requireNormalX () {
	if (hasRequiredNormalX) return NormalX_1;
	hasRequiredNormalX = 1;
	var MATH_CONST = require_const$c();
	var Angle = requireAngle();

	var NormalX = function (line)
	{
	    return Math.cos(Angle(line) - MATH_CONST.TAU);
	};

	NormalX_1 = NormalX;
	return NormalX_1;
}

var NormalY_1;
var hasRequiredNormalY;

function requireNormalY () {
	if (hasRequiredNormalY) return NormalY_1;
	hasRequiredNormalY = 1;
	var MATH_CONST = require_const$c();
	var Angle = requireAngle();

	var NormalY = function (line)
	{
	    return Math.sin(Angle(line) - MATH_CONST.TAU);
	};

	NormalY_1 = NormalY;
	return NormalY_1;
}

var Offset_1$2;
var hasRequiredOffset$2;

function requireOffset$2 () {
	if (hasRequiredOffset$2) return Offset_1$2;
	hasRequiredOffset$2 = 1;
	var Offset = function (line, x, y)
	{
	    line.x1 += x;
	    line.y1 += y;

	    line.x2 += x;
	    line.y2 += y;

	    return line;
	};

	Offset_1$2 = Offset;
	return Offset_1$2;
}

var PerpSlope_1;
var hasRequiredPerpSlope;

function requirePerpSlope () {
	if (hasRequiredPerpSlope) return PerpSlope_1;
	hasRequiredPerpSlope = 1;
	var PerpSlope = function (line)
	{
	    return -((line.x2 - line.x1) / (line.y2 - line.y1));
	};

	PerpSlope_1 = PerpSlope;
	return PerpSlope_1;
}

var ReflectAngle_1;
var hasRequiredReflectAngle;

function requireReflectAngle () {
	if (hasRequiredReflectAngle) return ReflectAngle_1;
	hasRequiredReflectAngle = 1;
	var Angle = requireAngle();
	var NormalAngle = requireNormalAngle();

	var ReflectAngle = function (lineA, lineB)
	{
	    return (2 * NormalAngle(lineB) - Math.PI - Angle(lineA));
	};

	ReflectAngle_1 = ReflectAngle;
	return ReflectAngle_1;
}

var RotateAroundXY_1$1;
var hasRequiredRotateAroundXY$1;

function requireRotateAroundXY$1 () {
	if (hasRequiredRotateAroundXY$1) return RotateAroundXY_1$1;
	hasRequiredRotateAroundXY$1 = 1;
	var RotateAroundXY = function (line, x, y, angle)
	{
	    var c = Math.cos(angle);
	    var s = Math.sin(angle);

	    var tx = line.x1 - x;
	    var ty = line.y1 - y;

	    line.x1 = tx * c - ty * s + x;
	    line.y1 = tx * s + ty * c + y;

	    tx = line.x2 - x;
	    ty = line.y2 - y;

	    line.x2 = tx * c - ty * s + x;
	    line.y2 = tx * s + ty * c + y;

	    return line;
	};

	RotateAroundXY_1$1 = RotateAroundXY;
	return RotateAroundXY_1$1;
}

var Rotate_1$1;
var hasRequiredRotate$1;

function requireRotate$1 () {
	if (hasRequiredRotate$1) return Rotate_1$1;
	hasRequiredRotate$1 = 1;
	var RotateAroundXY = requireRotateAroundXY$1();

	var Rotate = function (line, angle)
	{
	    var x = (line.x1 + line.x2) / 2;
	    var y = (line.y1 + line.y2) / 2;

	    return RotateAroundXY(line, x, y, angle);
	};

	Rotate_1$1 = Rotate;
	return Rotate_1$1;
}

var RotateAroundPoint_1$1;
var hasRequiredRotateAroundPoint$1;

function requireRotateAroundPoint$1 () {
	if (hasRequiredRotateAroundPoint$1) return RotateAroundPoint_1$1;
	hasRequiredRotateAroundPoint$1 = 1;
	var RotateAroundXY = requireRotateAroundXY$1();

	var RotateAroundPoint = function (line, point, angle)
	{
	    return RotateAroundXY(line, point.x, point.y, angle);
	};

	RotateAroundPoint_1$1 = RotateAroundPoint;
	return RotateAroundPoint_1$1;
}

var SetToAngle_1;
var hasRequiredSetToAngle;

function requireSetToAngle () {
	if (hasRequiredSetToAngle) return SetToAngle_1;
	hasRequiredSetToAngle = 1;
	var SetToAngle = function (line, x, y, angle, length)
	{
	    line.x1 = x;
	    line.y1 = y;

	    line.x2 = x + (Math.cos(angle) * length);
	    line.y2 = y + (Math.sin(angle) * length);

	    return line;
	};

	SetToAngle_1 = SetToAngle;
	return SetToAngle_1;
}

var Slope_1;
var hasRequiredSlope;

function requireSlope () {
	if (hasRequiredSlope) return Slope_1;
	hasRequiredSlope = 1;
	var Slope = function (line)
	{
	    return (line.y2 - line.y1) / (line.x2 - line.x1);
	};

	Slope_1 = Slope;
	return Slope_1;
}

var Width_1;
var hasRequiredWidth;

function requireWidth () {
	if (hasRequiredWidth) return Width_1;
	hasRequiredWidth = 1;
	var Width = function (line)
	{
	    return Math.abs(line.x1 - line.x2);
	};

	Width_1 = Width;
	return Width_1;
}

var line;
var hasRequiredLine;

function requireLine () {
	if (hasRequiredLine) return line;
	hasRequiredLine = 1;
	var Line = requireLine$2();

	Line.Angle = requireAngle();
	Line.BresenhamPoints = requireBresenhamPoints();
	Line.CenterOn = requireCenterOn$1();
	Line.Clone = requireClone$4();
	Line.CopyFrom = requireCopyFrom$2();
	Line.Equals = requireEquals$3();
	Line.Extend = requireExtend();
	Line.GetEasedPoints = requireGetEasedPoints();
	Line.GetMidPoint = requireGetMidPoint();
	Line.GetNearestPoint = requireGetNearestPoint();
	Line.GetNormal = requireGetNormal();
	Line.GetPoint = requireGetPoint$2();
	Line.GetPoints = requireGetPoints$3();
	Line.GetShortestDistance = requireGetShortestDistance();
	Line.Height = requireHeight();
	Line.Length = requireLength();
	Line.NormalAngle = requireNormalAngle();
	Line.NormalX = requireNormalX();
	Line.NormalY = requireNormalY();
	Line.Offset = requireOffset$2();
	Line.PerpSlope = requirePerpSlope();
	Line.Random = requireRandom$4();
	Line.ReflectAngle = requireReflectAngle();
	Line.Rotate = requireRotate$1();
	Line.RotateAroundPoint = requireRotateAroundPoint$1();
	Line.RotateAroundXY = requireRotateAroundXY$1();
	Line.SetToAngle = requireSetToAngle();
	Line.Slope = requireSlope();
	Line.Width = requireWidth();

	line = Line;
	return line;
}

var ParseObj_1;
var hasRequiredParseObj;

function requireParseObj () {
	if (hasRequiredParseObj) return ParseObj_1;
	hasRequiredParseObj = 1;
	var flip = true;

	var defaultModelName = 'untitled';
	var currentGroup = '';
	var currentMaterial = '';

	function stripComments (line)
	{
	    var idx = line.indexOf('#');

	    return (idx > -1) ? line.substring(0, idx) : line;
	}

	function currentModel (result)
	{
	    if (result.models.length === 0)
	    {
	        result.models.push({
	            faces: [],
	            name: defaultModelName,
	            textureCoords: [],
	            vertexNormals: [],
	            vertices: []
	        });
	    }

	    currentGroup = '';

	    return result.models[result.models.length - 1];
	}

	function parseObject (lineItems, result)
	{
	    var modelName = lineItems.length >= 2 ? lineItems[1] : defaultModelName;

	    result.models.push({
	        faces: [],
	        name: modelName,
	        textureCoords: [],
	        vertexNormals: [],
	        vertices: []
	    });

	    currentGroup = '';
	}

	function parseGroup (lineItems)
	{
	    if (lineItems.length === 2)
	    {
	        currentGroup = lineItems[1];
	    }
	}

	function parseVertexCoords (lineItems, result)
	{
	    var len = lineItems.length;

	    var x = (len >= 2) ? parseFloat(lineItems[1]) : 0;
	    var y = (len >= 3) ? parseFloat(lineItems[2]) : 0;
	    var z = (len >= 4) ? parseFloat(lineItems[3]) : 0;

	    currentModel(result).vertices.push({ x: x, y: y, z: z });
	}

	function parseTextureCoords (lineItems, result)
	{
	    var len = lineItems.length;

	    var u = (len >= 2) ? parseFloat(lineItems[1]) : 0;
	    var v = (len >= 3) ? parseFloat(lineItems[2]) : 0;
	    var w = (len >= 4) ? parseFloat(lineItems[3]) : 0;

	    if (isNaN(u))
	    {
	        u = 0;
	    }

	    if (isNaN(v))
	    {
	        v = 0;
	    }

	    if (isNaN(w))
	    {
	        w = 0;
	    }

	    if (flip)
	    {
	        v = 1 - v;
	    }

	    currentModel(result).textureCoords.push({ u: u, v: v, w: w });
	}

	function parseVertexNormal (lineItems, result)
	{
	    var len = lineItems.length;

	    var x = (len >= 2) ? parseFloat(lineItems[1]) : 0;
	    var y = (len >= 3) ? parseFloat(lineItems[2]) : 0;
	    var z = (len >= 4) ? parseFloat(lineItems[3]) : 0;

	    currentModel(result).vertexNormals.push({ x: x, y: y, z: z });
	}

	function parsePolygon (lineItems, result)
	{
	    var totalVertices = lineItems.length - 1;

	    if (totalVertices < 3)
	    {
	        return;
	    }

	    var face = {
	        group: currentGroup,
	        material: currentMaterial,
	        vertices: []
	    };

	    for (var i = 0; i < totalVertices; i++)
	    {
	        var vertexString = lineItems[i + 1];
	        var vertexValues = vertexString.split('/');
	        var vvLen = vertexValues.length;

	        if (vvLen < 1 || vvLen > 3)
	        {
	            continue;
	        }

	        var vertexIndex = 0;
	        var textureCoordsIndex = 0;
	        var vertexNormalIndex = 0;

	        vertexIndex = parseInt(vertexValues[0], 10);

	        if (vvLen > 1 && vertexValues[1] !== '')
	        {
	            textureCoordsIndex = parseInt(vertexValues[1], 10);
	        }

	        if (vvLen > 2)
	        {
	            vertexNormalIndex = parseInt(vertexValues[2], 10);
	        }

	        if (vertexIndex !== 0)
	        {

	            if (vertexIndex < 0)
	            {
	                vertexIndex = currentModel(result).vertices.length + 1 + vertexIndex;
	            }

	            textureCoordsIndex -= 1;
	            vertexIndex -= 1;
	            vertexNormalIndex -= 1;

	            face.vertices.push({
	                textureCoordsIndex: textureCoordsIndex,
	                vertexIndex: vertexIndex,
	                vertexNormalIndex: vertexNormalIndex
	            });
	        }
	    }

	    currentModel(result).faces.push(face);
	}

	function parseMtlLib (lineItems, result)
	{
	    if (lineItems.length >= 2)
	    {
	        result.materialLibraries.push(lineItems[1]);
	    }
	}

	function parseUseMtl (lineItems)
	{
	    if (lineItems.length >= 2)
	    {
	        currentMaterial = lineItems[1];
	    }
	}

	var ParseObj = function (data, flipUV)
	{
	    if (flipUV === undefined) { flipUV = true; }

	    flip = flipUV;

	    var result = {
	        materials: {},
	        materialLibraries: [],
	        models: []
	    };

	    currentGroup = '';
	    currentMaterial = '';

	    var lines = data.split('\n');

	    for (var i = 0; i < lines.length; i++)
	    {
	        var line = stripComments(lines[i]);

	        var lineItems = line.replace(/\s\s+/g, ' ').trim().split(' ');

	        switch (lineItems[0].toLowerCase())
	        {
	            case 'o':

	                parseObject(lineItems, result);
	                break;

	            case 'g':

	                parseGroup(lineItems);
	                break;

	            case 'v':

	                parseVertexCoords(lineItems, result);
	                break;

	            case 'vt':

	                parseTextureCoords(lineItems, result);
	                break;

	            case 'vn':

	                parseVertexNormal(lineItems, result);
	                break;

	            case 'f':

	                parsePolygon(lineItems, result);
	                break;

	            case 'mtllib':

	                parseMtlLib(lineItems, result);
	                break;

	            case 'usemtl':

	                parseUseMtl(lineItems);
	                break;
	        }
	    }

	    return result;
	};

	ParseObj_1 = ParseObj;
	return ParseObj_1;
}

var ParseObjMaterial_1;
var hasRequiredParseObjMaterial;

function requireParseObjMaterial () {
	if (hasRequiredParseObjMaterial) return ParseObjMaterial_1;
	hasRequiredParseObjMaterial = 1;
	var GetColor = requireGetColor();

	var ParseObjMaterial = function (mtl)
	{
	    var output = {};

	    var lines = mtl.split('\n');

	    var currentMaterial = '';

	    for (var i = 0; i < lines.length; i++)
	    {
	        var line = lines[i].trim();

	        if (line.indexOf('#') === 0 || line === '')
	        {
	            continue;
	        }

	        var lineItems = line.replace(/\s\s+/g, ' ').trim().split(' ');

	        switch (lineItems[0].toLowerCase())
	        {
	            case 'newmtl':
	            {
	                currentMaterial = lineItems[1];
	                break;
	            }

	            case 'kd':
	            {
	                var r = Math.floor(lineItems[1] * 255);
	                var g = (lineItems.length >= 2) ? Math.floor(lineItems[2] * 255) : r;
	                var b = (lineItems.length >= 3) ? Math.floor(lineItems[3] * 255) : r;

	                output[currentMaterial] = GetColor(r, g, b);

	                break;
	            }
	        }
	    }

	    return output;
	};

	ParseObjMaterial_1 = ParseObjMaterial;
	return ParseObjMaterial_1;
}

var RotateFace_1;
var hasRequiredRotateFace;

function requireRotateFace () {
	if (hasRequiredRotateFace) return RotateFace_1;
	hasRequiredRotateFace = 1;
	var RotateFace = function (face, angle, cx, cy)
	{
	    var x;
	    var y;

	    if (cx === undefined && cy === undefined)
	    {
	        var inCenter = face.getInCenter();

	        x = inCenter.x;
	        y = inCenter.y;
	    }

	    var c = Math.cos(angle);
	    var s = Math.sin(angle);

	    var v1 = face.vertex1;
	    var v2 = face.vertex2;
	    var v3 = face.vertex3;

	    var tx = v1.x - x;
	    var ty = v1.y - y;

	    v1.set(tx * c - ty * s + x, tx * s + ty * c + y);

	    tx = v2.x - x;
	    ty = v2.y - y;

	    v2.set(tx * c - ty * s + x, tx * s + ty * c + y);

	    tx = v3.x - x;
	    ty = v3.y - y;

	    v3.set(tx * c - ty * s + x, tx * s + ty * c + y);
	};

	RotateFace_1 = RotateFace;
	return RotateFace_1;
}

var mesh;
var hasRequiredMesh;

function requireMesh () {
	if (hasRequiredMesh) return mesh;
	hasRequiredMesh = 1;
	var Mesh = {

	    Face: requireFace(),
	    GenerateGridVerts: requireGenerateGridVerts(),
	    GenerateObjVerts: requireGenerateObjVerts(),
	    GenerateVerts: requireGenerateVerts(),
	    ParseObj: requireParseObj(),
	    ParseObjMaterial: requireParseObjMaterial(),
	    RotateFace: requireRotateFace(),
	    Vertex: requireVertex()

	};

	mesh = Mesh;
	return mesh;
}

var Ceil_1$1;
var hasRequiredCeil$1;

function requireCeil$1 () {
	if (hasRequiredCeil$1) return Ceil_1$1;
	hasRequiredCeil$1 = 1;
	var Ceil = function (point)
	{
	    return point.setTo(Math.ceil(point.x), Math.ceil(point.y));
	};

	Ceil_1$1 = Ceil;
	return Ceil_1$1;
}

var Clone_1$3;
var hasRequiredClone$3;

function requireClone$3 () {
	if (hasRequiredClone$3) return Clone_1$3;
	hasRequiredClone$3 = 1;
	var Point = requirePoint$1();

	var Clone = function (source)
	{
	    return new Point(source.x, source.y);
	};

	Clone_1$3 = Clone;
	return Clone_1$3;
}

var CopyFrom_1$1;
var hasRequiredCopyFrom$1;

function requireCopyFrom$1 () {
	if (hasRequiredCopyFrom$1) return CopyFrom_1$1;
	hasRequiredCopyFrom$1 = 1;
	var CopyFrom = function (source, dest)
	{
	    return dest.setTo(source.x, source.y);
	};

	CopyFrom_1$1 = CopyFrom;
	return CopyFrom_1$1;
}

var Equals_1$2;
var hasRequiredEquals$2;

function requireEquals$2 () {
	if (hasRequiredEquals$2) return Equals_1$2;
	hasRequiredEquals$2 = 1;
	var Equals = function (point, toCompare)
	{
	    return (point.x === toCompare.x && point.y === toCompare.y);
	};

	Equals_1$2 = Equals;
	return Equals_1$2;
}

var Floor_1$1;
var hasRequiredFloor$1;

function requireFloor$1 () {
	if (hasRequiredFloor$1) return Floor_1$1;
	hasRequiredFloor$1 = 1;
	var Floor = function (point)
	{
	    return point.setTo(Math.floor(point.x), Math.floor(point.y));
	};

	Floor_1$1 = Floor;
	return Floor_1$1;
}

var GetCentroid_1;
var hasRequiredGetCentroid;

function requireGetCentroid () {
	if (hasRequiredGetCentroid) return GetCentroid_1;
	hasRequiredGetCentroid = 1;
	var Point = requirePoint$1();

	var GetCentroid = function (points, out)
	{
	    if (out === undefined) { out = new Point(); }

	    if (!Array.isArray(points))
	    {
	        throw new Error('GetCentroid points argument must be an array');
	    }

	    var len = points.length;

	    if (len < 1)
	    {
	        throw new Error('GetCentroid points array must not be empty');
	    }
	    else if (len === 1)
	    {
	        out.x = points[0].x;
	        out.y = points[0].y;
	    }
	    else
	    {
	        for (var i = 0; i < len; i++)
	        {
	            out.x += points[i].x;
	            out.y += points[i].y;
	        }

	        out.x /= len;
	        out.y /= len;
	    }

	    return out;
	};

	GetCentroid_1 = GetCentroid;
	return GetCentroid_1;
}

var GetMagnitude_1;
var hasRequiredGetMagnitude;

function requireGetMagnitude () {
	if (hasRequiredGetMagnitude) return GetMagnitude_1;
	hasRequiredGetMagnitude = 1;
	var GetMagnitude = function (point)
	{
	    return Math.sqrt((point.x * point.x) + (point.y * point.y));
	};

	GetMagnitude_1 = GetMagnitude;
	return GetMagnitude_1;
}

var GetMagnitudeSq_1;
var hasRequiredGetMagnitudeSq;

function requireGetMagnitudeSq () {
	if (hasRequiredGetMagnitudeSq) return GetMagnitudeSq_1;
	hasRequiredGetMagnitudeSq = 1;
	var GetMagnitudeSq = function (point)
	{
	    return (point.x * point.x) + (point.y * point.y);
	};

	GetMagnitudeSq_1 = GetMagnitudeSq;
	return GetMagnitudeSq_1;
}

var GetRectangleFromPoints_1;
var hasRequiredGetRectangleFromPoints;

function requireGetRectangleFromPoints () {
	if (hasRequiredGetRectangleFromPoints) return GetRectangleFromPoints_1;
	hasRequiredGetRectangleFromPoints = 1;
	var Rectangle = requireRectangle$2();

	var GetRectangleFromPoints = function (points, out)
	{
	    if (out === undefined) { out = new Rectangle(); }

	    var xMax = Number.NEGATIVE_INFINITY;
	    var xMin = Number.POSITIVE_INFINITY;
	    var yMax = Number.NEGATIVE_INFINITY;
	    var yMin = Number.POSITIVE_INFINITY;

	    for (var i = 0; i < points.length; i++)
	    {
	        var point = points[i];

	        if (point.x > xMax)
	        {
	            xMax = point.x;
	        }

	        if (point.x < xMin)
	        {
	            xMin = point.x;
	        }

	        if (point.y > yMax)
	        {
	            yMax = point.y;
	        }

	        if (point.y < yMin)
	        {
	            yMin = point.y;
	        }
	    }

	    out.x = xMin;
	    out.y = yMin;
	    out.width = xMax - xMin;
	    out.height = yMax - yMin;

	    return out;
	};

	GetRectangleFromPoints_1 = GetRectangleFromPoints;
	return GetRectangleFromPoints_1;
}

var Interpolate_1;
var hasRequiredInterpolate;

function requireInterpolate () {
	if (hasRequiredInterpolate) return Interpolate_1;
	hasRequiredInterpolate = 1;
	var Point = requirePoint$1();

	var Interpolate = function (pointA, pointB, t, out)
	{
	    if (t === undefined) { t = 0; }
	    if (out === undefined) { out = new Point(); }

	    out.x = pointA.x + ((pointB.x - pointA.x) * t);
	    out.y = pointA.y + ((pointB.y - pointA.y) * t);

	    return out;
	};

	Interpolate_1 = Interpolate;
	return Interpolate_1;
}

var Invert_1;
var hasRequiredInvert;

function requireInvert () {
	if (hasRequiredInvert) return Invert_1;
	hasRequiredInvert = 1;
	var Invert = function (point)
	{
	    return point.setTo(point.y, point.x);
	};

	Invert_1 = Invert;
	return Invert_1;
}

var Negative_1;
var hasRequiredNegative;

function requireNegative () {
	if (hasRequiredNegative) return Negative_1;
	hasRequiredNegative = 1;
	var Point = requirePoint$1();

	var Negative = function (point, out)
	{
	    if (out === undefined) { out = new Point(); }

	    return out.setTo(-point.x, -point.y);
	};

	Negative_1 = Negative;
	return Negative_1;
}

var Project_1;
var hasRequiredProject;

function requireProject () {
	if (hasRequiredProject) return Project_1;
	hasRequiredProject = 1;
	var Point = requirePoint$1();
	var GetMagnitudeSq = requireGetMagnitudeSq();

	var Project = function (pointA, pointB, out)
	{
	    if (out === undefined) { out = new Point(); }

	    var dot = ((pointA.x * pointB.x) + (pointA.y * pointB.y));
	    var amt = dot / GetMagnitudeSq(pointB);

	    if (amt !== 0)
	    {
	        out.x = amt * pointB.x;
	        out.y = amt * pointB.y;
	    }

	    return out;
	};

	Project_1 = Project;
	return Project_1;
}

var ProjectUnit_1;
var hasRequiredProjectUnit;

function requireProjectUnit () {
	if (hasRequiredProjectUnit) return ProjectUnit_1;
	hasRequiredProjectUnit = 1;
	var Point = requirePoint$1();

	var ProjectUnit = function (pointA, pointB, out)
	{
	    if (out === undefined) { out = new Point(); }

	    var amt = ((pointA.x * pointB.x) + (pointA.y * pointB.y));

	    if (amt !== 0)
	    {
	        out.x = amt * pointB.x;
	        out.y = amt * pointB.y;
	    }

	    return out;
	};

	ProjectUnit_1 = ProjectUnit;
	return ProjectUnit_1;
}

var SetMagnitude_1;
var hasRequiredSetMagnitude;

function requireSetMagnitude () {
	if (hasRequiredSetMagnitude) return SetMagnitude_1;
	hasRequiredSetMagnitude = 1;
	var GetMagnitude = requireGetMagnitude();

	var SetMagnitude = function (point, magnitude)
	{
	    if (point.x !== 0 || point.y !== 0)
	    {
	        var m = GetMagnitude(point);

	        point.x /= m;
	        point.y /= m;
	    }

	    point.x *= magnitude;
	    point.y *= magnitude;

	    return point;
	};

	SetMagnitude_1 = SetMagnitude;
	return SetMagnitude_1;
}

var point;
var hasRequiredPoint;

function requirePoint () {
	if (hasRequiredPoint) return point;
	hasRequiredPoint = 1;
	var Point = requirePoint$1();

	Point.Ceil = requireCeil$1();
	Point.Clone = requireClone$3();
	Point.CopyFrom = requireCopyFrom$1();
	Point.Equals = requireEquals$2();
	Point.Floor = requireFloor$1();
	Point.GetCentroid = requireGetCentroid();
	Point.GetMagnitude = requireGetMagnitude();
	Point.GetMagnitudeSq = requireGetMagnitudeSq();
	Point.GetRectangleFromPoints = requireGetRectangleFromPoints();
	Point.Interpolate = requireInterpolate();
	Point.Invert = requireInvert();
	Point.Negative = requireNegative();
	Point.Project = requireProject();
	Point.ProjectUnit = requireProjectUnit();
	Point.SetMagnitude = requireSetMagnitude();

	point = Point;
	return point;
}

var Clone_1$2;
var hasRequiredClone$2;

function requireClone$2 () {
	if (hasRequiredClone$2) return Clone_1$2;
	hasRequiredClone$2 = 1;
	var Polygon = requirePolygon$2();

	var Clone = function (polygon)
	{
	    return new Polygon(polygon.points);
	};

	Clone_1$2 = Clone;
	return Clone_1$2;
}

var ContainsPoint_1$2;
var hasRequiredContainsPoint$2;

function requireContainsPoint$2 () {
	if (hasRequiredContainsPoint$2) return ContainsPoint_1$2;
	hasRequiredContainsPoint$2 = 1;
	var Contains = requireContains$1();

	var ContainsPoint = function (polygon, point)
	{
	    return Contains(polygon, point.x, point.y);
	};

	ContainsPoint_1$2 = ContainsPoint;
	return ContainsPoint_1$2;
}

var GetNumberArray_1;
var hasRequiredGetNumberArray;

function requireGetNumberArray () {
	if (hasRequiredGetNumberArray) return GetNumberArray_1;
	hasRequiredGetNumberArray = 1;
	var GetNumberArray = function (polygon, output)
	{
	    if (output === undefined) { output = []; }

	    for (var i = 0; i < polygon.points.length; i++)
	    {
	        output.push(polygon.points[i].x);
	        output.push(polygon.points[i].y);
	    }

	    return output;
	};

	GetNumberArray_1 = GetNumberArray;
	return GetNumberArray_1;
}

var Reverse_1$1;
var hasRequiredReverse$1;

function requireReverse$1 () {
	if (hasRequiredReverse$1) return Reverse_1$1;
	hasRequiredReverse$1 = 1;
	var Reverse = function (polygon)
	{
	    polygon.points.reverse();

	    return polygon;
	};

	Reverse_1$1 = Reverse;
	return Reverse_1$1;
}

var Simplify_1;
var hasRequiredSimplify;

function requireSimplify () {
	if (hasRequiredSimplify) return Simplify_1;
	hasRequiredSimplify = 1;
	function getSqDist (p1, p2)
	{
	    var dx = p1.x - p2.x,
	        dy = p1.y - p2.y;

	    return dx * dx + dy * dy;
	}

	function getSqSegDist (p, p1, p2)
	{
	    var x = p1.x,
	        y = p1.y,
	        dx = p2.x - x,
	        dy = p2.y - y;

	    if (dx !== 0 || dy !== 0)
	    {
	        var t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);

	        if (t > 1)
	        {
	            x = p2.x;
	            y = p2.y;
	        }
	        else if (t > 0)
	        {
	            x += dx * t;
	            y += dy * t;
	        }
	    }

	    dx = p.x - x;
	    dy = p.y - y;

	    return dx * dx + dy * dy;
	}

	function simplifyRadialDist (points, sqTolerance)
	{
	    var prevPoint = points[0],
	        newPoints = [ prevPoint ],
	        point;

	    for (var i = 1, len = points.length; i < len; i++)
	    {
	        point = points[i];

	        if (getSqDist(point, prevPoint) > sqTolerance)
	        {
	            newPoints.push(point);
	            prevPoint = point;
	        }
	    }

	    if (prevPoint !== point)
	    {
	        newPoints.push(point);
	    }

	    return newPoints;
	}

	function simplifyDPStep (points, first, last, sqTolerance, simplified)
	{
	    var maxSqDist = sqTolerance,
	        index;

	    for (var i = first + 1; i < last; i++)
	    {
	        var sqDist = getSqSegDist(points[i], points[first], points[last]);

	        if (sqDist > maxSqDist)
	        {
	            index = i;
	            maxSqDist = sqDist;
	        }
	    }

	    if (maxSqDist > sqTolerance)
	    {
	        if (index - first > 1)
	        {
	            simplifyDPStep(points, first, index, sqTolerance, simplified);
	        }

	        simplified.push(points[index]);

	        if (last - index > 1)
	        {
	            simplifyDPStep(points, index, last, sqTolerance, simplified);
	        }
	    }
	}

	function simplifyDouglasPeucker (points, sqTolerance)
	{
	    var last = points.length - 1;

	    var simplified = [ points[0] ];

	    simplifyDPStep(points, 0, last, sqTolerance, simplified);

	    simplified.push(points[last]);

	    return simplified;
	}

	var Simplify = function (polygon, tolerance, highestQuality)
	{
	    if (tolerance === undefined) { tolerance = 1; }
	    if (highestQuality === undefined) { highestQuality = false; }

	    var points = polygon.points;

	    if (points.length > 2)
	    {
	        var sqTolerance = tolerance * tolerance;

	        if (!highestQuality)
	        {
	            points = simplifyRadialDist(points, sqTolerance);
	        }

	        polygon.setTo(simplifyDouglasPeucker(points, sqTolerance));
	    }

	    return polygon;
	};

	Simplify_1 = Simplify;
	return Simplify_1;
}

var Translate_1;
var hasRequiredTranslate;

function requireTranslate () {
	if (hasRequiredTranslate) return Translate_1;
	hasRequiredTranslate = 1;
	var Translate = function (polygon, x, y)
	{
	    var points = polygon.points;

	    for (var i = 0; i < points.length; i++)
	    {
	        points[i].x += x;
	        points[i].y += y;
	    }

	    return polygon;
	};

	Translate_1 = Translate;
	return Translate_1;
}

var polygon;
var hasRequiredPolygon;

function requirePolygon () {
	if (hasRequiredPolygon) return polygon;
	hasRequiredPolygon = 1;
	var Polygon = requirePolygon$2();

	Polygon.Clone = requireClone$2();
	Polygon.Contains = requireContains$1();
	Polygon.ContainsPoint = requireContainsPoint$2();
	Polygon.Earcut = requireEarcut();
	Polygon.GetAABB = requireGetAABB();
	Polygon.GetNumberArray = requireGetNumberArray();
	Polygon.GetPoints = requireGetPoints$1();
	Polygon.Perimeter = requirePerimeter$1();
	Polygon.Reverse = requireReverse$1();
	Polygon.Simplify = requireSimplify();
	Polygon.Smooth = requireSmooth();
	Polygon.Translate = requireTranslate();

	polygon = Polygon;
	return polygon;
}

var Area_1$1;
var hasRequiredArea$1;

function requireArea$1 () {
	if (hasRequiredArea$1) return Area_1$1;
	hasRequiredArea$1 = 1;
	var Area = function (rect)
	{
	    return rect.width * rect.height;
	};

	Area_1$1 = Area;
	return Area_1$1;
}

var Ceil_1;
var hasRequiredCeil;

function requireCeil () {
	if (hasRequiredCeil) return Ceil_1;
	hasRequiredCeil = 1;
	var Ceil = function (rect)
	{
	    rect.x = Math.ceil(rect.x);
	    rect.y = Math.ceil(rect.y);

	    return rect;
	};

	Ceil_1 = Ceil;
	return Ceil_1;
}

var CeilAll_1;
var hasRequiredCeilAll;

function requireCeilAll () {
	if (hasRequiredCeilAll) return CeilAll_1;
	hasRequiredCeilAll = 1;
	var CeilAll = function (rect)
	{
	    rect.x = Math.ceil(rect.x);
	    rect.y = Math.ceil(rect.y);
	    rect.width = Math.ceil(rect.width);
	    rect.height = Math.ceil(rect.height);

	    return rect;
	};

	CeilAll_1 = CeilAll;
	return CeilAll_1;
}

var Clone_1$1;
var hasRequiredClone$1;

function requireClone$1 () {
	if (hasRequiredClone$1) return Clone_1$1;
	hasRequiredClone$1 = 1;
	var Rectangle = requireRectangle$2();

	var Clone = function (source)
	{
	    return new Rectangle(source.x, source.y, source.width, source.height);
	};

	Clone_1$1 = Clone;
	return Clone_1$1;
}

var ContainsPoint_1$1;
var hasRequiredContainsPoint$1;

function requireContainsPoint$1 () {
	if (hasRequiredContainsPoint$1) return ContainsPoint_1$1;
	hasRequiredContainsPoint$1 = 1;
	var Contains = requireContains$3();

	var ContainsPoint = function (rect, point)
	{
	    return Contains(rect, point.x, point.y);
	};

	ContainsPoint_1$1 = ContainsPoint;
	return ContainsPoint_1$1;
}

var ContainsRect_1;
var hasRequiredContainsRect;

function requireContainsRect () {
	if (hasRequiredContainsRect) return ContainsRect_1;
	hasRequiredContainsRect = 1;
	var ContainsRect = function (rectA, rectB)
	{

	    if ((rectB.width * rectB.height) > (rectA.width * rectA.height))
	    {
	        return false;
	    }

	    return (
	        (rectB.x > rectA.x && rectB.x < rectA.right) &&
	        (rectB.right > rectA.x && rectB.right < rectA.right) &&
	        (rectB.y > rectA.y && rectB.y < rectA.bottom) &&
	        (rectB.bottom > rectA.y && rectB.bottom < rectA.bottom)
	    );
	};

	ContainsRect_1 = ContainsRect;
	return ContainsRect_1;
}

var Equals_1$1;
var hasRequiredEquals$1;

function requireEquals$1 () {
	if (hasRequiredEquals$1) return Equals_1$1;
	hasRequiredEquals$1 = 1;
	var Equals = function (rect, toCompare)
	{
	    return (
	        rect.x === toCompare.x &&
	        rect.y === toCompare.y &&
	        rect.width === toCompare.width &&
	        rect.height === toCompare.height
	    );
	};

	Equals_1$1 = Equals;
	return Equals_1$1;
}

var GetAspectRatio_1;
var hasRequiredGetAspectRatio;

function requireGetAspectRatio () {
	if (hasRequiredGetAspectRatio) return GetAspectRatio_1;
	hasRequiredGetAspectRatio = 1;
	var GetAspectRatio = function (rect)
	{
	    return (rect.height === 0) ? NaN : rect.width / rect.height;
	};

	GetAspectRatio_1 = GetAspectRatio;
	return GetAspectRatio_1;
}

var FitInside_1;
var hasRequiredFitInside;

function requireFitInside () {
	if (hasRequiredFitInside) return FitInside_1;
	hasRequiredFitInside = 1;
	var GetAspectRatio = requireGetAspectRatio();

	var FitInside = function (target, source)
	{
	    var ratio = GetAspectRatio(target);

	    if (ratio < GetAspectRatio(source))
	    {

	        target.setSize(source.height * ratio, source.height);
	    }
	    else
	    {

	        target.setSize(source.width, source.width / ratio);
	    }

	    return target.setPosition(
	        source.centerX - (target.width / 2),
	        source.centerY - (target.height / 2)
	    );
	};

	FitInside_1 = FitInside;
	return FitInside_1;
}

var FitOutside_1;
var hasRequiredFitOutside;

function requireFitOutside () {
	if (hasRequiredFitOutside) return FitOutside_1;
	hasRequiredFitOutside = 1;
	var GetAspectRatio = requireGetAspectRatio();

	var FitOutside = function (target, source)
	{
	    var ratio = GetAspectRatio(target);

	    if (ratio > GetAspectRatio(source))
	    {

	        target.setSize(source.height * ratio, source.height);
	    }
	    else
	    {

	        target.setSize(source.width, source.width / ratio);
	    }

	    return target.setPosition(
	        source.centerX - target.width / 2,
	        source.centerY - target.height / 2
	    );
	};

	FitOutside_1 = FitOutside;
	return FitOutside_1;
}

var Floor_1;
var hasRequiredFloor;

function requireFloor () {
	if (hasRequiredFloor) return Floor_1;
	hasRequiredFloor = 1;
	var Floor = function (rect)
	{
	    rect.x = Math.floor(rect.x);
	    rect.y = Math.floor(rect.y);

	    return rect;
	};

	Floor_1 = Floor;
	return Floor_1;
}

var FloorAll_1;
var hasRequiredFloorAll;

function requireFloorAll () {
	if (hasRequiredFloorAll) return FloorAll_1;
	hasRequiredFloorAll = 1;
	var FloorAll = function (rect)
	{
	    rect.x = Math.floor(rect.x);
	    rect.y = Math.floor(rect.y);
	    rect.width = Math.floor(rect.width);
	    rect.height = Math.floor(rect.height);

	    return rect;
	};

	FloorAll_1 = FloorAll;
	return FloorAll_1;
}

var FromXY_1;
var hasRequiredFromXY;

function requireFromXY () {
	if (hasRequiredFromXY) return FromXY_1;
	hasRequiredFromXY = 1;
	var Rectangle = requireRectangle$2();

	var FromXY = function (x1, y1, x2, y2, out)
	{
	    if (out === undefined) { out = new Rectangle(); }

	    return out.setTo(
	        Math.min(x1, x2),
	        Math.min(y1, y2),
	        Math.abs(x1 - x2),
	        Math.abs(y1 - y2)
	    );
	};

	FromXY_1 = FromXY;
	return FromXY_1;
}

var GetCenter_1;
var hasRequiredGetCenter;

function requireGetCenter () {
	if (hasRequiredGetCenter) return GetCenter_1;
	hasRequiredGetCenter = 1;
	var Point = requirePoint$1();

	var GetCenter = function (rect, out)
	{
	    if (out === undefined) { out = new Point(); }

	    out.x = rect.centerX;
	    out.y = rect.centerY;

	    return out;
	};

	GetCenter_1 = GetCenter;
	return GetCenter_1;
}

var GetSize_1;
var hasRequiredGetSize;

function requireGetSize () {
	if (hasRequiredGetSize) return GetSize_1;
	hasRequiredGetSize = 1;
	var Point = requirePoint$1();

	var GetSize = function (rect, out)
	{
	    if (out === undefined) { out = new Point(); }

	    out.x = rect.width;
	    out.y = rect.height;

	    return out;
	};

	GetSize_1 = GetSize;
	return GetSize_1;
}

var Intersection_1;
var hasRequiredIntersection;

function requireIntersection () {
	if (hasRequiredIntersection) return Intersection_1;
	hasRequiredIntersection = 1;
	var Rectangle = requireRectangle$2();
	var Intersects = requireRectangleToRectangle();

	var Intersection = function (rectA, rectB, out)
	{
	    if (out === undefined) { out = new Rectangle(); }

	    if (Intersects(rectA, rectB))
	    {
	        out.x = Math.max(rectA.x, rectB.x);
	        out.y = Math.max(rectA.y, rectB.y);
	        out.width = Math.min(rectA.right, rectB.right) - out.x;
	        out.height = Math.min(rectA.bottom, rectB.bottom) - out.y;
	    }
	    else
	    {
	        out.setEmpty();
	    }

	    return out;
	};

	Intersection_1 = Intersection;
	return Intersection_1;
}

var MergePoints_1;
var hasRequiredMergePoints;

function requireMergePoints () {
	if (hasRequiredMergePoints) return MergePoints_1;
	hasRequiredMergePoints = 1;
	var MergePoints = function (target, points)
	{
	    var minX = target.x;
	    var maxX = target.right;
	    var minY = target.y;
	    var maxY = target.bottom;

	    for (var i = 0; i < points.length; i++)
	    {
	        minX = Math.min(minX, points[i].x);
	        maxX = Math.max(maxX, points[i].x);
	        minY = Math.min(minY, points[i].y);
	        maxY = Math.max(maxY, points[i].y);
	    }

	    target.x = minX;
	    target.y = minY;
	    target.width = maxX - minX;
	    target.height = maxY - minY;

	    return target;
	};

	MergePoints_1 = MergePoints;
	return MergePoints_1;
}

var MergeXY_1;
var hasRequiredMergeXY;

function requireMergeXY () {
	if (hasRequiredMergeXY) return MergeXY_1;
	hasRequiredMergeXY = 1;
	var MergeXY = function (target, x, y)
	{
	    var minX = Math.min(target.x, x);
	    var maxX = Math.max(target.right, x);

	    target.x = minX;
	    target.width = maxX - minX;

	    var minY = Math.min(target.y, y);
	    var maxY = Math.max(target.bottom, y);

	    target.y = minY;
	    target.height = maxY - minY;

	    return target;
	};

	MergeXY_1 = MergeXY;
	return MergeXY_1;
}

var Offset_1$1;
var hasRequiredOffset$1;

function requireOffset$1 () {
	if (hasRequiredOffset$1) return Offset_1$1;
	hasRequiredOffset$1 = 1;
	var Offset = function (rect, x, y)
	{
	    rect.x += x;
	    rect.y += y;

	    return rect;
	};

	Offset_1$1 = Offset;
	return Offset_1$1;
}

var OffsetPoint_1;
var hasRequiredOffsetPoint;

function requireOffsetPoint () {
	if (hasRequiredOffsetPoint) return OffsetPoint_1;
	hasRequiredOffsetPoint = 1;
	var OffsetPoint = function (rect, point)
	{
	    rect.x += point.x;
	    rect.y += point.y;

	    return rect;
	};

	OffsetPoint_1 = OffsetPoint;
	return OffsetPoint_1;
}

var Overlaps_1;
var hasRequiredOverlaps;

function requireOverlaps () {
	if (hasRequiredOverlaps) return Overlaps_1;
	hasRequiredOverlaps = 1;
	var Overlaps = function (rectA, rectB)
	{
	    return (
	        rectA.x < rectB.right &&
	        rectA.right > rectB.x &&
	        rectA.y < rectB.bottom &&
	        rectA.bottom > rectB.y
	    );
	};

	Overlaps_1 = Overlaps;
	return Overlaps_1;
}

var PerimeterPoint_1;
var hasRequiredPerimeterPoint;

function requirePerimeterPoint () {
	if (hasRequiredPerimeterPoint) return PerimeterPoint_1;
	hasRequiredPerimeterPoint = 1;
	var Point = requirePoint$1();
	var DegToRad = requireDegToRad();

	var PerimeterPoint = function (rectangle, angle, out)
	{
	    if (out === undefined) { out = new Point(); }

	    angle = DegToRad(angle);

	    var s = Math.sin(angle);
	    var c = Math.cos(angle);

	    var dx = (c > 0) ? rectangle.width / 2 : rectangle.width / -2;
	    var dy = (s > 0) ? rectangle.height / 2 : rectangle.height / -2;

	    if (Math.abs(dx * s) < Math.abs(dy * c))
	    {
	        dy = (dx * s) / c;
	    }
	    else
	    {
	        dx = (dy * c) / s;
	    }

	    out.x = dx + rectangle.centerX;
	    out.y = dy + rectangle.centerY;

	    return out;
	};

	PerimeterPoint_1 = PerimeterPoint;
	return PerimeterPoint_1;
}

var RandomOutside_1;
var hasRequiredRandomOutside;

function requireRandomOutside () {
	if (hasRequiredRandomOutside) return RandomOutside_1;
	hasRequiredRandomOutside = 1;
	var Between = requireBetween$1();
	var ContainsRect = requireContainsRect();
	var Point = requirePoint$1();

	var RandomOutside = function (outer, inner, out)
	{
	    if (out === undefined) { out = new Point(); }

	    if (ContainsRect(outer, inner))
	    {

	        switch (Between(0, 3))
	        {
	            case 0: 
	                out.x = outer.x + (Math.random() * (inner.right - outer.x));
	                out.y = outer.y + (Math.random() * (inner.top - outer.y));
	                break;

	            case 1: 
	                out.x = inner.x + (Math.random() * (outer.right - inner.x));
	                out.y = inner.bottom + (Math.random() * (outer.bottom - inner.bottom));
	                break;

	            case 2: 
	                out.x = outer.x + (Math.random() * (inner.x - outer.x));
	                out.y = inner.y + (Math.random() * (outer.bottom - inner.y));
	                break;

	            case 3: 
	                out.x = inner.right + (Math.random() * (outer.right - inner.right));
	                out.y = outer.y + (Math.random() * (inner.bottom - outer.y));
	                break;
	        }
	    }

	    return out;
	};

	RandomOutside_1 = RandomOutside;
	return RandomOutside_1;
}

var SameDimensions_1;
var hasRequiredSameDimensions;

function requireSameDimensions () {
	if (hasRequiredSameDimensions) return SameDimensions_1;
	hasRequiredSameDimensions = 1;
	var SameDimensions = function (rect, toCompare)
	{
	    return (rect.width === toCompare.width && rect.height === toCompare.height);
	};

	SameDimensions_1 = SameDimensions;
	return SameDimensions_1;
}

var Scale_1;
var hasRequiredScale$1;

function requireScale$1 () {
	if (hasRequiredScale$1) return Scale_1;
	hasRequiredScale$1 = 1;
	var Scale = function (rect, x, y)
	{
	    if (y === undefined) { y = x; }

	    rect.width *= x;
	    rect.height *= y;

	    return rect;
	};

	Scale_1 = Scale;
	return Scale_1;
}

var rectangle;
var hasRequiredRectangle;

function requireRectangle () {
	if (hasRequiredRectangle) return rectangle;
	hasRequiredRectangle = 1;
	var Rectangle = requireRectangle$2();

	Rectangle.Area = requireArea$1();
	Rectangle.Ceil = requireCeil();
	Rectangle.CeilAll = requireCeilAll();
	Rectangle.CenterOn = requireCenterOn$2();
	Rectangle.Clone = requireClone$1();
	Rectangle.Contains = requireContains$3();
	Rectangle.ContainsPoint = requireContainsPoint$1();
	Rectangle.ContainsRect = requireContainsRect();
	Rectangle.CopyFrom = requireCopyFrom$5();
	Rectangle.Decompose = requireDecompose$1();
	Rectangle.Equals = requireEquals$1();
	Rectangle.FitInside = requireFitInside();
	Rectangle.FitOutside = requireFitOutside();
	Rectangle.Floor = requireFloor();
	Rectangle.FloorAll = requireFloorAll();
	Rectangle.FromPoints = requireFromPoints();
	Rectangle.FromXY = requireFromXY();
	Rectangle.GetAspectRatio = requireGetAspectRatio();
	Rectangle.GetCenter = requireGetCenter();
	Rectangle.GetPoint = requireGetPoint$3();
	Rectangle.GetPoints = requireGetPoints$4();
	Rectangle.GetSize = requireGetSize();
	Rectangle.Inflate = requireInflate();
	Rectangle.Intersection = requireIntersection();
	Rectangle.MarchingAnts = requireMarchingAnts();
	Rectangle.MergePoints = requireMergePoints();
	Rectangle.MergeRect = requireMergeRect();
	Rectangle.MergeXY = requireMergeXY();
	Rectangle.Offset = requireOffset$1();
	Rectangle.OffsetPoint = requireOffsetPoint();
	Rectangle.Overlaps = requireOverlaps();
	Rectangle.Perimeter = requirePerimeter$2();
	Rectangle.PerimeterPoint = requirePerimeterPoint();
	Rectangle.Random = requireRandom$3();
	Rectangle.RandomOutside = requireRandomOutside();
	Rectangle.SameDimensions = requireSameDimensions();
	Rectangle.Scale = requireScale$1();
	Rectangle.Union = requireUnion();

	rectangle = Rectangle;
	return rectangle;
}

var Area_1;
var hasRequiredArea;

function requireArea () {
	if (hasRequiredArea) return Area_1;
	hasRequiredArea = 1;
	var Area = function (triangle)
	{
	    var x1 = triangle.x1;
	    var y1 = triangle.y1;

	    var x2 = triangle.x2;
	    var y2 = triangle.y2;

	    var x3 = triangle.x3;
	    var y3 = triangle.y3;

	    return Math.abs(((x3 - x1) * (y2 - y1) - (x2 - x1) * (y3 - y1)) / 2);
	};

	Area_1 = Area;
	return Area_1;
}

var BuildEquilateral_1;
var hasRequiredBuildEquilateral;

function requireBuildEquilateral () {
	if (hasRequiredBuildEquilateral) return BuildEquilateral_1;
	hasRequiredBuildEquilateral = 1;
	var Triangle = requireTriangle$2();

	var BuildEquilateral = function (x, y, length)
	{
	    var height = length * (Math.sqrt(3) / 2);

	    var x1 = x;
	    var y1 = y;

	    var x2 = x + (length / 2);
	    var y2 = y + height;

	    var x3 = x - (length / 2);
	    var y3 = y + height;

	    return new Triangle(x1, y1, x2, y2, x3, y3);
	};

	BuildEquilateral_1 = BuildEquilateral;
	return BuildEquilateral_1;
}

var BuildFromPolygon_1;
var hasRequiredBuildFromPolygon;

function requireBuildFromPolygon () {
	if (hasRequiredBuildFromPolygon) return BuildFromPolygon_1;
	hasRequiredBuildFromPolygon = 1;
	var EarCut = requireEarcut();
	var Triangle = requireTriangle$2();

	var BuildFromPolygon = function (data, holes, scaleX, scaleY, out)
	{
	    if (holes === undefined) { holes = null; }
	    if (scaleX === undefined) { scaleX = 1; }
	    if (scaleY === undefined) { scaleY = 1; }
	    if (out === undefined) { out = []; }

	    var tris = EarCut(data, holes);

	    var a;
	    var b;
	    var c;

	    var x1;
	    var y1;

	    var x2;
	    var y2;

	    var x3;
	    var y3;

	    for (var i = 0; i < tris.length; i += 3)
	    {
	        a = tris[i];
	        b = tris[i + 1];
	        c = tris[i + 2];

	        x1 = data[a * 2] * scaleX;
	        y1 = data[(a * 2) + 1] * scaleY;

	        x2 = data[b * 2] * scaleX;
	        y2 = data[(b * 2) + 1] * scaleY;

	        x3 = data[c * 2] * scaleX;
	        y3 = data[(c * 2) + 1] * scaleY;

	        out.push(new Triangle(x1, y1, x2, y2, x3, y3));
	    }

	    return out;
	};

	BuildFromPolygon_1 = BuildFromPolygon;
	return BuildFromPolygon_1;
}

var BuildRight_1;
var hasRequiredBuildRight;

function requireBuildRight () {
	if (hasRequiredBuildRight) return BuildRight_1;
	hasRequiredBuildRight = 1;
	var Triangle = requireTriangle$2();

	var BuildRight = function (x, y, width, height)
	{
	    if (height === undefined) { height = width; }

	    var x1 = x;
	    var y1 = y;

	    var x2 = x;
	    var y2 = y - height;

	    var x3 = x + width;
	    var y3 = y;

	    return new Triangle(x1, y1, x2, y2, x3, y3);
	};

	BuildRight_1 = BuildRight;
	return BuildRight_1;
}

var Centroid_1;
var hasRequiredCentroid;

function requireCentroid () {
	if (hasRequiredCentroid) return Centroid_1;
	hasRequiredCentroid = 1;
	var Point = requirePoint$1();

	var Centroid = function (triangle, out)
	{
	    if (out === undefined) { out = new Point(); }

	    out.x = (triangle.x1 + triangle.x2 + triangle.x3) / 3;
	    out.y = (triangle.y1 + triangle.y2 + triangle.y3) / 3;

	    return out;
	};

	Centroid_1 = Centroid;
	return Centroid_1;
}

var Offset_1;
var hasRequiredOffset;

function requireOffset () {
	if (hasRequiredOffset) return Offset_1;
	hasRequiredOffset = 1;
	var Offset = function (triangle, x, y)
	{
	    triangle.x1 += x;
	    triangle.y1 += y;

	    triangle.x2 += x;
	    triangle.y2 += y;

	    triangle.x3 += x;
	    triangle.y3 += y;

	    return triangle;
	};

	Offset_1 = Offset;
	return Offset_1;
}

var CenterOn_1;
var hasRequiredCenterOn;

function requireCenterOn () {
	if (hasRequiredCenterOn) return CenterOn_1;
	hasRequiredCenterOn = 1;
	var Centroid = requireCentroid();
	var Offset = requireOffset();

	var CenterOn = function (triangle, x, y, centerFunc)
	{
	    if (centerFunc === undefined) { centerFunc = Centroid; }

	    var center = centerFunc(triangle);

	    var diffX = x - center.x;
	    var diffY = y - center.y;

	    return Offset(triangle, diffX, diffY);
	};

	CenterOn_1 = CenterOn;
	return CenterOn_1;
}

var CircumCenter_1;
var hasRequiredCircumCenter;

function requireCircumCenter () {
	if (hasRequiredCircumCenter) return CircumCenter_1;
	hasRequiredCircumCenter = 1;
	var Vector2 = requireVector2();

	function det (m00, m01, m10, m11)
	{
	    return (m00 * m11) - (m01 * m10);
	}

	var CircumCenter = function (triangle, out)
	{
	    if (out === undefined) { out = new Vector2(); }

	    var cx = triangle.x3;
	    var cy = triangle.y3;

	    var ax = triangle.x1 - cx;
	    var ay = triangle.y1 - cy;

	    var bx = triangle.x2 - cx;
	    var by = triangle.y2 - cy;

	    var denom = 2 * det(ax, ay, bx, by);
	    var numx = det(ay, ax * ax + ay * ay, by, bx * bx + by * by);
	    var numy = det(ax, ax * ax + ay * ay, bx, bx * bx + by * by);

	    out.x = cx - numx / denom;
	    out.y = cy + numy / denom;

	    return out;
	};

	CircumCenter_1 = CircumCenter;
	return CircumCenter_1;
}

var CircumCircle_1;
var hasRequiredCircumCircle;

function requireCircumCircle () {
	if (hasRequiredCircumCircle) return CircumCircle_1;
	hasRequiredCircumCircle = 1;
	var Circle = requireCircle$2();

	var CircumCircle = function (triangle, out)
	{
	    if (out === undefined) { out = new Circle(); }

	    var x1 = triangle.x1;
	    var y1 = triangle.y1;

	    var x2 = triangle.x2;
	    var y2 = triangle.y2;

	    var x3 = triangle.x3;
	    var y3 = triangle.y3;

	    var A = x2 - x1;
	    var B = y2 - y1;
	    var C = x3 - x1;
	    var D = y3 - y1;
	    var E = A * (x1 + x2) + B * (y1 + y2);
	    var F = C * (x1 + x3) + D * (y1 + y3);
	    var G = 2 * (A * (y3 - y2) - B * (x3 - x2));

	    var dx;
	    var dy;

	    if (Math.abs(G) < 0.000001)
	    {
	        var minX = Math.min(x1, x2, x3);
	        var minY = Math.min(y1, y2, y3);
	        dx = (Math.max(x1, x2, x3) - minX) * 0.5;
	        dy = (Math.max(y1, y2, y3) - minY) * 0.5;

	        out.x = minX + dx;
	        out.y = minY + dy;
	        out.radius = Math.sqrt(dx * dx + dy * dy);
	    }
	    else
	    {
	        out.x = (D * E - B * F) / G;
	        out.y = (A * F - C * E) / G;
	        dx = out.x - x1;
	        dy = out.y - y1;
	        out.radius = Math.sqrt(dx * dx + dy * dy);
	    }

	    return out;
	};

	CircumCircle_1 = CircumCircle;
	return CircumCircle_1;
}

var Clone_1;
var hasRequiredClone;

function requireClone () {
	if (hasRequiredClone) return Clone_1;
	hasRequiredClone = 1;
	var Triangle = requireTriangle$2();

	var Clone = function (source)
	{
	    return new Triangle(source.x1, source.y1, source.x2, source.y2, source.x3, source.y3);
	};

	Clone_1 = Clone;
	return Clone_1;
}

var ContainsPoint_1;
var hasRequiredContainsPoint;

function requireContainsPoint () {
	if (hasRequiredContainsPoint) return ContainsPoint_1;
	hasRequiredContainsPoint = 1;
	var Contains = requireContains();

	var ContainsPoint = function (triangle, point)
	{
	    return Contains(triangle, point.x, point.y);
	};

	ContainsPoint_1 = ContainsPoint;
	return ContainsPoint_1;
}

var CopyFrom_1;
var hasRequiredCopyFrom;

function requireCopyFrom () {
	if (hasRequiredCopyFrom) return CopyFrom_1;
	hasRequiredCopyFrom = 1;
	var CopyFrom = function (source, dest)
	{
	    return dest.setTo(source.x1, source.y1, source.x2, source.y2, source.x3, source.y3);
	};

	CopyFrom_1 = CopyFrom;
	return CopyFrom_1;
}

var Equals_1;
var hasRequiredEquals;

function requireEquals () {
	if (hasRequiredEquals) return Equals_1;
	hasRequiredEquals = 1;
	var Equals = function (triangle, toCompare)
	{
	    return (
	        triangle.x1 === toCompare.x1 &&
	        triangle.y1 === toCompare.y1 &&
	        triangle.x2 === toCompare.x2 &&
	        triangle.y2 === toCompare.y2 &&
	        triangle.x3 === toCompare.x3 &&
	        triangle.y3 === toCompare.y3
	    );
	};

	Equals_1 = Equals;
	return Equals_1;
}

var InCenter_1;
var hasRequiredInCenter;

function requireInCenter () {
	if (hasRequiredInCenter) return InCenter_1;
	hasRequiredInCenter = 1;
	var Point = requirePoint$1();

	function getLength (x1, y1, x2, y2)
	{
	    var x = x1 - x2;
	    var y = y1 - y2;
	    var magnitude = (x * x) + (y * y);

	    return Math.sqrt(magnitude);
	}

	var InCenter = function (triangle, out)
	{
	    if (out === undefined) { out = new Point(); }

	    var x1 = triangle.x1;
	    var y1 = triangle.y1;

	    var x2 = triangle.x2;
	    var y2 = triangle.y2;

	    var x3 = triangle.x3;
	    var y3 = triangle.y3;

	    var d1 = getLength(x3, y3, x2, y2);
	    var d2 = getLength(x1, y1, x3, y3);
	    var d3 = getLength(x2, y2, x1, y1);

	    var p = d1 + d2 + d3;

	    out.x = (x1 * d1 + x2 * d2 + x3 * d3) / p;
	    out.y = (y1 * d1 + y2 * d2 + y3 * d3) / p;

	    return out;
	};

	InCenter_1 = InCenter;
	return InCenter_1;
}

var Perimeter_1;
var hasRequiredPerimeter;

function requirePerimeter () {
	if (hasRequiredPerimeter) return Perimeter_1;
	hasRequiredPerimeter = 1;
	var Length = requireLength();

	var Perimeter = function (triangle)
	{
	    var line1 = triangle.getLineA();
	    var line2 = triangle.getLineB();
	    var line3 = triangle.getLineC();

	    return (Length(line1) + Length(line2) + Length(line3));
	};

	Perimeter_1 = Perimeter;
	return Perimeter_1;
}

var RotateAroundXY_1;
var hasRequiredRotateAroundXY;

function requireRotateAroundXY () {
	if (hasRequiredRotateAroundXY) return RotateAroundXY_1;
	hasRequiredRotateAroundXY = 1;
	var RotateAroundXY = function (triangle, x, y, angle)
	{
	    var c = Math.cos(angle);
	    var s = Math.sin(angle);

	    var tx = triangle.x1 - x;
	    var ty = triangle.y1 - y;

	    triangle.x1 = tx * c - ty * s + x;
	    triangle.y1 = tx * s + ty * c + y;

	    tx = triangle.x2 - x;
	    ty = triangle.y2 - y;

	    triangle.x2 = tx * c - ty * s + x;
	    triangle.y2 = tx * s + ty * c + y;

	    tx = triangle.x3 - x;
	    ty = triangle.y3 - y;

	    triangle.x3 = tx * c - ty * s + x;
	    triangle.y3 = tx * s + ty * c + y;

	    return triangle;
	};

	RotateAroundXY_1 = RotateAroundXY;
	return RotateAroundXY_1;
}

var Rotate_1;
var hasRequiredRotate;

function requireRotate () {
	if (hasRequiredRotate) return Rotate_1;
	hasRequiredRotate = 1;
	var RotateAroundXY = requireRotateAroundXY();
	var InCenter = requireInCenter();

	var Rotate = function (triangle, angle)
	{
	    var point = InCenter(triangle);

	    return RotateAroundXY(triangle, point.x, point.y, angle);
	};

	Rotate_1 = Rotate;
	return Rotate_1;
}

var RotateAroundPoint_1;
var hasRequiredRotateAroundPoint;

function requireRotateAroundPoint () {
	if (hasRequiredRotateAroundPoint) return RotateAroundPoint_1;
	hasRequiredRotateAroundPoint = 1;
	var RotateAroundXY = requireRotateAroundXY();

	var RotateAroundPoint = function (triangle, point, angle)
	{
	    return RotateAroundXY(triangle, point.x, point.y, angle);
	};

	RotateAroundPoint_1 = RotateAroundPoint;
	return RotateAroundPoint_1;
}

var triangle;
var hasRequiredTriangle;

function requireTriangle () {
	if (hasRequiredTriangle) return triangle;
	hasRequiredTriangle = 1;
	var Triangle = requireTriangle$2();

	Triangle.Area = requireArea();
	Triangle.BuildEquilateral = requireBuildEquilateral();
	Triangle.BuildFromPolygon = requireBuildFromPolygon();
	Triangle.BuildRight = requireBuildRight();
	Triangle.CenterOn = requireCenterOn();
	Triangle.Centroid = requireCentroid();
	Triangle.CircumCenter = requireCircumCenter();
	Triangle.CircumCircle = requireCircumCircle();
	Triangle.Clone = requireClone();
	Triangle.Contains = requireContains();
	Triangle.ContainsArray = requireContainsArray();
	Triangle.ContainsPoint = requireContainsPoint();
	Triangle.CopyFrom = requireCopyFrom();
	Triangle.Decompose = requireDecompose();
	Triangle.Equals = requireEquals();
	Triangle.GetPoint = requireGetPoint();
	Triangle.GetPoints = requireGetPoints();
	Triangle.InCenter = requireInCenter();
	Triangle.Perimeter = requirePerimeter();
	Triangle.Offset = requireOffset();
	Triangle.Random = requireRandom$1();
	Triangle.Rotate = requireRotate();
	Triangle.RotateAroundPoint = requireRotateAroundPoint();
	Triangle.RotateAroundXY = requireRotateAroundXY();

	triangle = Triangle;
	return triangle;
}

var geom;
var hasRequiredGeom;

function requireGeom () {
	if (hasRequiredGeom) return geom;
	hasRequiredGeom = 1;
	var CONST = require_const$d();
	var Extend = requireExtend$1();

	var Geom = {

	    Circle: requireCircle(),
	    Ellipse: requireEllipse(),
	    Intersects: requireIntersects(),
	    Line: requireLine(),
	    Mesh: requireMesh(),
	    Point: requirePoint(),
	    Polygon: requirePolygon(),
	    Rectangle: requireRectangle(),
	    Triangle: requireTriangle()

	};

	Geom = Extend(false, Geom, CONST);

	geom = Geom;
	return geom;
}

var CreatePixelPerfectHandler_1;
var hasRequiredCreatePixelPerfectHandler;

function requireCreatePixelPerfectHandler () {
	if (hasRequiredCreatePixelPerfectHandler) return CreatePixelPerfectHandler_1;
	hasRequiredCreatePixelPerfectHandler = 1;
	var CreatePixelPerfectHandler = function (textureManager, alphaTolerance)
	{
	    return function (hitArea, x, y, gameObject)
	    {
	        var alpha = textureManager.getPixelAlpha(x, y, gameObject.texture.key, gameObject.frame.name);

	        return (alpha && alpha >= alphaTolerance);
	    };
	};

	CreatePixelPerfectHandler_1 = CreatePixelPerfectHandler;
	return CreatePixelPerfectHandler_1;
}

var CreateInteractiveObject_1;
var hasRequiredCreateInteractiveObject;

function requireCreateInteractiveObject () {
	if (hasRequiredCreateInteractiveObject) return CreateInteractiveObject_1;
	hasRequiredCreateInteractiveObject = 1;
	var CreateInteractiveObject = function (gameObject, hitArea, hitAreaCallback)
	{
	    return {

	        gameObject: gameObject,

	        enabled: true,
	        draggable: false,
	        dropZone: false,
	        cursor: false,

	        target: null,

	        camera: null,

	        hitArea: hitArea,
	        hitAreaCallback: hitAreaCallback,
	        hitAreaDebug: null,

	        customHitArea: false,

	        localX: 0,
	        localY: 0,

	        dragState: 0,

	        dragStartX: 0,
	        dragStartY: 0,
	        dragStartXGlobal: 0,
	        dragStartYGlobal: 0,
	        dragStartCamera: null,

	        dragX: 0,
	        dragY: 0

	    };
	};

	CreateInteractiveObject_1 = CreateInteractiveObject;
	return CreateInteractiveObject_1;
}

var Axis_1;
var hasRequiredAxis;

function requireAxis () {
	if (hasRequiredAxis) return Axis_1;
	hasRequiredAxis = 1;
	var Class = requireClass();

	var Axis = new Class({

	    initialize:

	    function Axis (pad, index)
	    {

	        this.pad = pad;

	        this.events = pad.events;

	        this.index = index;

	        this.value = 0;

	        this.threshold = 0.1;
	    },

	    update: function (value)
	    {
	        this.value = value;
	    },

	    getValue: function ()
	    {
	        return (Math.abs(this.value) < this.threshold) ? 0 : this.value;
	    },

	    destroy: function ()
	    {
	        this.pad = null;
	        this.events = null;
	    }

	});

	Axis_1 = Axis;
	return Axis_1;
}

var BUTTON_DOWN_EVENT;
var hasRequiredBUTTON_DOWN_EVENT;

function requireBUTTON_DOWN_EVENT () {
	if (hasRequiredBUTTON_DOWN_EVENT) return BUTTON_DOWN_EVENT;
	hasRequiredBUTTON_DOWN_EVENT = 1;
	BUTTON_DOWN_EVENT = 'down';
	return BUTTON_DOWN_EVENT;
}

var BUTTON_UP_EVENT;
var hasRequiredBUTTON_UP_EVENT;

function requireBUTTON_UP_EVENT () {
	if (hasRequiredBUTTON_UP_EVENT) return BUTTON_UP_EVENT;
	hasRequiredBUTTON_UP_EVENT = 1;
	BUTTON_UP_EVENT = 'up';
	return BUTTON_UP_EVENT;
}

var CONNECTED_EVENT;
var hasRequiredCONNECTED_EVENT;

function requireCONNECTED_EVENT () {
	if (hasRequiredCONNECTED_EVENT) return CONNECTED_EVENT;
	hasRequiredCONNECTED_EVENT = 1;
	CONNECTED_EVENT = 'connected';
	return CONNECTED_EVENT;
}

var DISCONNECTED_EVENT;
var hasRequiredDISCONNECTED_EVENT;

function requireDISCONNECTED_EVENT () {
	if (hasRequiredDISCONNECTED_EVENT) return DISCONNECTED_EVENT;
	hasRequiredDISCONNECTED_EVENT = 1;
	DISCONNECTED_EVENT = 'disconnected';
	return DISCONNECTED_EVENT;
}

var GAMEPAD_BUTTON_DOWN_EVENT;
var hasRequiredGAMEPAD_BUTTON_DOWN_EVENT;

function requireGAMEPAD_BUTTON_DOWN_EVENT () {
	if (hasRequiredGAMEPAD_BUTTON_DOWN_EVENT) return GAMEPAD_BUTTON_DOWN_EVENT;
	hasRequiredGAMEPAD_BUTTON_DOWN_EVENT = 1;
	GAMEPAD_BUTTON_DOWN_EVENT = 'down';
	return GAMEPAD_BUTTON_DOWN_EVENT;
}

var GAMEPAD_BUTTON_UP_EVENT;
var hasRequiredGAMEPAD_BUTTON_UP_EVENT;

function requireGAMEPAD_BUTTON_UP_EVENT () {
	if (hasRequiredGAMEPAD_BUTTON_UP_EVENT) return GAMEPAD_BUTTON_UP_EVENT;
	hasRequiredGAMEPAD_BUTTON_UP_EVENT = 1;
	GAMEPAD_BUTTON_UP_EVENT = 'up';
	return GAMEPAD_BUTTON_UP_EVENT;
}

var events$4;
var hasRequiredEvents$4;

function requireEvents$4 () {
	if (hasRequiredEvents$4) return events$4;
	hasRequiredEvents$4 = 1;
	events$4 = {

	    BUTTON_DOWN: requireBUTTON_DOWN_EVENT(),
	    BUTTON_UP: requireBUTTON_UP_EVENT(),
	    CONNECTED: requireCONNECTED_EVENT(),
	    DISCONNECTED: requireDISCONNECTED_EVENT(),
	    GAMEPAD_BUTTON_DOWN: requireGAMEPAD_BUTTON_DOWN_EVENT(),
	    GAMEPAD_BUTTON_UP: requireGAMEPAD_BUTTON_UP_EVENT()

	};
	return events$4;
}

var Button_1;
var hasRequiredButton;

function requireButton () {
	if (hasRequiredButton) return Button_1;
	hasRequiredButton = 1;
	var Class = requireClass();
	var Events = requireEvents$4();

	var Button = new Class({

	    initialize:

	    function Button (pad, index)
	    {

	        this.pad = pad;

	        this.events = pad.manager;

	        this.index = index;

	        this.value = 0;

	        this.threshold = 1;

	        this.pressed = false;
	    },

	    update: function (value)
	    {
	        this.value = value;

	        var pad = this.pad;
	        var index = this.index;

	        if (value >= this.threshold)
	        {
	            if (!this.pressed)
	            {
	                this.pressed = true;
	                this.events.emit(Events.BUTTON_DOWN, pad, this, value);
	                this.pad.emit(Events.GAMEPAD_BUTTON_DOWN, index, value, this);
	            }
	        }
	        else if (this.pressed)
	        {
	            this.pressed = false;
	            this.events.emit(Events.BUTTON_UP, pad, this, value);
	            this.pad.emit(Events.GAMEPAD_BUTTON_UP, index, value, this);
	        }
	    },

	    destroy: function ()
	    {
	        this.pad = null;
	        this.events = null;
	    }

	});

	Button_1 = Button;
	return Button_1;
}

var Gamepad_1;
var hasRequiredGamepad$1;

function requireGamepad$1 () {
	if (hasRequiredGamepad$1) return Gamepad_1;
	hasRequiredGamepad$1 = 1;
	var Axis = requireAxis();
	var Button = requireButton();
	var Class = requireClass();
	var EventEmitter = requireEventemitter3();
	var Vector2 = requireVector2();

	var Gamepad = new Class({

	    Extends: EventEmitter,

	    initialize:

	    function Gamepad (manager, pad)
	    {
	        EventEmitter.call(this);

	        this.manager = manager;

	        this.pad = pad;

	        this.id = pad.id;

	        this.index = pad.index;

	        var buttons = [];

	        for (var i = 0; i < pad.buttons.length; i++)
	        {
	            buttons.push(new Button(this, i));
	        }

	        this.buttons = buttons;

	        var axes = [];

	        for (i = 0; i < pad.axes.length; i++)
	        {
	            axes.push(new Axis(this, i));
	        }

	        this.axes = axes;

	        this.vibration = pad.vibrationActuator;

	        var _noButton = { value: 0, pressed: false };

	        this._LCLeft = (buttons[14]) ? buttons[14] : _noButton;

	        this._LCRight = (buttons[15]) ? buttons[15] : _noButton;

	        this._LCTop = (buttons[12]) ? buttons[12] : _noButton;

	        this._LCBottom = (buttons[13]) ? buttons[13] : _noButton;

	        this._RCLeft = (buttons[2]) ? buttons[2] : _noButton;

	        this._RCRight = (buttons[1]) ? buttons[1] : _noButton;

	        this._RCTop = (buttons[3]) ? buttons[3] : _noButton;

	        this._RCBottom = (buttons[0]) ? buttons[0] : _noButton;

	        this._FBLeftTop = (buttons[4]) ? buttons[4] : _noButton;

	        this._FBLeftBottom = (buttons[6]) ? buttons[6] : _noButton;

	        this._FBRightTop = (buttons[5]) ? buttons[5] : _noButton;

	        this._FBRightBottom = (buttons[7]) ? buttons[7] : _noButton;

	        var _noAxis = { value: 0 };

	        this._HAxisLeft = (axes[0]) ? axes[0] : _noAxis;

	        this._VAxisLeft = (axes[1]) ? axes[1] : _noAxis;

	        this._HAxisRight = (axes[2]) ? axes[2] : _noAxis;

	        this._VAxisRight = (axes[3]) ? axes[3] : _noAxis;

	        this.leftStick = new Vector2();

	        this.rightStick = new Vector2();

	        this._created = performance.now();
	    },

	    getAxisTotal: function ()
	    {
	        return this.axes.length;
	    },

	    getAxisValue: function (index)
	    {
	        return this.axes[index].getValue();
	    },

	    setAxisThreshold: function (value)
	    {
	        for (var i = 0; i < this.axes.length; i++)
	        {
	            this.axes[i].threshold = value;
	        }
	    },

	    getButtonTotal: function ()
	    {
	        return this.buttons.length;
	    },

	    getButtonValue: function (index)
	    {
	        return this.buttons[index].value;
	    },

	    isButtonDown: function (index)
	    {
	        return this.buttons[index].pressed;
	    },

	    update: function (pad)
	    {
	        if (pad.timestamp < this._created)
	        {
	            return;
	        }

	        var i;

	        var localButtons = this.buttons;
	        var gamepadButtons = pad.buttons;

	        var len = localButtons.length;

	        for (i = 0; i < len; i++)
	        {
	            localButtons[i].update(gamepadButtons[i].value);
	        }

	        var localAxes = this.axes;
	        var gamepadAxes = pad.axes;

	        len = localAxes.length;

	        for (i = 0; i < len; i++)
	        {
	            localAxes[i].update(gamepadAxes[i]);
	        }

	        if (len >= 2)
	        {
	            this.leftStick.set(localAxes[0].getValue(), localAxes[1].getValue());

	            if (len >= 4)
	            {
	                this.rightStick.set(localAxes[2].getValue(), localAxes[3].getValue());
	            }
	        }
	    },

	    destroy: function ()
	    {
	        this.removeAllListeners();

	        this.manager = null;
	        this.pad = null;

	        var i;

	        for (i = 0; i < this.buttons.length; i++)
	        {
	            this.buttons[i].destroy();
	        }

	        for (i = 0; i < this.axes.length; i++)
	        {
	            this.axes[i].destroy();
	        }

	        this.buttons = [];
	        this.axes = [];
	    },

	    connected: {

	        get: function ()
	        {
	            return this.pad.connected;
	        }

	    },

	    timestamp: {

	        get: function ()
	        {
	            return this.pad.timestamp;
	        }

	    },

	    left: {

	        get: function ()
	        {
	            return this._LCLeft.pressed;
	        }

	    },

	    right: {

	        get: function ()
	        {
	            return this._LCRight.pressed;
	        }

	    },

	    up: {

	        get: function ()
	        {
	            return this._LCTop.pressed;
	        }

	    },

	    down: {

	        get: function ()
	        {
	            return this._LCBottom.pressed;
	        }

	    },

	    A: {

	        get: function ()
	        {
	            return this._RCBottom.pressed;
	        }

	    },

	    Y: {

	        get: function ()
	        {
	            return this._RCTop.pressed;
	        }

	    },

	    X: {

	        get: function ()
	        {
	            return this._RCLeft.pressed;
	        }

	    },

	    B: {

	        get: function ()
	        {
	            return this._RCRight.pressed;
	        }

	    },

	    L1: {

	        get: function ()
	        {
	            return this._FBLeftTop.value;
	        }

	    },

	    L2: {

	        get: function ()
	        {
	            return this._FBLeftBottom.value;
	        }

	    },

	    R1: {

	        get: function ()
	        {
	            return this._FBRightTop.value;
	        }

	    },

	    R2: {

	        get: function ()
	        {
	            return this._FBRightBottom.value;
	        }

	    }

	});

	Gamepad_1 = Gamepad;
	return Gamepad_1;
}

var InputPluginCache_1;
var hasRequiredInputPluginCache;

function requireInputPluginCache () {
	if (hasRequiredInputPluginCache) return InputPluginCache_1;
	hasRequiredInputPluginCache = 1;
	var GetValue = requireGetValue();

	var inputPlugins = {};

	var InputPluginCache = {};

	InputPluginCache.register = function (key, plugin, mapping, settingsKey, configKey)
	{
	    inputPlugins[key] = { plugin: plugin, mapping: mapping, settingsKey: settingsKey, configKey: configKey };
	};

	InputPluginCache.getPlugin = function (key)
	{
	    return inputPlugins[key];
	};

	InputPluginCache.install = function (target)
	{
	    var sys = target.scene.sys;
	    var settings = sys.settings.input;
	    var config = sys.game.config;

	    for (var key in inputPlugins)
	    {
	        var source = inputPlugins[key].plugin;
	        var mapping = inputPlugins[key].mapping;
	        var settingsKey = inputPlugins[key].settingsKey;
	        var configKey = inputPlugins[key].configKey;

	        if (GetValue(settings, settingsKey, config[configKey]))
	        {
	            target[mapping] = new source(target);
	        }
	    }
	};

	InputPluginCache.remove = function (key)
	{
	    if (inputPlugins.hasOwnProperty(key))
	    {
	        delete inputPlugins[key];
	    }
	};

	InputPluginCache_1 = InputPluginCache;
	return InputPluginCache_1;
}

var GamepadPlugin_1;
var hasRequiredGamepadPlugin;

function requireGamepadPlugin () {
	if (hasRequiredGamepadPlugin) return GamepadPlugin_1;
	hasRequiredGamepadPlugin = 1;
	var Class = requireClass();
	var EventEmitter = requireEventemitter3();
	var Events = requireEvents$4();
	var Gamepad = requireGamepad$1();
	var GetValue = requireGetValue();
	var InputPluginCache = requireInputPluginCache();
	var InputEvents = requireEvents$9();

	var GamepadPlugin = new Class({

	    Extends: EventEmitter,

	    initialize:

	    function GamepadPlugin (sceneInputPlugin)
	    {
	        EventEmitter.call(this);

	        this.scene = sceneInputPlugin.scene;

	        this.settings = this.scene.sys.settings;

	        this.sceneInputPlugin = sceneInputPlugin;

	        this.enabled = true;

	        this.target;

	        this.gamepads = [];

	        this.queue = [];

	        this.onGamepadHandler;

	        this._pad1;

	        this._pad2;

	        this._pad3;

	        this._pad4;

	        sceneInputPlugin.pluginEvents.once(InputEvents.BOOT, this.boot, this);
	        sceneInputPlugin.pluginEvents.on(InputEvents.START, this.start, this);
	    },

	    boot: function ()
	    {
	        var game = this.scene.sys.game;
	        var settings = this.settings.input;
	        var config = game.config;

	        this.enabled = GetValue(settings, 'gamepad', config.inputGamepad) && game.device.input.gamepads;
	        this.target = GetValue(settings, 'gamepad.target', config.inputGamepadEventTarget);

	        this.sceneInputPlugin.pluginEvents.once(InputEvents.DESTROY, this.destroy, this);
	    },

	    start: function ()
	    {
	        if (this.enabled)
	        {
	            this.startListeners();

	            this.refreshPads();
	        }

	        this.sceneInputPlugin.pluginEvents.once(InputEvents.SHUTDOWN, this.shutdown, this);
	    },

	    isActive: function ()
	    {
	        return (this.enabled && this.scene.sys.isActive());
	    },

	    startListeners: function ()
	    {
	        var _this = this;
	        var target = this.target;

	        var handler = function (event)
	        {
	            if (event.defaultPrevented || !_this.isActive())
	            {

	                return;
	            }

	            _this.refreshPads();

	            _this.queue.push(event);
	        };

	        this.onGamepadHandler = handler;

	        target.addEventListener('gamepadconnected', handler, false);
	        target.addEventListener('gamepaddisconnected', handler, false);

	        this.sceneInputPlugin.pluginEvents.on(InputEvents.UPDATE, this.update, this);
	    },

	    stopListeners: function ()
	    {
	        this.target.removeEventListener('gamepadconnected', this.onGamepadHandler);
	        this.target.removeEventListener('gamepaddisconnected', this.onGamepadHandler);

	        this.sceneInputPlugin.pluginEvents.off(InputEvents.UPDATE, this.update);

	        for (var i = 0; i < this.gamepads.length; i++)
	        {
	            this.gamepads[i].removeAllListeners();
	        }
	    },

	    disconnectAll: function ()
	    {
	        for (var i = 0; i < this.gamepads.length; i++)
	        {
	            this.gamepads[i].pad.connected = false;
	        }
	    },

	    refreshPads: function ()
	    {
	        var connectedPads = navigator.getGamepads();

	        if (!connectedPads)
	        {
	            this.disconnectAll();
	        }
	        else
	        {
	            var currentPads = this.gamepads;

	            for (var i = 0; i < connectedPads.length; i++)
	            {
	                var livePad = connectedPads[i];

	                if (!livePad)
	                {
	                    continue;
	                }

	                var id = livePad.id;
	                var index = livePad.index;
	                var currentPad = currentPads[index];

	                if (!currentPad)
	                {

	                    var newPad = new Gamepad(this, livePad);

	                    currentPads[index] = newPad;

	                    if (!this._pad1)
	                    {
	                        this._pad1 = newPad;
	                    }
	                    else if (!this._pad2)
	                    {
	                        this._pad2 = newPad;
	                    }
	                    else if (!this._pad3)
	                    {
	                        this._pad3 = newPad;
	                    }
	                    else if (!this._pad4)
	                    {
	                        this._pad4 = newPad;
	                    }
	                }
	                else if (currentPad.id !== id)
	                {

	                    currentPad.destroy();

	                    currentPads[index] = new Gamepad(this, livePad);
	                }
	                else
	                {

	                    currentPad.update(livePad);
	                }
	            }
	        }
	    },

	    getAll: function ()
	    {
	        var out = [];
	        var pads = this.gamepads;

	        for (var i = 0; i < pads.length; i++)
	        {
	            if (pads[i])
	            {
	                out.push(pads[i]);
	            }
	        }

	        return out;
	    },

	    getPad: function (index)
	    {
	        var pads = this.gamepads;

	        for (var i = 0; i < pads.length; i++)
	        {
	            if (pads[i] && pads[i].index === index)
	            {
	                return pads[i];
	            }
	        }
	    },

	    update: function ()
	    {
	        if (!this.enabled)
	        {
	            return;
	        }

	        this.refreshPads();

	        var len = this.queue.length;

	        if (len === 0)
	        {
	            return;
	        }

	        var queue = this.queue.splice(0, len);

	        for (var i = 0; i < len; i++)
	        {
	            var event = queue[i];
	            var pad = this.getPad(event.gamepad.index);

	            if (event.type === 'gamepadconnected')
	            {
	                this.emit(Events.CONNECTED, pad, event);
	            }
	            else if (event.type === 'gamepaddisconnected')
	            {
	                this.emit(Events.DISCONNECTED, pad, event);
	            }
	        }
	    },

	    shutdown: function ()
	    {
	        this.stopListeners();

	        this.removeAllListeners();
	    },

	    destroy: function ()
	    {
	        this.shutdown();

	        for (var i = 0; i < this.gamepads.length; i++)
	        {
	            if (this.gamepads[i])
	            {
	                this.gamepads[i].destroy();
	            }
	        }

	        this.gamepads = [];

	        this.scene = null;
	        this.settings = null;
	        this.sceneInputPlugin = null;
	        this.target = null;
	    },

	    total: {

	        get: function ()
	        {
	            return this.gamepads.length;
	        }

	    },

	    pad1: {

	        get: function ()
	        {
	            return this._pad1;
	        }

	    },

	    pad2: {

	        get: function ()
	        {
	            return this._pad2;
	        }

	    },

	    pad3: {

	        get: function ()
	        {
	            return this._pad3;
	        }

	    },

	    pad4: {

	        get: function ()
	        {
	            return this._pad4;
	        }

	    }

	});

	InputPluginCache.register('GamepadPlugin', GamepadPlugin, 'gamepad', 'gamepad', 'inputGamepad');

	GamepadPlugin_1 = GamepadPlugin;
	return GamepadPlugin_1;
}

var Sony_PlayStation_DualShock_4;
var hasRequiredSony_PlayStation_DualShock_4;

function requireSony_PlayStation_DualShock_4 () {
	if (hasRequiredSony_PlayStation_DualShock_4) return Sony_PlayStation_DualShock_4;
	hasRequiredSony_PlayStation_DualShock_4 = 1;
	Sony_PlayStation_DualShock_4 = {

	    UP: 12,

	    DOWN: 13,

	    LEFT: 14,

	    RIGHT: 15,

	    SHARE: 8,

	    OPTIONS: 9,

	    PS: 16,

	    TOUCHBAR: 17,

	    X: 0,

	    CIRCLE: 1,

	    SQUARE: 2,

	    TRIANGLE: 3,

	    L1: 4,

	    R1: 5,

	    L2: 6,

	    R2: 7,

	    L3: 10,

	    R3: 11,

	    LEFT_STICK_H: 0,

	    LEFT_STICK_V: 1,

	    RIGHT_STICK_H: 2,

	    RIGHT_STICK_V: 3

	};
	return Sony_PlayStation_DualShock_4;
}

var SNES_USB_Controller;
var hasRequiredSNES_USB_Controller;

function requireSNES_USB_Controller () {
	if (hasRequiredSNES_USB_Controller) return SNES_USB_Controller;
	hasRequiredSNES_USB_Controller = 1;
	SNES_USB_Controller = {

	    UP: 12,

	    DOWN: 13,

	    LEFT: 14,

	    RIGHT: 15,

	    SELECT: 8,

	    START: 9,

	    B: 0,

	    A: 1,

	    Y: 2,

	    X: 3,

	    LEFT_SHOULDER: 4,

	    RIGHT_SHOULDER: 5

	};
	return SNES_USB_Controller;
}

var XBox360_Controller;
var hasRequiredXBox360_Controller;

function requireXBox360_Controller () {
	if (hasRequiredXBox360_Controller) return XBox360_Controller;
	hasRequiredXBox360_Controller = 1;
	XBox360_Controller = {

	    UP: 12,

	    DOWN: 13,

	    LEFT: 14,

	    RIGHT: 15,

	    MENU: 16,

	    A: 0,

	    B: 1,

	    X: 2,

	    Y: 3,

	    LB: 4,

	    RB: 5,

	    LT: 6,

	    RT: 7,

	    BACK: 8,

	    START: 9,

	    LS: 10,

	    RS: 11,

	    LEFT_STICK_H: 0,

	    LEFT_STICK_V: 1,

	    RIGHT_STICK_H: 2,

	    RIGHT_STICK_V: 3

	};
	return XBox360_Controller;
}

var configs;
var hasRequiredConfigs;

function requireConfigs () {
	if (hasRequiredConfigs) return configs;
	hasRequiredConfigs = 1;
	configs = {

	    DUALSHOCK_4: requireSony_PlayStation_DualShock_4(),
	    SNES_USB: requireSNES_USB_Controller(),
	    XBOX_360: requireXBox360_Controller()

	};
	return configs;
}

var gamepad;
var hasRequiredGamepad;

function requireGamepad () {
	if (hasRequiredGamepad) return gamepad;
	hasRequiredGamepad = 1;
	gamepad = {

	    Axis: requireAxis(),
	    Button: requireButton(),
	    Events: requireEvents$4(),
	    Gamepad: requireGamepad$1(),
	    GamepadPlugin: requireGamepadPlugin(),

	    Configs: requireConfigs()
	};
	return gamepad;
}

var InputPlugin_1;
var hasRequiredInputPlugin;

function requireInputPlugin () {
	if (hasRequiredInputPlugin) return InputPlugin_1;
	hasRequiredInputPlugin = 1;
	var Circle = requireCircle$2();
	var CircleContains = requireContains$4();
	var Class = requireClass();
	var CONST = require_const$6();
	var CreateInteractiveObject = requireCreateInteractiveObject();
	var CreatePixelPerfectHandler = requireCreatePixelPerfectHandler();
	var DistanceBetween = requireDistanceBetween();
	var Ellipse = requireEllipse$2();
	var EllipseContains = requireContains$2();
	var Events = requireEvents$9();
	var EventEmitter = requireEventemitter3();
	var GetFastValue = requireGetFastValue();
	var GEOM_CONST = require_const$d();
	var InputPluginCache = requireInputPluginCache();
	var IsPlainObject = requireIsPlainObject();
	var PluginCache = requirePluginCache();
	var Rectangle = requireRectangle$2();
	var RectangleContains = requireContains$3();
	var SceneEvents = requireEvents$l();
	var Triangle = requireTriangle$2();
	var TriangleContains = requireContains();

	var InputPlugin = new Class({

	    Extends: EventEmitter,

	    initialize:

	    function InputPlugin (scene)
	    {
	        EventEmitter.call(this);

	        this.scene = scene;

	        this.systems = scene.sys;

	        this.settings = scene.sys.settings;

	        this.manager = scene.sys.game.input;

	        this.pluginEvents = new EventEmitter();

	        this.enabled = true;

	        this.displayList;

	        this.cameras;

	        InputPluginCache.install(this);

	        this.mouse = this.manager.mouse;

	        this.topOnly = true;

	        this.pollRate = -1;

	        this._pollTimer = 0;

	        var _eventData = { cancelled: false };

	        this._eventContainer = {
	            stopPropagation: function ()
	            {
	                _eventData.cancelled = true;
	            }
	        };

	        this._eventData = _eventData;

	        this.dragDistanceThreshold = 0;

	        this.dragTimeThreshold = 0;

	        this._temp = [];

	        this._tempZones = [];

	        this._list = [];

	        this._pendingInsertion = [];

	        this._pendingRemoval = [];

	        this._draggable = [];

	        this._drag = { 0: [], 1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: [], 8: [], 9: [], 10: [] };

	        this._dragState = [];

	        this._over = { 0: [], 1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: [], 8: [], 9: [], 10: [] };

	        this._validTypes = [ 'onDown', 'onUp', 'onOver', 'onOut', 'onMove', 'onDragStart', 'onDrag', 'onDragEnd', 'onDragEnter', 'onDragLeave', 'onDragOver', 'onDrop' ];

	        this._updatedThisFrame = false;

	        scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
	        scene.sys.events.on(SceneEvents.START, this.start, this);
	    },

	    boot: function ()
	    {
	        this.cameras = this.systems.cameras;

	        this.displayList = this.systems.displayList;

	        this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);

	        this.pluginEvents.emit(Events.BOOT);
	    },

	    start: function ()
	    {
	        var eventEmitter = this.systems.events;

	        eventEmitter.on(SceneEvents.TRANSITION_START, this.transitionIn, this);
	        eventEmitter.on(SceneEvents.TRANSITION_OUT, this.transitionOut, this);
	        eventEmitter.on(SceneEvents.TRANSITION_COMPLETE, this.transitionComplete, this);
	        eventEmitter.on(SceneEvents.PRE_UPDATE, this.preUpdate, this);
	        eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);

	        this.manager.events.on(Events.GAME_OUT, this.onGameOut, this);
	        this.manager.events.on(Events.GAME_OVER, this.onGameOver, this);

	        this.enabled = true;

	        this._dragState = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];

	        this.pluginEvents.emit(Events.START);
	    },

	    onGameOver: function (event)
	    {
	        if (this.isActive())
	        {
	            this.emit(Events.GAME_OVER, event.timeStamp, event);
	        }
	    },

	    onGameOut: function (event)
	    {
	        if (this.isActive())
	        {
	            this.emit(Events.GAME_OUT, event.timeStamp, event);
	        }
	    },

	    preUpdate: function ()
	    {

	        this.pluginEvents.emit(Events.PRE_UPDATE);

	        var removeList = this._pendingRemoval;
	        var insertList = this._pendingInsertion;

	        var toRemove = removeList.length;
	        var toInsert = insertList.length;

	        if (toRemove === 0 && toInsert === 0)
	        {

	            return;
	        }

	        var current = this._list;

	        for (var i = 0; i < toRemove; i++)
	        {
	            var gameObject = removeList[i];

	            var index = current.indexOf(gameObject);

	            if (index > -1)
	            {
	                current.splice(index, 1);

	                this.clear(gameObject, true);
	            }
	        }

	        this._pendingRemoval.length = 0;

	        this._list = current.concat(insertList.splice(0));
	    },

	    isActive: function ()
	    {
	        return (this.manager && this.manager.enabled && this.enabled && this.scene.sys.canInput());
	    },

	    setCursor: function (interactiveObject)
	    {
	        if (this.manager)
	        {
	            this.manager.setCursor(interactiveObject);
	        }
	    },

	    resetCursor: function ()
	    {
	        if (this.manager)
	        {
	            this.manager.resetCursor(null, true);
	        }
	    },

	    updatePoll: function (time, delta)
	    {
	        if (!this.isActive())
	        {
	            return false;
	        }

	        this.pluginEvents.emit(Events.UPDATE, time, delta);

	        if (this._updatedThisFrame)
	        {
	            this._updatedThisFrame = false;

	            return false;
	        }

	        var i;
	        var manager = this.manager;

	        var pointers = manager.pointers;

	        for (i = 0; i < pointers.length; i++)
	        {
	            pointers[i].updateMotion();
	        }

	        if (this._list.length === 0)
	        {
	            return false;
	        }

	        var rate = this.pollRate;

	        if (rate === -1)
	        {
	            return false;
	        }
	        else if (rate > 0)
	        {
	            this._pollTimer -= delta;

	            if (this._pollTimer < 0)
	            {

	                this._pollTimer = this.pollRate;
	            }
	            else
	            {

	                return false;
	            }
	        }

	        var captured = false;

	        for (i = 0; i < pointers.length; i++)
	        {
	            var total = 0;

	            var pointer = pointers[i];

	            this._tempZones = [];

	            this._temp = this.hitTestPointer(pointer);

	            this.sortGameObjects(this._temp, pointer);
	            this.sortDropZones(this._tempZones);

	            if (this.topOnly)
	            {

	                if (this._temp.length)
	                {
	                    this._temp.splice(1);
	                }

	                if (this._tempZones.length)
	                {
	                    this._tempZones.splice(1);
	                }
	            }

	            total += this.processOverOutEvents(pointer);

	            if (this.getDragState(pointer) === 2)
	            {
	                this.processDragThresholdEvent(pointer, time);
	            }

	            if (total > 0)
	            {

	                captured = true;
	            }
	        }

	        return captured;
	    },

	    update: function (type, pointers)
	    {
	        if (!this.isActive())
	        {
	            return false;
	        }

	        var captured = false;

	        for (var i = 0; i < pointers.length; i++)
	        {
	            var total = 0;
	            var pointer = pointers[i];

	            this._tempZones = [];

	            this._temp = this.hitTestPointer(pointer);

	            this.sortGameObjects(this._temp, pointer);
	            this.sortDropZones(this._tempZones);

	            if (this.topOnly)
	            {

	                if (this._temp.length)
	                {
	                    this._temp.splice(1);
	                }

	                if (this._tempZones.length)
	                {
	                    this._tempZones.splice(1);
	                }
	            }

	            switch (type)
	            {
	                case CONST.MOUSE_DOWN:
	                    total += this.processDragDownEvent(pointer);
	                    total += this.processDownEvents(pointer);
	                    total += this.processOverOutEvents(pointer);
	                    break;

	                case CONST.MOUSE_UP:
	                    total += this.processDragUpEvent(pointer);
	                    total += this.processUpEvents(pointer);
	                    total += this.processOverOutEvents(pointer);
	                    break;

	                case CONST.TOUCH_START:
	                    total += this.processDragDownEvent(pointer);
	                    total += this.processDownEvents(pointer);
	                    total += this.processOverEvents(pointer);
	                    break;

	                case CONST.TOUCH_END:
	                case CONST.TOUCH_CANCEL:
	                    total += this.processDragUpEvent(pointer);
	                    total += this.processUpEvents(pointer);
	                    total += this.processOutEvents(pointer);
	                    break;

	                case CONST.MOUSE_MOVE:
	                case CONST.TOUCH_MOVE:
	                    total += this.processDragMoveEvent(pointer);
	                    total += this.processMoveEvents(pointer);
	                    total += this.processOverOutEvents(pointer);
	                    break;

	                case CONST.MOUSE_WHEEL:
	                    total += this.processWheelEvent(pointer);
	                    break;
	            }

	            if (total > 0)
	            {

	                captured = true;
	            }
	        }

	        this._updatedThisFrame = true;

	        return captured;
	    },

	    clear: function (gameObject, skipQueue)
	    {
	        if (skipQueue === undefined) { skipQueue = false; }

	        this.disable(gameObject);

	        var input = gameObject.input;

	        if (input)
	        {
	            this.removeDebug(gameObject);
	            this.manager.resetCursor(input);

	            input.gameObject = undefined;
	            input.target = undefined;
	            input.hitArea = undefined;
	            input.hitAreaCallback = undefined;
	            input.callbackContext = undefined;

	            gameObject.input = null;
	        }

	        if (!skipQueue)
	        {
	            this.queueForRemoval(gameObject);
	        }

	        var index = this._draggable.indexOf(gameObject);

	        if (index > -1)
	        {
	            this._draggable.splice(index, 1);
	        }

	        return gameObject;
	    },

	    disable: function (gameObject, resetCursor)
	    {
	        if (resetCursor === undefined) { resetCursor = false; }

	        var input = gameObject.input;

	        if (input)
	        {
	            input.enabled = false;
	            input.dragState = 0;
	        }

	        var drag = this._drag;
	        var over = this._over;
	        var manager = this.manager;

	        for (var i = 0, index; i < manager.pointers.length; i++)
	        {
	            index = drag[i].indexOf(gameObject);

	            if (index > -1)
	            {
	                drag[i].splice(index, 1);
	            }

	            index = over[i].indexOf(gameObject);

	            if (index > -1)
	            {
	                over[i].splice(index, 1);
	            }
	        }

	        if (resetCursor)
	        {
	            this.resetCursor();
	        }

	        return this;
	    },

	    enable: function (gameObject, hitArea, hitAreaCallback, dropZone)
	    {
	        if (dropZone === undefined) { dropZone = false; }

	        if (gameObject.input)
	        {

	            gameObject.input.enabled = true;
	        }
	        else
	        {

	            this.setHitArea(gameObject, hitArea, hitAreaCallback);
	        }

	        if (gameObject.input && dropZone && !gameObject.input.dropZone)
	        {
	            gameObject.input.dropZone = dropZone;
	        }

	        return this;
	    },

	    hitTestPointer: function (pointer)
	    {
	        var cameras = this.cameras.getCamerasBelowPointer(pointer);

	        for (var c = 0; c < cameras.length; c++)
	        {
	            var camera = cameras[c];

	            var over = this.manager.hitTest(pointer, this._list, camera);

	            for (var i = 0; i < over.length; i++)
	            {
	                var obj = over[i];

	                if (obj.input.dropZone)
	                {
	                    this._tempZones.push(obj);
	                }
	            }

	            if (over.length > 0)
	            {
	                pointer.camera = camera;

	                return over;
	            }
	        }

	        pointer.camera = cameras[0];

	        return [];
	    },

	    processDownEvents: function (pointer)
	    {
	        var total = 0;
	        var currentlyOver = this._temp;

	        var _eventData = this._eventData;
	        var _eventContainer = this._eventContainer;

	        _eventData.cancelled = false;

	        for (var i = 0; i < currentlyOver.length; i++)
	        {
	            var gameObject = currentlyOver[i];

	            if (!gameObject.input || !gameObject.input.enabled)
	            {
	                continue;
	            }

	            total++;

	            gameObject.emit(Events.GAMEOBJECT_POINTER_DOWN, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);

	            if (_eventData.cancelled || !this.isActive())
	            {

	                break;
	            }

	            if (gameObject.input && gameObject.input.enabled)
	            {

	                this.emit(Events.GAMEOBJECT_DOWN, pointer, gameObject, _eventContainer);

	                if (_eventData.cancelled || !this.isActive())
	                {

	                    break;
	                }
	            }
	        }

	        if (!_eventData.cancelled && this.isActive())
	        {
	            if (pointer.downElement === this.manager.game.canvas)
	            {

	                this.emit(Events.POINTER_DOWN, pointer, currentlyOver);
	            }
	            else
	            {

	                this.emit(Events.POINTER_DOWN_OUTSIDE, pointer);
	            }
	        }

	        return total;
	    },

	    getDragState: function (pointer)
	    {
	        return this._dragState[pointer.id];
	    },

	    setDragState: function (pointer, state)
	    {
	        this._dragState[pointer.id] = state;
	    },

	    processDragThresholdEvent: function (pointer, time)
	    {
	        var passed = false;
	        var timeThreshold = this.dragTimeThreshold;
	        var distanceThreshold = this.dragDistanceThreshold;

	        if (distanceThreshold > 0 && DistanceBetween(pointer.x, pointer.y, pointer.downX, pointer.downY) >= distanceThreshold)
	        {

	            passed = true;
	        }
	        else if (timeThreshold > 0 && (time >= pointer.downTime + timeThreshold))
	        {

	            passed = true;
	        }

	        if (passed)
	        {
	            this.setDragState(pointer, 3);

	            return this.processDragStartList(pointer);
	        }
	    },

	    processDragStartList: function (pointer)
	    {

	        if (this.getDragState(pointer) !== 3)
	        {
	            return 0;
	        }

	        var list = this._drag[pointer.id];

	        if (list.length > 1)
	        {
	            list = list.slice(0);
	        }

	        for (var i = 0; i < list.length; i++)
	        {
	            var gameObject = list[i];

	            var input = gameObject.input;

	            input.dragState = 2;

	            input.dragStartX = gameObject.x;
	            input.dragStartY = gameObject.y;

	            input.dragStartXGlobal = pointer.worldX;
	            input.dragStartYGlobal = pointer.worldY;

	            input.dragStartCamera = pointer.camera;

	            input.dragX = input.dragStartXGlobal - input.dragStartX;
	            input.dragY = input.dragStartYGlobal - input.dragStartY;

	            gameObject.emit(Events.GAMEOBJECT_DRAG_START, pointer, input.dragX, input.dragY);

	            this.emit(Events.DRAG_START, pointer, gameObject);
	        }

	        this.setDragState(pointer, 4);

	        return list.length;
	    },

	    processDragDownEvent: function (pointer)
	    {
	        var currentlyOver = this._temp;

	        if (this._draggable.length === 0 || currentlyOver.length === 0 || !pointer.primaryDown || this.getDragState(pointer) !== 0)
	        {

	            return 0;
	        }

	        this.setDragState(pointer, 1);

	        var draglist = [];

	        for (var i = 0; i < currentlyOver.length; i++)
	        {
	            var gameObject = currentlyOver[i];

	            if (gameObject.input.draggable && (gameObject.input.dragState === 0))
	            {
	                draglist.push(gameObject);
	            }
	        }

	        if (draglist.length === 0)
	        {
	            this.setDragState(pointer, 0);

	            return 0;
	        }
	        else if (draglist.length > 1)
	        {
	            this.sortGameObjects(draglist, pointer);

	            if (this.topOnly)
	            {
	                draglist.splice(1);
	            }
	        }

	        this._drag[pointer.id] = draglist;

	        if (this.dragDistanceThreshold === 0 && this.dragTimeThreshold === 0)
	        {

	            this.setDragState(pointer, 3);

	            return this.processDragStartList(pointer);
	        }
	        else
	        {

	            this.setDragState(pointer, 2);

	            return 0;
	        }
	    },

	    processDragMoveEvent: function (pointer)
	    {

	        if (this.getDragState(pointer) === 2)
	        {
	            this.processDragThresholdEvent(pointer, this.manager.game.loop.now);
	        }

	        if (this.getDragState(pointer) !== 4)
	        {
	            return 0;
	        }

	        var dropZones = this._tempZones;

	        var list = this._drag[pointer.id];

	        if (list.length > 1)
	        {
	            list = list.slice(0);
	        }

	        for (var i = 0; i < list.length; i++)
	        {
	            var gameObject = list[i];

	            var input = gameObject.input;

	            var target = input.target;

	            if (target)
	            {
	                var index = dropZones.indexOf(target);

	                if (index === 0)
	                {

	                    gameObject.emit(Events.GAMEOBJECT_DRAG_OVER, pointer, target);

	                    this.emit(Events.DRAG_OVER, pointer, gameObject, target);
	                }
	                else if (index > 0)
	                {

	                    gameObject.emit(Events.GAMEOBJECT_DRAG_LEAVE, pointer, target);

	                    this.emit(Events.DRAG_LEAVE, pointer, gameObject, target);

	                    input.target = dropZones[0];

	                    target = input.target;

	                    gameObject.emit(Events.GAMEOBJECT_DRAG_ENTER, pointer, target);

	                    this.emit(Events.DRAG_ENTER, pointer, gameObject, target);
	                }
	                else
	                {

	                    gameObject.emit(Events.GAMEOBJECT_DRAG_LEAVE, pointer, target);

	                    this.emit(Events.DRAG_LEAVE, pointer, gameObject, target);

	                    if (dropZones[0])
	                    {
	                        input.target = dropZones[0];

	                        target = input.target;

	                        gameObject.emit(Events.GAMEOBJECT_DRAG_ENTER, pointer, target);

	                        this.emit(Events.DRAG_ENTER, pointer, gameObject, target);
	                    }
	                    else
	                    {

	                        input.target = null;
	                    }
	                }
	            }
	            else if (!target && dropZones[0])
	            {
	                input.target = dropZones[0];

	                target = input.target;

	                gameObject.emit(Events.GAMEOBJECT_DRAG_ENTER, pointer, target);

	                this.emit(Events.DRAG_ENTER, pointer, gameObject, target);
	            }

	            var dragX;
	            var dragY;

	            var dragWorldXY = pointer.positionToCamera(input.dragStartCamera);

	            if (!gameObject.parentContainer)
	            {
	                dragX = dragWorldXY.x - input.dragX;
	                dragY = dragWorldXY.y - input.dragY;
	            }
	            else
	            {
	                var dx = dragWorldXY.x - input.dragStartXGlobal;
	                var dy = dragWorldXY.y - input.dragStartYGlobal;

	                var rotation = gameObject.getParentRotation();

	                var dxRotated = dx * Math.cos(rotation) + dy * Math.sin(rotation);
	                var dyRotated = dy * Math.cos(rotation) - dx * Math.sin(rotation);

	                dxRotated *= (1 / gameObject.parentContainer.scaleX);
	                dyRotated *= (1 / gameObject.parentContainer.scaleY);

	                dragX = dxRotated + input.dragStartX;
	                dragY = dyRotated + input.dragStartY;
	            }

	            gameObject.emit(Events.GAMEOBJECT_DRAG, pointer, dragX, dragY);

	            this.emit(Events.DRAG, pointer, gameObject, dragX, dragY);
	        }

	        return list.length;
	    },

	    processDragUpEvent: function (pointer)
	    {

	        var list = this._drag[pointer.id];

	        if (list.length > 1)
	        {
	            list = list.slice(0);
	        }

	        for (var i = 0; i < list.length; i++)
	        {
	            var gameObject = list[i];

	            var input = gameObject.input;

	            if (input && input.dragState === 2)
	            {
	                input.dragState = 0;

	                input.dragX = input.localX - gameObject.displayOriginX;
	                input.dragY = input.localY - gameObject.displayOriginY;

	                input.dragStartCamera = null;

	                var dropped = false;

	                var target = input.target;

	                if (target)
	                {
	                    gameObject.emit(Events.GAMEOBJECT_DROP, pointer, target);

	                    this.emit(Events.DROP, pointer, gameObject, target);

	                    input.target = null;

	                    dropped = true;
	                }

	                if (gameObject.input && gameObject.input.enabled)
	                {
	                    gameObject.emit(Events.GAMEOBJECT_DRAG_END, pointer, input.dragX, input.dragY, dropped);

	                    this.emit(Events.DRAG_END, pointer, gameObject, dropped);
	                }
	            }
	        }

	        this.setDragState(pointer, 0);

	        list.splice(0);

	        return 0;
	    },

	    processMoveEvents: function (pointer)
	    {
	        var total = 0;
	        var currentlyOver = this._temp;

	        var _eventData = this._eventData;
	        var _eventContainer = this._eventContainer;

	        _eventData.cancelled = false;

	        for (var i = 0; i < currentlyOver.length; i++)
	        {
	            var gameObject = currentlyOver[i];

	            if (!gameObject.input || !gameObject.input.enabled)
	            {
	                continue;
	            }

	            total++;

	            gameObject.emit(Events.GAMEOBJECT_POINTER_MOVE, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);

	            if (_eventData.cancelled || !this.isActive())
	            {

	                break;
	            }

	            if (gameObject.input && gameObject.input.enabled)
	            {
	                this.emit(Events.GAMEOBJECT_MOVE, pointer, gameObject, _eventContainer);

	                if (_eventData.cancelled || !this.isActive())
	                {

	                    break;
	                }

	                if (this.topOnly)
	                {
	                    break;
	                }
	            }
	        }

	        if (!_eventData.cancelled && this.isActive())
	        {
	            this.emit(Events.POINTER_MOVE, pointer, currentlyOver);
	        }

	        return total;
	    },

	    processWheelEvent: function (pointer)
	    {
	        var total = 0;
	        var currentlyOver = this._temp;

	        var _eventData = this._eventData;
	        var _eventContainer = this._eventContainer;

	        _eventData.cancelled = false;

	        var dx = pointer.deltaX;
	        var dy = pointer.deltaY;
	        var dz = pointer.deltaZ;

	        for (var i = 0; i < currentlyOver.length; i++)
	        {
	            var gameObject = currentlyOver[i];

	            if (!gameObject.input || !gameObject.input.enabled)
	            {
	                continue;
	            }

	            total++;

	            gameObject.emit(Events.GAMEOBJECT_POINTER_WHEEL, pointer, dx, dy, dz, _eventContainer);

	            if (_eventData.cancelled || !this.isActive())
	            {

	                break;
	            }

	            if (gameObject.input && gameObject.input.enabled)
	            {
	                this.emit(Events.GAMEOBJECT_WHEEL, pointer, gameObject, dx, dy, dz, _eventContainer);

	                if (_eventData.cancelled || !this.isActive())
	                {

	                    break;
	                }
	            }
	        }

	        if (!_eventData.cancelled && this.isActive())
	        {
	            this.emit(Events.POINTER_WHEEL, pointer, currentlyOver, dx, dy, dz);
	        }

	        return total;
	    },

	    processOverEvents: function (pointer)
	    {
	        var currentlyOver = this._temp;

	        var totalInteracted = 0;

	        var total = currentlyOver.length;

	        var justOver = [];

	        if (total > 0)
	        {
	            var manager = this.manager;

	            var _eventData = this._eventData;
	            var _eventContainer = this._eventContainer;

	            _eventData.cancelled = false;

	            for (var i = 0; i < total; i++)
	            {
	                var gameObject = currentlyOver[i];

	                if (!gameObject.input || !gameObject.input.enabled)
	                {
	                    continue;
	                }

	                justOver.push(gameObject);

	                manager.setCursor(gameObject.input);

	                gameObject.emit(Events.GAMEOBJECT_POINTER_OVER, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);

	                totalInteracted++;

	                if (_eventData.cancelled || !this.isActive())
	                {

	                    break;
	                }

	                if (gameObject.input && gameObject.input.enabled)
	                {
	                    this.emit(Events.GAMEOBJECT_OVER, pointer, gameObject, _eventContainer);

	                    if (_eventData.cancelled || !this.isActive())
	                    {

	                        break;
	                    }
	                }
	            }

	            if (!_eventData.cancelled && this.isActive())
	            {
	                this.emit(Events.POINTER_OVER, pointer, justOver);
	            }
	        }

	        this._over[pointer.id] = justOver;

	        return totalInteracted;
	    },

	    processOutEvents: function (pointer)
	    {
	        var previouslyOver = this._over[pointer.id];

	        var totalInteracted = 0;

	        var total = previouslyOver.length;

	        if (total > 0)
	        {
	            var manager = this.manager;

	            var _eventData = this._eventData;
	            var _eventContainer = this._eventContainer;

	            _eventData.cancelled = false;

	            this.sortGameObjects(previouslyOver, pointer);

	            for (var i = 0; i < total; i++)
	            {
	                var gameObject = previouslyOver[i];

	                gameObject = previouslyOver[i];

	                if (!gameObject.input || !gameObject.input.enabled)
	                {
	                    continue;
	                }

	                manager.resetCursor(gameObject.input);

	                gameObject.emit(Events.GAMEOBJECT_POINTER_OUT, pointer, _eventContainer);

	                totalInteracted++;

	                if (_eventData.cancelled || !this.isActive())
	                {

	                    break;
	                }

	                if (gameObject.input && gameObject.input.enabled)
	                {
	                    this.emit(Events.GAMEOBJECT_OUT, pointer, gameObject, _eventContainer);

	                    if (_eventData.cancelled || !this.isActive())
	                    {

	                        break;
	                    }
	                }
	            }

	            if (!_eventData.cancelled && this.isActive())
	            {
	                this.emit(Events.POINTER_OUT, pointer, previouslyOver);
	            }

	            this._over[pointer.id] = [];
	        }

	        return totalInteracted;
	    },

	    processOverOutEvents: function (pointer)
	    {
	        var currentlyOver = this._temp;

	        var i;
	        var gameObject;
	        var justOut = [];
	        var justOver = [];
	        var stillOver = [];
	        var previouslyOver = this._over[pointer.id];
	        var currentlyDragging = this._drag[pointer.id];

	        var manager = this.manager;

	        for (i = 0; i < previouslyOver.length; i++)
	        {
	            gameObject = previouslyOver[i];

	            if (currentlyOver.indexOf(gameObject) === -1 && currentlyDragging.indexOf(gameObject) === -1)
	            {

	                justOut.push(gameObject);
	            }
	            else
	            {

	                stillOver.push(gameObject);
	            }
	        }

	        for (i = 0; i < currentlyOver.length; i++)
	        {
	            gameObject = currentlyOver[i];

	            if (previouslyOver.indexOf(gameObject) === -1)
	            {
	                justOver.push(gameObject);
	            }
	        }

	        var total = justOut.length;

	        var totalInteracted = 0;

	        var _eventData = this._eventData;
	        var _eventContainer = this._eventContainer;

	        _eventData.cancelled = false;

	        if (total > 0)
	        {
	            this.sortGameObjects(justOut, pointer);

	            for (i = 0; i < total; i++)
	            {
	                gameObject = justOut[i];

	                if (!gameObject.input || !gameObject.input.enabled)
	                {
	                    continue;
	                }

	                manager.resetCursor(gameObject.input);

	                gameObject.emit(Events.GAMEOBJECT_POINTER_OUT, pointer, _eventContainer);

	                totalInteracted++;

	                if (_eventData.cancelled || !this.isActive())
	                {

	                    break;
	                }

	                if (gameObject.input && gameObject.input.enabled)
	                {
	                    this.emit(Events.GAMEOBJECT_OUT, pointer, gameObject, _eventContainer);

	                    if (_eventData.cancelled || !this.isActive())
	                    {

	                        break;
	                    }
	                }
	            }

	            if (!_eventData.cancelled || this.isActive())
	            {
	                this.emit(Events.POINTER_OUT, pointer, justOut);
	            }
	        }

	        total = justOver.length;

	        _eventData.cancelled = false;

	        if (total > 0)
	        {
	            this.sortGameObjects(justOver, pointer);

	            for (i = 0; i < total; i++)
	            {
	                gameObject = justOver[i];

	                if (!gameObject.input || !gameObject.input.enabled)
	                {
	                    continue;
	                }

	                manager.setCursor(gameObject.input);

	                gameObject.emit(Events.GAMEOBJECT_POINTER_OVER, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);

	                totalInteracted++;

	                if (_eventData.cancelled || !this.isActive())
	                {

	                    break;
	                }

	                if (gameObject.input && gameObject.input.enabled)
	                {
	                    this.emit(Events.GAMEOBJECT_OVER, pointer, gameObject, _eventContainer);

	                    if (_eventData.cancelled || !this.isActive())
	                    {

	                        break;
	                    }
	                }
	            }

	            if (!_eventData.cancelled && this.isActive())
	            {
	                this.emit(Events.POINTER_OVER, pointer, justOver);
	            }
	        }

	        previouslyOver = stillOver.concat(justOver);

	        this._over[pointer.id] = this.sortGameObjects(previouslyOver, pointer);

	        return totalInteracted;
	    },

	    processUpEvents: function (pointer)
	    {
	        var currentlyOver = this._temp;

	        var _eventData = this._eventData;
	        var _eventContainer = this._eventContainer;

	        _eventData.cancelled = false;

	        for (var i = 0; i < currentlyOver.length; i++)
	        {
	            var gameObject = currentlyOver[i];

	            if (!gameObject.input || !gameObject.input.enabled)
	            {
	                continue;
	            }

	            gameObject.emit(Events.GAMEOBJECT_POINTER_UP, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);

	            if (_eventData.cancelled || !this.isActive())
	            {

	                break;
	            }

	            if (gameObject.input && gameObject.input.enabled)
	            {

	                this.emit(Events.GAMEOBJECT_UP, pointer, gameObject, _eventContainer);

	                if (_eventData.cancelled || !this.isActive())
	                {

	                    break;
	                }
	            }
	        }

	        if (!_eventData.cancelled && this.isActive())
	        {
	            if (pointer.upElement === this.manager.game.canvas)
	            {
	                this.emit(Events.POINTER_UP, pointer, currentlyOver);
	            }
	            else
	            {
	                this.emit(Events.POINTER_UP_OUTSIDE, pointer);
	            }
	        }

	        return currentlyOver.length;
	    },

	    forceDownState: function (pointer, gameObject)
	    {
	        this.forceState(pointer, gameObject, Events.GAMEOBJECT_POINTER_DOWN, Events.GAMEOBJECT_DOWN, false);
	    },

	    forceUpState: function (pointer, gameObject)
	    {
	        this.forceState(pointer, gameObject, Events.GAMEOBJECT_POINTER_UP, Events.GAMEOBJECT_UP, false);
	    },

	    forceOverState: function (pointer, gameObject)
	    {
	        this.forceState(pointer, gameObject, Events.GAMEOBJECT_POINTER_OVER, Events.GAMEOBJECT_OVER, true);
	    },

	    forceOutState: function (pointer, gameObject)
	    {
	        this.forceState(pointer, gameObject, Events.GAMEOBJECT_POINTER_OUT, Events.GAMEOBJECT_OUT, false);
	    },

	    forceState: function (pointer, gameObject, gameObjectEvent, inputPluginEvent, setCursor)
	    {
	        var _eventData = this._eventData;
	        var _eventContainer = this._eventContainer;

	        _eventData.cancelled = false;

	        if (gameObject.input && gameObject.input.enabled)
	        {
	            gameObject.emit(gameObjectEvent, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);

	            if (setCursor)
	            {
	                this.setCursor(gameObject.input);
	            }

	            if (!_eventData.cancelled && this.isActive() && gameObject.input && gameObject.input.enabled)
	            {
	                this.emit(inputPluginEvent, pointer, gameObject, _eventContainer);
	            }
	        }
	    },

	    queueForInsertion: function (child)
	    {
	        if (this._pendingInsertion.indexOf(child) === -1 && this._list.indexOf(child) === -1)
	        {
	            this._pendingInsertion.push(child);
	        }

	        return this;
	    },

	    queueForRemoval: function (child)
	    {
	        this._pendingRemoval.push(child);

	        return this;
	    },

	    setDraggable: function (gameObjects, value)
	    {
	        if (value === undefined) { value = true; }

	        if (!Array.isArray(gameObjects))
	        {
	            gameObjects = [ gameObjects ];
	        }

	        for (var i = 0; i < gameObjects.length; i++)
	        {
	            var gameObject = gameObjects[i];

	            gameObject.input.draggable = value;

	            var index = this._draggable.indexOf(gameObject);

	            if (value && index === -1)
	            {
	                this._draggable.push(gameObject);
	            }
	            else if (!value && index > -1)
	            {
	                this._draggable.splice(index, 1);
	            }
	        }

	        return this;
	    },

	    makePixelPerfect: function (alphaTolerance)
	    {
	        if (alphaTolerance === undefined) { alphaTolerance = 1; }

	        var textureManager = this.systems.textures;

	        return CreatePixelPerfectHandler(textureManager, alphaTolerance);
	    },

	    setHitArea: function (gameObjects, hitArea, hitAreaCallback)
	    {
	        if (hitArea === undefined)
	        {
	            return this.setHitAreaFromTexture(gameObjects);
	        }

	        if (!Array.isArray(gameObjects))
	        {
	            gameObjects = [ gameObjects ];
	        }

	        var draggable = false;
	        var dropZone = false;
	        var cursor = false;
	        var useHandCursor = false;
	        var pixelPerfect = false;
	        var customHitArea = true;

	        if (IsPlainObject(hitArea) && Object.keys(hitArea).length)
	        {
	            var config = hitArea;

	            var isMesh = gameObjects.some(function (gameObject)
	            {
	                return gameObject.hasOwnProperty('faces');
	            });

	            if (!isMesh)
	            {
	                hitArea = GetFastValue(config, 'hitArea', null);
	                hitAreaCallback = GetFastValue(config, 'hitAreaCallback', null);

	                pixelPerfect = GetFastValue(config, 'pixelPerfect', false);
	                var alphaTolerance = GetFastValue(config, 'alphaTolerance', 1);

	                if (pixelPerfect)
	                {
	                    hitArea = {};
	                    hitAreaCallback = this.makePixelPerfect(alphaTolerance);
	                }
	            }

	            draggable = GetFastValue(config, 'draggable', false);
	            dropZone = GetFastValue(config, 'dropZone', false);
	            cursor = GetFastValue(config, 'cursor', false);
	            useHandCursor = GetFastValue(config, 'useHandCursor', false);

	            if (!hitArea || !hitAreaCallback)
	            {
	                this.setHitAreaFromTexture(gameObjects);
	                customHitArea = false;
	            }
	        }
	        else if (typeof hitArea === 'function' && !hitAreaCallback)
	        {
	            hitAreaCallback = hitArea;
	            hitArea = {};
	        }

	        for (var i = 0; i < gameObjects.length; i++)
	        {
	            var gameObject = gameObjects[i];

	            if (pixelPerfect && gameObject.type === 'Container')
	            {
	                console.warn('Cannot pixelPerfect test a Container. Use a custom callback.');
	                continue;
	            }

	            var io = (!gameObject.input) ? CreateInteractiveObject(gameObject, hitArea, hitAreaCallback) : gameObject.input;

	            io.customHitArea = customHitArea;
	            io.dropZone = dropZone;
	            io.cursor = (useHandCursor) ? 'pointer' : cursor;

	            gameObject.input = io;

	            if (draggable)
	            {
	                this.setDraggable(gameObject);
	            }

	            this.queueForInsertion(gameObject);
	        }

	        return this;
	    },

	    setHitAreaCircle: function (gameObjects, x, y, radius, callback)
	    {
	        if (callback === undefined) { callback = CircleContains; }

	        var shape = new Circle(x, y, radius);

	        return this.setHitArea(gameObjects, shape, callback);
	    },

	    setHitAreaEllipse: function (gameObjects, x, y, width, height, callback)
	    {
	        if (callback === undefined) { callback = EllipseContains; }

	        var shape = new Ellipse(x, y, width, height);

	        return this.setHitArea(gameObjects, shape, callback);
	    },

	    setHitAreaFromTexture: function (gameObjects, callback)
	    {
	        if (callback === undefined) { callback = RectangleContains; }

	        if (!Array.isArray(gameObjects))
	        {
	            gameObjects = [ gameObjects ];
	        }

	        for (var i = 0; i < gameObjects.length; i++)
	        {
	            var gameObject = gameObjects[i];

	            var frame = gameObject.frame;

	            var width = 0;
	            var height = 0;

	            if (gameObject.width)
	            {
	                width = gameObject.width;
	                height = gameObject.height;
	            }
	            else if (frame)
	            {
	                width = frame.realWidth;
	                height = frame.realHeight;
	            }

	            if (gameObject.type === 'Container' && (width === 0 || height === 0))
	            {
	                console.warn('Container.setInteractive must specify a Shape or call setSize() first');
	                continue;
	            }

	            if (width !== 0 && height !== 0)
	            {
	                gameObject.input = CreateInteractiveObject(gameObject, new Rectangle(0, 0, width, height), callback);

	                this.queueForInsertion(gameObject);
	            }
	        }

	        return this;
	    },

	    setHitAreaRectangle: function (gameObjects, x, y, width, height, callback)
	    {
	        if (callback === undefined) { callback = RectangleContains; }

	        var shape = new Rectangle(x, y, width, height);

	        return this.setHitArea(gameObjects, shape, callback);
	    },

	    setHitAreaTriangle: function (gameObjects, x1, y1, x2, y2, x3, y3, callback)
	    {
	        if (callback === undefined) { callback = TriangleContains; }

	        var shape = new Triangle(x1, y1, x2, y2, x3, y3);

	        return this.setHitArea(gameObjects, shape, callback);
	    },

	    enableDebug: function (gameObject, color)
	    {
	        if (color === undefined) { color = 0x00ff00; }

	        var input = gameObject.input;

	        if (!input || !input.hitArea)
	        {
	            return this;
	        }

	        var shape = input.hitArea;
	        var shapeType = shape.type;
	        var debug = input.hitAreaDebug;
	        var factory = this.systems.add;
	        var updateList = this.systems.updateList;

	        if (debug)
	        {
	            updateList.remove(debug);

	            debug.destroy();

	            debug = null;
	        }

	        var offsetx = 0;
	        var offsety = 0;

	        switch (shapeType)
	        {
	            case GEOM_CONST.CIRCLE:
	                debug = factory.arc(0, 0, shape.radius);
	                offsetx = shape.x - shape.radius;
	                offsety = shape.y - shape.radius;
	                break;

	            case GEOM_CONST.ELLIPSE:
	                debug = factory.ellipse(0, 0, shape.width, shape.height);
	                offsetx = shape.x - shape.width / 2;
	                offsety = shape.y - shape.height / 2;
	                break;

	            case GEOM_CONST.LINE:
	                debug = factory.line(0, 0, shape.x1, shape.y1, shape.x2, shape.y2);
	                break;

	            case GEOM_CONST.POLYGON:
	                debug = factory.polygon(0, 0, shape.points);
	                break;

	            case GEOM_CONST.RECTANGLE:
	                debug = factory.rectangle(0, 0, shape.width, shape.height);
	                offsetx = shape.x;
	                offsety = shape.y;
	                break;

	            case GEOM_CONST.TRIANGLE:
	                debug = factory.triangle(0, 0, shape.x1, shape.y1, shape.x2, shape.y2, shape.x3, shape.y3);
	                break;
	        }

	        if (debug)
	        {
	            debug.isFilled = false;
	            debug.strokeColor = color;

	            debug.preUpdate = function ()
	            {
	                debug.setVisible(gameObject.visible);

	                debug.setStrokeStyle(1 / gameObject.scale, debug.strokeColor);

	                debug.setDisplayOrigin(gameObject.displayOriginX, gameObject.displayOriginY);

	                var x = gameObject.x;
	                var y = gameObject.y;
	                var rotation = gameObject.rotation;
	                var scaleX = gameObject.scaleX;
	                var scaleY = gameObject.scaleY;

	                if (gameObject.parentContainer)
	                {
	                    var matrix = gameObject.getWorldTransformMatrix();

	                    x = matrix.tx;
	                    y = matrix.ty;
	                    rotation = matrix.rotation;
	                    scaleX = matrix.scaleX;
	                    scaleY = matrix.scaleY;
	                }

	                debug.setRotation(rotation);
	                debug.setScale(scaleX, scaleY);
	                debug.setPosition(x + offsetx * scaleX, y + offsety * scaleY);
	                debug.setScrollFactor(gameObject.scrollFactorX, gameObject.scrollFactorY);
	                debug.setDepth(gameObject.depth);
	            };

	            updateList.add(debug);

	            input.hitAreaDebug = debug;
	        }

	        return this;
	    },

	    removeDebug: function (gameObject)
	    {
	        var input = gameObject.input;

	        if (input && input.hitAreaDebug)
	        {
	            var debug = input.hitAreaDebug;

	            debug.destroy();

	            input.hitAreaDebug = null;
	        }

	        return this;
	    },

	    setPollAlways: function ()
	    {
	        return this.setPollRate(0);
	    },

	    setPollOnMove: function ()
	    {
	        return this.setPollRate(-1);
	    },

	    setPollRate: function (value)
	    {
	        this.pollRate = value;
	        this._pollTimer = 0;

	        return this;
	    },

	    setGlobalTopOnly: function (value)
	    {
	        this.manager.globalTopOnly = value;

	        return this;
	    },

	    setTopOnly: function (value)
	    {
	        this.topOnly = value;

	        return this;
	    },

	    sortGameObjects: function (gameObjects, pointer)
	    {
	        if (gameObjects.length < 2 || !pointer.camera)
	        {
	            return gameObjects;
	        }

	        var list = pointer.camera.renderList;

	        return gameObjects.sort(function (childA, childB)
	        {
	            var indexA = Math.max(list.indexOf(childA), 0);
	            var indexB = Math.max(list.indexOf(childB), 0);

	            return indexB - indexA;
	        });
	    },

	    sortDropZones: function (gameObjects)
	    {
	        if (gameObjects.length < 2)
	        {
	            return gameObjects;
	        }

	        this.scene.sys.depthSort();

	        return gameObjects.sort(this.sortDropZoneHandler.bind(this));
	    },

	    sortDropZoneHandler: function (childA, childB)
	    {
	        if (!childA.parentContainer && !childB.parentContainer)
	        {

	            return this.displayList.getIndex(childB) - this.displayList.getIndex(childA);
	        }
	        else if (childA.parentContainer === childB.parentContainer)
	        {

	            return childB.parentContainer.getIndex(childB) - childA.parentContainer.getIndex(childA);
	        }
	        else if (childA.parentContainer === childB)
	        {

	            return -1;
	        }
	        else if (childB.parentContainer === childA)
	        {

	            return 1;
	        }
	        else
	        {

	            var listA = childA.getIndexList();
	            var listB = childB.getIndexList();
	            var len = Math.min(listA.length, listB.length);

	            for (var i = 0; i < len; i++)
	            {
	                var indexA = listA[i];
	                var indexB = listB[i];

	                if (indexA === indexB)
	                {

	                    continue;
	                }
	                else
	                {

	                    return indexB - indexA;
	                }
	            }

	            return listB.length - listA.length;
	        }
	    },

	    stopPropagation: function ()
	    {
	        this.manager._tempSkip = true;

	        return this;
	    },

	    addPointer: function (quantity)
	    {
	        return this.manager.addPointer(quantity);
	    },

	    setDefaultCursor: function (cursor)
	    {
	        this.manager.setDefaultCursor(cursor);

	        return this;
	    },

	    transitionIn: function ()
	    {
	        this.enabled = this.settings.transitionAllowInput;
	    },

	    transitionComplete: function ()
	    {
	        if (!this.settings.transitionAllowInput)
	        {
	            this.enabled = true;
	        }
	    },

	    transitionOut: function ()
	    {
	        this.enabled = this.settings.transitionAllowInput;
	    },

	    shutdown: function ()
	    {

	        this.pluginEvents.emit(Events.SHUTDOWN);

	        this._temp.length = 0;
	        this._list.length = 0;
	        this._draggable.length = 0;
	        this._pendingRemoval.length = 0;
	        this._pendingInsertion.length = 0;
	        this._dragState.length = 0;

	        for (var i = 0; i < 10; i++)
	        {
	            this._drag[i] = [];
	            this._over[i] = [];
	        }

	        this.removeAllListeners();

	        var manager = this.manager;

	        manager.canvas.style.cursor = manager.defaultCursor;

	        var eventEmitter = this.systems.events;

	        eventEmitter.off(SceneEvents.TRANSITION_START, this.transitionIn, this);
	        eventEmitter.off(SceneEvents.TRANSITION_OUT, this.transitionOut, this);
	        eventEmitter.off(SceneEvents.TRANSITION_COMPLETE, this.transitionComplete, this);
	        eventEmitter.off(SceneEvents.PRE_UPDATE, this.preUpdate, this);

	        manager.events.off(Events.GAME_OUT, this.onGameOut, this);
	        manager.events.off(Events.GAME_OVER, this.onGameOver, this);

	        eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);
	    },

	    resetPointers: function ()
	    {
	        var pointers = this.manager.pointers;

	        for (var i = 0; i < pointers.length; i++)
	        {
	            pointers[i].reset();
	        }
	    },

	    destroy: function ()
	    {
	        this.shutdown();

	        this.pluginEvents.emit(Events.DESTROY);

	        this.pluginEvents.removeAllListeners();

	        this.scene.sys.events.off(SceneEvents.START, this.start, this);

	        this.scene = null;
	        this.cameras = null;
	        this.manager = null;
	        this.events = null;
	        this.mouse = null;
	    },

	    x: {

	        get: function ()
	        {
	            return this.manager.activePointer.x;
	        }

	    },

	    y: {

	        get: function ()
	        {
	            return this.manager.activePointer.y;
	        }

	    },

	    isOver: {

	        get: function ()
	        {
	            return this.manager.isOver;
	        }

	    },

	    mousePointer: {

	        get: function ()
	        {
	            return this.manager.mousePointer;
	        }

	    },

	    activePointer: {

	        get: function ()
	        {
	            return this.manager.activePointer;
	        }

	    },

	    pointer1: {

	        get: function ()
	        {
	            return this.manager.pointers[1];
	        }

	    },

	    pointer2: {

	        get: function ()
	        {
	            return this.manager.pointers[2];
	        }

	    },

	    pointer3: {

	        get: function ()
	        {
	            return this.manager.pointers[3];
	        }

	    },

	    pointer4: {

	        get: function ()
	        {
	            return this.manager.pointers[4];
	        }

	    },

	    pointer5: {

	        get: function ()
	        {
	            return this.manager.pointers[5];
	        }

	    },

	    pointer6: {

	        get: function ()
	        {
	            return this.manager.pointers[6];
	        }

	    },

	    pointer7: {

	        get: function ()
	        {
	            return this.manager.pointers[7];
	        }

	    },

	    pointer8: {

	        get: function ()
	        {
	            return this.manager.pointers[8];
	        }

	    },

	    pointer9: {

	        get: function ()
	        {
	            return this.manager.pointers[9];
	        }

	    },

	    pointer10: {

	        get: function ()
	        {
	            return this.manager.pointers[10];
	        }

	    }

	});

	PluginCache.register('InputPlugin', InputPlugin, 'input');

	InputPlugin_1 = InputPlugin;
	return InputPlugin_1;
}

var ANY_KEY_DOWN_EVENT;
var hasRequiredANY_KEY_DOWN_EVENT;

function requireANY_KEY_DOWN_EVENT () {
	if (hasRequiredANY_KEY_DOWN_EVENT) return ANY_KEY_DOWN_EVENT;
	hasRequiredANY_KEY_DOWN_EVENT = 1;
	ANY_KEY_DOWN_EVENT = 'keydown';
	return ANY_KEY_DOWN_EVENT;
}

var ANY_KEY_UP_EVENT;
var hasRequiredANY_KEY_UP_EVENT;

function requireANY_KEY_UP_EVENT () {
	if (hasRequiredANY_KEY_UP_EVENT) return ANY_KEY_UP_EVENT;
	hasRequiredANY_KEY_UP_EVENT = 1;
	ANY_KEY_UP_EVENT = 'keyup';
	return ANY_KEY_UP_EVENT;
}

var COMBO_MATCH_EVENT;
var hasRequiredCOMBO_MATCH_EVENT;

function requireCOMBO_MATCH_EVENT () {
	if (hasRequiredCOMBO_MATCH_EVENT) return COMBO_MATCH_EVENT;
	hasRequiredCOMBO_MATCH_EVENT = 1;
	COMBO_MATCH_EVENT = 'keycombomatch';
	return COMBO_MATCH_EVENT;
}

var DOWN_EVENT;
var hasRequiredDOWN_EVENT;

function requireDOWN_EVENT () {
	if (hasRequiredDOWN_EVENT) return DOWN_EVENT;
	hasRequiredDOWN_EVENT = 1;
	DOWN_EVENT = 'down';
	return DOWN_EVENT;
}

var KEY_DOWN_EVENT;
var hasRequiredKEY_DOWN_EVENT;

function requireKEY_DOWN_EVENT () {
	if (hasRequiredKEY_DOWN_EVENT) return KEY_DOWN_EVENT;
	hasRequiredKEY_DOWN_EVENT = 1;
	KEY_DOWN_EVENT = 'keydown-';
	return KEY_DOWN_EVENT;
}

var KEY_UP_EVENT;
var hasRequiredKEY_UP_EVENT;

function requireKEY_UP_EVENT () {
	if (hasRequiredKEY_UP_EVENT) return KEY_UP_EVENT;
	hasRequiredKEY_UP_EVENT = 1;
	KEY_UP_EVENT = 'keyup-';
	return KEY_UP_EVENT;
}

var UP_EVENT;
var hasRequiredUP_EVENT;

function requireUP_EVENT () {
	if (hasRequiredUP_EVENT) return UP_EVENT;
	hasRequiredUP_EVENT = 1;
	UP_EVENT = 'up';
	return UP_EVENT;
}

var events$3;
var hasRequiredEvents$3;

function requireEvents$3 () {
	if (hasRequiredEvents$3) return events$3;
	hasRequiredEvents$3 = 1;
	events$3 = {

	    ANY_KEY_DOWN: requireANY_KEY_DOWN_EVENT(),
	    ANY_KEY_UP: requireANY_KEY_UP_EVENT(),
	    COMBO_MATCH: requireCOMBO_MATCH_EVENT(),
	    DOWN: requireDOWN_EVENT(),
	    KEY_DOWN: requireKEY_DOWN_EVENT(),
	    KEY_UP: requireKEY_UP_EVENT(),
	    UP: requireUP_EVENT()

	};
	return events$3;
}

var Key_1;
var hasRequiredKey;

function requireKey () {
	if (hasRequiredKey) return Key_1;
	hasRequiredKey = 1;
	var Class = requireClass();
	var EventEmitter = requireEventemitter3();
	var Events = requireEvents$3();

	var Key = new Class({

	    Extends: EventEmitter,

	    initialize:

	    function Key (plugin, keyCode)
	    {
	        EventEmitter.call(this);

	        this.plugin = plugin;

	        this.keyCode = keyCode;

	        this.originalEvent = undefined;

	        this.enabled = true;

	        this.isDown = false;

	        this.isUp = true;

	        this.altKey = false;

	        this.ctrlKey = false;

	        this.shiftKey = false;

	        this.metaKey = false;

	        this.location = 0;

	        this.timeDown = 0;

	        this.duration = 0;

	        this.timeUp = 0;

	        this.emitOnRepeat = false;

	        this.repeats = 0;

	        this._justDown = false;

	        this._justUp = false;

	        this._tick = -1;
	    },

	    setEmitOnRepeat: function (value)
	    {
	        this.emitOnRepeat = value;

	        return this;
	    },

	    onDown: function (event)
	    {
	        this.originalEvent = event;

	        if (!this.enabled)
	        {
	            return;
	        }

	        this.altKey = event.altKey;
	        this.ctrlKey = event.ctrlKey;
	        this.shiftKey = event.shiftKey;
	        this.metaKey = event.metaKey;
	        this.location = event.location;

	        this.repeats++;

	        if (!this.isDown)
	        {
	            this.isDown = true;
	            this.isUp = false;
	            this.timeDown = event.timeStamp;
	            this.duration = 0;
	            this._justDown = true;
	            this._justUp = false;

	            this.emit(Events.DOWN, this, event);
	        }
	        else if (this.emitOnRepeat)
	        {
	            this.emit(Events.DOWN, this, event);
	        }
	    },

	    onUp: function (event)
	    {
	        this.originalEvent = event;

	        if (!this.enabled)
	        {
	            return;
	        }

	        this.isDown = false;
	        this.isUp = true;
	        this.timeUp = event.timeStamp;
	        this.duration = this.timeUp - this.timeDown;
	        this.repeats = 0;

	        this._justDown = false;
	        this._justUp = true;
	        this._tick = -1;

	        this.emit(Events.UP, this, event);
	    },

	    reset: function ()
	    {
	        this.isDown = false;
	        this.isUp = true;
	        this.altKey = false;
	        this.ctrlKey = false;
	        this.shiftKey = false;
	        this.metaKey = false;
	        this.timeDown = 0;
	        this.duration = 0;
	        this.timeUp = 0;
	        this.repeats = 0;
	        this._justDown = false;
	        this._justUp = false;
	        this._tick = -1;

	        return this;
	    },

	    getDuration: function ()
	    {
	        if (this.isDown)
	        {
	            return (this.plugin.game.loop.time - this.timeDown);
	        }
	        else
	        {
	            return 0;
	        }
	    },

	    destroy: function ()
	    {
	        this.removeAllListeners();

	        this.originalEvent = null;

	        this.plugin = null;
	    }

	});

	Key_1 = Key;
	return Key_1;
}

var AdvanceKeyCombo_1;
var hasRequiredAdvanceKeyCombo;

function requireAdvanceKeyCombo () {
	if (hasRequiredAdvanceKeyCombo) return AdvanceKeyCombo_1;
	hasRequiredAdvanceKeyCombo = 1;
	var AdvanceKeyCombo = function (event, combo)
	{
	    combo.timeLastMatched = event.timeStamp;
	    combo.index++;

	    if (combo.index === combo.size)
	    {
	        return true;
	    }
	    else
	    {
	        combo.current = combo.keyCodes[combo.index];
	        return false;
	    }
	};

	AdvanceKeyCombo_1 = AdvanceKeyCombo;
	return AdvanceKeyCombo_1;
}

var ProcessKeyCombo_1;
var hasRequiredProcessKeyCombo;

function requireProcessKeyCombo () {
	if (hasRequiredProcessKeyCombo) return ProcessKeyCombo_1;
	hasRequiredProcessKeyCombo = 1;
	var AdvanceKeyCombo = requireAdvanceKeyCombo();

	var ProcessKeyCombo = function (event, combo)
	{
	    if (combo.matched)
	    {
	        return true;
	    }

	    var comboMatched = false;
	    var keyMatched = false;

	    if (event.keyCode === combo.current)
	    {

	        if (combo.index > 0 && combo.maxKeyDelay > 0)
	        {

	            var timeLimit = combo.timeLastMatched + combo.maxKeyDelay;

	            if (event.timeStamp <= timeLimit)
	            {
	                keyMatched = true;
	                comboMatched = AdvanceKeyCombo(event, combo);
	            }
	        }
	        else
	        {
	            keyMatched = true;

	            comboMatched = AdvanceKeyCombo(event, combo);
	        }
	    }

	    if (!keyMatched && combo.resetOnWrongKey)
	    {

	        combo.index = 0;
	        combo.current = combo.keyCodes[0];
	    }

	    if (comboMatched)
	    {
	        combo.timeLastMatched = event.timeStamp;
	        combo.matched = true;
	        combo.timeMatched = event.timeStamp;
	    }

	    return comboMatched;
	};

	ProcessKeyCombo_1 = ProcessKeyCombo;
	return ProcessKeyCombo_1;
}

var ResetKeyCombo_1;
var hasRequiredResetKeyCombo;

function requireResetKeyCombo () {
	if (hasRequiredResetKeyCombo) return ResetKeyCombo_1;
	hasRequiredResetKeyCombo = 1;
	var ResetKeyCombo = function (combo)
	{
	    combo.current = combo.keyCodes[0];
	    combo.index = 0;
	    combo.timeLastMatched = 0;
	    combo.matched = false;
	    combo.timeMatched = 0;

	    return combo;
	};

	ResetKeyCombo_1 = ResetKeyCombo;
	return ResetKeyCombo_1;
}

var KeyCombo_1;
var hasRequiredKeyCombo;

function requireKeyCombo () {
	if (hasRequiredKeyCombo) return KeyCombo_1;
	hasRequiredKeyCombo = 1;
	var Class = requireClass();
	var Events = requireEvents$3();
	var GetFastValue = requireGetFastValue();
	var ProcessKeyCombo = requireProcessKeyCombo();
	var ResetKeyCombo = requireResetKeyCombo();

	var KeyCombo = new Class({

	    initialize:

	    function KeyCombo (keyboardPlugin, keys, config)
	    {
	        if (config === undefined) { config = {}; }

	        if (keys.length < 2)
	        {
	            return false;
	        }

	        this.manager = keyboardPlugin;

	        this.enabled = true;

	        this.keyCodes = [];

	        for (var i = 0; i < keys.length; i++)
	        {
	            var char = keys[i];

	            if (typeof char === 'string')
	            {
	                this.keyCodes.push(char.toUpperCase().charCodeAt(0));
	            }
	            else if (typeof char === 'number')
	            {
	                this.keyCodes.push(char);
	            }
	            else if (char.hasOwnProperty('keyCode'))
	            {
	                this.keyCodes.push(char.keyCode);
	            }
	        }

	        this.current = this.keyCodes[0];

	        this.index = 0;

	        this.size = this.keyCodes.length;

	        this.timeLastMatched = 0;

	        this.matched = false;

	        this.timeMatched = 0;

	        this.resetOnWrongKey = GetFastValue(config, 'resetOnWrongKey', true);

	        this.maxKeyDelay = GetFastValue(config, 'maxKeyDelay', 0);

	        this.resetOnMatch = GetFastValue(config, 'resetOnMatch', false);

	        this.deleteOnMatch = GetFastValue(config, 'deleteOnMatch', false);

	        var _this = this;

	        var onKeyDownHandler = function (event)
	        {
	            if (_this.matched || !_this.enabled)
	            {
	                return;
	            }

	            var matched = ProcessKeyCombo(event, _this);

	            if (matched)
	            {
	                _this.manager.emit(Events.COMBO_MATCH, _this, event);

	                if (_this.resetOnMatch)
	                {
	                    ResetKeyCombo(_this);
	                }
	                else if (_this.deleteOnMatch)
	                {
	                    _this.destroy();
	                }
	            }
	        };

	        this.onKeyDown = onKeyDownHandler;

	        this.manager.on(Events.ANY_KEY_DOWN, this.onKeyDown);
	    },

	    progress: {

	        get: function ()
	        {
	            return this.index / this.size;
	        }

	    },

	    destroy: function ()
	    {
	        this.enabled = false;
	        this.keyCodes = [];

	        this.manager.off(Events.ANY_KEY_DOWN, this.onKeyDown);

	        this.manager = null;
	    }

	});

	KeyCombo_1 = KeyCombo;
	return KeyCombo_1;
}

var KeyMap_1;
var hasRequiredKeyMap;

function requireKeyMap () {
	if (hasRequiredKeyMap) return KeyMap_1;
	hasRequiredKeyMap = 1;
	var KeyCodes = requireKeyCodes();

	var KeyMap = {};

	for (var key in KeyCodes)
	{
	    KeyMap[KeyCodes[key]] = key;
	}

	KeyMap_1 = KeyMap;
	return KeyMap_1;
}

var KeyboardPlugin_1;
var hasRequiredKeyboardPlugin;

function requireKeyboardPlugin () {
	if (hasRequiredKeyboardPlugin) return KeyboardPlugin_1;
	hasRequiredKeyboardPlugin = 1;
	var Class = requireClass();
	var EventEmitter = requireEventemitter3();
	var Events = requireEvents$3();
	var GameEvents = requireEvents$h();
	var GetValue = requireGetValue();
	var InputEvents = requireEvents$9();
	var InputPluginCache = requireInputPluginCache();
	var Key = requireKey();
	var KeyCodes = requireKeyCodes();
	var KeyCombo = requireKeyCombo();
	var KeyMap = requireKeyMap();
	var SceneEvents = requireEvents$l();
	var SnapFloor = requireSnapFloor();

	var KeyboardPlugin = new Class({

	    Extends: EventEmitter,

	    initialize:

	    function KeyboardPlugin (sceneInputPlugin)
	    {
	        EventEmitter.call(this);

	        this.game = sceneInputPlugin.systems.game;

	        this.scene = sceneInputPlugin.scene;

	        this.settings = this.scene.sys.settings;

	        this.sceneInputPlugin = sceneInputPlugin;

	        this.manager = sceneInputPlugin.manager.keyboard;

	        this.enabled = true;

	        this.keys = [];

	        this.combos = [];

	        this.prevCode = null;

	        this.prevTime = 0;

	        this.prevType = null;

	        sceneInputPlugin.pluginEvents.once(InputEvents.BOOT, this.boot, this);
	        sceneInputPlugin.pluginEvents.on(InputEvents.START, this.start, this);
	    },

	    boot: function ()
	    {
	        var settings = this.settings.input;

	        this.enabled = GetValue(settings, 'keyboard', true);

	        var captures = GetValue(settings, 'keyboard.capture', null);

	        if (captures)
	        {
	            this.addCaptures(captures);
	        }

	        this.sceneInputPlugin.pluginEvents.once(InputEvents.DESTROY, this.destroy, this);
	    },

	    start: function ()
	    {
	        this.sceneInputPlugin.manager.events.on(InputEvents.MANAGER_PROCESS, this.update, this);

	        this.sceneInputPlugin.pluginEvents.once(InputEvents.SHUTDOWN, this.shutdown, this);

	        this.game.events.on(GameEvents.BLUR, this.resetKeys, this);

	        this.scene.sys.events.on(SceneEvents.PAUSE, this.resetKeys, this);
	        this.scene.sys.events.on(SceneEvents.SLEEP, this.resetKeys, this);
	    },

	    isActive: function ()
	    {
	        return (this.enabled && this.scene.sys.canInput());
	    },

	    addCapture: function (keycode)
	    {
	        this.manager.addCapture(keycode);

	        return this;
	    },

	    removeCapture: function (keycode)
	    {
	        this.manager.removeCapture(keycode);

	        return this;
	    },

	    getCaptures: function ()
	    {
	        return this.manager.captures;
	    },

	    enableGlobalCapture: function ()
	    {
	        this.manager.preventDefault = true;

	        return this;
	    },

	    disableGlobalCapture: function ()
	    {
	        this.manager.preventDefault = false;

	        return this;
	    },

	    clearCaptures: function ()
	    {
	        this.manager.clearCaptures();

	        return this;
	    },

	    createCursorKeys: function ()
	    {
	        return this.addKeys({
	            up: KeyCodes.UP,
	            down: KeyCodes.DOWN,
	            left: KeyCodes.LEFT,
	            right: KeyCodes.RIGHT,
	            space: KeyCodes.SPACE,
	            shift: KeyCodes.SHIFT
	        });
	    },

	    addKeys: function (keys, enableCapture, emitOnRepeat)
	    {
	        if (enableCapture === undefined) { enableCapture = true; }
	        if (emitOnRepeat === undefined) { emitOnRepeat = false; }

	        var output = {};

	        if (typeof keys === 'string')
	        {
	            keys = keys.split(',');

	            for (var i = 0; i < keys.length; i++)
	            {
	                var currentKey = keys[i].trim();

	                if (currentKey)
	                {
	                    output[currentKey] = this.addKey(currentKey, enableCapture, emitOnRepeat);
	                }
	            }
	        }
	        else
	        {
	            for (var key in keys)
	            {
	                output[key] = this.addKey(keys[key], enableCapture, emitOnRepeat);
	            }
	        }

	        return output;
	    },

	    addKey: function (key, enableCapture, emitOnRepeat)
	    {
	        if (enableCapture === undefined) { enableCapture = true; }
	        if (emitOnRepeat === undefined) { emitOnRepeat = false; }

	        var keys = this.keys;

	        if (key instanceof Key)
	        {
	            var idx = keys.indexOf(key);

	            if (idx > -1)
	            {
	                keys[idx] = key;
	            }
	            else
	            {
	                keys[key.keyCode] = key;
	            }

	            if (enableCapture)
	            {
	                this.addCapture(key.keyCode);
	            }

	            key.setEmitOnRepeat(emitOnRepeat);

	            return key;
	        }

	        if (typeof key === 'string')
	        {
	            key = KeyCodes[key.toUpperCase()];
	        }

	        if (!keys[key])
	        {
	            keys[key] = new Key(this, key);

	            if (enableCapture)
	            {
	                this.addCapture(key);
	            }

	            keys[key].setEmitOnRepeat(emitOnRepeat);
	        }

	        return keys[key];
	    },

	    removeKey: function (key, destroy, removeCapture)
	    {
	        if (destroy === undefined) { destroy = false; }
	        if (removeCapture === undefined) { removeCapture = false; }

	        var keys = this.keys;
	        var ref;

	        if (key instanceof Key)
	        {
	            var idx = keys.indexOf(key);

	            if (idx > -1)
	            {
	                ref = this.keys[idx];

	                this.keys[idx] = undefined;
	            }
	        }
	        else if (typeof key === 'string')
	        {
	            key = KeyCodes[key.toUpperCase()];
	        }

	        if (keys[key])
	        {
	            ref = keys[key];

	            keys[key] = undefined;
	        }

	        if (ref)
	        {
	            ref.plugin = null;

	            if (removeCapture)
	            {
	                this.removeCapture(ref.keyCode);
	            }

	            if (destroy)
	            {
	                ref.destroy();
	            }
	        }

	        return this;
	    },

	    removeAllKeys: function (destroy, removeCapture)
	    {
	        if (destroy === undefined) { destroy = false; }
	        if (removeCapture === undefined) { removeCapture = false; }

	        var keys = this.keys;

	        for (var i = 0; i < keys.length; i++)
	        {
	            var key = keys[i];

	            if (key)
	            {
	                keys[i] = undefined;

	                if (removeCapture)
	                {
	                    this.removeCapture(key.keyCode);
	                }

	                if (destroy)
	                {
	                    key.destroy();
	                }
	            }
	        }

	        return this;
	    },

	    createCombo: function (keys, config)
	    {
	        return new KeyCombo(this, keys, config);
	    },

	    checkDown: function (key, duration)
	    {
	        if (duration === undefined) { duration = 0; }

	        if (this.enabled && key.isDown)
	        {
	            var t = SnapFloor(this.time - key.timeDown, duration);

	            if (t > key._tick)
	            {
	                key._tick = t;

	                return true;
	            }
	        }

	        return false;
	    },

	    update: function ()
	    {
	        var queue = this.manager.queue;
	        var len = queue.length;

	        if (!this.isActive() || len === 0)
	        {
	            return;
	        }

	        var keys = this.keys;

	        for (var i = 0; i < len; i++)
	        {
	            var event = queue[i];
	            var code = event.keyCode;
	            var key = keys[code];
	            var repeat = false;

	            if (event.cancelled === undefined)
	            {

	                event.cancelled = 0;

	                event.stopImmediatePropagation = function ()
	                {
	                    event.cancelled = 1;
	                };

	                event.stopPropagation = function ()
	                {
	                    event.cancelled = -1;
	                };
	            }

	            if (event.cancelled === -1)
	            {

	                continue;
	            }

	            if (code === this.prevCode && event.timeStamp === this.prevTime && event.type === this.prevType)
	            {

	                continue;
	            }

	            this.prevCode = code;
	            this.prevTime = event.timeStamp;
	            this.prevType = event.type;

	            if (event.type === 'keydown')
	            {

	                if (key)
	                {
	                    repeat = key.isDown;

	                    key.onDown(event);
	                }

	                if (!event.cancelled && (!key || !repeat))
	                {
	                    if (KeyMap[code])
	                    {
	                        this.emit(Events.KEY_DOWN + KeyMap[code], event);
	                    }

	                    if (!event.cancelled)
	                    {
	                        this.emit(Events.ANY_KEY_DOWN, event);
	                    }
	                }
	            }
	            else
	            {

	                if (key)
	                {
	                    key.onUp(event);
	                }

	                if (!event.cancelled)
	                {
	                    if (KeyMap[code])
	                    {
	                        this.emit(Events.KEY_UP + KeyMap[code], event);
	                    }

	                    if (!event.cancelled)
	                    {
	                        this.emit(Events.ANY_KEY_UP, event);
	                    }
	                }
	            }

	            if (event.cancelled === 1)
	            {
	                event.cancelled = 0;
	            }
	        }
	    },

	    resetKeys: function ()
	    {
	        var keys = this.keys;

	        for (var i = 0; i < keys.length; i++)
	        {

	            if (keys[i])
	            {
	                keys[i].reset();
	            }
	        }

	        return this;
	    },

	    shutdown: function ()
	    {
	        this.removeAllKeys(true);
	        this.removeAllListeners();

	        this.sceneInputPlugin.manager.events.off(InputEvents.MANAGER_PROCESS, this.update, this);

	        this.game.events.off(GameEvents.BLUR, this.resetKeys);

	        this.scene.sys.events.off(SceneEvents.PAUSE, this.resetKeys, this);
	        this.scene.sys.events.off(SceneEvents.SLEEP, this.resetKeys, this);

	        this.queue = [];
	    },

	    destroy: function ()
	    {
	        this.shutdown();

	        var keys = this.keys;

	        for (var i = 0; i < keys.length; i++)
	        {

	            if (keys[i])
	            {
	                keys[i].destroy();
	            }
	        }

	        this.keys = [];
	        this.combos = [];
	        this.queue = [];

	        this.scene = null;
	        this.settings = null;
	        this.sceneInputPlugin = null;
	        this.manager = null;
	    },

	    time: {

	        get: function ()
	        {
	            return this.sceneInputPlugin.manager.time;
	        }

	    }

	});

	InputPluginCache.register('KeyboardPlugin', KeyboardPlugin, 'keyboard', 'keyboard', 'inputKeyboard');

	KeyboardPlugin_1 = KeyboardPlugin;
	return KeyboardPlugin_1;
}

var JustDown_1;
var hasRequiredJustDown;

function requireJustDown () {
	if (hasRequiredJustDown) return JustDown_1;
	hasRequiredJustDown = 1;
	var JustDown = function (key)
	{
	    if (key._justDown)
	    {
	        key._justDown = false;

	        return true;
	    }
	    else
	    {
	        return false;
	    }
	};

	JustDown_1 = JustDown;
	return JustDown_1;
}

var JustUp_1;
var hasRequiredJustUp;

function requireJustUp () {
	if (hasRequiredJustUp) return JustUp_1;
	hasRequiredJustUp = 1;
	var JustUp = function (key)
	{
	    if (key._justUp)
	    {
	        key._justUp = false;

	        return true;
	    }
	    else
	    {
	        return false;
	    }
	};

	JustUp_1 = JustUp;
	return JustUp_1;
}

var DownDuration_1;
var hasRequiredDownDuration;

function requireDownDuration () {
	if (hasRequiredDownDuration) return DownDuration_1;
	hasRequiredDownDuration = 1;
	var DownDuration = function (key, duration)
	{
	    if (duration === undefined) { duration = 50; }

	    var current = key.plugin.game.loop.time - key.timeDown;

	    return (key.isDown && current < duration);
	};

	DownDuration_1 = DownDuration;
	return DownDuration_1;
}

var UpDuration_1;
var hasRequiredUpDuration;

function requireUpDuration () {
	if (hasRequiredUpDuration) return UpDuration_1;
	hasRequiredUpDuration = 1;
	var UpDuration = function (key, duration)
	{
	    if (duration === undefined) { duration = 50; }

	    var current = key.plugin.game.loop.time - key.timeUp;

	    return (key.isUp && current < duration);
	};

	UpDuration_1 = UpDuration;
	return UpDuration_1;
}

var keyboard;
var hasRequiredKeyboard;

function requireKeyboard () {
	if (hasRequiredKeyboard) return keyboard;
	hasRequiredKeyboard = 1;
	keyboard = {

	    Events: requireEvents$3(),

	    KeyboardManager: requireKeyboardManager(),
	    KeyboardPlugin: requireKeyboardPlugin(),

	    Key: requireKey(),
	    KeyCodes: requireKeyCodes(),

	    KeyCombo: requireKeyCombo(),

	    AdvanceKeyCombo: requireAdvanceKeyCombo(),
	    ProcessKeyCombo: requireProcessKeyCombo(),
	    ResetKeyCombo: requireResetKeyCombo(),

	    JustDown: requireJustDown(),
	    JustUp: requireJustUp(),
	    DownDuration: requireDownDuration(),
	    UpDuration: requireUpDuration()

	};
	return keyboard;
}

var mouse;
var hasRequiredMouse;

function requireMouse () {
	if (hasRequiredMouse) return mouse;
	hasRequiredMouse = 1;
	mouse = {

	    MouseManager: requireMouseManager()

	};
	return mouse;
}

var touch;
var hasRequiredTouch;

function requireTouch () {
	if (hasRequiredTouch) return touch;
	hasRequiredTouch = 1;
	touch = {

	    TouchManager: requireTouchManager()

	};
	return touch;
}

var input;
var hasRequiredInput;

function requireInput () {
	if (hasRequiredInput) return input;
	hasRequiredInput = 1;
	var CONST = require_const$6();
	var Extend = requireExtend$1();

	var Input = {

	    CreatePixelPerfectHandler: requireCreatePixelPerfectHandler(),
	    CreateInteractiveObject: requireCreateInteractiveObject(),
	    Events: requireEvents$9(),
	    Gamepad: requireGamepad(),
	    InputManager: requireInputManager(),
	    InputPlugin: requireInputPlugin(),
	    InputPluginCache: requireInputPluginCache(),
	    Keyboard: requireKeyboard(),
	    Mouse: requireMouse(),
	    Pointer: requirePointer(),
	    Touch: requireTouch()

	};

	Input = Extend(false, Input, CONST);

	input = Input;
	return input;
}

var _const$3;
var hasRequired_const$3;

function require_const$3 () {
	if (hasRequired_const$3) return _const$3;
	hasRequired_const$3 = 1;
	var FILE_CONST = {

	    
	    LOADER_IDLE: 0,

	    
	    LOADER_LOADING: 1,

	    
	    LOADER_PROCESSING: 2,

	    
	    LOADER_COMPLETE: 3,

	    
	    LOADER_SHUTDOWN: 4,

	    
	    LOADER_DESTROYED: 5,

	    
	    FILE_PENDING: 10,

	    
	    FILE_LOADING: 11,

	    
	    FILE_LOADED: 12,

	    
	    FILE_FAILED: 13,

	    
	    FILE_PROCESSING: 14,

	    
	    FILE_ERRORED: 16,

	    
	    FILE_COMPLETE: 17,

	    
	    FILE_DESTROYED: 18,

	    
	    FILE_POPULATED: 19,

	    
	    FILE_PENDING_DESTROY: 20

	};

	_const$3 = FILE_CONST;
	return _const$3;
}

var GetURL_1;
var hasRequiredGetURL;

function requireGetURL () {
	if (hasRequiredGetURL) return GetURL_1;
	hasRequiredGetURL = 1;
	var GetURL = function (file, baseURL)
	{
	    if (!file.url)
	    {
	        return false;
	    }

	    if (file.url.match(/^(?:blob:|data:|capacitor:\/\/|http:\/\/|https:\/\/|\/\/)/))
	    {
	        return file.url;
	    }
	    else
	    {
	        return baseURL + file.url;
	    }
	};

	GetURL_1 = GetURL;
	return GetURL_1;
}

var XHRSettings_1;
var hasRequiredXHRSettings;

function requireXHRSettings () {
	if (hasRequiredXHRSettings) return XHRSettings_1;
	hasRequiredXHRSettings = 1;
	var XHRSettings = function (responseType, async, user, password, timeout, withCredentials)
	{
	    if (responseType === undefined) { responseType = ''; }
	    if (async === undefined) { async = true; }
	    if (user === undefined) { user = ''; }
	    if (password === undefined) { password = ''; }
	    if (timeout === undefined) { timeout = 0; }
	    if (withCredentials === undefined) { withCredentials = false; }

	    // Before sending a request, set the xhr.responseType to "text",
	    // "arraybuffer", "blob", or "document", depending on your data needs.
	    // Note, setting xhr.responseType = '' (or omitting) will default the response to "text".

	    return {

	        //  Ignored by the Loader, only used by File.
	        responseType: responseType,

	        async: async,

	        //  credentials
	        user: user,
	        password: password,

	        //  timeout in ms (0 = no timeout)
	        timeout: timeout,

	        //  setRequestHeader
	        headers: undefined,
	        header: undefined,
	        headerValue: undefined,
	        requestedWith: false,

	        //  overrideMimeType
	        overrideMimeType: undefined,

	        //  withCredentials
	        withCredentials: withCredentials

	    };
	};

	XHRSettings_1 = XHRSettings;
	return XHRSettings_1;
}

var MergeXHRSettings_1;
var hasRequiredMergeXHRSettings;

function requireMergeXHRSettings () {
	if (hasRequiredMergeXHRSettings) return MergeXHRSettings_1;
	hasRequiredMergeXHRSettings = 1;
	var Extend = requireExtend$1();
	var XHRSettings = requireXHRSettings();


	var MergeXHRSettings = function (global, local)
	{
	    var output = (global === undefined) ? XHRSettings() : Extend({}, global);

	    if (local)
	    {
	        for (var setting in local)
	        {
	            if (local[setting] !== undefined)
	            {
	                output[setting] = local[setting];
	            }
	        }
	    }

	    return output;
	};

	MergeXHRSettings_1 = MergeXHRSettings;
	return MergeXHRSettings_1;
}

var XHRLoader_1;
var hasRequiredXHRLoader;

function requireXHRLoader () {
	if (hasRequiredXHRLoader) return XHRLoader_1;
	hasRequiredXHRLoader = 1;
	var MergeXHRSettings = requireMergeXHRSettings();


	var XHRLoader = function (file, globalXHRSettings)
	{
	    var config = MergeXHRSettings(globalXHRSettings, file.xhrSettings);

	    if (file.base64)
	    {
	        var base64Data = file.url.split(';base64,').pop() || file.url.split(',').pop();

	        var fakeXHR;

	        if (file.xhrSettings.responseType === 'arraybuffer')
	        {
	            fakeXHR = {
	                response: Uint8Array.from(atob(base64Data), function (c)
	                {
	                    return c.charCodeAt(0);
	                }).buffer
	            };
	        }
	        else
	        {
	            fakeXHR = {
	                responseText: atob(base64Data)
	            };
	        }

	        file.onBase64Load(fakeXHR);

	        return;
	    }

	    var xhr = new XMLHttpRequest();

	    xhr.open('GET', file.src, config.async, config.user, config.password);

	    xhr.responseType = file.xhrSettings.responseType;
	    xhr.timeout = config.timeout;

	    if (config.headers)
	    {
	        for (var key in config.headers)
	        {
	            xhr.setRequestHeader(key, config.headers[key]);
	        }
	    }

	    if (config.header && config.headerValue)
	    {
	        xhr.setRequestHeader(config.header, config.headerValue);
	    }

	    if (config.requestedWith)
	    {
	        xhr.setRequestHeader('X-Requested-With', config.requestedWith);
	    }

	    if (config.overrideMimeType)
	    {
	        xhr.overrideMimeType(config.overrideMimeType);
	    }

	    if (config.withCredentials)
	    {
	        xhr.withCredentials = true;
	    }

	    // After a successful request, the xhr.response property will contain the requested data as a DOMString, ArrayBuffer, Blob, or Document (depending on what was set for responseType.)

	    xhr.onload = file.onLoad.bind(file, xhr);
	    xhr.onerror = file.onError.bind(file, xhr);
	    xhr.onprogress = file.onProgress.bind(file);
	    xhr.ontimeout = file.onError.bind(file, xhr);

	    //  This is the only standard method, the ones above are browser additions (maybe not universal?)
	    // xhr.onreadystatechange

	    xhr.send();

	    return xhr;
	};

	XHRLoader_1 = XHRLoader;
	return XHRLoader_1;
}

var File_1;
var hasRequiredFile;

function requireFile () {
	if (hasRequiredFile) return File_1;
	hasRequiredFile = 1;
	var Class = requireClass();
	var CONST = require_const$3();
	var Events = requireEvents$8();
	var GetFastValue = requireGetFastValue();
	var GetURL = requireGetURL();
	var MergeXHRSettings = requireMergeXHRSettings();
	var XHRLoader = requireXHRLoader();
	var XHRSettings = requireXHRSettings();


	var File = new Class({

	    initialize:

	    function File (loader, fileConfig)
	    {
	        
	        this.loader = loader;

	        
	        this.cache = GetFastValue(fileConfig, 'cache', false);

	        
	        this.type = GetFastValue(fileConfig, 'type', false);

	        if (!this.type)
	        {
	            throw new Error('Invalid File type: ' + this.type);
	        }

	        
	        this.key = GetFastValue(fileConfig, 'key', false);

	        var loadKey = this.key;

	        if (loader.prefix && loader.prefix !== '')
	        {
	            this.key = loader.prefix + loadKey;
	        }

	        if (!this.key)
	        {
	            throw new Error('Invalid File key: ' + this.key);
	        }

	        var url = GetFastValue(fileConfig, 'url');

	        if (url === undefined)
	        {
	            url = loader.path + loadKey + '.' + GetFastValue(fileConfig, 'extension', '');
	        }
	        else if (typeof url === 'string' && !url.match(/^(?:blob:|data:|capacitor:\/\/|http:\/\/|https:\/\/|\/\/)/))
	        {
	            url = loader.path + url;
	        }

	        
	        this.url = url;

	        
	        this.src = '';

	        
	        this.xhrSettings = XHRSettings(GetFastValue(fileConfig, 'responseType', undefined));

	        if (GetFastValue(fileConfig, 'xhrSettings', false))
	        {
	            this.xhrSettings = MergeXHRSettings(this.xhrSettings, GetFastValue(fileConfig, 'xhrSettings', {}));
	        }

	        
	        this.xhrLoader = null;

	        
	        this.state = (typeof(this.url) === 'function') ? CONST.FILE_POPULATED : CONST.FILE_PENDING;

	        
	        this.bytesTotal = 0;

	        
	        this.bytesLoaded = -1;

	        
	        this.percentComplete = -1;

	        
	        this.crossOrigin = undefined;

	        
	        this.data = undefined;

	        
	        this.config = GetFastValue(fileConfig, 'config', {});

	        
	        this.multiFile;

	        
	        this.linkFile;

	        
	        this.base64 = (typeof url === 'string') && (url.indexOf('data:') === 0);

	        
	        this.retryAttempts = GetFastValue(fileConfig, 'maxRetries', loader.maxRetries);
	    },

	    
	    setLink: function (fileB)
	    {
	        this.linkFile = fileB;

	        fileB.linkFile = this;
	    },

	    
	    resetXHR: function ()
	    {
	        if (this.xhrLoader)
	        {
	            this.xhrLoader.onload = undefined;
	            this.xhrLoader.onerror = undefined;
	            this.xhrLoader.onprogress = undefined;
	        }
	    },

	    
	    load: function ()
	    {
	        if (this.state === CONST.FILE_POPULATED)
	        {
	            //  Can happen for example in a JSONFile if they've provided a JSON object instead of a URL
	            this.loader.nextFile(this, true);
	        }
	        else
	        {
	            this.state = CONST.FILE_LOADING;

	            this.src = GetURL(this, this.loader.baseURL);

	            if (!this.src)
	            {
	                throw new Error('URL Error in File: ' + this.key + ' from: ' + this.url);
	            }

	            if (this.src.indexOf('data:') === 0)
	            {
	                this.base64 = true;
	            }

	            this.xhrLoader = XHRLoader(this, this.loader.xhr);
	        }
	    },

	    
	    onLoad: function (xhr, event)
	    {
	        var isLocalFile = xhr.responseURL && this.loader.localSchemes.some(function (scheme)
	        {
	            return xhr.responseURL.indexOf(scheme) === 0;
	        });

	        var localFileOk = (isLocalFile && event.target.status === 0);

	        var success = !(event.target && event.target.status !== 200) || localFileOk;

	        //  Handle HTTP status codes of 4xx and 5xx as errors, even if xhr.onerror was not called.
	        if (xhr.readyState === 4 && xhr.status >= 400 && xhr.status <= 599)
	        {
	            success = false;
	        }

	        this.state = CONST.FILE_LOADED;

	        this.resetXHR();

	        this.loader.nextFile(this, success);
	    },

	    
	    onBase64Load: function (xhr)
	    {
	        this.xhrLoader = xhr;

	        this.state = CONST.FILE_LOADED;

	        this.percentComplete = 1;

	        this.loader.emit(Events.FILE_PROGRESS, this, this.percentComplete);

	        this.loader.nextFile(this, true);
	    },

	    
	    onError: function ()
	    {
	        this.resetXHR();

	        if (this.retryAttempts > 0)
	        {
	            this.retryAttempts--;

	            this.load();
	        }
	        else
	        {
	            this.loader.nextFile(this, false);
	        }
	    },

	    
	    onProgress: function (event)
	    {
	        if (event.lengthComputable)
	        {
	            this.bytesLoaded = event.loaded;
	            this.bytesTotal = event.total;

	            this.percentComplete = Math.min((this.bytesLoaded / this.bytesTotal), 1);

	            this.loader.emit(Events.FILE_PROGRESS, this, this.percentComplete);
	        }
	    },

	    
	    onProcess: function ()
	    {
	        this.state = CONST.FILE_PROCESSING;

	        this.onProcessComplete();
	    },

	    
	    onProcessComplete: function ()
	    {
	        this.state = CONST.FILE_COMPLETE;

	        if (this.multiFile)
	        {
	            this.multiFile.onFileComplete(this);
	        }

	        this.loader.fileProcessComplete(this);
	    },

	    
	    onProcessError: function ()
	    {
	        // eslint-disable-next-line no-console
	        console.error('Failed to process file: %s "%s"', this.type, this.key);

	        this.state = CONST.FILE_ERRORED;

	        if (this.multiFile)
	        {
	            this.multiFile.onFileFailed(this);
	        }

	        this.loader.fileProcessComplete(this);
	    },

	    
	    hasCacheConflict: function ()
	    {
	        return (this.cache && this.cache.exists(this.key));
	    },

	    
	    addToCache: function ()
	    {
	        if (this.cache && this.data)
	        {
	            this.cache.add(this.key, this.data);
	        }
	    },

	    
	    pendingDestroy: function (data)
	    {
	        if (this.state === CONST.FILE_PENDING_DESTROY)
	        {
	            return;
	        }

	        if (data === undefined) { data = this.data; }

	        var key = this.key;
	        var type = this.type;

	        this.loader.emit(Events.FILE_COMPLETE, key, type, data);
	        this.loader.emit(Events.FILE_KEY_COMPLETE + type + '-' + key, key, type, data);

	        this.loader.flagForRemoval(this);

	        this.state = CONST.FILE_PENDING_DESTROY;
	    },

	    
	    destroy: function ()
	    {
	        this.loader = null;
	        this.cache = null;
	        this.xhrSettings = null;
	        this.multiFile = null;
	        this.linkFile = null;
	        this.data = null;
	    }

	});


	File.createObjectURL = function (image, blob, defaultType)
	{
	    if (typeof URL === 'function')
	    {
	        image.src = URL.createObjectURL(blob);
	    }
	    else
	    {
	        var reader = new FileReader();

	        reader.onload = function ()
	        {
	            image.removeAttribute('crossOrigin');
	            image.src = 'data:' + (blob.type || defaultType) + ';base64,' + reader.result.split(',')[1];
	        };

	        reader.onerror = image.onerror;

	        reader.readAsDataURL(blob);
	    }
	};


	File.revokeObjectURL = function (image)
	{
	    if (typeof URL === 'function')
	    {
	        URL.revokeObjectURL(image.src);
	    }
	};

	File_1 = File;
	return File_1;
}

var JSONFile_1;
var hasRequiredJSONFile;

function requireJSONFile () {
	if (hasRequiredJSONFile) return JSONFile_1;
	hasRequiredJSONFile = 1;
	var Class = requireClass();
	var CONST = require_const$3();
	var File = requireFile();
	var FileTypesManager = requireFileTypesManager();
	var GetFastValue = requireGetFastValue();
	var GetValue = requireGetValue();
	var IsPlainObject = requireIsPlainObject();


	var JSONFile = new Class({

	    Extends: File,

	    initialize:

	    //  url can either be a string, in which case it is treated like a proper url, or an object, in which case it is treated as a ready-made JS Object
	    //  dataKey allows you to pluck a specific object out of the JSON and put just that into the cache, rather than the whole thing

	    function JSONFile (loader, key, url, xhrSettings, dataKey)
	    {
	        var extension = 'json';

	        if (IsPlainObject(key))
	        {
	            var config = key;

	            key = GetFastValue(config, 'key');
	            url = GetFastValue(config, 'url');
	            xhrSettings = GetFastValue(config, 'xhrSettings');
	            extension = GetFastValue(config, 'extension', extension);
	            dataKey = GetFastValue(config, 'dataKey', dataKey);
	        }

	        var fileConfig = {
	            type: 'json',
	            cache: loader.cacheManager.json,
	            extension: extension,
	            responseType: 'text',
	            key: key,
	            url: url,
	            xhrSettings: xhrSettings,
	            config: dataKey
	        };

	        File.call(this, loader, fileConfig);

	        //  A JSON object has been provided (instead of a URL), so we'll use it directly as the File.data. No need to load it.
	        if (IsPlainObject(url))
	        {
	            if (dataKey)
	            {
	                this.data = GetValue(url, dataKey);
	            }
	            else
	            {
	                this.data = url;
	            }

	            this.state = CONST.FILE_POPULATED;
	        }
	    },

	    
	    onProcess: function ()
	    {
	        if (this.state !== CONST.FILE_POPULATED)
	        {
	            this.state = CONST.FILE_PROCESSING;

	            try
	            {
	                var json = JSON.parse(this.xhrLoader.responseText);
	            }
	            catch (e)
	            {
	                this.onProcessError();

	                throw e;
	            }

	            var key = this.config;

	            if (typeof key === 'string')
	            {
	                this.data = GetValue(json, key, json);
	            }
	            else
	            {
	                this.data = json;
	            }
	        }

	        this.onProcessComplete();
	    }

	});


	FileTypesManager.register('json', function (key, url, dataKey, xhrSettings)
	{
	    if (Array.isArray(key))
	    {
	        for (var i = 0; i < key.length; i++)
	        {
	            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object
	            this.addFile(new JSONFile(this, key[i]));
	        }
	    }
	    else
	    {
	        this.addFile(new JSONFile(this, key, url, xhrSettings, dataKey));
	    }

	    return this;
	});

	JSONFile_1 = JSONFile;
	return JSONFile_1;
}

var AnimationJSONFile_1;
var hasRequiredAnimationJSONFile;

function requireAnimationJSONFile () {
	if (hasRequiredAnimationJSONFile) return AnimationJSONFile_1;
	hasRequiredAnimationJSONFile = 1;
	var Class = requireClass();
	var FileTypesManager = requireFileTypesManager();
	var JSONFile = requireJSONFile();
	var LoaderEvents = requireEvents$8();


	var AnimationJSONFile = new Class({

	    Extends: JSONFile,

	    initialize:

	    //  url can either be a string, in which case it is treated like a proper url, or an object, in which case it is treated as a ready-made JS Object
	    //  dataKey allows you to pluck a specific object out of the JSON and put just that into the cache, rather than the whole thing

	    function AnimationJSONFile (loader, key, url, xhrSettings, dataKey)
	    {
	        JSONFile.call(this, loader, key, url, xhrSettings, dataKey);

	        this.type = 'animationJSON';
	    },

	    
	    onProcess: function ()
	    {
	        //  We need to hook into this event:
	        this.loader.once(LoaderEvents.POST_PROCESS, this.onLoadComplete, this);

	        //  But the rest is the same as a normal JSON file
	        JSONFile.prototype.onProcess.call(this);
	    },

	    
	    onLoadComplete: function ()
	    {
	        this.loader.systems.anims.fromJSON(this.data);
	    }

	});


	FileTypesManager.register('animation', function (key, url, dataKey, xhrSettings)
	{
	    //  Supports an Object file definition in the key argument
	    //  Or an array of objects in the key argument
	    //  Or a single entry where all arguments have been defined

	    if (Array.isArray(key))
	    {
	        for (var i = 0; i < key.length; i++)
	        {
	            this.addFile(new AnimationJSONFile(this, key[i]));
	        }
	    }
	    else
	    {
	        this.addFile(new AnimationJSONFile(this, key, url, xhrSettings, dataKey));
	    }

	    return this;
	});

	AnimationJSONFile_1 = AnimationJSONFile;
	return AnimationJSONFile_1;
}

var ImageFile_1;
var hasRequiredImageFile;

function requireImageFile () {
	if (hasRequiredImageFile) return ImageFile_1;
	hasRequiredImageFile = 1;
	var Class = requireClass();
	var CONST = require_const$3();
	var File = requireFile();
	var FileTypesManager = requireFileTypesManager();
	var GetFastValue = requireGetFastValue();
	var IsPlainObject = requireIsPlainObject();
	var GetURL = requireGetURL();


	var ImageFile = new Class({

	    Extends: File,

	    initialize:

	    function ImageFile (loader, key, url, xhrSettings, frameConfig)
	    {
	        var extension = 'png';
	        var normalMapURL;

	        if (IsPlainObject(key))
	        {
	            var config = key;

	            key = GetFastValue(config, 'key');
	            url = GetFastValue(config, 'url');
	            normalMapURL = GetFastValue(config, 'normalMap');
	            xhrSettings = GetFastValue(config, 'xhrSettings');
	            extension = GetFastValue(config, 'extension', extension);
	            frameConfig = GetFastValue(config, 'frameConfig');
	        }

	        if (Array.isArray(url))
	        {
	            normalMapURL = url[1];
	            url = url[0];
	        }

	        var fileConfig = {
	            type: 'image',
	            cache: loader.textureManager,
	            extension: extension,
	            responseType: 'blob',
	            key: key,
	            url: url,
	            xhrSettings: xhrSettings,
	            config: frameConfig
	        };

	        File.call(this, loader, fileConfig);

	        //  Do we have a normal map to load as well?
	        if (normalMapURL)
	        {
	            var normalMap = new ImageFile(loader, this.key, normalMapURL, xhrSettings, frameConfig);

	            normalMap.type = 'normalMap';

	            this.setLink(normalMap);

	            loader.addFile(normalMap);
	        }

	        this.useImageElementLoad = (loader.imageLoadType === 'HTMLImageElement') || this.base64;

	        if (this.useImageElementLoad)
	        {
	            this.load = this.loadImage;
	            this.onProcess = this.onProcessImage;
	        }
	    },

	    
	    onProcess: function ()
	    {
	        this.state = CONST.FILE_PROCESSING;

	        this.data = new Image();

	        this.data.crossOrigin = this.crossOrigin;

	        var _this = this;

	        this.data.onload = function ()
	        {
	            File.revokeObjectURL(_this.data);

	            _this.onProcessComplete();
	        };

	        this.data.onerror = function ()
	        {
	            File.revokeObjectURL(_this.data);

	            _this.onProcessError();
	        };

	        File.createObjectURL(this.data, this.xhrLoader.response, 'image/png');
	    },

	    
	    onProcessImage: function ()
	    {
	        var result = this.state;

	        this.state = CONST.FILE_PROCESSING;

	        if (result === CONST.FILE_LOADED)
	        {
	            this.onProcessComplete();
	        }
	        else
	        {
	            this.onProcessError();
	        }
	    },

	    
	    loadImage: function ()
	    {
	        this.state = CONST.FILE_LOADING;

	        this.src = GetURL(this, this.loader.baseURL);

	        this.data = new Image();

	        this.data.crossOrigin = this.crossOrigin;

	        var _this = this;

	        this.data.onload = function ()
	        {
	            _this.state = CONST.FILE_LOADED;

	            _this.loader.nextFile(_this, true);
	        };

	        this.data.onerror = function ()
	        {
	            _this.loader.nextFile(_this, false);
	        };

	        this.data.src = this.src;
	    },

	    
	    addToCache: function ()
	    {
	        //  Check if we have a linked normal map
	        var linkFile = this.linkFile;

	        if (linkFile)
	        {
	            //  We do, but has it loaded?
	            if (linkFile.state >= CONST.FILE_COMPLETE)
	            {
	                if (linkFile.type === 'spritesheet')
	                {
	                    linkFile.addToCache();
	                }
	                else if (this.type === 'normalMap')
	                {
	                    //  linkFile.data = Image
	                    //  this.data = Normal Map
	                    this.cache.addImage(this.key, linkFile.data, this.data);
	                }
	                else
	                {
	                    //  linkFile.data = Normal Map
	                    //  this.data = Image
	                    this.cache.addImage(this.key, this.data, linkFile.data);
	                }
	            }

	            //  Nothing to do here, we'll use the linkFile `addToCache` call
	            //  to process this pair
	        }
	        else
	        {
	            this.cache.addImage(this.key, this.data);
	        }
	    }

	});


	FileTypesManager.register('image', function (key, url, xhrSettings)
	{
	    if (Array.isArray(key))
	    {
	        for (var i = 0; i < key.length; i++)
	        {
	            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object
	            this.addFile(new ImageFile(this, key[i]));
	        }
	    }
	    else
	    {
	        this.addFile(new ImageFile(this, key, url, xhrSettings));
	    }

	    return this;
	});

	ImageFile_1 = ImageFile;
	return ImageFile_1;
}

var MultiFile_1;
var hasRequiredMultiFile;

function requireMultiFile () {
	if (hasRequiredMultiFile) return MultiFile_1;
	hasRequiredMultiFile = 1;
	var Class = requireClass();
	var CONST = require_const$3();
	var Events = requireEvents$8();


	var MultiFile = new Class({

	    initialize:

	    function MultiFile (loader, type, key, files)
	    {
	        var finalFiles = [];

	        //  Clean out any potential 'null' or 'undefined' file entries
	        files.forEach(function (file)
	        {
	            if (file)
	            {
	                finalFiles.push(file);
	            }
	        });

	        
	        this.loader = loader;

	        
	        this.type = type;

	        
	        this.key = key;

	        var loadKey = this.key;

	        if (loader.prefix && loader.prefix !== '')
	        {
	            this.key = loader.prefix + loadKey;
	        }

	        
	        this.multiKeyIndex = loader.multiKeyIndex++;

	        
	        this.files = finalFiles;

	        
	        this.state = CONST.FILE_PENDING;

	        
	        this.complete = false;

	        

	        this.pending = finalFiles.length;

	        
	        this.failed = 0;

	        
	        this.config = {};

	        
	        this.baseURL = loader.baseURL;

	        
	        this.path = loader.path;

	        
	        this.prefix = loader.prefix;

	        //  Link the files
	        for (var i = 0; i < finalFiles.length; i++)
	        {
	            finalFiles[i].multiFile = this;
	        }
	    },

	    
	    isReadyToProcess: function ()
	    {
	        return (this.pending === 0 && this.failed === 0 && !this.complete);
	    },

	    
	    addToMultiFile: function (file)
	    {
	        this.files.push(file);

	        file.multiFile = this;

	        this.pending++;

	        this.complete = false;

	        return this;
	    },

	    
	    onFileComplete: function (file)
	    {
	        var index = this.files.indexOf(file);

	        if (index !== -1)
	        {
	            this.pending--;
	        }
	    },

	    
	    onFileFailed: function (file)
	    {
	        var index = this.files.indexOf(file);

	        if (index !== -1)
	        {
	            this.failed++;

	            // eslint-disable-next-line no-console
	            console.error('File failed: %s "%s" (via %s "%s")', this.type, this.key, file.type, file.key);
	        }
	    },

	    
	    pendingDestroy: function ()
	    {
	        if (this.state === CONST.FILE_PENDING_DESTROY)
	        {
	            return;
	        }

	        var key = this.key;
	        var type = this.type;

	        this.loader.emit(Events.FILE_COMPLETE, key, type);
	        this.loader.emit(Events.FILE_KEY_COMPLETE + type + '-' + key, key, type);

	        this.loader.flagForRemoval(this);

	        for (var i = 0; i < this.files.length; i++)
	        {
	            this.files[i].pendingDestroy();
	        }

	        this.state = CONST.FILE_PENDING_DESTROY;
	    },

	    
	    destroy: function ()
	    {
	        this.loader = null;
	        this.files = null;
	        this.config = null;
	    }

	});

	MultiFile_1 = MultiFile;
	return MultiFile_1;
}

var AsepriteFile_1;
var hasRequiredAsepriteFile;

function requireAsepriteFile () {
	if (hasRequiredAsepriteFile) return AsepriteFile_1;
	hasRequiredAsepriteFile = 1;
	var Class = requireClass();
	var FileTypesManager = requireFileTypesManager();
	var GetFastValue = requireGetFastValue();
	var ImageFile = requireImageFile();
	var IsPlainObject = requireIsPlainObject();
	var JSONFile = requireJSONFile();
	var MultiFile = requireMultiFile();


	var AsepriteFile = new Class({

	    Extends: MultiFile,

	    initialize:

	    function AsepriteFile (loader, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings)
	    {
	        var image;
	        var data;

	        if (IsPlainObject(key))
	        {
	            var config = key;

	            key = GetFastValue(config, 'key');

	            image = new ImageFile(loader, {
	                key: key,
	                url: GetFastValue(config, 'textureURL'),
	                extension: GetFastValue(config, 'textureExtension', 'png'),
	                normalMap: GetFastValue(config, 'normalMap'),
	                xhrSettings: GetFastValue(config, 'textureXhrSettings')
	            });

	            data = new JSONFile(loader, {
	                key: key,
	                url: GetFastValue(config, 'atlasURL'),
	                extension: GetFastValue(config, 'atlasExtension', 'json'),
	                xhrSettings: GetFastValue(config, 'atlasXhrSettings')
	            });
	        }
	        else
	        {
	            image = new ImageFile(loader, key, textureURL, textureXhrSettings);
	            data = new JSONFile(loader, key, atlasURL, atlasXhrSettings);
	        }

	        if (image.linkFile)
	        {
	            //  Image has a normal map
	            MultiFile.call(this, loader, 'atlasjson', key, [ image, data, image.linkFile ]);
	        }
	        else
	        {
	            MultiFile.call(this, loader, 'atlasjson', key, [ image, data ]);
	        }
	    },

	    
	    addToCache: function ()
	    {
	        if (this.isReadyToProcess())
	        {
	            var image = this.files[0];
	            var json = this.files[1];
	            var normalMap = (this.files[2]) ? this.files[2].data : null;

	            this.loader.textureManager.addAtlas(image.key, image.data, json.data, normalMap);

	            json.addToCache();

	            this.complete = true;
	        }
	    }

	});


	FileTypesManager.register('aseprite', function (key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings)
	{
	    var multifile;

	    //  Supports an Object file definition in the key argument
	    //  Or an array of objects in the key argument
	    //  Or a single entry where all arguments have been defined

	    if (Array.isArray(key))
	    {
	        for (var i = 0; i < key.length; i++)
	        {
	            multifile = new AsepriteFile(this, key[i]);

	            this.addFile(multifile.files);
	        }
	    }
	    else
	    {
	        multifile = new AsepriteFile(this, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings);

	        this.addFile(multifile.files);
	    }

	    return this;
	});

	AsepriteFile_1 = AsepriteFile;
	return AsepriteFile_1;
}

var AtlasJSONFile_1;
var hasRequiredAtlasJSONFile;

function requireAtlasJSONFile () {
	if (hasRequiredAtlasJSONFile) return AtlasJSONFile_1;
	hasRequiredAtlasJSONFile = 1;
	var Class = requireClass();
	var FileTypesManager = requireFileTypesManager();
	var GetFastValue = requireGetFastValue();
	var ImageFile = requireImageFile();
	var IsPlainObject = requireIsPlainObject();
	var JSONFile = requireJSONFile();
	var MultiFile = requireMultiFile();


	var AtlasJSONFile = new Class({

	    Extends: MultiFile,

	    initialize:

	    function AtlasJSONFile (loader, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings)
	    {
	        var image;
	        var data;

	        if (IsPlainObject(key))
	        {
	            var config = key;

	            key = GetFastValue(config, 'key');

	            image = new ImageFile(loader, {
	                key: key,
	                url: GetFastValue(config, 'textureURL'),
	                extension: GetFastValue(config, 'textureExtension', 'png'),
	                normalMap: GetFastValue(config, 'normalMap'),
	                xhrSettings: GetFastValue(config, 'textureXhrSettings')
	            });

	            data = new JSONFile(loader, {
	                key: key,
	                url: GetFastValue(config, 'atlasURL'),
	                extension: GetFastValue(config, 'atlasExtension', 'json'),
	                xhrSettings: GetFastValue(config, 'atlasXhrSettings')
	            });
	        }
	        else
	        {
	            image = new ImageFile(loader, key, textureURL, textureXhrSettings);
	            data = new JSONFile(loader, key, atlasURL, atlasXhrSettings);
	        }

	        if (image.linkFile)
	        {
	            //  Image has a normal map
	            MultiFile.call(this, loader, 'atlasjson', key, [ image, data, image.linkFile ]);
	        }
	        else
	        {
	            MultiFile.call(this, loader, 'atlasjson', key, [ image, data ]);
	        }
	    },

	    
	    addToCache: function ()
	    {
	        if (this.isReadyToProcess())
	        {
	            var image = this.files[0];
	            var json = this.files[1];
	            var normalMap = (this.files[2]) ? this.files[2].data : null;

	            this.loader.textureManager.addAtlas(image.key, image.data, json.data, normalMap);

	            this.complete = true;
	        }
	    }

	});


	FileTypesManager.register('atlas', function (key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings)
	{
	    var multifile;

	    //  Supports an Object file definition in the key argument
	    //  Or an array of objects in the key argument
	    //  Or a single entry where all arguments have been defined

	    if (Array.isArray(key))
	    {
	        for (var i = 0; i < key.length; i++)
	        {
	            multifile = new AtlasJSONFile(this, key[i]);

	            this.addFile(multifile.files);
	        }
	    }
	    else
	    {
	        multifile = new AtlasJSONFile(this, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings);

	        this.addFile(multifile.files);
	    }

	    return this;
	});

	AtlasJSONFile_1 = AtlasJSONFile;
	return AtlasJSONFile_1;
}

var XMLFile_1;
var hasRequiredXMLFile;

function requireXMLFile () {
	if (hasRequiredXMLFile) return XMLFile_1;
	hasRequiredXMLFile = 1;
	var Class = requireClass();
	var CONST = require_const$3();
	var File = requireFile();
	var FileTypesManager = requireFileTypesManager();
	var GetFastValue = requireGetFastValue();
	var IsPlainObject = requireIsPlainObject();
	var ParseXML = requireParseXML();


	var XMLFile = new Class({

	    Extends: File,

	    initialize:

	    function XMLFile (loader, key, url, xhrSettings)
	    {
	        var extension = 'xml';

	        if (IsPlainObject(key))
	        {
	            var config = key;

	            key = GetFastValue(config, 'key');
	            url = GetFastValue(config, 'url');
	            xhrSettings = GetFastValue(config, 'xhrSettings');
	            extension = GetFastValue(config, 'extension', extension);
	        }

	        var fileConfig = {
	            type: 'xml',
	            cache: loader.cacheManager.xml,
	            extension: extension,
	            responseType: 'text',
	            key: key,
	            url: url,
	            xhrSettings: xhrSettings
	        };

	        File.call(this, loader, fileConfig);
	    },

	    
	    onProcess: function ()
	    {
	        this.state = CONST.FILE_PROCESSING;

	        this.data = ParseXML(this.xhrLoader.responseText);

	        if (this.data)
	        {
	            this.onProcessComplete();
	        }
	        else
	        {
	            this.onProcessError();
	        }
	    }

	});


	FileTypesManager.register('xml', function (key, url, xhrSettings)
	{
	    if (Array.isArray(key))
	    {
	        for (var i = 0; i < key.length; i++)
	        {
	            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object
	            this.addFile(new XMLFile(this, key[i]));
	        }
	    }
	    else
	    {
	        this.addFile(new XMLFile(this, key, url, xhrSettings));
	    }

	    return this;
	});

	XMLFile_1 = XMLFile;
	return XMLFile_1;
}

var AtlasXMLFile_1;
var hasRequiredAtlasXMLFile;

function requireAtlasXMLFile () {
	if (hasRequiredAtlasXMLFile) return AtlasXMLFile_1;
	hasRequiredAtlasXMLFile = 1;
	var Class = requireClass();
	var FileTypesManager = requireFileTypesManager();
	var GetFastValue = requireGetFastValue();
	var ImageFile = requireImageFile();
	var IsPlainObject = requireIsPlainObject();
	var MultiFile = requireMultiFile();
	var XMLFile = requireXMLFile();


	var AtlasXMLFile = new Class({

	    Extends: MultiFile,

	    initialize:

	    function AtlasXMLFile (loader, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings)
	    {
	        var image;
	        var data;

	        if (IsPlainObject(key))
	        {
	            var config = key;

	            key = GetFastValue(config, 'key');

	            image = new ImageFile(loader, {
	                key: key,
	                url: GetFastValue(config, 'textureURL'),
	                extension: GetFastValue(config, 'textureExtension', 'png'),
	                normalMap: GetFastValue(config, 'normalMap'),
	                xhrSettings: GetFastValue(config, 'textureXhrSettings')
	            });

	            data = new XMLFile(loader, {
	                key: key,
	                url: GetFastValue(config, 'atlasURL'),
	                extension: GetFastValue(config, 'atlasExtension', 'xml'),
	                xhrSettings: GetFastValue(config, 'atlasXhrSettings')
	            });
	        }
	        else
	        {
	            image = new ImageFile(loader, key, textureURL, textureXhrSettings);
	            data = new XMLFile(loader, key, atlasURL, atlasXhrSettings);
	        }

	        if (image.linkFile)
	        {
	            //  Image has a normal map
	            MultiFile.call(this, loader, 'atlasxml', key, [ image, data, image.linkFile ]);
	        }
	        else
	        {
	            MultiFile.call(this, loader, 'atlasxml', key, [ image, data ]);
	        }
	    },

	    
	    addToCache: function ()
	    {
	        if (this.isReadyToProcess())
	        {
	            var image = this.files[0];
	            var xml = this.files[1];
	            var normalMap = (this.files[2]) ? this.files[2].data : null;

	            this.loader.textureManager.addAtlasXML(image.key, image.data, xml.data, normalMap);

	            this.complete = true;
	        }
	    }

	});


	FileTypesManager.register('atlasXML', function (key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings)
	{
	    var multifile;

	    //  Supports an Object file definition in the key argument
	    //  Or an array of objects in the key argument
	    //  Or a single entry where all arguments have been defined

	    if (Array.isArray(key))
	    {
	        for (var i = 0; i < key.length; i++)
	        {
	            multifile = new AtlasXMLFile(this, key[i]);

	            this.addFile(multifile.files);
	        }
	    }
	    else
	    {
	        multifile = new AtlasXMLFile(this, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings);

	        this.addFile(multifile.files);
	    }

	    return this;
	});

	AtlasXMLFile_1 = AtlasXMLFile;
	return AtlasXMLFile_1;
}

var HTML5AudioFile_1;
var hasRequiredHTML5AudioFile;

function requireHTML5AudioFile () {
	if (hasRequiredHTML5AudioFile) return HTML5AudioFile_1;
	hasRequiredHTML5AudioFile = 1;
	var Class = requireClass();
	var Events = requireEvents$8();
	var File = requireFile();
	var GetFastValue = requireGetFastValue();
	var GetURL = requireGetURL();
	var IsPlainObject = requireIsPlainObject();


	var HTML5AudioFile = new Class({

	    Extends: File,

	    initialize:

	    function HTML5AudioFile (loader, key, urlConfig, audioConfig)
	    {
	        if (IsPlainObject(key))
	        {
	            var config = key;

	            key = GetFastValue(config, 'key');
	            audioConfig = GetFastValue(config, 'config', audioConfig);
	        }

	        var fileConfig = {
	            type: 'audio',
	            cache: loader.cacheManager.audio,
	            extension: urlConfig.type,
	            key: key,
	            url: urlConfig.url,
	            config: audioConfig
	        };

	        File.call(this, loader, fileConfig);

	        //  New properties specific to this class
	        this.locked = 'ontouchstart' in window;
	        this.loaded = false;
	        this.filesLoaded = 0;
	        this.filesTotal = 0;
	    },

	    
	    onLoad: function ()
	    {
	        if (this.loaded)
	        {
	            return;
	        }

	        this.loaded = true;

	        this.loader.nextFile(this, true);
	    },

	    
	    onError: function ()
	    {
	        for (var i = 0; i < this.data.length; i++)
	        {
	            var audio = this.data[i];

	            audio.oncanplaythrough = null;
	            audio.onerror = null;
	        }

	        this.loader.nextFile(this, false);
	    },

	    
	    onProgress: function (event)
	    {
	        var audio = event.target;

	        audio.oncanplaythrough = null;
	        audio.onerror = null;

	        this.filesLoaded++;

	        this.percentComplete = Math.min((this.filesLoaded / this.filesTotal), 1);

	        this.loader.emit(Events.FILE_PROGRESS, this, this.percentComplete);

	        if (this.filesLoaded === this.filesTotal)
	        {
	            this.onLoad();
	        }
	    },

	    
	    load: function ()
	    {
	        this.data = [];

	        var instances = (this.config && this.config.instances) || 1;

	        this.filesTotal = instances;
	        this.filesLoaded = 0;
	        this.percentComplete = 0;

	        for (var i = 0; i < instances; i++)
	        {
	            var audio = new Audio();

	            if (!audio.dataset)
	            {
	                audio.dataset = {};
	            }

	            audio.dataset.name = this.key + ('0' + i).slice(-2);
	            audio.dataset.used = 'false';

	            if (this.locked)
	            {
	                audio.dataset.locked = 'true';
	            }
	            else
	            {
	                audio.dataset.locked = 'false';

	                audio.preload = 'auto';
	                audio.oncanplaythrough = this.onProgress.bind(this);
	                audio.onerror = this.onError.bind(this);
	            }

	            this.data.push(audio);
	        }

	        for (i = 0; i < this.data.length; i++)
	        {
	            audio = this.data[i];
	            audio.src = GetURL(this, this.loader.baseURL);

	            if (!this.locked)
	            {
	                audio.load();
	            }
	        }

	        if (this.locked)
	        {
	            //  This is super-dangerous but works. Race condition potential high.
	            //  Is there another way?
	            setTimeout(this.onLoad.bind(this));
	        }
	    }

	});

	HTML5AudioFile_1 = HTML5AudioFile;
	return HTML5AudioFile_1;
}

var AudioFile_1;
var hasRequiredAudioFile;

function requireAudioFile () {
	if (hasRequiredAudioFile) return AudioFile_1;
	hasRequiredAudioFile = 1;
	var Class = requireClass();
	var CONST = require_const$3();
	var File = requireFile();
	var FileTypesManager = requireFileTypesManager();
	var GetFastValue = requireGetFastValue();
	var HTML5AudioFile = requireHTML5AudioFile();
	var IsPlainObject = requireIsPlainObject();


	var AudioFile = new Class({

	    Extends: File,

	    initialize:

	    //  URL is an object created by AudioFile.findAudioURL
	    function AudioFile (loader, key, urlConfig, xhrSettings, audioContext)
	    {
	        if (IsPlainObject(key))
	        {
	            var config = key;

	            key = GetFastValue(config, 'key');
	            xhrSettings = GetFastValue(config, 'xhrSettings');
	            audioContext = GetFastValue(config, 'context', audioContext);
	        }

	        var fileConfig = {
	            type: 'audio',
	            cache: loader.cacheManager.audio,
	            extension: urlConfig.type,
	            responseType: 'arraybuffer',
	            key: key,
	            url: urlConfig.url,
	            xhrSettings: xhrSettings,
	            config: { context: audioContext }
	        };

	        File.call(this, loader, fileConfig);
	    },

	    
	    onProcess: function ()
	    {
	        this.state = CONST.FILE_PROCESSING;

	        var _this = this;

	        // interesting read https://github.com/WebAudio/web-audio-api/issues/1305
	        this.config.context.decodeAudioData(this.xhrLoader.response,
	            function (audioBuffer)
	            {
	                _this.data = audioBuffer;

	                _this.onProcessComplete();
	            },
	            function (e)
	            {
	                // eslint-disable-next-line no-console
	                console.error('Error decoding audio: ' + _this.key + ' - ', e ? e.message : null);

	                _this.onProcessError();
	            }
	        );

	        this.config.context = null;
	    }

	});

	AudioFile.create = function (loader, key, urls, config, xhrSettings)
	{
	    var game = loader.systems.game;
	    var audioConfig = game.config.audio;
	    var deviceAudio = game.device.audio;

	    //  url may be inside key, which may be an object
	    if (IsPlainObject(key))
	    {
	        urls = GetFastValue(key, 'url', []);
	        config = GetFastValue(key, 'config', {});
	    }

	    var urlConfig = AudioFile.getAudioURL(game, urls);

	    if (!urlConfig)
	    {
	        console.warn('No audio URLs for "%s" can play on this device', key);

	        return null;
	    }

	    // https://developers.google.com/web/updates/2012/02/HTML5-audio-and-the-Web-Audio-API-are-BFFs
	    // var stream = GetFastValue(config, 'stream', false);

	    if (deviceAudio.webAudio && !audioConfig.disableWebAudio)
	    {
	        return new AudioFile(loader, key, urlConfig, xhrSettings, game.sound.context);
	    }
	    else
	    {
	        return new HTML5AudioFile(loader, key, urlConfig, config);
	    }
	};

	AudioFile.getAudioURL = function (game, urls)
	{
	    if (!Array.isArray(urls))
	    {
	        urls = [ urls ];
	    }

	    for (var i = 0; i < urls.length; i++)
	    {
	        var url = GetFastValue(urls[i], 'url', urls[i]);

	        if (url.indexOf('blob:') === 0 || url.indexOf('data:') === 0)
	        {
	            return {
	                url: url,
	                type: ''
	            };
	        }

	        var audioType = url.match(/\.([a-zA-Z0-9]+)($|\?)/);

	        audioType = GetFastValue(urls[i], 'type', (audioType) ? audioType[1] : '').toLowerCase();

	        if (game.device.audio[audioType])
	        {
	            return {
	                url: url,
	                type: audioType
	            };
	        }
	    }

	    return null;
	};


	FileTypesManager.register('audio', function (key, urls, config, xhrSettings)
	{
	    var game = this.systems.game;
	    var audioConfig = game.config.audio;
	    var deviceAudio = game.device.audio;

	    if (audioConfig.noAudio || (!deviceAudio.webAudio && !deviceAudio.audioData))
	    {
	        //  Sounds are disabled, so skip loading audio
	        return this;
	    }

	    var audioFile;

	    if (Array.isArray(key))
	    {
	        for (var i = 0; i < key.length; i++)
	        {
	            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object
	            audioFile = AudioFile.create(this, key[i]);

	            if (audioFile)
	            {
	                this.addFile(audioFile);
	            }
	        }
	    }
	    else
	    {
	        audioFile = AudioFile.create(this, key, urls, config, xhrSettings);

	        if (audioFile)
	        {
	            this.addFile(audioFile);
	        }
	    }

	    return this;
	});

	AudioFile_1 = AudioFile;
	return AudioFile_1;
}

var AudioSpriteFile = {};

var hasRequiredAudioSpriteFile;

function requireAudioSpriteFile () {
	if (hasRequiredAudioSpriteFile) return AudioSpriteFile;
	hasRequiredAudioSpriteFile = 1;
	var AudioFile = requireAudioFile();
	var Class = requireClass();
	var FileTypesManager = requireFileTypesManager();
	var GetFastValue = requireGetFastValue();
	var IsPlainObject = requireIsPlainObject();
	var JSONFile = requireJSONFile();
	var MultiFile = requireMultiFile();


	var AudioSpriteFile$1 = new Class({

	    Extends: MultiFile,

	    initialize:

	    function AudioSpriteFile (loader, key, jsonURL, audioURL, audioConfig, audioXhrSettings, jsonXhrSettings)
	    {
	        if (IsPlainObject(key))
	        {
	            var config = key;

	            key = GetFastValue(config, 'key');
	            jsonURL = GetFastValue(config, 'jsonURL');
	            audioURL = GetFastValue(config, 'audioURL');
	            audioConfig = GetFastValue(config, 'audioConfig');
	            audioXhrSettings = GetFastValue(config, 'audioXhrSettings');
	            jsonXhrSettings = GetFastValue(config, 'jsonXhrSettings');
	        }

	        var data;

	        //  No url? then we're going to do a json load and parse it from that
	        if (!audioURL)
	        {
	            data = new JSONFile(loader, key, jsonURL, jsonXhrSettings);

	            MultiFile.call(this, loader, 'audiosprite', key, [ data ]);

	            this.config.resourceLoad = true;
	            this.config.audioConfig = audioConfig;
	            this.config.audioXhrSettings = audioXhrSettings;
	        }
	        else
	        {
	            var audio = AudioFile.create(loader, key, audioURL, audioConfig, audioXhrSettings);

	            if (audio)
	            {
	                data = new JSONFile(loader, key, jsonURL, jsonXhrSettings);

	                MultiFile.call(this, loader, 'audiosprite', key, [ audio, data ]);

	                this.config.resourceLoad = false;
	            }
	        }
	    },

	    
	    onFileComplete: function (file)
	    {
	        var index = this.files.indexOf(file);

	        if (index !== -1)
	        {
	            this.pending--;

	            if (this.config.resourceLoad && file.type === 'json' && file.data.hasOwnProperty('resources'))
	            {
	                //  Inspect the data for the files to now load
	                var urls = file.data.resources;

	                var audioConfig = GetFastValue(this.config, 'audioConfig');
	                var audioXhrSettings = GetFastValue(this.config, 'audioXhrSettings');

	                var audio = AudioFile.create(this.loader, file.key, urls, audioConfig, audioXhrSettings);

	                if (audio)
	                {
	                    this.addToMultiFile(audio);

	                    this.loader.addFile(audio);
	                }
	            }
	        }
	    },

	    
	    addToCache: function ()
	    {
	        if (this.isReadyToProcess())
	        {
	            var fileA = this.files[0];
	            var fileB = this.files[1];

	            fileA.addToCache();
	            fileB.addToCache();

	            this.complete = true;
	        }
	    }

	});


	FileTypesManager.register('audioSprite', function (key, jsonURL, audioURL, audioConfig, audioXhrSettings, jsonXhrSettings)
	{
	    var game = this.systems.game;
	    var gameAudioConfig = game.config.audio;
	    var deviceAudio = game.device.audio;

	    if ((gameAudioConfig && gameAudioConfig.noAudio) || (!deviceAudio.webAudio && !deviceAudio.audioData))
	    {
	        //  Sounds are disabled, so skip loading audio
	        return this;
	    }

	    var multifile;

	    //  Supports an Object file definition in the key argument
	    //  Or an array of objects in the key argument
	    //  Or a single entry where all arguments have been defined

	    if (Array.isArray(key))
	    {
	        for (var i = 0; i < key.length; i++)
	        {
	            multifile = new AudioSpriteFile$1(this, key[i]);

	            if (multifile.files)
	            {
	                this.addFile(multifile.files);
	            }
	        }
	    }
	    else
	    {
	        multifile = new AudioSpriteFile$1(this, key, jsonURL, audioURL, audioConfig, audioXhrSettings, jsonXhrSettings);

	        if (multifile.files)
	        {
	            this.addFile(multifile.files);
	        }
	    }

	    return this;
	});
	return AudioSpriteFile;
}

var BinaryFile_1;
var hasRequiredBinaryFile;

function requireBinaryFile () {
	if (hasRequiredBinaryFile) return BinaryFile_1;
	hasRequiredBinaryFile = 1;
	var Class = requireClass();
	var CONST = require_const$3();
	var File = requireFile();
	var FileTypesManager = requireFileTypesManager();
	var GetFastValue = requireGetFastValue();
	var IsPlainObject = requireIsPlainObject();


	var BinaryFile = new Class({

	    Extends: File,

	    initialize:

	    function BinaryFile (loader, key, url, xhrSettings, dataType)
	    {
	        var extension = 'bin';

	        if (IsPlainObject(key))
	        {
	            var config = key;

	            key = GetFastValue(config, 'key');
	            url = GetFastValue(config, 'url');
	            xhrSettings = GetFastValue(config, 'xhrSettings');
	            extension = GetFastValue(config, 'extension', extension);
	            dataType = GetFastValue(config, 'dataType', dataType);
	        }

	        var fileConfig = {
	            type: 'binary',
	            cache: loader.cacheManager.binary,
	            extension: extension,
	            responseType: 'arraybuffer',
	            key: key,
	            url: url,
	            xhrSettings: xhrSettings,
	            config: { dataType: dataType }
	        };

	        File.call(this, loader, fileConfig);
	    },

	    
	    onProcess: function ()
	    {
	        this.state = CONST.FILE_PROCESSING;

	        var ctor = this.config.dataType;

	        this.data = (ctor) ? new ctor(this.xhrLoader.response) : this.xhrLoader.response;

	        this.onProcessComplete();
	    }

	});


	FileTypesManager.register('binary', function (key, url, dataType, xhrSettings)
	{
	    if (Array.isArray(key))
	    {
	        for (var i = 0; i < key.length; i++)
	        {
	            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object
	            this.addFile(new BinaryFile(this, key[i]));
	        }
	    }
	    else
	    {
	        this.addFile(new BinaryFile(this, key, url, xhrSettings, dataType));
	    }

	    return this;
	});

	BinaryFile_1 = BinaryFile;
	return BinaryFile_1;
}

var BitmapFontFile_1;
var hasRequiredBitmapFontFile;

function requireBitmapFontFile () {
	if (hasRequiredBitmapFontFile) return BitmapFontFile_1;
	hasRequiredBitmapFontFile = 1;
	var Class = requireClass();
	var FileTypesManager = requireFileTypesManager();
	var GetFastValue = requireGetFastValue();
	var ImageFile = requireImageFile();
	var IsPlainObject = requireIsPlainObject();
	var MultiFile = requireMultiFile();
	var ParseXMLBitmapFont = requireParseXMLBitmapFont();
	var XMLFile = requireXMLFile();


	var BitmapFontFile = new Class({

	    Extends: MultiFile,

	    initialize:

	    function BitmapFontFile (loader, key, textureURL, fontDataURL, textureXhrSettings, fontDataXhrSettings)
	    {
	        var image;
	        var data;

	        if (IsPlainObject(key))
	        {
	            var config = key;

	            key = GetFastValue(config, 'key');

	            image = new ImageFile(loader, {
	                key: key,
	                url: GetFastValue(config, 'textureURL'),
	                extension: GetFastValue(config, 'textureExtension', 'png'),
	                normalMap: GetFastValue(config, 'normalMap'),
	                xhrSettings: GetFastValue(config, 'textureXhrSettings')
	            });

	            data = new XMLFile(loader, {
	                key: key,
	                url: GetFastValue(config, 'fontDataURL'),
	                extension: GetFastValue(config, 'fontDataExtension', 'xml'),
	                xhrSettings: GetFastValue(config, 'fontDataXhrSettings')
	            });
	        }
	        else
	        {
	            image = new ImageFile(loader, key, textureURL, textureXhrSettings);
	            data = new XMLFile(loader, key, fontDataURL, fontDataXhrSettings);
	        }

	        if (image.linkFile)
	        {
	            //  Image has a normal map
	            MultiFile.call(this, loader, 'bitmapfont', key, [ image, data, image.linkFile ]);
	        }
	        else
	        {
	            MultiFile.call(this, loader, 'bitmapfont', key, [ image, data ]);
	        }
	    },

	    
	    addToCache: function ()
	    {
	        if (this.isReadyToProcess())
	        {
	            var image = this.files[0];
	            var xml = this.files[1];

	            image.addToCache();

	            var texture = image.cache.get(image.key);

	            var data = ParseXMLBitmapFont(xml.data, image.cache.getFrame(image.key), 0, 0, texture);

	            this.loader.cacheManager.bitmapFont.add(image.key, { data: data, texture: image.key, frame: null });

	            this.complete = true;
	        }
	    }

	});


	FileTypesManager.register('bitmapFont', function (key, textureURL, fontDataURL, textureXhrSettings, fontDataXhrSettings)
	{
	    var multifile;

	    //  Supports an Object file definition in the key argument
	    //  Or an array of objects in the key argument
	    //  Or a single entry where all arguments have been defined

	    if (Array.isArray(key))
	    {
	        for (var i = 0; i < key.length; i++)
	        {
	            multifile = new BitmapFontFile(this, key[i]);

	            this.addFile(multifile.files);
	        }
	    }
	    else
	    {
	        multifile = new BitmapFontFile(this, key, textureURL, fontDataURL, textureXhrSettings, fontDataXhrSettings);

	        this.addFile(multifile.files);
	    }

	    return this;
	});

	BitmapFontFile_1 = BitmapFontFile;
	return BitmapFontFile_1;
}

var MultiAtlasFile_1;
var hasRequiredMultiAtlasFile;

function requireMultiAtlasFile () {
	if (hasRequiredMultiAtlasFile) return MultiAtlasFile_1;
	hasRequiredMultiAtlasFile = 1;
	var Class = requireClass();
	var FileTypesManager = requireFileTypesManager();
	var GetFastValue = requireGetFastValue();
	var ImageFile = requireImageFile();
	var IsPlainObject = requireIsPlainObject();
	var JSONFile = requireJSONFile();
	var MultiFile = requireMultiFile();


	var MultiAtlasFile = new Class({

	    Extends: MultiFile,

	    initialize:

	    function MultiAtlasFile (loader, key, atlasURL, path, baseURL, atlasXhrSettings, textureXhrSettings)
	    {
	        if (IsPlainObject(key))
	        {
	            var config = key;

	            key = GetFastValue(config, 'key');

	            if (GetFastValue(config, 'url', false))
	            {
	                atlasURL = GetFastValue(config, 'url');
	            }
	            else
	            {
	                atlasURL = GetFastValue(config, 'atlasURL');
	            }

	            atlasXhrSettings = GetFastValue(config, 'xhrSettings');
	            path = GetFastValue(config, 'path');
	            baseURL = GetFastValue(config, 'baseURL');
	            textureXhrSettings = GetFastValue(config, 'textureXhrSettings');
	        }

	        var data = new JSONFile(loader, key, atlasURL, atlasXhrSettings);

	        MultiFile.call(this, loader, 'multiatlas', key, [ data ]);

	        this.config.path = path;
	        this.config.baseURL = baseURL;
	        this.config.textureXhrSettings = textureXhrSettings;
	    },

	    
	    onFileComplete: function (file)
	    {
	        var index = this.files.indexOf(file);

	        if (index !== -1)
	        {
	            this.pending--;

	            if (file.type === 'json' && file.data.hasOwnProperty('textures'))
	            {
	                //  Inspect the data for the files to now load
	                var textures = file.data.textures;

	                var config = this.config;
	                var loader = this.loader;

	                var currentBaseURL = loader.baseURL;
	                var currentPath = loader.path;
	                var currentPrefix = loader.prefix;

	                var baseURL = GetFastValue(config, 'baseURL', this.baseURL);
	                var path = GetFastValue(config, 'path', this.path);
	                var prefix = GetFastValue(config, 'prefix', this.prefix);
	                var textureXhrSettings = GetFastValue(config, 'textureXhrSettings');

	                loader.setBaseURL(baseURL);
	                loader.setPath(path);
	                loader.setPrefix(prefix);

	                for (var i = 0; i < textures.length; i++)
	                {
	                    //  "image": "texture-packer-multi-atlas-0.png",
	                    var textureURL = textures[i].image;

	                    var key = 'MA' + this.multiKeyIndex + '_' + textureURL;

	                    var image = new ImageFile(loader, key, textureURL, textureXhrSettings);

	                    this.addToMultiFile(image);

	                    loader.addFile(image);

	                    //  "normalMap": "texture-packer-multi-atlas-0_n.png",
	                    if (textures[i].normalMap)
	                    {
	                        var normalMap = new ImageFile(loader, key, textures[i].normalMap, textureXhrSettings);

	                        normalMap.type = 'normalMap';

	                        image.setLink(normalMap);

	                        this.addToMultiFile(normalMap);

	                        loader.addFile(normalMap);
	                    }
	                }

	                //  Reset the loader settings
	                loader.setBaseURL(currentBaseURL);
	                loader.setPath(currentPath);
	                loader.setPrefix(currentPrefix);
	            }
	        }
	    },

	    
	    addToCache: function ()
	    {
	        if (this.isReadyToProcess())
	        {
	            var fileJSON = this.files[0];

	            var data = [];
	            var images = [];
	            var normalMaps = [];

	            for (var i = 1; i < this.files.length; i++)
	            {
	                var file = this.files[i];

	                if (file.type === 'normalMap')
	                {
	                    continue;
	                }

	                var pos = file.key.indexOf('_');
	                var key = file.key.substr(pos + 1);

	                var image = file.data;

	                //  Now we need to find out which json entry this mapped to
	                for (var t = 0; t < fileJSON.data.textures.length; t++)
	                {
	                    var item = fileJSON.data.textures[t];

	                    if (item.image === key)
	                    {
	                        images.push(image);

	                        data.push(item);

	                        if (file.linkFile)
	                        {
	                            normalMaps.push(file.linkFile.data);
	                        }

	                        break;
	                    }
	                }
	            }

	            if (normalMaps.length === 0)
	            {
	                normalMaps = undefined;
	            }

	            this.loader.textureManager.addAtlasJSONArray(this.key, images, data, normalMaps);

	            this.complete = true;
	        }
	    }

	});


	FileTypesManager.register('multiatlas', function (key, atlasURL, path, baseURL, atlasXhrSettings)
	{
	    var multifile;

	    //  Supports an Object file definition in the key argument
	    //  Or an array of objects in the key argument
	    //  Or a single entry where all arguments have been defined

	    if (Array.isArray(key))
	    {
	        for (var i = 0; i < key.length; i++)
	        {
	            multifile = new MultiAtlasFile(this, key[i]);

	            this.addFile(multifile.files);
	        }
	    }
	    else
	    {
	        multifile = new MultiAtlasFile(this, key, atlasURL, path, baseURL, atlasXhrSettings);

	        this.addFile(multifile.files);
	    }

	    return this;
	});

	MultiAtlasFile_1 = MultiAtlasFile;
	return MultiAtlasFile_1;
}

var VerifyCompressedTexture;
var hasRequiredVerifyCompressedTexture;

function requireVerifyCompressedTexture () {
	if (hasRequiredVerifyCompressedTexture) return VerifyCompressedTexture;
	hasRequiredVerifyCompressedTexture = 1;
	var IsSizePowerOfTwo = requireIsSizePowerOfTwo();

	var verifyCompressedTexture = function (data)
	{

	    var mipmaps = data.mipmaps;
	    for (var level = 1; level < mipmaps.length; level++)
	    {
	        var width = mipmaps[level].width;
	        var height = mipmaps[level].height;
	        if (!IsSizePowerOfTwo(width, height))
	        {
	            console.warn('Mip level ' + level + ' is not a power-of-two size: ' + width + 'x' + height);
	            return false;
	        }
	    }

	    var checker = formatCheckers[data.internalFormat];
	    if (!checker)
	    {
	        console.warn('No format checker found for internal format ' + data.internalFormat + '. Assuming valid.');
	        return true;
	    }
	    return checker(data);
	};

	function check4x4 (data)
	{
	    var mipmaps = data.mipmaps;
	    for (var level = 0; level < mipmaps.length; level++)
	    {
	        var width = mipmaps[level].width;
	        var height = mipmaps[level].height;
	        if ((width << level) % 4 !== 0 || (height << level) % 4 !== 0)
	        {
	            console.warn('BPTC, RGTC, and S3TC dimensions must be a multiple of 4 pixels, and each successive mip level must be half the size of the previous level, rounded down. Mip level ' + level + ' is ' + width + 'x' + height);
	            return false;
	        }
	    }
	    return true;
	}

	function checkAlways ()
	{

	    return true;
	}

	function checkPVRTC (data)
	{

	    var mipmaps = data.mipmaps;
	    var baseLevel = mipmaps[0];
	    if (!IsSizePowerOfTwo(baseLevel.width, baseLevel.height))
	    {
	        console.warn('PVRTC base dimensions must be power of two. Base level is ' + baseLevel.width + 'x' + baseLevel.height);
	        return false;
	    }

	    return true;
	}

	function checkS3TCSRGB (data)
	{

	    var mipmaps = data.mipmaps;
	    var baseLevel = mipmaps[0];
	    if (baseLevel.width % 4 !== 0 || baseLevel.height % 4 !== 0)
	    {
	        console.warn('S3TC SRGB base dimensions must be a multiple of 4 pixels. Base level is ' + baseLevel.width + 'x' + baseLevel.height + ' pixels');
	        return false;
	    }

	    return true;
	}

	var formatCheckers = {

	    0x9270: checkAlways,

	    0x9271: checkAlways,

	    0x9272: checkAlways,

	    0x9273: checkAlways,

	    0x9274: checkAlways,

	    0x9275: checkAlways,

	    0x9276: checkAlways,

	    0x9277: checkAlways,

	    0x9278: checkAlways,

	    0x9279: checkAlways,

	    0x8D64: checkAlways,

	    0x93B0: checkAlways,

	    0x93B1: checkAlways,

	    0x93B2: checkAlways,

	    0x93B3: checkAlways,

	    0x93B4: checkAlways,

	    0x93B5: checkAlways,

	    0x93B6: checkAlways,

	    0x93B7: checkAlways,

	    0x93B8: checkAlways,

	    0x93B9: checkAlways,

	    0x93BA: checkAlways,

	    0x93BB: checkAlways,

	    0x93BC: checkAlways,

	    0x93BD: checkAlways,

	    0x93D0: checkAlways,

	    0x93D1: checkAlways,

	    0x93D2: checkAlways,

	    0x93D3: checkAlways,

	    0x93D4: checkAlways,

	    0x93D5: checkAlways,

	    0x93D6: checkAlways,

	    0x93D7: checkAlways,

	    0x93D8: checkAlways,

	    0x93D9: checkAlways,

	    0x93DA: checkAlways,

	    0x93DB: checkAlways,

	    0x93DC: checkAlways,

	    0x93DD: checkAlways,

	    0x8E8C: check4x4,

	    0x8E8D: check4x4,

	    0x8E8E: check4x4,

	    0x8E8F: check4x4,

	    0x8DBB: check4x4,

	    0x8DBC: check4x4,

	    0x8DBD: check4x4,

	    0x8DBE: check4x4,

	    0x8C00: checkPVRTC,

	    0x8C01: checkPVRTC,

	    0x8C02: checkPVRTC,

	    0x8C03: checkPVRTC,

	    0x83F0: check4x4,

	    0x83F1: check4x4,

	    0x83F2: check4x4,

	    0x83F3: check4x4,

	    0x8C4C: checkS3TCSRGB,

	    0x8C4D: checkS3TCSRGB,

	    0x8C4E: checkS3TCSRGB,

	    0x8C4F: checkS3TCSRGB
	};

	VerifyCompressedTexture = verifyCompressedTexture;
	return VerifyCompressedTexture;
}

var CompressedTextureFile_1;
var hasRequiredCompressedTextureFile;

function requireCompressedTextureFile () {
	if (hasRequiredCompressedTextureFile) return CompressedTextureFile_1;
	hasRequiredCompressedTextureFile = 1;
	var AtlasJSONFile = requireAtlasJSONFile();
	var BinaryFile = requireBinaryFile();
	var Class = requireClass();
	var FileTypesManager = requireFileTypesManager();
	var GetFastValue = requireGetFastValue();
	var ImageFile = requireImageFile();
	var IsPlainObject = requireIsPlainObject();
	var JSONFile = requireJSONFile();
	var KTXParser = requireKTXParser();
	var Merge = requireMerge();
	var MultiAtlasFile = requireMultiAtlasFile();
	var MultiFile = requireMultiFile();
	var PVRParser = requirePVRParser();
	var verifyCompressedTexture = requireVerifyCompressedTexture();


	var CompressedTextureFile = new Class({

	    Extends: MultiFile,

	    initialize:

	    function CompressedTextureFile (loader, key, entry, xhrSettings)
	    {
	        if (entry.multiAtlasURL)
	        {
	            var multi = new JSONFile(loader, {
	                key: key,
	                url: entry.multiAtlasURL,
	                xhrSettings: xhrSettings,
	                config: entry
	            });

	            MultiFile.call(this, loader, 'texture', key, [ multi ]);
	        }
	        else
	        {
	            var extension = entry.textureURL.substr(entry.textureURL.length - 3);

	            if (!entry.type)
	            {
	                entry.type = (extension.toLowerCase() === 'ktx') ? 'KTX' : 'PVR';
	            }

	            var image = new BinaryFile(loader, {
	                key: key,
	                url: entry.textureURL,
	                extension: extension,
	                xhrSettings: xhrSettings,
	                config: entry
	            });

	            if (entry.atlasURL)
	            {
	                var data = new JSONFile(loader, {
	                    key: key,
	                    url: entry.atlasURL,
	                    xhrSettings: xhrSettings,
	                    config: entry
	                });

	                MultiFile.call(this, loader, 'texture', key, [ image, data ]);
	            }
	            else
	            {
	                MultiFile.call(this, loader, 'texture', key, [ image ]);
	            }
	        }

	        this.config = entry;
	    },

	    
	    onFileComplete: function (file)
	    {
	        var index = this.files.indexOf(file);

	        if (index !== -1)
	        {
	            this.pending--;

	            if (!this.config.multiAtlasURL)
	            {
	                return;
	            }

	            if (file.type === 'json' && file.data.hasOwnProperty('textures'))
	            {
	                //  Inspect the data for the files to now load
	                var textures = file.data.textures;

	                var config = this.config;
	                var loader = this.loader;

	                var currentBaseURL = loader.baseURL;
	                var currentPath = loader.path;
	                var currentPrefix = loader.prefix;

	                var baseURL = GetFastValue(config, 'multiBaseURL', this.baseURL);
	                var path = GetFastValue(config, 'multiPath', this.path);
	                var prefix = GetFastValue(config, 'prefix', this.prefix);
	                var textureXhrSettings = GetFastValue(config, 'textureXhrSettings');

	                if (baseURL)
	                {
	                    loader.setBaseURL(baseURL);
	                }

	                if (path)
	                {
	                    loader.setPath(path);
	                }

	                if (prefix)
	                {
	                    loader.setPrefix(prefix);
	                }

	                for (var i = 0; i < textures.length; i++)
	                {
	                    //  "image": "texture-packer-multi-atlas-0.png",
	                    var textureURL = textures[i].image;

	                    var key = 'CMA' + this.multiKeyIndex + '_' + textureURL;

	                    var image = new BinaryFile(loader, key, textureURL, textureXhrSettings);

	                    this.addToMultiFile(image);

	                    loader.addFile(image);

	                    //  "normalMap": "texture-packer-multi-atlas-0_n.png",
	                    if (textures[i].normalMap)
	                    {
	                        var normalMap = new BinaryFile(loader, key, textures[i].normalMap, textureXhrSettings);

	                        normalMap.type = 'normalMap';

	                        image.setLink(normalMap);

	                        this.addToMultiFile(normalMap);

	                        loader.addFile(normalMap);
	                    }
	                }

	                //  Reset the loader settings
	                loader.setBaseURL(currentBaseURL);
	                loader.setPath(currentPath);
	                loader.setPrefix(currentPrefix);
	            }
	        }
	    },

	    
	    addToCache: function ()
	    {
	        function compressionWarning (message)
	        {
	            console.warn('Compressed Texture Invalid: "' + image.key + '". ' + message);
	        }

	        if (this.isReadyToProcess())
	        {
	            var entry = this.config;

	            if (entry.multiAtlasURL)
	            {
	                this.addMultiToCache();
	            }
	            else
	            {
	                var renderer = this.loader.systems.renderer;
	                var textureManager = this.loader.textureManager;
	                var textureData;

	                var image = this.files[0];
	                var json = this.files[1];

	                if (entry.type === 'PVR')
	                {
	                    textureData = PVRParser(image.data);
	                }
	                else if (entry.type === 'KTX')
	                {
	                    textureData = KTXParser(image.data);
	                    if (!textureData)
	                    {
	                        compressionWarning('KTX file contains unsupported format.');
	                    }
	                }

	                // Check block size.
	                if (textureData && !verifyCompressedTexture(textureData))
	                {
	                    compressionWarning('Texture dimensions failed verification. Check the texture format specifications for ' + entry.format + ' 0x' + textureData.internalFormat.toString(16) + '.');
	                    textureData = null;
	                }

	                // Check texture compression.
	                if (textureData && !renderer.supportsCompressedTexture(entry.format, textureData.internalFormat))
	                {
	                    compressionWarning('Texture format ' + entry.format + ' with internal format ' + textureData.internalFormat + ' not supported by the GPU. Texture invalid. This is often due to the texture using sRGB instead of linear RGB.');
	                    textureData = null;
	                }

	                if (textureData)
	                {
	                    textureData.format = renderer.getCompressedTextureName(entry.format, textureData.internalFormat);

	                    var atlasData = (json && json.data) ? json.data : null;

	                    textureManager.addCompressedTexture(image.key, textureData, atlasData);
	                }
	            }

	            this.complete = true;
	        }
	    },

	    
	    addMultiToCache: function ()
	    {
	        var entry = this.config;
	        var json = this.files[0];

	        var data = [];
	        var images = [];
	        var normalMaps = [];

	        var renderer = this.loader.systems.renderer;
	        var textureManager = this.loader.textureManager;
	        var textureData;

	        for (var i = 1; i < this.files.length; i++)
	        {
	            var file = this.files[i];

	            if (file.type === 'normalMap')
	            {
	                continue;
	            }

	            var pos = file.key.indexOf('_');
	            var key = file.key.substr(pos + 1);

	            var image = file.data;

	            //  Now we need to find out which json entry this mapped to
	            for (var t = 0; t < json.data.textures.length; t++)
	            {
	                var item = json.data.textures[t];

	                if (item.image === key)
	                {
	                    if (entry.type === 'PVR')
	                    {
	                        textureData = PVRParser(image);
	                    }
	                    else if (entry.type === 'KTX')
	                    {
	                        textureData = KTXParser(image);
	                    }

	                    if (textureData && renderer.supportsCompressedTexture(entry.format, textureData.internalFormat))
	                    {
	                        textureData.format = renderer.getCompressedTextureName(entry.format, textureData.internalFormat);

	                        images.push(textureData);

	                        data.push(item);

	                        if (file.linkFile)
	                        {
	                            normalMaps.push(file.linkFile.data);
	                        }
	                    }

	                    break;
	                }
	            }
	        }

	        if (normalMaps.length === 0)
	        {
	            normalMaps = undefined;
	        }

	        textureManager.addAtlasJSONArray(this.key, images, data, normalMaps);

	        this.complete = true;
	    }

	});


	FileTypesManager.register('texture', function (key, url, xhrSettings)
	{
	    var renderer = this.systems.renderer;

	    var AddEntry = function (loader, key, urls, xhrSettings)
	    {
	        var entry = {
	            format: null,
	            type: null,
	            textureURL: undefined,
	            atlasURL: undefined,
	            multiAtlasURL: undefined,
	            multiPath: undefined,
	            multiBaseURL: undefined
	        };

	        if (IsPlainObject(key))
	        {
	            var config = key;

	            key = GetFastValue(config, 'key');
	            urls = GetFastValue(config, 'url'),
	            xhrSettings = GetFastValue(config, 'xhrSettings');
	        }

	        var matched = false;

	        for (var textureBaseFormat in urls)
	        {
	            if (renderer.supportsCompressedTexture(textureBaseFormat))
	            {
	                var urlEntry = urls[textureBaseFormat];

	                if (typeof urlEntry === 'string')
	                {
	                    entry.textureURL = urlEntry;
	                }
	                else
	                {
	                    entry = Merge(urlEntry, entry);
	                }

	                entry.format = textureBaseFormat.toUpperCase();

	                matched = true;

	                break;
	            }
	        }

	        if (!matched)
	        {
	            console.warn('No supported compressed texture format or IMG fallback', key);
	        }
	        else if (entry.format === 'IMG')
	        {
	            var file;
	            var multifile;

	            if (entry.multiAtlasURL)
	            {
	                multifile = new MultiAtlasFile(loader, key, entry.multiAtlasURL, entry.multiPath, entry.multiBaseURL, xhrSettings);

	                file = multifile.files;
	            }
	            else if (entry.atlasURL)
	            {
	                multifile = new AtlasJSONFile(loader, key, entry.textureURL, entry.atlasURL, xhrSettings);

	                file = multifile.files;
	            }
	            else
	            {
	                file = new ImageFile(loader, key, entry.textureURL, xhrSettings);
	            }

	            loader.addFile(file);
	        }
	        else
	        {
	            var texture = new CompressedTextureFile(loader, key, entry, xhrSettings);

	            loader.addFile(texture.files);
	        }
	    };

	    if (Array.isArray(key))
	    {
	        for (var i = 0; i < key.length; i++)
	        {
	            AddEntry(this, key[i]);
	        }
	    }
	    else
	    {
	        AddEntry(this, key, url, xhrSettings);
	    }

	    return this;
	});

	CompressedTextureFile_1 = CompressedTextureFile;
	return CompressedTextureFile_1;
}

var CSSFile_1;
var hasRequiredCSSFile;

function requireCSSFile () {
	if (hasRequiredCSSFile) return CSSFile_1;
	hasRequiredCSSFile = 1;
	var Class = requireClass();
	var CONST = require_const$3();
	var File = requireFile();
	var FileTypesManager = requireFileTypesManager();
	var GetFastValue = requireGetFastValue();
	var IsPlainObject = requireIsPlainObject();


	var CSSFile = new Class({

	    Extends: File,

	    initialize:

	    function CSSFile (loader, key, url, xhrSettings)
	    {
	        var extension = 'css';

	        if (IsPlainObject(key))
	        {
	            var config = key;

	            key = GetFastValue(config, 'key');
	            url = GetFastValue(config, 'url');
	            xhrSettings = GetFastValue(config, 'xhrSettings');
	            extension = GetFastValue(config, 'extension', extension);
	        }

	        var fileConfig = {
	            type: 'script',
	            cache: false,
	            extension: extension,
	            responseType: 'text',
	            key: key,
	            url: url,
	            xhrSettings: xhrSettings
	        };

	        File.call(this, loader, fileConfig);
	    },

	    
	    onProcess: function ()
	    {
	        this.state = CONST.FILE_PROCESSING;

	        this.data = document.createElement('style');
	        this.data.defer = false;
	        this.data.innerHTML = this.xhrLoader.responseText;

	        document.head.appendChild(this.data);

	        this.onProcessComplete();
	    }

	});


	FileTypesManager.register('css', function (key, url, xhrSettings)
	{
	    if (Array.isArray(key))
	    {
	        for (var i = 0; i < key.length; i++)
	        {
	            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object
	            this.addFile(new CSSFile(this, key[i]));
	        }
	    }
	    else
	    {
	        this.addFile(new CSSFile(this, key, url, xhrSettings));
	    }

	    return this;
	});

	CSSFile_1 = CSSFile;
	return CSSFile_1;
}

var FontFile_1;
var hasRequiredFontFile;

function requireFontFile () {
	if (hasRequiredFontFile) return FontFile_1;
	hasRequiredFontFile = 1;
	var Class = requireClass();
	var CONST = require_const$3();
	var File = requireFile();
	var FileTypesManager = requireFileTypesManager();
	var GetFastValue = requireGetFastValue();
	var GetURL = requireGetURL();
	var IsPlainObject = requireIsPlainObject();


	var FontFile = new Class({

	    Extends: File,

	    initialize:

	    function FontFile (loader, key, url, format, descriptors, xhrSettings)
	    {
	        var extension = 'ttf';

	        if (IsPlainObject(key))
	        {
	            var config = key;

	            key = GetFastValue(config, 'key');
	            url = GetFastValue(config, 'url');
	            format = GetFastValue(config, 'format', 'truetype');
	            descriptors = GetFastValue(config, 'descriptors', null);
	            xhrSettings = GetFastValue(config, 'xhrSettings');
	            extension = GetFastValue(config, 'extension', extension);
	        }
	        else if (format === undefined)
	        {
	            format = 'truetype';
	        }

	        var fileConfig = {
	            type: 'font',
	            cache: false,
	            extension: extension,
	            responseType: 'text',
	            key: key,
	            url: url,
	            xhrSettings: xhrSettings
	        };

	        File.call(this, loader, fileConfig);

	        this.data = {
	            format: format,
	            descriptors: descriptors
	        };

	        this.state = CONST.FILE_POPULATED;
	    },

	    
	    onProcess: function ()
	    {
	        this.state = CONST.FILE_PROCESSING;

	        this.src = GetURL(this, this.loader.baseURL);

	        var font;
	        var key = this.key;
	        var source = 'url(' + this.src + ') format("' + this.data.format + '")';

	        if (this.data.descriptors)
	        {
	            font = new FontFace(key, source, this.data.descriptors);
	        }
	        else
	        {
	            font = new FontFace(key, source);
	        }

	        var _this = this;

	        font.load().then(function ()
	        {
	            document.fonts.add(font);
	            document.body.classList.add("fonts-loaded");
	            
	            _this.onProcessComplete();

	        }).catch(function ()
	        {
	            console.warn('Font failed to load', source);

	            _this.onProcessComplete();
	        });
	    }

	});


	FileTypesManager.register('font', function (key, url, format, descriptors, xhrSettings)
	{
	    if (Array.isArray(key))
	    {
	        for (var i = 0; i < key.length; i++)
	        {
	            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object
	            this.addFile(new FontFile(this, key[i]));
	        }
	    }
	    else
	    {
	        this.addFile(new FontFile(this, key, url, format, descriptors, xhrSettings));
	    }

	    return this;
	});

	FontFile_1 = FontFile;
	return FontFile_1;
}

var GLSLFile_1;
var hasRequiredGLSLFile;

function requireGLSLFile () {
	if (hasRequiredGLSLFile) return GLSLFile_1;
	hasRequiredGLSLFile = 1;
	var Class = requireClass();
	var CONST = require_const$3();
	var File = requireFile();
	var FileTypesManager = requireFileTypesManager();
	var GetFastValue = requireGetFastValue();
	var IsPlainObject = requireIsPlainObject();
	var Shader = requireBaseShader();


	var GLSLFile = new Class({

	    Extends: File,

	    initialize:

	    function GLSLFile (loader, key, url, shaderType, xhrSettings)
	    {
	        var extension = 'glsl';

	        if (IsPlainObject(key))
	        {
	            var config = key;

	            key = GetFastValue(config, 'key');
	            url = GetFastValue(config, 'url');
	            shaderType = GetFastValue(config, 'shaderType', 'fragment');
	            xhrSettings = GetFastValue(config, 'xhrSettings');
	            extension = GetFastValue(config, 'extension', extension);
	        }
	        else if (shaderType === undefined)
	        {
	            shaderType = 'fragment';
	        }

	        var fileConfig = {
	            type: 'glsl',
	            cache: loader.cacheManager.shader,
	            extension: extension,
	            responseType: 'text',
	            key: key,
	            url: url,
	            config: {
	                shaderType: shaderType
	            },
	            xhrSettings: xhrSettings
	        };

	        File.call(this, loader, fileConfig);
	    },

	    
	    onProcess: function ()
	    {
	        this.state = CONST.FILE_PROCESSING;

	        this.data = this.xhrLoader.responseText;

	        this.onProcessComplete();
	    },

	    
	    addToCache: function ()
	    {
	        var data = this.data.split('\n');

	        //  Check to see if this is a shader bundle, or raw glsl file.
	        var block = this.extractBlock(data, 0);

	        if (block)
	        {
	            while (block)
	            {
	                var key = this.getShaderName(block.header);
	                var shaderType = this.getShaderType(block.header);
	                var uniforms = this.getShaderUniforms(block.header);
	                var shaderSrc = block.shader;

	                if (this.cache.has(key))
	                {
	                    var shader = this.cache.get(key);

	                    if (shaderType === 'fragment')
	                    {
	                        shader.fragmentSrc = shaderSrc;
	                    }
	                    else
	                    {
	                        shader.vertexSrc = shaderSrc;
	                    }

	                    if (!shader.uniforms)
	                    {
	                        shader.uniforms = uniforms;
	                    }
	                }
	                else if (shaderType === 'fragment')
	                {
	                    this.cache.add(key, new Shader(key, shaderSrc, '', uniforms));
	                }
	                else
	                {
	                    this.cache.add(key, new Shader(key, '', shaderSrc, uniforms));
	                }

	                block = this.extractBlock(data, block.offset);
	            }
	        }
	        else if (this.config.shaderType === 'fragment')
	        {
	            //  Single shader
	            this.cache.add(this.key, new Shader(this.key, this.data));
	        }
	        else
	        {
	            this.cache.add(this.key, new Shader(this.key, '', this.data));
	        }
	    },

	    
	    getShaderName: function (headerSource)
	    {
	        for (var i = 0; i < headerSource.length; i++)
	        {
	            var line = headerSource[i].trim();

	            if (line.substring(0, 5) === 'name:')
	            {
	                return line.substring(5).trim();
	            }
	        }

	        return this.key;
	    },

	    
	    getShaderType: function (headerSource)
	    {
	        for (var i = 0; i < headerSource.length; i++)
	        {
	            var line = headerSource[i].trim();

	            if (line.substring(0, 5) === 'type:')
	            {
	                return line.substring(5).trim();
	            }
	        }

	        return this.config.shaderType;
	    },

	    
	    getShaderUniforms: function (headerSource)
	    {
	        var uniforms = {};

	        for (var i = 0; i < headerSource.length; i++)
	        {
	            var line = headerSource[i].trim();

	            if (line.substring(0, 8) === 'uniform.')
	            {
	                var pos = line.indexOf(':');

	                if (pos)
	                {
	                    var key = line.substring(8, pos);

	                    try
	                    {
	                        uniforms[key] = JSON.parse(line.substring(pos + 1));
	                    }
	                    catch (e)
	                    {
	                        console.warn('Invalid uniform JSON: ' + key);
	                    }
	                }
	            }
	        }

	        return uniforms;
	    },

	    
	    extractBlock: function (data, offset)
	    {
	        var headerStart = -1;
	        var headerEnd = -1;
	        var blockEnd = -1;
	        var headerOpen = false;
	        var captureSource = false;
	        var headerSource = [];
	        var shaderSource = [];

	        for (var i = offset; i < data.length; i++)
	        {
	            var line = data[i].trim();

	            if (line === '---')
	            {
	                if (headerStart === -1)
	                {
	                    headerStart = i;
	                    headerOpen = true;
	                }
	                else if (headerOpen)
	                {
	                    headerEnd = i;
	                    headerOpen = false;
	                    captureSource = true;
	                }
	                else
	                {
	                    //  We've hit another --- delimiter, break out
	                    captureSource = false;
	                    break;
	                }
	            }
	            else if (headerOpen)
	            {
	                headerSource.push(line);
	            }
	            else if (captureSource)
	            {
	                shaderSource.push(line);
	                blockEnd = i;
	            }
	        }

	        if (!headerOpen && headerEnd !== -1)
	        {
	            return { header: headerSource, shader: shaderSource.join('\n'), offset: blockEnd };
	        }
	        else
	        {
	            return null;
	        }
	    }

	});


	FileTypesManager.register('glsl', function (key, url, shaderType, xhrSettings)
	{
	    if (Array.isArray(key))
	    {
	        for (var i = 0; i < key.length; i++)
	        {
	            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object
	            this.addFile(new GLSLFile(this, key[i]));
	        }
	    }
	    else
	    {
	        this.addFile(new GLSLFile(this, key, url, shaderType, xhrSettings));
	    }

	    return this;
	});

	GLSLFile_1 = GLSLFile;
	return GLSLFile_1;
}

var HTMLFile_1;
var hasRequiredHTMLFile;

function requireHTMLFile () {
	if (hasRequiredHTMLFile) return HTMLFile_1;
	hasRequiredHTMLFile = 1;
	var Class = requireClass();
	var CONST = require_const$3();
	var File = requireFile();
	var FileTypesManager = requireFileTypesManager();
	var GetFastValue = requireGetFastValue();
	var IsPlainObject = requireIsPlainObject();


	var HTMLFile = new Class({

	    Extends: File,

	    initialize:

	    function HTMLFile (loader, key, url, xhrSettings)
	    {
	        var extension = 'html';

	        if (IsPlainObject(key))
	        {
	            var config = key;

	            key = GetFastValue(config, 'key');
	            url = GetFastValue(config, 'url');
	            xhrSettings = GetFastValue(config, 'xhrSettings');
	            extension = GetFastValue(config, 'extension', extension);
	        }

	        var fileConfig = {
	            type: 'text',
	            cache: loader.cacheManager.html,
	            extension: extension,
	            responseType: 'text',
	            key: key,
	            url: url,
	            xhrSettings: xhrSettings
	        };

	        File.call(this, loader, fileConfig);
	    },

	    
	    onProcess: function ()
	    {
	        this.state = CONST.FILE_PROCESSING;

	        this.data = this.xhrLoader.responseText;

	        this.onProcessComplete();
	    }

	});


	FileTypesManager.register('html', function (key, url, xhrSettings)
	{
	    if (Array.isArray(key))
	    {
	        for (var i = 0; i < key.length; i++)
	        {
	            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object
	            this.addFile(new HTMLFile(this, key[i]));
	        }
	    }
	    else
	    {
	        this.addFile(new HTMLFile(this, key, url, xhrSettings));
	    }

	    return this;
	});

	HTMLFile_1 = HTMLFile;
	return HTMLFile_1;
}

var HTMLTextureFile_1;
var hasRequiredHTMLTextureFile;

function requireHTMLTextureFile () {
	if (hasRequiredHTMLTextureFile) return HTMLTextureFile_1;
	hasRequiredHTMLTextureFile = 1;
	var Class = requireClass();
	var CONST = require_const$3();
	var File = requireFile();
	var FileTypesManager = requireFileTypesManager();
	var GetFastValue = requireGetFastValue();
	var IsPlainObject = requireIsPlainObject();


	var HTMLTextureFile = new Class({

	    Extends: File,

	    initialize:

	    function HTMLTextureFile (loader, key, url, width, height, xhrSettings)
	    {
	        if (width === undefined) { width = 512; }
	        if (height === undefined) { height = 512; }

	        var extension = 'html';

	        if (IsPlainObject(key))
	        {
	            var config = key;

	            key = GetFastValue(config, 'key');
	            url = GetFastValue(config, 'url');
	            xhrSettings = GetFastValue(config, 'xhrSettings');
	            extension = GetFastValue(config, 'extension', extension);
	            width = GetFastValue(config, 'width', width);
	            height = GetFastValue(config, 'height', height);
	        }

	        var fileConfig = {
	            type: 'html',
	            cache: loader.textureManager,
	            extension: extension,
	            responseType: 'text',
	            key: key,
	            url: url,
	            xhrSettings: xhrSettings,
	            config: {
	                width: width,
	                height: height
	            }
	        };

	        File.call(this, loader, fileConfig);
	    },

	    
	    onProcess: function ()
	    {
	        this.state = CONST.FILE_PROCESSING;

	        var w = this.config.width;
	        var h = this.config.height;

	        var data = [];

	        data.push('<svg width="' + w + 'px" height="' + h + 'px" viewBox="0 0 ' + w + ' ' + h + '" xmlns="http://www.w3.org/2000/svg">');
	        data.push('<foreignObject width="100%" height="100%">');
	        data.push('<body xmlns="http://www.w3.org/1999/xhtml">');
	        data.push(this.xhrLoader.responseText);
	        data.push('</body>');
	        data.push('</foreignObject>');
	        data.push('</svg>');

	        var svg = [ data.join('\n') ];
	        var _this = this;

	        try
	        {
	            var blob = new window.Blob(svg, { type: 'image/svg+xml;charset=utf-8' });
	        }
	        catch (e)
	        {
	            _this.state = CONST.FILE_ERRORED;

	            _this.onProcessComplete();

	            return;
	        }

	        this.data = new Image();

	        this.data.crossOrigin = this.crossOrigin;

	        this.data.onload = function ()
	        {
	            File.revokeObjectURL(_this.data);

	            _this.onProcessComplete();
	        };

	        this.data.onerror = function ()
	        {
	            File.revokeObjectURL(_this.data);

	            _this.onProcessError();
	        };

	        File.createObjectURL(this.data, blob, 'image/svg+xml');
	    },

	    
	    addToCache: function ()
	    {
	        this.cache.addImage(this.key, this.data);
	    }

	});


	FileTypesManager.register('htmlTexture', function (key, url, width, height, xhrSettings)
	{
	    if (Array.isArray(key))
	    {
	        for (var i = 0; i < key.length; i++)
	        {
	            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object
	            this.addFile(new HTMLTextureFile(this, key[i]));
	        }
	    }
	    else
	    {
	        this.addFile(new HTMLTextureFile(this, key, url, width, height, xhrSettings));
	    }

	    return this;
	});

	HTMLTextureFile_1 = HTMLTextureFile;
	return HTMLTextureFile_1;
}

var ScriptFile_1;
var hasRequiredScriptFile;

function requireScriptFile () {
	if (hasRequiredScriptFile) return ScriptFile_1;
	hasRequiredScriptFile = 1;
	var Class = requireClass();
	var CONST = require_const$3();
	var File = requireFile();
	var FileTypesManager = requireFileTypesManager();
	var GetFastValue = requireGetFastValue();
	var IsPlainObject = requireIsPlainObject();


	var ScriptFile = new Class({

	    Extends: File,

	    initialize:

	    function ScriptFile (loader, key, url, type, xhrSettings)
	    {
	        var extension = 'js';

	        if (IsPlainObject(key))
	        {
	            var config = key;

	            key = GetFastValue(config, 'key');
	            url = GetFastValue(config, 'url');
	            type = GetFastValue(config, 'type', 'script');
	            xhrSettings = GetFastValue(config, 'xhrSettings');
	            extension = GetFastValue(config, 'extension', extension);
	        }
	        else if (type === undefined)
	        {
	            type = 'script';
	        }

	        var fileConfig = {
	            type: type,
	            cache: false,
	            extension: extension,
	            responseType: 'text',
	            key: key,
	            url: url,
	            xhrSettings: xhrSettings
	        };

	        File.call(this, loader, fileConfig);
	    },

	    
	    onProcess: function ()
	    {
	        this.state = CONST.FILE_PROCESSING;

	        this.data = document.createElement('script');
	        this.data.language = 'javascript';
	        this.data.type = 'text/javascript';
	        this.data.defer = false;
	        this.data.text = this.xhrLoader.responseText;

	        document.head.appendChild(this.data);

	        this.onProcessComplete();
	    }

	});


	FileTypesManager.register('script', function (key, url, type, xhrSettings)
	{
	    if (Array.isArray(key))
	    {
	        for (var i = 0; i < key.length; i++)
	        {
	            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object
	            this.addFile(new ScriptFile(this, key[i]));
	        }
	    }
	    else
	    {
	        this.addFile(new ScriptFile(this, key, url, type, xhrSettings));
	    }

	    return this;
	});

	ScriptFile_1 = ScriptFile;
	return ScriptFile_1;
}

var MultiScriptFile_1;
var hasRequiredMultiScriptFile;

function requireMultiScriptFile () {
	if (hasRequiredMultiScriptFile) return MultiScriptFile_1;
	hasRequiredMultiScriptFile = 1;
	var Class = requireClass();
	var FileTypesManager = requireFileTypesManager();
	var GetFastValue = requireGetFastValue();
	var IsPlainObject = requireIsPlainObject();
	var MultiFile = requireMultiFile();
	var ScriptFile = requireScriptFile();


	var MultiScriptFile = new Class({

	    Extends: MultiFile,

	    initialize:

	    function MultiScriptFile (loader, key, url, xhrSettings)
	    {
	        var extension = 'js';
	        var files = [];

	        if (IsPlainObject(key))
	        {
	            var config = key;

	            key = GetFastValue(config, 'key');
	            url = GetFastValue(config, 'url');
	            xhrSettings = GetFastValue(config, 'xhrSettings');
	            extension = GetFastValue(config, 'extension', extension);
	        }

	        if (!Array.isArray(url))
	        {
	            url = [ url ];
	        }

	        for (var i = 0; i < url.length; i++)
	        {
	            var scriptFile = new ScriptFile(loader, {
	                key: key + '_' + i.toString(),
	                url: url[i],
	                extension: extension,
	                xhrSettings: xhrSettings
	            });

	            //  Override the default onProcess function
	            scriptFile.onProcess = function ()
	            {
	                this.onProcessComplete();
	            };

	            files.push(scriptFile);
	        }

	        MultiFile.call(this, loader, 'scripts', key, files);
	    },

	    
	    addToCache: function ()
	    {
	        if (this.isReadyToProcess())
	        {
	            for (var i = 0; i < this.files.length; i++)
	            {
	                var file = this.files[i];

	                file.data = document.createElement('script');
	                file.data.language = 'javascript';
	                file.data.type = 'text/javascript';
	                file.data.defer = false;
	                file.data.text = file.xhrLoader.responseText;

	                document.head.appendChild(file.data);
	            }

	            this.complete = true;
	        }
	    }

	});


	FileTypesManager.register('scripts', function (key, url, xhrSettings)
	{
	    var multifile;

	    //  Supports an Object file definition in the key argument
	    //  Or an array of objects in the key argument
	    //  Or a single entry where all arguments have been defined

	    if (Array.isArray(key))
	    {
	        for (var i = 0; i < key.length; i++)
	        {
	            multifile = new MultiScriptFile(this, key[i]);

	            this.addFile(multifile.files);
	        }
	    }
	    else
	    {
	        multifile = new MultiScriptFile(this, key, url, xhrSettings);

	        this.addFile(multifile.files);
	    }

	    return this;
	});

	MultiScriptFile_1 = MultiScriptFile;
	return MultiScriptFile_1;
}

var TextFile_1;
var hasRequiredTextFile;

function requireTextFile () {
	if (hasRequiredTextFile) return TextFile_1;
	hasRequiredTextFile = 1;
	var Class = requireClass();
	var CONST = require_const$3();
	var File = requireFile();
	var FileTypesManager = requireFileTypesManager();
	var GetFastValue = requireGetFastValue();
	var IsPlainObject = requireIsPlainObject();


	var TextFile = new Class({

	    Extends: File,

	    initialize:

	    function TextFile (loader, key, url, xhrSettings)
	    {
	        var type = 'text';
	        var extension = 'txt';
	        var cache = loader.cacheManager.text;

	        if (IsPlainObject(key))
	        {
	            var config = key;

	            key = GetFastValue(config, 'key');
	            url = GetFastValue(config, 'url');
	            xhrSettings = GetFastValue(config, 'xhrSettings');
	            extension = GetFastValue(config, 'extension', extension);
	            type = GetFastValue(config, 'type', type);
	            cache = GetFastValue(config, 'cache', cache);
	        }

	        var fileConfig = {
	            type: type,
	            cache: cache,
	            extension: extension,
	            responseType: 'text',
	            key: key,
	            url: url,
	            xhrSettings: xhrSettings
	        };

	        File.call(this, loader, fileConfig);
	    },

	    
	    onProcess: function ()
	    {
	        this.state = CONST.FILE_PROCESSING;

	        this.data = this.xhrLoader.responseText;

	        this.onProcessComplete();
	    }

	});


	FileTypesManager.register('text', function (key, url, xhrSettings)
	{
	    if (Array.isArray(key))
	    {
	        for (var i = 0; i < key.length; i++)
	        {
	            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object
	            this.addFile(new TextFile(this, key[i]));
	        }
	    }
	    else
	    {
	        this.addFile(new TextFile(this, key, url, xhrSettings));
	    }

	    return this;
	});

	TextFile_1 = TextFile;
	return TextFile_1;
}

var OBJFile_1;
var hasRequiredOBJFile;

function requireOBJFile () {
	if (hasRequiredOBJFile) return OBJFile_1;
	hasRequiredOBJFile = 1;
	var Class = requireClass();
	var FileTypesManager = requireFileTypesManager();
	var GetFastValue = requireGetFastValue();
	var IsPlainObject = requireIsPlainObject();
	var MultiFile = requireMultiFile();
	var ParseObj = requireParseObj();
	var ParseObjMaterial = requireParseObjMaterial();
	var TextFile = requireTextFile();


	var OBJFile = new Class({

	    Extends: MultiFile,

	    initialize:

	    function OBJFile (loader, key, objURL, matURL, flipUV, xhrSettings)
	    {
	        var obj;
	        var mat;

	        var cache = loader.cacheManager.obj;

	        if (IsPlainObject(key))
	        {
	            var config = key;

	            key = GetFastValue(config, 'key');

	            obj = new TextFile(loader, {
	                key: key,
	                type: 'obj',
	                cache: cache,
	                url: GetFastValue(config, 'url'),
	                extension: GetFastValue(config, 'extension', 'obj'),
	                xhrSettings: GetFastValue(config, 'xhrSettings'),
	                config: {
	                    flipUV: GetFastValue(config, 'flipUV', flipUV)
	                }
	            });

	            matURL = GetFastValue(config, 'matURL');

	            if (matURL)
	            {
	                mat = new TextFile(loader, {
	                    key: key,
	                    type: 'mat',
	                    cache: cache,
	                    url: matURL,
	                    extension: GetFastValue(config, 'matExtension', 'mat'),
	                    xhrSettings: GetFastValue(config, 'xhrSettings')
	                });
	            }
	        }
	        else
	        {
	            obj = new TextFile(loader, {
	                key: key,
	                url: objURL,
	                type: 'obj',
	                cache: cache,
	                extension: 'obj',
	                xhrSettings: xhrSettings,
	                config: {
	                    flipUV: flipUV
	                }
	            });

	            if (matURL)
	            {
	                mat = new TextFile(loader, {
	                    key: key,
	                    url: matURL,
	                    type: 'mat',
	                    cache: cache,
	                    extension: 'mat',
	                    xhrSettings: xhrSettings
	                });
	            }
	        }

	        MultiFile.call(this, loader, 'obj', key, [ obj, mat ]);
	    },

	    
	    addToCache: function ()
	    {
	        if (this.isReadyToProcess())
	        {
	            var obj = this.files[0];
	            var mat = this.files[1];

	            var objData = ParseObj(obj.data, obj.config.flipUV);

	            if (mat)
	            {
	                objData.materials = ParseObjMaterial(mat.data);
	            }

	            obj.cache.add(obj.key, objData);

	            this.complete = true;
	        }
	    }

	});


	FileTypesManager.register('obj', function (key, objURL, matURL, flipUVs, xhrSettings)
	{
	    var multifile;

	    if (Array.isArray(key))
	    {
	        for (var i = 0; i < key.length; i++)
	        {
	            multifile = new OBJFile(this, key[i]);

	            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object
	            this.addFile(multifile.files);
	        }
	    }
	    else
	    {
	        multifile = new OBJFile(this, key, objURL, matURL, flipUVs, xhrSettings);

	        this.addFile(multifile.files);
	    }

	    return this;
	});

	OBJFile_1 = OBJFile;
	return OBJFile_1;
}

var PackFile_1;
var hasRequiredPackFile;

function requirePackFile () {
	if (hasRequiredPackFile) return PackFile_1;
	hasRequiredPackFile = 1;
	var Class = requireClass();
	var CONST = require_const$3();
	var FileTypesManager = requireFileTypesManager();
	var JSONFile = requireJSONFile();


	var PackFile = new Class({

	    Extends: JSONFile,

	    initialize:

	    //  url can either be a string, in which case it is treated like a proper url, or an object, in which case it is treated as a ready-made JS Object
	    //  dataKey allows you to pluck a specific object out of the JSON and put just that into the cache, rather than the whole thing

	    function PackFile (loader, key, url, xhrSettings, dataKey)
	    {
	        JSONFile.call(this, loader, key, url, xhrSettings, dataKey);

	        this.type = 'packfile';
	    },

	    
	    onProcess: function ()
	    {
	        if (this.state !== CONST.FILE_POPULATED)
	        {
	            this.state = CONST.FILE_PROCESSING;

	            this.data = JSON.parse(this.xhrLoader.responseText);
	        }

	        if (this.data.hasOwnProperty('files') && this.config)
	        {
	            var newData = {};

	            newData[this.config] = this.data;

	            this.data = newData;
	        }

	        //  Let's pass the pack file data over to the Loader ...
	        this.loader.addPack(this.data, this.config);

	        this.onProcessComplete();
	    }

	});


	FileTypesManager.register('pack', function (key, url, dataKey, xhrSettings)
	{
	    //  Supports an Object file definition in the key argument
	    //  Or an array of objects in the key argument
	    //  Or a single entry where all arguments have been defined

	    if (Array.isArray(key))
	    {
	        for (var i = 0; i < key.length; i++)
	        {
	            this.addFile(new PackFile(this, key[i]));
	        }
	    }
	    else
	    {
	        this.addFile(new PackFile(this, key, url, xhrSettings, dataKey));
	    }

	    return this;
	});

	PackFile_1 = PackFile;
	return PackFile_1;
}

var PluginFile_1;
var hasRequiredPluginFile;

function requirePluginFile () {
	if (hasRequiredPluginFile) return PluginFile_1;
	hasRequiredPluginFile = 1;
	var Class = requireClass();
	var CONST = require_const$3();
	var File = requireFile();
	var FileTypesManager = requireFileTypesManager();
	var GetFastValue = requireGetFastValue();
	var IsPlainObject = requireIsPlainObject();


	var PluginFile = new Class({

	    Extends: File,

	    initialize:

	    function PluginFile (loader, key, url, start, mapping, xhrSettings)
	    {
	        var extension = 'js';

	        if (IsPlainObject(key))
	        {
	            var config = key;

	            key = GetFastValue(config, 'key');
	            url = GetFastValue(config, 'url');
	            xhrSettings = GetFastValue(config, 'xhrSettings');
	            extension = GetFastValue(config, 'extension', extension);
	            start = GetFastValue(config, 'start');
	            mapping = GetFastValue(config, 'mapping');
	        }

	        var fileConfig = {
	            type: 'plugin',
	            cache: false,
	            extension: extension,
	            responseType: 'text',
	            key: key,
	            url: url,
	            xhrSettings: xhrSettings,
	            config: {
	                start: start,
	                mapping: mapping
	            }
	        };

	        File.call(this, loader, fileConfig);

	        // If the url variable refers to a class, add the plugin directly
	        if (typeof url === 'function')
	        {
	            this.data = url;

	            this.state = CONST.FILE_POPULATED;
	        }
	    },

	    
	    onProcess: function ()
	    {
	        var pluginManager = this.loader.systems.plugins;
	        var config = this.config;

	        var start = GetFastValue(config, 'start', false);
	        var mapping = GetFastValue(config, 'mapping', null);

	        if (this.state === CONST.FILE_POPULATED)
	        {
	            pluginManager.install(this.key, this.data, start, mapping);
	        }
	        else
	        {
	            //  Plugin added via a js file
	            this.state = CONST.FILE_PROCESSING;

	            this.data = document.createElement('script');
	            this.data.language = 'javascript';
	            this.data.type = 'text/javascript';
	            this.data.defer = false;
	            this.data.text = this.xhrLoader.responseText;

	            document.head.appendChild(this.data);

	            var plugin = pluginManager.install(this.key, window[this.key], start, mapping);

	            if (start || mapping)
	            {
	                //  Install into the current Scene Systems and Scene
	                this.loader.systems[mapping] = plugin;
	                this.loader.scene[mapping] = plugin;
	            }
	        }

	        this.onProcessComplete();
	    }

	});


	FileTypesManager.register('plugin', function (key, url, start, mapping, xhrSettings)
	{
	    if (Array.isArray(key))
	    {
	        for (var i = 0; i < key.length; i++)
	        {
	            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object
	            this.addFile(new PluginFile(this, key[i]));
	        }
	    }
	    else
	    {
	        this.addFile(new PluginFile(this, key, url, start, mapping, xhrSettings));
	    }

	    return this;
	});

	PluginFile_1 = PluginFile;
	return PluginFile_1;
}

var SceneFile_1;
var hasRequiredSceneFile;

function requireSceneFile () {
	if (hasRequiredSceneFile) return SceneFile_1;
	hasRequiredSceneFile = 1;
	var Class = requireClass();
	var CONST = require_const$3();
	var File = requireFile();
	var FileTypesManager = requireFileTypesManager();
	var GetFastValue = requireGetFastValue();
	var IsPlainObject = requireIsPlainObject();


	var SceneFile = new Class({

	    Extends: File,

	    initialize:

	    function SceneFile (loader, key, url, xhrSettings)
	    {
	        var extension = 'js';

	        if (IsPlainObject(key))
	        {
	            var config = key;

	            key = GetFastValue(config, 'key');
	            url = GetFastValue(config, 'url');
	            xhrSettings = GetFastValue(config, 'xhrSettings');
	            extension = GetFastValue(config, 'extension', extension);
	        }

	        var fileConfig = {
	            type: 'text',
	            extension: extension,
	            responseType: 'text',
	            key: key,
	            url: url,
	            xhrSettings: xhrSettings
	        };

	        File.call(this, loader, fileConfig);
	    },

	    
	    onProcess: function ()
	    {
	        this.state = CONST.FILE_PROCESSING;

	        this.data = this.xhrLoader.responseText;

	        this.onProcessComplete();
	    },

	    
	    addToCache: function ()
	    {
	        var code = this.data.concat('(function(){\n' + 'return new ' + this.key + '();\n' + '}).call(this);');

	        //  Stops rollup from freaking out during build
	        var eval2 = eval;

	        this.loader.sceneManager.add(this.key, eval2(code));

	        this.complete = true;
	    }

	});


	FileTypesManager.register('sceneFile', function (key, url, xhrSettings)
	{
	    if (Array.isArray(key))
	    {
	        for (var i = 0; i < key.length; i++)
	        {
	            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object
	            this.addFile(new SceneFile(this, key[i]));
	        }
	    }
	    else
	    {
	        this.addFile(new SceneFile(this, key, url, xhrSettings));
	    }

	    return this;
	});

	SceneFile_1 = SceneFile;
	return SceneFile_1;
}

var ScenePluginFile_1;
var hasRequiredScenePluginFile;

function requireScenePluginFile () {
	if (hasRequiredScenePluginFile) return ScenePluginFile_1;
	hasRequiredScenePluginFile = 1;
	var Class = requireClass();
	var CONST = require_const$3();
	var File = requireFile();
	var FileTypesManager = requireFileTypesManager();
	var GetFastValue = requireGetFastValue();
	var IsPlainObject = requireIsPlainObject();


	var ScenePluginFile = new Class({

	    Extends: File,

	    initialize:

	    function ScenePluginFile (loader, key, url, systemKey, sceneKey, xhrSettings)
	    {
	        var extension = 'js';

	        if (IsPlainObject(key))
	        {
	            var config = key;

	            key = GetFastValue(config, 'key');
	            url = GetFastValue(config, 'url');
	            xhrSettings = GetFastValue(config, 'xhrSettings');
	            extension = GetFastValue(config, 'extension', extension);
	            systemKey = GetFastValue(config, 'systemKey');
	            sceneKey = GetFastValue(config, 'sceneKey');
	        }

	        var fileConfig = {
	            type: 'scenePlugin',
	            cache: false,
	            extension: extension,
	            responseType: 'text',
	            key: key,
	            url: url,
	            xhrSettings: xhrSettings,
	            config: {
	                systemKey: systemKey,
	                sceneKey: sceneKey
	            }
	        };

	        File.call(this, loader, fileConfig);

	        // If the url variable refers to a class, add the plugin directly
	        if (typeof url === 'function')
	        {
	            this.data = url;

	            this.state = CONST.FILE_POPULATED;
	        }
	    },

	    
	    onProcess: function ()
	    {
	        var pluginManager = this.loader.systems.plugins;
	        var config = this.config;

	        var key = this.key;
	        var systemKey = GetFastValue(config, 'systemKey', key);
	        var sceneKey = GetFastValue(config, 'sceneKey', key);

	        if (this.state === CONST.FILE_POPULATED)
	        {
	            pluginManager.installScenePlugin(systemKey, this.data, sceneKey, this.loader.scene, true);
	        }
	        else
	        {
	            //  Plugin added via a js file
	            this.state = CONST.FILE_PROCESSING;

	            this.data = document.createElement('script');
	            this.data.language = 'javascript';
	            this.data.type = 'text/javascript';
	            this.data.defer = false;
	            this.data.text = this.xhrLoader.responseText;

	            document.head.appendChild(this.data);

	            pluginManager.installScenePlugin(systemKey, window[this.key], sceneKey, this.loader.scene, true);
	        }

	        this.onProcessComplete();
	    }

	});


	FileTypesManager.register('scenePlugin', function (key, url, systemKey, sceneKey, xhrSettings)
	{
	    if (Array.isArray(key))
	    {
	        for (var i = 0; i < key.length; i++)
	        {
	            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object
	            this.addFile(new ScenePluginFile(this, key[i]));
	        }
	    }
	    else
	    {
	        this.addFile(new ScenePluginFile(this, key, url, systemKey, sceneKey, xhrSettings));
	    }

	    return this;
	});

	ScenePluginFile_1 = ScenePluginFile;
	return ScenePluginFile_1;
}

var SpriteSheetFile_1;
var hasRequiredSpriteSheetFile;

function requireSpriteSheetFile () {
	if (hasRequiredSpriteSheetFile) return SpriteSheetFile_1;
	hasRequiredSpriteSheetFile = 1;
	var Class = requireClass();
	var CONST = require_const$3();
	var FileTypesManager = requireFileTypesManager();
	var ImageFile = requireImageFile();


	var SpriteSheetFile = new Class({

	    Extends: ImageFile,

	    initialize:

	    function SpriteSheetFile (loader, key, url, frameConfig, xhrSettings)
	    {
	        ImageFile.call(this, loader, key, url, xhrSettings, frameConfig);

	        this.type = 'spritesheet';
	    },

	    
	    addToCache: function ()
	    {
	        //  Check if we have a linked normal map
	        var linkFile = this.linkFile;

	        if (linkFile)
	        {
	            //  We do, but has it loaded?
	            if (linkFile.state >= CONST.FILE_COMPLETE)
	            {
	                //  Both files have loaded
	                if (this.type === 'normalMap')
	                {
	                    //  linkFile.data = Image
	                    //  this.data = Normal Map
	                    this.cache.addSpriteSheet(this.key, linkFile.data, this.config, this.data);
	                }
	                else
	                {
	                    //  linkFile.data = Normal Map
	                    //  this.data = Image
	                    this.cache.addSpriteSheet(this.key, this.data, this.config, linkFile.data);
	                }
	            }

	            //  Nothing to do here, we'll use the linkFile `addToCache` call
	            //  to process this pair
	        }
	        else
	        {
	            this.cache.addSpriteSheet(this.key, this.data, this.config);
	        }
	    }

	});


	FileTypesManager.register('spritesheet', function (key, url, frameConfig, xhrSettings)
	{
	    if (Array.isArray(key))
	    {
	        for (var i = 0; i < key.length; i++)
	        {
	            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object
	            this.addFile(new SpriteSheetFile(this, key[i]));
	        }
	    }
	    else
	    {
	        this.addFile(new SpriteSheetFile(this, key, url, frameConfig, xhrSettings));
	    }

	    return this;
	});

	SpriteSheetFile_1 = SpriteSheetFile;
	return SpriteSheetFile_1;
}

var SVGFile_1;
var hasRequiredSVGFile;

function requireSVGFile () {
	if (hasRequiredSVGFile) return SVGFile_1;
	hasRequiredSVGFile = 1;
	var Class = requireClass();
	var CONST = require_const$3();
	var File = requireFile();
	var FileTypesManager = requireFileTypesManager();
	var GetFastValue = requireGetFastValue();
	var IsPlainObject = requireIsPlainObject();


	var SVGFile = new Class({

	    Extends: File,

	    initialize:

	    function SVGFile (loader, key, url, svgConfig, xhrSettings)
	    {
	        var extension = 'svg';

	        if (IsPlainObject(key))
	        {
	            var config = key;

	            key = GetFastValue(config, 'key');
	            url = GetFastValue(config, 'url');
	            svgConfig = GetFastValue(config, 'svgConfig', {});
	            xhrSettings = GetFastValue(config, 'xhrSettings');
	            extension = GetFastValue(config, 'extension', extension);
	        }

	        var fileConfig = {
	            type: 'svg',
	            cache: loader.textureManager,
	            extension: extension,
	            responseType: 'text',
	            key: key,
	            url: url,
	            xhrSettings: xhrSettings,
	            config: {
	                width: GetFastValue(svgConfig, 'width'),
	                height: GetFastValue(svgConfig, 'height'),
	                scale: GetFastValue(svgConfig, 'scale')
	            }
	        };

	        File.call(this, loader, fileConfig);
	    },

	    
	    onProcess: function ()
	    {
	        this.state = CONST.FILE_PROCESSING;

	        var text = this.xhrLoader.responseText;
	        var svg = [ text ];
	        var width = this.config.width;
	        var height = this.config.height;
	        var scale = this.config.scale;

	        resize: if (width && height || scale)
	        {
	            var xml = null;
	            var parser = new DOMParser();
	            xml = parser.parseFromString(text, 'text/xml');
	            var svgXML = xml.getElementsByTagName('svg')[0];

	            var hasViewBox = svgXML.hasAttribute('viewBox');
	            var svgWidth = parseFloat(svgXML.getAttribute('width'));
	            var svgHeight = parseFloat(svgXML.getAttribute('height'));

	            if (!hasViewBox && svgWidth && svgHeight)
	            {
	                //  If there's no viewBox attribute, set one
	                svgXML.setAttribute('viewBox', '0  0 ' + svgWidth + ' ' + svgHeight);
	            }
	            else if (hasViewBox && !svgWidth && !svgHeight)
	            {
	                //  Get the w/h from the viewbox
	                var viewBox = svgXML.getAttribute('viewBox').split(/\s+|,/);

	                svgWidth = viewBox[2];
	                svgHeight = viewBox[3];
	            }

	            if (scale)
	            {
	                if (svgWidth && svgHeight)
	                {
	                    width = svgWidth * scale;
	                    height = svgHeight * scale;
	                }
	                else
	                {
	                    break resize;
	                }
	            }

	            svgXML.setAttribute('width', width.toString() + 'px');
	            svgXML.setAttribute('height', height.toString() + 'px');

	            svg = [ (new XMLSerializer()).serializeToString(svgXML) ];
	        }

	        try
	        {
	            var blob = new window.Blob(svg, { type: 'image/svg+xml;charset=utf-8' });
	        }
	        catch (e)
	        {
	            this.onProcessError();

	            return;
	        }

	        this.data = new Image();

	        this.data.crossOrigin = this.crossOrigin;

	        var _this = this;
	        var retry = false;

	        this.data.onload = function ()
	        {
	            if (!retry)
	            {
	                File.revokeObjectURL(_this.data);
	            }

	            _this.onProcessComplete();
	        };

	        this.data.onerror = function ()
	        {
	            //  Safari 8 re-try
	            if (!retry)
	            {
	                retry = true;

	                File.revokeObjectURL(_this.data);

	                _this.data.src = 'data:image/svg+xml,' + encodeURIComponent(svg.join(''));
	            }
	            else
	            {
	                _this.onProcessError();
	            }
	        };

	        File.createObjectURL(this.data, blob, 'image/svg+xml');
	    },

	    
	    addToCache: function ()
	    {
	        this.cache.addImage(this.key, this.data);
	    }

	});


	FileTypesManager.register('svg', function (key, url, svgConfig, xhrSettings)
	{
	    if (Array.isArray(key))
	    {
	        for (var i = 0; i < key.length; i++)
	        {
	            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object
	            this.addFile(new SVGFile(this, key[i]));
	        }
	    }
	    else
	    {
	        this.addFile(new SVGFile(this, key, url, svgConfig, xhrSettings));
	    }

	    return this;
	});

	SVGFile_1 = SVGFile;
	return SVGFile_1;
}

var Formats;
var hasRequiredFormats;

function requireFormats () {
	if (hasRequiredFormats) return Formats;
	hasRequiredFormats = 1;
	Formats = {

	    CSV: 0,

	    TILED_JSON: 1,

	    ARRAY_2D: 2,

	    WELTMEISTER: 3

	};
	return Formats;
}

var TilemapCSVFile_1;
var hasRequiredTilemapCSVFile;

function requireTilemapCSVFile () {
	if (hasRequiredTilemapCSVFile) return TilemapCSVFile_1;
	hasRequiredTilemapCSVFile = 1;
	var Class = requireClass();
	var CONST = require_const$3();
	var File = requireFile();
	var FileTypesManager = requireFileTypesManager();
	var GetFastValue = requireGetFastValue();
	var IsPlainObject = requireIsPlainObject();
	var TILEMAP_FORMATS = requireFormats();


	var TilemapCSVFile = new Class({

	    Extends: File,

	    initialize:

	    function TilemapCSVFile (loader, key, url, xhrSettings)
	    {
	        var extension = 'csv';

	        if (IsPlainObject(key))
	        {
	            var config = key;

	            key = GetFastValue(config, 'key');
	            url = GetFastValue(config, 'url');
	            xhrSettings = GetFastValue(config, 'xhrSettings');
	            extension = GetFastValue(config, 'extension', extension);
	        }

	        var fileConfig = {
	            type: 'tilemapCSV',
	            cache: loader.cacheManager.tilemap,
	            extension: extension,
	            responseType: 'text',
	            key: key,
	            url: url,
	            xhrSettings: xhrSettings
	        };

	        File.call(this, loader, fileConfig);

	        this.tilemapFormat = TILEMAP_FORMATS.CSV;
	    },

	    
	    onProcess: function ()
	    {
	        this.state = CONST.FILE_PROCESSING;

	        this.data = this.xhrLoader.responseText;

	        this.onProcessComplete();
	    },

	    
	    addToCache: function ()
	    {
	        var tiledata = { format: this.tilemapFormat, data: this.data };

	        this.cache.add(this.key, tiledata);
	    }

	});


	FileTypesManager.register('tilemapCSV', function (key, url, xhrSettings)
	{
	    if (Array.isArray(key))
	    {
	        for (var i = 0; i < key.length; i++)
	        {
	            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object
	            this.addFile(new TilemapCSVFile(this, key[i]));
	        }
	    }
	    else
	    {
	        this.addFile(new TilemapCSVFile(this, key, url, xhrSettings));
	    }

	    return this;
	});

	TilemapCSVFile_1 = TilemapCSVFile;
	return TilemapCSVFile_1;
}

var TilemapImpactFile_1;
var hasRequiredTilemapImpactFile;

function requireTilemapImpactFile () {
	if (hasRequiredTilemapImpactFile) return TilemapImpactFile_1;
	hasRequiredTilemapImpactFile = 1;
	var Class = requireClass();
	var FileTypesManager = requireFileTypesManager();
	var JSONFile = requireJSONFile();
	var TILEMAP_FORMATS = requireFormats();


	var TilemapImpactFile = new Class({

	    Extends: JSONFile,

	    initialize:

	    function TilemapImpactFile (loader, key, url, xhrSettings)
	    {
	        JSONFile.call(this, loader, key, url, xhrSettings);

	        this.type = 'tilemapJSON';

	        this.cache = loader.cacheManager.tilemap;
	    },

	    
	    addToCache: function ()
	    {
	        var tiledata = { format: TILEMAP_FORMATS.WELTMEISTER, data: this.data };

	        this.cache.add(this.key, tiledata);
	    }

	});


	FileTypesManager.register('tilemapImpact', function (key, url, xhrSettings)
	{
	    if (Array.isArray(key))
	    {
	        for (var i = 0; i < key.length; i++)
	        {
	            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object
	            this.addFile(new TilemapImpactFile(this, key[i]));
	        }
	    }
	    else
	    {
	        this.addFile(new TilemapImpactFile(this, key, url, xhrSettings));
	    }

	    return this;
	});

	TilemapImpactFile_1 = TilemapImpactFile;
	return TilemapImpactFile_1;
}

var TilemapJSONFile_1;
var hasRequiredTilemapJSONFile;

function requireTilemapJSONFile () {
	if (hasRequiredTilemapJSONFile) return TilemapJSONFile_1;
	hasRequiredTilemapJSONFile = 1;
	var Class = requireClass();
	var FileTypesManager = requireFileTypesManager();
	var JSONFile = requireJSONFile();
	var TILEMAP_FORMATS = requireFormats();


	var TilemapJSONFile = new Class({

	    Extends: JSONFile,

	    initialize:

	    function TilemapJSONFile (loader, key, url, xhrSettings)
	    {
	        JSONFile.call(this, loader, key, url, xhrSettings);

	        this.type = 'tilemapJSON';

	        this.cache = loader.cacheManager.tilemap;
	    },

	    
	    addToCache: function ()
	    {
	        var tiledata = { format: TILEMAP_FORMATS.TILED_JSON, data: this.data };

	        this.cache.add(this.key, tiledata);
	    }

	});


	FileTypesManager.register('tilemapTiledJSON', function (key, url, xhrSettings)
	{
	    if (Array.isArray(key))
	    {
	        for (var i = 0; i < key.length; i++)
	        {
	            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object
	            this.addFile(new TilemapJSONFile(this, key[i]));
	        }
	    }
	    else
	    {
	        this.addFile(new TilemapJSONFile(this, key, url, xhrSettings));
	    }

	    return this;
	});

	TilemapJSONFile_1 = TilemapJSONFile;
	return TilemapJSONFile_1;
}

var UnityAtlasFile_1;
var hasRequiredUnityAtlasFile;

function requireUnityAtlasFile () {
	if (hasRequiredUnityAtlasFile) return UnityAtlasFile_1;
	hasRequiredUnityAtlasFile = 1;
	var Class = requireClass();
	var FileTypesManager = requireFileTypesManager();
	var GetFastValue = requireGetFastValue();
	var ImageFile = requireImageFile();
	var IsPlainObject = requireIsPlainObject();
	var MultiFile = requireMultiFile();
	var TextFile = requireTextFile();


	var UnityAtlasFile = new Class({

	    Extends: MultiFile,

	    initialize:

	    function UnityAtlasFile (loader, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings)
	    {
	        var image;
	        var data;

	        if (IsPlainObject(key))
	        {
	            var config = key;

	            key = GetFastValue(config, 'key');

	            image = new ImageFile(loader, {
	                key: key,
	                url: GetFastValue(config, 'textureURL'),
	                extension: GetFastValue(config, 'textureExtension', 'png'),
	                normalMap: GetFastValue(config, 'normalMap'),
	                xhrSettings: GetFastValue(config, 'textureXhrSettings')
	            });

	            data = new TextFile(loader, {
	                key: key,
	                url: GetFastValue(config, 'atlasURL'),
	                extension: GetFastValue(config, 'atlasExtension', 'txt'),
	                xhrSettings: GetFastValue(config, 'atlasXhrSettings')
	            });
	        }
	        else
	        {
	            image = new ImageFile(loader, key, textureURL, textureXhrSettings);
	            data = new TextFile(loader, key, atlasURL, atlasXhrSettings);
	        }

	        if (image.linkFile)
	        {
	            //  Image has a normal map
	            MultiFile.call(this, loader, 'unityatlas', key, [ image, data, image.linkFile ]);
	        }
	        else
	        {
	            MultiFile.call(this, loader, 'unityatlas', key, [ image, data ]);
	        }
	    },

	    
	    addToCache: function ()
	    {
	        if (this.isReadyToProcess())
	        {
	            var image = this.files[0];
	            var text = this.files[1];
	            var normalMap = (this.files[2]) ? this.files[2].data : null;

	            this.loader.textureManager.addUnityAtlas(image.key, image.data, text.data, normalMap);

	            this.complete = true;
	        }
	    }

	});


	FileTypesManager.register('unityAtlas', function (key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings)
	{
	    var multifile;

	    //  Supports an Object file definition in the key argument
	    //  Or an array of objects in the key argument
	    //  Or a single entry where all arguments have been defined

	    if (Array.isArray(key))
	    {
	        for (var i = 0; i < key.length; i++)
	        {
	            multifile = new UnityAtlasFile(this, key[i]);

	            this.addFile(multifile.files);
	        }
	    }
	    else
	    {
	        multifile = new UnityAtlasFile(this, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings);

	        this.addFile(multifile.files);
	    }

	    return this;
	});

	UnityAtlasFile_1 = UnityAtlasFile;
	return UnityAtlasFile_1;
}

var VideoFile_1;
var hasRequiredVideoFile;

function requireVideoFile () {
	if (hasRequiredVideoFile) return VideoFile_1;
	hasRequiredVideoFile = 1;
	var Class = requireClass();
	var CONST = require_const$3();
	var File = requireFile();
	var FileTypesManager = requireFileTypesManager();
	var GetURL = requireGetURL();
	var GetFastValue = requireGetFastValue();
	var IsPlainObject = requireIsPlainObject();


	var VideoFile = new Class({

	    Extends: File,

	    initialize:

	    function VideoFile (loader, key, url, noAudio)
	    {
	        if (noAudio === undefined) { noAudio = false; }

	        if (IsPlainObject(key))
	        {
	            var config = key;

	            key = GetFastValue(config, 'key');
	            url = GetFastValue(config, 'url', []);
	            noAudio = GetFastValue(config, 'noAudio', false);
	        }

	        var urlConfig = loader.systems.game.device.video.getVideoURL(url);

	        if (!urlConfig)
	        {
	            console.warn('VideoFile: No supported format for ' + key);
	        }

	        var fileConfig = {
	            type: 'video',
	            cache: loader.cacheManager.video,
	            extension: urlConfig.type,
	            key: key,
	            url: urlConfig.url,
	            config: {
	                noAudio: noAudio
	            }
	        };

	        File.call(this, loader, fileConfig);
	    },

	    
	    onProcess: function ()
	    {
	        this.data = {
	            url: this.src,
	            noAudio: this.config.noAudio,
	            crossOrigin: this.crossOrigin
	        };

	        this.onProcessComplete();
	    },

	    
	    load: function ()
	    {
	        //  We set these, but we don't actually load anything (the Video Game Object does that)

	        this.src = GetURL(this, this.loader.baseURL);

	        this.state = CONST.FILE_LOADED;

	        this.loader.nextFile(this, true);
	    }

	});


	FileTypesManager.register('video', function (key, urls, noAudio)
	{
	    if (Array.isArray(key))
	    {
	        for (var i = 0; i < key.length; i++)
	        {
	            this.addFile(new VideoFile(this, key[i]));
	        }
	    }
	    else
	    {
	        this.addFile(new VideoFile(this, key, urls, noAudio));
	    }

	    return this;
	});

	VideoFile_1 = VideoFile;
	return VideoFile_1;
}

var filetypes;
var hasRequiredFiletypes;

function requireFiletypes () {
	if (hasRequiredFiletypes) return filetypes;
	hasRequiredFiletypes = 1;
	filetypes = {

	    AnimationJSONFile: requireAnimationJSONFile(),
	    AsepriteFile: requireAsepriteFile(),
	    AtlasJSONFile: requireAtlasJSONFile(),
	    AtlasXMLFile: requireAtlasXMLFile(),
	    AudioFile: requireAudioFile(),
	    AudioSpriteFile: requireAudioSpriteFile(),
	    BinaryFile: requireBinaryFile(),
	    BitmapFontFile: requireBitmapFontFile(),
	    CompressedTextureFile: requireCompressedTextureFile(),
	    CSSFile: requireCSSFile(),
	    FontFile: requireFontFile(),
	    GLSLFile: requireGLSLFile(),
	    HTML5AudioFile: requireHTML5AudioFile(),
	    HTMLFile: requireHTMLFile(),
	    HTMLTextureFile: requireHTMLTextureFile(),
	    ImageFile: requireImageFile(),
	    JSONFile: requireJSONFile(),
	    MultiAtlasFile: requireMultiAtlasFile(),
	    MultiScriptFile: requireMultiScriptFile(),
	    OBJFile: requireOBJFile(),
	    PackFile: requirePackFile(),
	    PluginFile: requirePluginFile(),
	    SceneFile: requireSceneFile(),
	    ScenePluginFile: requireScenePluginFile(),
	    ScriptFile: requireScriptFile(),
	    SpriteSheetFile: requireSpriteSheetFile(),
	    SVGFile: requireSVGFile(),
	    TextFile: requireTextFile(),
	    TilemapCSVFile: requireTilemapCSVFile(),
	    TilemapImpactFile: requireTilemapImpactFile(),
	    TilemapJSONFile: requireTilemapJSONFile(),
	    UnityAtlasFile: requireUnityAtlasFile(),
	    VideoFile: requireVideoFile(),
	    XMLFile: requireXMLFile()

	};
	return filetypes;
}

var LoaderPlugin_1;
var hasRequiredLoaderPlugin;

function requireLoaderPlugin () {
	if (hasRequiredLoaderPlugin) return LoaderPlugin_1;
	hasRequiredLoaderPlugin = 1;
	var Class = requireClass();
	var CONST = require_const$3();
	var CustomSet = require_Set();
	var EventEmitter = requireEventemitter3();
	var Events = requireEvents$8();
	var FileTypesManager = requireFileTypesManager();
	var GetFastValue = requireGetFastValue();
	var GetValue = requireGetValue();
	var IsPlainObject = requireIsPlainObject();
	var PluginCache = requirePluginCache();
	var SceneEvents = requireEvents$l();
	var XHRSettings = requireXHRSettings();


	var LoaderPlugin = new Class({

	    Extends: EventEmitter,

	    initialize:

	    function LoaderPlugin (scene)
	    {
	        EventEmitter.call(this);

	        var gameConfig = scene.sys.game.config;
	        var sceneConfig = scene.sys.settings.loader;

	        
	        this.scene = scene;

	        
	        this.systems = scene.sys;

	        
	        this.cacheManager = scene.sys.cache;

	        
	        this.textureManager = scene.sys.textures;

	        
	        this.sceneManager = scene.sys.game.scene;

	        //  Inject the available filetypes into the Loader
	        FileTypesManager.install(this);

	        
	        this.prefix = '';

	        
	        this.path = '';

	        
	        this.baseURL = '';

	        this.setBaseURL(GetFastValue(sceneConfig, 'baseURL', gameConfig.loaderBaseURL));

	        this.setPath(GetFastValue(sceneConfig, 'path', gameConfig.loaderPath));

	        this.setPrefix(GetFastValue(sceneConfig, 'prefix', gameConfig.loaderPrefix));

	        
	        this.maxParallelDownloads = GetFastValue(sceneConfig, 'maxParallelDownloads', gameConfig.loaderMaxParallelDownloads);

	        
	        this.xhr = XHRSettings(
	            GetFastValue(sceneConfig, 'responseType', gameConfig.loaderResponseType),
	            GetFastValue(sceneConfig, 'async', gameConfig.loaderAsync),
	            GetFastValue(sceneConfig, 'user', gameConfig.loaderUser),
	            GetFastValue(sceneConfig, 'password', gameConfig.loaderPassword),
	            GetFastValue(sceneConfig, 'timeout', gameConfig.loaderTimeout),
	            GetFastValue(sceneConfig, 'withCredentials', gameConfig.loaderWithCredentials)
	        );

	        
	        this.crossOrigin = GetFastValue(sceneConfig, 'crossOrigin', gameConfig.loaderCrossOrigin);

	        
	        this.imageLoadType = GetFastValue(sceneConfig, 'imageLoadType', gameConfig.loaderImageLoadType);

	        
	        this.localSchemes = GetFastValue(sceneConfig, 'localScheme', gameConfig.loaderLocalScheme);

	        
	        this.totalToLoad = 0;

	        
	        this.progress = 0;

	        
	        this.list = new CustomSet();

	        
	        this.inflight = new CustomSet();

	        
	        this.queue = new CustomSet();

	        
	        this._deleteQueue = new CustomSet();

	        
	        this.totalFailed = 0;

	        
	        this.totalComplete = 0;

	        
	        this.state = CONST.LOADER_IDLE;

	        
	        this.multiKeyIndex = 0;

	        
	        this.maxRetries = GetFastValue(sceneConfig, 'maxRetries', gameConfig.loaderMaxRetries);

	        scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
	        scene.sys.events.on(SceneEvents.START, this.pluginStart, this);
	    },

	    
	    boot: function ()
	    {
	        this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);
	    },

	    
	    pluginStart: function ()
	    {
	        this.systems.events.once(SceneEvents.SHUTDOWN, this.shutdown, this);
	    },

	    
	    setBaseURL: function (url)
	    {
	        if (url === undefined) { url = ''; }

	        if (url !== '' && url.substr(-1) !== '/')
	        {
	            url = url.concat('/');
	        }

	        this.baseURL = url;

	        return this;
	    },

	    
	    setPath: function (path)
	    {
	        if (path === undefined) { path = ''; }

	        if (path !== '' && path.substr(-1) !== '/')
	        {
	            path = path.concat('/');
	        }

	        this.path = path;

	        return this;
	    },

	    
	    setPrefix: function (prefix)
	    {
	        if (prefix === undefined) { prefix = ''; }

	        this.prefix = prefix;

	        return this;
	    },

	    
	    setCORS: function (crossOrigin)
	    {
	        this.crossOrigin = crossOrigin;

	        return this;
	    },

	    
	    addFile: function (file)
	    {
	        if (!Array.isArray(file))
	        {
	            file = [ file ];
	        }

	        for (var i = 0; i < file.length; i++)
	        {
	            var item = file[i];

	            //  Does the file already exist in the cache or texture manager?
	            //  Or will it conflict with a file already in the queue or inflight?
	            if (!this.keyExists(item))
	            {
	                this.list.set(item);

	                this.emit(Events.ADD, item.key, item.type, this, item);

	                if (this.isLoading())
	                {
	                    this.totalToLoad++;
	                    this.updateProgress();
	                }
	            }
	        }
	    },

	    
	    keyExists: function (file)
	    {
	        var keyConflict = file.hasCacheConflict();

	        if (!keyConflict)
	        {
	            this.list.iterate(function (item)
	            {
	                if (item.type === file.type && item.key === file.key)
	                {
	                    keyConflict = true;

	                    return false;
	                }

	            });
	        }

	        if (!keyConflict && this.isLoading())
	        {
	            this.inflight.iterate(function (item)
	            {
	                if (item.type === file.type && item.key === file.key)
	                {
	                    keyConflict = true;

	                    return false;
	                }

	            });

	            this.queue.iterate(function (item)
	            {
	                if (item.type === file.type && item.key === file.key)
	                {
	                    keyConflict = true;

	                    return false;
	                }

	            });
	        }

	        return keyConflict;
	    },

	    
	    addPack: function (pack, packKey)
	    {
	        //  if no packKey provided we'll add everything to the queue
	        if (typeof(packKey) === 'string')
	        {
	            var subPack = GetValue(pack, packKey);

	            if (subPack)
	            {
	                pack = { packKey: subPack };
	            }
	        }

	        var total = 0;

	        //  Store the loader settings in case this pack replaces them
	        var currentBaseURL = this.baseURL;
	        var currentPath = this.path;
	        var currentPrefix = this.prefix;

	        //  Here we go ...
	        for (var key in pack)
	        {
	            if (!Object.prototype.hasOwnProperty.call(pack, key))
	            {
	                continue;
	            }

	            var config = pack[key];

	            //  Any meta data to process?
	            var baseURL = GetFastValue(config, 'baseURL', currentBaseURL);
	            var path = GetFastValue(config, 'path', currentPath);
	            var prefix = GetFastValue(config, 'prefix', currentPrefix);
	            var files = GetFastValue(config, 'files', null);
	            var defaultType = GetFastValue(config, 'defaultType', 'void');

	            if (Array.isArray(files))
	            {
	                this.setBaseURL(baseURL);
	                this.setPath(path);
	                this.setPrefix(prefix);

	                for (var i = 0; i < files.length; i++)
	                {
	                    var file = files[i];
	                    var type = (file.hasOwnProperty('type')) ? file.type : defaultType;

	                    if (this[type])
	                    {
	                        this[type](file);
	                        total++;
	                    }
	                }
	            }
	        }

	        //  Reset the loader settings
	        this.setBaseURL(currentBaseURL);
	        this.setPath(currentPath);
	        this.setPrefix(currentPrefix);

	        return (total > 0);
	    },

	    
	    removePack: function (packKey, dataKey)
	    {
	        var animationManager = this.systems.anims;
	        var cacheManager = this.cacheManager;
	        var textureManager = this.textureManager;

	        var cacheMap = {
	            animation: 'json',
	            aseprite: 'json',
	            audio: 'audio',
	            audioSprite: 'audio',
	            binary: 'binary',
	            bitmapFont: 'bitmapFont',
	            css: null,
	            glsl: 'shader',
	            html: 'html',
	            json: 'json',
	            obj: 'obj',
	            plugin: null,
	            scenePlugin: null,
	            script: null,
	            spine: 'json',
	            text: 'text',
	            tilemapCSV: 'tilemap',
	            tilemapImpact: 'tilemap',
	            tilemapTiledJSON: 'tilemap',
	            video: 'video',
	            xml: 'xml'
	        };

	        var pack;

	        if (IsPlainObject(packKey))
	        {
	            pack = packKey;
	        }
	        else
	        {
	            pack = cacheManager.json.get(packKey);

	            if (!pack)
	            {
	                console.warn('Asset Pack not found in JSON cache:', packKey);

	                return;
	            }
	        }

	        if (dataKey)
	        {
	            pack = { _: pack[dataKey] };
	        }

	        for (var configKey in pack)
	        {
	            var config = pack[configKey];
	            var prefix = GetFastValue(config, 'prefix', '');
	            var files = GetFastValue(config, 'files');
	            var defaultType = GetFastValue(config, 'defaultType');

	            if (Array.isArray(files))
	            {
	                for (var i = 0; i < files.length; i++)
	                {
	                    var file = files[i];
	                    var type = (file.hasOwnProperty('type')) ? file.type : defaultType;

	                    if (!type)
	                    {
	                        console.warn('No type:', file);

	                        continue;
	                    }

	                    var fileKey = prefix + file.key;

	                    if (type === 'animation')
	                    {
	                        animationManager.remove(fileKey);
	                    }

	                    if (type === 'aseprite' || type === 'atlas' || type === 'atlasXML' || type === 'htmlTexture' || type === 'image' || type === 'multiatlas' || type === 'spritesheet' || type === 'svg' || type === 'texture' || type === 'unityAtlas')
	                    {
	                        textureManager.remove(fileKey);

	                        if (!cacheMap[type])
	                        {
	                            continue;
	                        }
	                    }

	                    if (type === 'pack')
	                    {
	                        this.removePack(fileKey, file.dataKey);

	                        continue;
	                    }

	                    if (type === 'spine')
	                    {
	                        var spineAtlas = cacheManager.custom.spine.get(fileKey);

	                        if (!spineAtlas)
	                        {
	                            continue;
	                        }

	                        var spinePrefix = (spineAtlas.prefix === undefined) ? '' : spineAtlas.prefix;

	                        cacheManager.custom.spine.remove(fileKey);

	                        var spineTexture = cacheManager.custom.spineTextures.get(fileKey);

	                        if (!spineTexture)
	                        {
	                            continue;
	                        }

	                        cacheManager.custom.spineTextures.remove(fileKey);

	                        for (var j = 0; j < spineTexture.pages.length; j++)
	                        {
	                            var page = spineTexture.pages[j];
	                            var textureKey = spinePrefix + page.name;
	                            var altTextureKey = fileKey + ':' + textureKey;

	                            if (textureManager.exists(altTextureKey))
	                            {
	                                textureManager.remove(altTextureKey);
	                            }
	                            else
	                            {
	                                textureManager.remove(textureKey);
	                            }
	                        }
	                    }

	                    var cacheName = cacheMap[type];

	                    if (cacheName === null)
	                    {
	                        //  Nothing to remove.

	                        continue;
	                    }

	                    if (!cacheName)
	                    {
	                        console.warn('Unknown type:', type);

	                        continue;
	                    }

	                    var cache = cacheManager[cacheName];

	                    cache.remove(fileKey);
	                }
	            }
	        }
	    },

	    
	    isLoading: function ()
	    {
	        return (this.state === CONST.LOADER_LOADING || this.state === CONST.LOADER_PROCESSING);
	    },

	    
	    isReady: function ()
	    {
	        return (this.state === CONST.LOADER_IDLE || this.state === CONST.LOADER_COMPLETE);
	    },

	    
	    start: function ()
	    {
	        if (!this.isReady())
	        {
	            return;
	        }

	        this.progress = 0;

	        this.totalFailed = 0;
	        this.totalComplete = 0;
	        this.totalToLoad = this.list.size;

	        this.emit(Events.START, this);

	        if (this.list.size === 0)
	        {
	            this.loadComplete();
	        }
	        else
	        {
	            this.state = CONST.LOADER_LOADING;

	            this.inflight.clear();
	            this.queue.clear();

	            this.updateProgress();

	            this.checkLoadQueue();

	            this.systems.events.on(SceneEvents.UPDATE, this.update, this);
	        }
	    },

	    
	    updateProgress: function ()
	    {
	        this.progress = 1 - ((this.list.size + this.inflight.size) / this.totalToLoad);

	        this.emit(Events.PROGRESS, this.progress);
	    },

	    
	    update: function ()
	    {
	        if (this.state === CONST.LOADER_LOADING && this.list.size > 0 && this.inflight.size < this.maxParallelDownloads)
	        {
	            this.checkLoadQueue();
	        }
	    },

	    
	    checkLoadQueue: function ()
	    {
	        this.list.each(function (file)
	        {
	            if (file.state === CONST.FILE_POPULATED || (file.state === CONST.FILE_PENDING && this.inflight.size < this.maxParallelDownloads))
	            {
	                this.inflight.set(file);

	                this.list.delete(file);

	                //  If the file doesn't have its own crossOrigin set, we'll use the Loaders (which is undefined by default)
	                if (!file.crossOrigin)
	                {
	                    file.crossOrigin = this.crossOrigin;
	                }

	                file.load();
	            }

	            if (this.inflight.size === this.maxParallelDownloads)
	            {
	                //  Tells the Set iterator to abort
	                return false;
	            }

	        }, this);
	    },

	    
	    nextFile: function (file, success)
	    {
	        //  Has the game been destroyed during load? If so, bail out now.
	        if (!this.inflight)
	        {
	            return;
	        }

	        this.inflight.delete(file);

	        this.updateProgress();

	        if (success)
	        {
	            this.totalComplete++;

	            this.queue.set(file);

	            this.emit(Events.FILE_LOAD, file);

	            file.onProcess();
	        }
	        else
	        {
	            this.totalFailed++;

	            this._deleteQueue.set(file);

	            this.emit(Events.FILE_LOAD_ERROR, file);

	            this.fileProcessComplete(file);
	        }
	    },

	    
	    fileProcessComplete: function (file)
	    {
	        //  Has the game been destroyed during load? If so, bail out now.
	        if (!this.scene || !this.systems || !this.systems.game || this.systems.game.pendingDestroy)
	        {
	            return;
	        }

	        //  This file has failed, so move it to the failed Set
	        if (file.state === CONST.FILE_ERRORED)
	        {
	            if (file.multiFile)
	            {
	                file.multiFile.onFileFailed(file);
	            }
	        }
	        else if (file.state === CONST.FILE_COMPLETE)
	        {
	            if (file.multiFile)
	            {
	                if (file.multiFile.isReadyToProcess())
	                {
	                    //  If we got here then all files the link file needs are ready to add to the cache
	                    file.multiFile.addToCache();
	                    file.multiFile.pendingDestroy();
	                }
	            }
	            else
	            {
	                //  If we got here, then the file processed, so let it add itself to its cache
	                file.addToCache();
	                file.pendingDestroy();
	            }
	        }

	        //  Remove it from the queue
	        this.queue.delete(file);

	        //  Nothing left to do?

	        if (this.list.size === 0 && this.inflight.size === 0 && this.queue.size === 0)
	        {
	            this.loadComplete();
	        }
	    },

	    
	    loadComplete: function ()
	    {
	        this.emit(Events.POST_PROCESS, this);

	        this.list.clear();
	        this.inflight.clear();
	        this.queue.clear();

	        this.progress = 1;

	        this.state = CONST.LOADER_COMPLETE;

	        this.systems.events.off(SceneEvents.UPDATE, this.update, this);

	        //  Call 'destroy' on each file ready for deletion
	        this._deleteQueue.iterateLocal('destroy');

	        this._deleteQueue.clear();

	        this.emit(Events.COMPLETE, this, this.totalComplete, this.totalFailed);
	    },

	    
	    flagForRemoval: function (file)
	    {
	        this._deleteQueue.set(file);
	    },

	    
	    saveJSON: function (data, filename)
	    {
	        return this.save(JSON.stringify(data), filename);
	    },

	    
	    save: function (data, filename, filetype)
	    {
	        if (filename === undefined) { filename = 'file.json'; }
	        if (filetype === undefined) { filetype = 'application/json'; }

	        var blob = new Blob([ data ], { type: filetype });

	        var url = URL.createObjectURL(blob);

	        var a = document.createElement('a');

	        a.download = filename;
	        a.textContent = 'Download ' + filename;
	        a.href = url;
	        a.click();

	        return this;
	    },

	    
	    reset: function ()
	    {
	        this.list.clear();
	        this.inflight.clear();
	        this.queue.clear();

	        var gameConfig = this.systems.game.config;
	        var sceneConfig = this.systems.settings.loader;

	        this.setBaseURL(GetFastValue(sceneConfig, 'baseURL', gameConfig.loaderBaseURL));
	        this.setPath(GetFastValue(sceneConfig, 'path', gameConfig.loaderPath));
	        this.setPrefix(GetFastValue(sceneConfig, 'prefix', gameConfig.loaderPrefix));

	        this.state = CONST.LOADER_IDLE;
	    },

	    
	    shutdown: function ()
	    {
	        this.reset();

	        this.state = CONST.LOADER_SHUTDOWN;

	        this.removeAllListeners();

	        this.systems.events.off(SceneEvents.UPDATE, this.update, this);
	        this.systems.events.off(SceneEvents.SHUTDOWN, this.shutdown, this);
	    },

	    
	    destroy: function ()
	    {
	        this.shutdown();

	        this.state = CONST.LOADER_DESTROYED;

	        this.systems.events.off(SceneEvents.UPDATE, this.update, this);
	        this.systems.events.off(SceneEvents.START, this.pluginStart, this);

	        this.list = null;
	        this.inflight = null;
	        this.queue = null;

	        this.scene = null;
	        this.systems = null;
	        this.textureManager = null;
	        this.cacheManager = null;
	        this.sceneManager = null;
	    }

	});

	PluginCache.register('Loader', LoaderPlugin, 'load');

	LoaderPlugin_1 = LoaderPlugin;
	return LoaderPlugin_1;
}

var loader;
var hasRequiredLoader;

function requireLoader () {
	if (hasRequiredLoader) return loader;
	hasRequiredLoader = 1;
	var CONST = require_const$3();
	var Extend = requireExtend$1();



	var Loader = {

	    Events: requireEvents$8(),

	    FileTypes: requireFiletypes(),

	    File: requireFile(),
	    FileTypesManager: requireFileTypesManager(),
	    GetURL: requireGetURL(),
	    LoaderPlugin: requireLoaderPlugin(),
	    MergeXHRSettings: requireMergeXHRSettings(),
	    MultiFile: requireMultiFile(),
	    XHRLoader: requireXHRLoader(),
	    XHRSettings: requireXHRSettings()

	};

	//   Merge in the consts
	Loader = Extend(false, Loader, CONST);

	loader = Loader;
	return loader;
}

var _const$2;
var hasRequired_const$2;

function require_const$2 () {
	if (hasRequired_const$2) return _const$2;
	hasRequired_const$2 = 1;
	var CONST = {

	    DYNAMIC_BODY: 0,

	    STATIC_BODY: 1,

	    GROUP: 2,

	    TILEMAPLAYER: 3,

	    FACING_NONE: 10,

	    FACING_UP: 11,

	    FACING_DOWN: 12,

	    FACING_LEFT: 13,

	    FACING_RIGHT: 14

	};

	_const$2 = CONST;
	return _const$2;
}

var Acceleration_1;
var hasRequiredAcceleration;

function requireAcceleration () {
	if (hasRequiredAcceleration) return Acceleration_1;
	hasRequiredAcceleration = 1;
	var Acceleration = {

	    setAcceleration: function (x, y)
	    {
	        this.body.acceleration.set(x, y);

	        return this;
	    },

	    setAccelerationX: function (value)
	    {
	        this.body.acceleration.x = value;

	        return this;
	    },

	    setAccelerationY: function (value)
	    {
	        this.body.acceleration.y = value;

	        return this;
	    }

	};

	Acceleration_1 = Acceleration;
	return Acceleration_1;
}

var Angular_1;
var hasRequiredAngular;

function requireAngular () {
	if (hasRequiredAngular) return Angular_1;
	hasRequiredAngular = 1;
	var Angular = {

	    setAngularVelocity: function (value)
	    {
	        this.body.angularVelocity = value;

	        return this;
	    },

	    setAngularAcceleration: function (value)
	    {
	        this.body.angularAcceleration = value;

	        return this;
	    },

	    setAngularDrag: function (value)
	    {
	        this.body.angularDrag = value;

	        return this;
	    }

	};

	Angular_1 = Angular;
	return Angular_1;
}

var Bounce_1;
var hasRequiredBounce;

function requireBounce () {
	if (hasRequiredBounce) return Bounce_1;
	hasRequiredBounce = 1;
	var Bounce = {

	    setBounce: function (x, y)
	    {
	        this.body.bounce.set(x, y);

	        return this;
	    },

	    setBounceX: function (value)
	    {
	        this.body.bounce.x = value;

	        return this;
	    },

	    setBounceY: function (value)
	    {
	        this.body.bounce.y = value;

	        return this;
	    },

	    setCollideWorldBounds: function (value, bounceX, bounceY, onWorldBounds)
	    {
	        this.body.setCollideWorldBounds(value, bounceX, bounceY, onWorldBounds);

	        return this;
	    }

	};

	Bounce_1 = Bounce;
	return Bounce_1;
}

var GetCollidesWith_1;
var hasRequiredGetCollidesWith;

function requireGetCollidesWith () {
	if (hasRequiredGetCollidesWith) return GetCollidesWith_1;
	hasRequiredGetCollidesWith = 1;
	var GetCollidesWith = function (categories)
	{
	    var flags = 0;

	    if (!Array.isArray(categories))
	    {
	        flags = categories;
	    }
	    else
	    {
	        for (var i = 0; i < categories.length; i++)
	        {
	            flags |= categories[i];
	        }
	    }

	    return flags;
	};

	GetCollidesWith_1 = GetCollidesWith;
	return GetCollidesWith_1;
}

var Collision_1;
var hasRequiredCollision;

function requireCollision () {
	if (hasRequiredCollision) return Collision_1;
	hasRequiredCollision = 1;
	var GetCollidesWith = requireGetCollidesWith();

	var Collision = {

	    setCollisionCategory: function (category)
	    {
	        var target = (this.body) ? this.body : this;

	        target.collisionCategory = category;

	        return this;
	    },

	    willCollideWith: function (category)
	    {
	        var target = (this.body) ? this.body : this;

	        return (target.collisionMask & category) !== 0;
	    },

	    addCollidesWith: function (category)
	    {
	        var target = (this.body) ? this.body : this;

	        target.collisionMask = target.collisionMask | category;

	        return this;
	    },

	    removeCollidesWith: function (category)
	    {
	        var target = (this.body) ? this.body : this;

	        target.collisionMask = target.collisionMask & ~category;

	        return this;
	    },

	    setCollidesWith: function (categories)
	    {
	        var target = (this.body) ? this.body : this;

	        target.collisionMask = GetCollidesWith(categories);

	        return this;
	    },

	    resetCollisionCategory: function ()
	    {
	        var target = (this.body) ? this.body : this;

	        target.collisionCategory = 0x0001;
	        target.collisionMask = 2147483647;

	        return this;
	    }

	};

	Collision_1 = Collision;
	return Collision_1;
}

var Debug_1;
var hasRequiredDebug;

function requireDebug () {
	if (hasRequiredDebug) return Debug_1;
	hasRequiredDebug = 1;
	var Debug = {

	    setDebug: function (showBody, showVelocity, bodyColor)
	    {
	        this.debugShowBody = showBody;
	        this.debugShowVelocity = showVelocity;
	        this.debugBodyColor = bodyColor;

	        return this;
	    },

	    setDebugBodyColor: function (value)
	    {
	        this.body.debugBodyColor = value;

	        return this;
	    },

	    debugShowBody: {

	        get: function ()
	        {
	            return this.body.debugShowBody;
	        },

	        set: function (value)
	        {
	            this.body.debugShowBody = value;
	        }

	    },

	    debugShowVelocity: {

	        get: function ()
	        {
	            return this.body.debugShowVelocity;
	        },

	        set: function (value)
	        {
	            this.body.debugShowVelocity = value;
	        }

	    },

	    debugBodyColor: {

	        get: function ()
	        {
	            return this.body.debugBodyColor;
	        },

	        set: function (value)
	        {
	            this.body.debugBodyColor = value;
	        }

	    }

	};

	Debug_1 = Debug;
	return Debug_1;
}

var Drag_1;
var hasRequiredDrag;

function requireDrag () {
	if (hasRequiredDrag) return Drag_1;
	hasRequiredDrag = 1;
	var Drag = {

	    setDrag: function (x, y)
	    {
	        this.body.drag.set(x, y);

	        return this;
	    },

	    setDragX: function (value)
	    {
	        this.body.drag.x = value;

	        return this;
	    },

	    setDragY: function (value)
	    {
	        this.body.drag.y = value;

	        return this;
	    },

	    setDamping: function (value)
	    {
	        this.body.useDamping = value;

	        return this;
	    }

	};

	Drag_1 = Drag;
	return Drag_1;
}

var Enable_1;
var hasRequiredEnable;

function requireEnable () {
	if (hasRequiredEnable) return Enable_1;
	hasRequiredEnable = 1;
	var Enable = {

	    setDirectControl: function (value)
	    {
	        this.body.setDirectControl(value);

	        return this;
	    },

	    enableBody: function (reset, x, y, enableGameObject, showGameObject)
	    {
	        if (reset)
	        {
	            this.body.reset(x, y);
	        }

	        if (enableGameObject)
	        {
	            this.body.gameObject.active = true;
	        }

	        if (showGameObject)
	        {
	            this.body.gameObject.visible = true;
	        }

	        this.body.enable = true;

	        return this;
	    },

	    disableBody: function (disableGameObject, hideGameObject)
	    {
	        if (disableGameObject === undefined) { disableGameObject = false; }
	        if (hideGameObject === undefined) { hideGameObject = false; }

	        this.body.stop();

	        this.body.enable = false;

	        if (disableGameObject)
	        {
	            this.body.gameObject.active = false;
	        }

	        if (hideGameObject)
	        {
	            this.body.gameObject.visible = false;
	        }

	        return this;
	    },

	    refreshBody: function ()
	    {
	        this.body.updateFromGameObject();

	        return this;
	    }

	};

	Enable_1 = Enable;
	return Enable_1;
}

var Friction_1;
var hasRequiredFriction;

function requireFriction () {
	if (hasRequiredFriction) return Friction_1;
	hasRequiredFriction = 1;
	var Friction = {

	    setFriction: function (x, y)
	    {
	        this.body.friction.set(x, y);

	        return this;
	    },

	    setFrictionX: function (x)
	    {
	        this.body.friction.x = x;

	        return this;
	    },

	    setFrictionY: function (y)
	    {
	        this.body.friction.y = y;

	        return this;
	    }

	};

	Friction_1 = Friction;
	return Friction_1;
}

var Gravity_1;
var hasRequiredGravity;

function requireGravity () {
	if (hasRequiredGravity) return Gravity_1;
	hasRequiredGravity = 1;
	var Gravity = {

	    setGravity: function (x, y)
	    {
	        this.body.gravity.set(x, y);

	        return this;
	    },

	    setGravityX: function (x)
	    {
	        this.body.gravity.x = x;

	        return this;
	    },

	    setGravityY: function (y)
	    {
	        this.body.gravity.y = y;

	        return this;
	    }

	};

	Gravity_1 = Gravity;
	return Gravity_1;
}

var Immovable_1;
var hasRequiredImmovable;

function requireImmovable () {
	if (hasRequiredImmovable) return Immovable_1;
	hasRequiredImmovable = 1;
	var Immovable = {

	    setImmovable: function (value)
	    {
	        if (value === undefined) { value = true; }

	        this.body.immovable = value;

	        return this;
	    }

	};

	Immovable_1 = Immovable;
	return Immovable_1;
}

var Mass_1;
var hasRequiredMass;

function requireMass () {
	if (hasRequiredMass) return Mass_1;
	hasRequiredMass = 1;
	var Mass = {

	    setMass: function (value)
	    {
	        this.body.mass = value;

	        return this;
	    }

	};

	Mass_1 = Mass;
	return Mass_1;
}

var OverlapRect_1;
var hasRequiredOverlapRect;

function requireOverlapRect () {
	if (hasRequiredOverlapRect) return OverlapRect_1;
	hasRequiredOverlapRect = 1;
	var OverlapRect = function (world, x, y, width, height, includeDynamic, includeStatic)
	{
	    if (includeDynamic === undefined) { includeDynamic = true; }
	    if (includeStatic === undefined) { includeStatic = false; }

	    var dynamicBodies = [];
	    var staticBodies = [];

	    var minMax = world.treeMinMax;

	    minMax.minX = x;
	    minMax.minY = y;
	    minMax.maxX = x + width;
	    minMax.maxY = y + height;

	    if (includeStatic)
	    {
	        staticBodies = world.staticTree.search(minMax);
	    }

	    if (includeDynamic && world.useTree)
	    {
	        dynamicBodies = world.tree.search(minMax);
	    }
	    else if (includeDynamic)
	    {
	        var bodies = world.bodies;

	        var fakeBody =
	        {
	            position: {
	                x: x,
	                y: y
	            },
	            left: x,
	            top: y,
	            right: x + width,
	            bottom: y + height,
	            isCircle: false
	        };

	        var intersects = world.intersects;

	        bodies.iterate(function (target)
	        {
	            if (intersects(target, fakeBody))
	            {
	                dynamicBodies.push(target);
	            }

	        });
	    }

	    return staticBodies.concat(dynamicBodies);
	};

	OverlapRect_1 = OverlapRect;
	return OverlapRect_1;
}

var OverlapCirc_1;
var hasRequiredOverlapCirc;

function requireOverlapCirc () {
	if (hasRequiredOverlapCirc) return OverlapCirc_1;
	hasRequiredOverlapCirc = 1;
	var OverlapRect = requireOverlapRect();
	var Circle = requireCircle$2();
	var CircleToCircle = requireCircleToCircle();
	var CircleToRectangle = requireCircleToRectangle();

	var OverlapCirc = function (world, x, y, radius, includeDynamic, includeStatic)
	{
	    var bodiesInRect = OverlapRect(world, x - radius, y - radius, 2 * radius, 2 * radius, includeDynamic, includeStatic);

	    if (bodiesInRect.length === 0)
	    {
	        return bodiesInRect;
	    }

	    var area = new Circle(x, y, radius);
	    var circFromBody = new Circle();
	    var bodiesInArea = [];

	    for (var i = 0; i < bodiesInRect.length; i++)
	    {
	        var body = bodiesInRect[i];

	        if (body.isCircle)
	        {
	            circFromBody.setTo(body.center.x, body.center.y, body.halfWidth);

	            if (CircleToCircle(area, circFromBody))
	            {
	                bodiesInArea.push(body);
	            }
	        }
	        else if (CircleToRectangle(area, body))
	        {
	            bodiesInArea.push(body);
	        }
	    }

	    return bodiesInArea;
	};

	OverlapCirc_1 = OverlapCirc;
	return OverlapCirc_1;
}

var Pushable_1;
var hasRequiredPushable;

function requirePushable () {
	if (hasRequiredPushable) return Pushable_1;
	hasRequiredPushable = 1;
	var Pushable = {

	    setPushable: function (value)
	    {
	        if (value === undefined) { value = true; }

	        this.body.pushable = value;

	        return this;
	    }

	};

	Pushable_1 = Pushable;
	return Pushable_1;
}

var Size_1;
var hasRequiredSize;

function requireSize () {
	if (hasRequiredSize) return Size_1;
	hasRequiredSize = 1;
	var Size = {

	    setOffset: function (x, y)
	    {
	        this.body.setOffset(x, y);

	        return this;
	    },

	    setSize: function (width, height, center)
	    {
	        this.body.setSize(width, height, center);

	        return this;
	    },

	    setBodySize: function (width, height, center)
	    {
	        this.body.setSize(width, height, center);

	        return this;
	    },

	    setCircle: function (radius, offsetX, offsetY)
	    {
	        this.body.setCircle(radius, offsetX, offsetY);

	        return this;
	    }

	};

	Size_1 = Size;
	return Size_1;
}

var Velocity_1;
var hasRequiredVelocity;

function requireVelocity () {
	if (hasRequiredVelocity) return Velocity_1;
	hasRequiredVelocity = 1;
	var Velocity = {

	    setVelocity: function (x, y)
	    {
	        this.body.setVelocity(x, y);

	        return this;
	    },

	    setVelocityX: function (x)
	    {
	        this.body.setVelocityX(x);

	        return this;
	    },

	    setVelocityY: function (y)
	    {
	        this.body.setVelocityY(y);

	        return this;
	    },

	    setMaxVelocity: function (x, y)
	    {
	        this.body.maxVelocity.set(x, y);

	        return this;
	    }

	};

	Velocity_1 = Velocity;
	return Velocity_1;
}

var components$1;
var hasRequiredComponents$1;

function requireComponents$1 () {
	if (hasRequiredComponents$1) return components$1;
	hasRequiredComponents$1 = 1;
	components$1 = {

	    Acceleration: requireAcceleration(),
	    Angular: requireAngular(),
	    Bounce: requireBounce(),
	    Collision: requireCollision(),
	    Debug: requireDebug(),
	    Drag: requireDrag(),
	    Enable: requireEnable(),
	    Friction: requireFriction(),
	    Gravity: requireGravity(),
	    Immovable: requireImmovable(),
	    Mass: requireMass(),
	    OverlapCirc: requireOverlapCirc(),
	    OverlapRect: requireOverlapRect(),
	    Pushable: requirePushable(),
	    Size: requireSize(),
	    Velocity: requireVelocity()

	};
	return components$1;
}

var ArcadeImage_1;
var hasRequiredArcadeImage;

function requireArcadeImage () {
	if (hasRequiredArcadeImage) return ArcadeImage_1;
	hasRequiredArcadeImage = 1;
	var Class = requireClass();
	var Components = requireComponents$1();
	var Image = requireImage$1();

	var ArcadeImage = new Class({

	    Extends: Image,

	    Mixins: [
	        Components.Acceleration,
	        Components.Angular,
	        Components.Bounce,
	        Components.Collision,
	        Components.Debug,
	        Components.Drag,
	        Components.Enable,
	        Components.Friction,
	        Components.Gravity,
	        Components.Immovable,
	        Components.Mass,
	        Components.Pushable,
	        Components.Size,
	        Components.Velocity
	    ],

	    initialize:

	    function ArcadeImage (scene, x, y, texture, frame)
	    {
	        Image.call(this, scene, x, y, texture, frame);

	        this.body = null;
	    }

	});

	ArcadeImage_1 = ArcadeImage;
	return ArcadeImage_1;
}

var ArcadeSprite_1;
var hasRequiredArcadeSprite;

function requireArcadeSprite () {
	if (hasRequiredArcadeSprite) return ArcadeSprite_1;
	hasRequiredArcadeSprite = 1;
	var Class = requireClass();
	var Components = requireComponents$1();
	var Sprite = requireSprite();

	var ArcadeSprite = new Class({

	    Extends: Sprite,

	    Mixins: [
	        Components.Acceleration,
	        Components.Angular,
	        Components.Bounce,
	        Components.Collision,
	        Components.Debug,
	        Components.Drag,
	        Components.Enable,
	        Components.Friction,
	        Components.Gravity,
	        Components.Immovable,
	        Components.Mass,
	        Components.Pushable,
	        Components.Size,
	        Components.Velocity
	    ],

	    initialize:

	    function ArcadeSprite (scene, x, y, texture, frame)
	    {
	        Sprite.call(this, scene, x, y, texture, frame);

	        this.body = null;
	    }

	});

	ArcadeSprite_1 = ArcadeSprite;
	return ArcadeSprite_1;
}

var COLLIDE_EVENT;
var hasRequiredCOLLIDE_EVENT;

function requireCOLLIDE_EVENT () {
	if (hasRequiredCOLLIDE_EVENT) return COLLIDE_EVENT;
	hasRequiredCOLLIDE_EVENT = 1;
	COLLIDE_EVENT = 'collide';
	return COLLIDE_EVENT;
}

var OVERLAP_EVENT;
var hasRequiredOVERLAP_EVENT;

function requireOVERLAP_EVENT () {
	if (hasRequiredOVERLAP_EVENT) return OVERLAP_EVENT;
	hasRequiredOVERLAP_EVENT = 1;
	OVERLAP_EVENT = 'overlap';
	return OVERLAP_EVENT;
}

var PAUSE_EVENT;
var hasRequiredPAUSE_EVENT;

function requirePAUSE_EVENT () {
	if (hasRequiredPAUSE_EVENT) return PAUSE_EVENT;
	hasRequiredPAUSE_EVENT = 1;
	PAUSE_EVENT = 'pause';
	return PAUSE_EVENT;
}

var RESUME_EVENT;
var hasRequiredRESUME_EVENT;

function requireRESUME_EVENT () {
	if (hasRequiredRESUME_EVENT) return RESUME_EVENT;
	hasRequiredRESUME_EVENT = 1;
	RESUME_EVENT = 'resume';
	return RESUME_EVENT;
}

var TILE_COLLIDE_EVENT;
var hasRequiredTILE_COLLIDE_EVENT;

function requireTILE_COLLIDE_EVENT () {
	if (hasRequiredTILE_COLLIDE_EVENT) return TILE_COLLIDE_EVENT;
	hasRequiredTILE_COLLIDE_EVENT = 1;
	TILE_COLLIDE_EVENT = 'tilecollide';
	return TILE_COLLIDE_EVENT;
}

var TILE_OVERLAP_EVENT;
var hasRequiredTILE_OVERLAP_EVENT;

function requireTILE_OVERLAP_EVENT () {
	if (hasRequiredTILE_OVERLAP_EVENT) return TILE_OVERLAP_EVENT;
	hasRequiredTILE_OVERLAP_EVENT = 1;
	TILE_OVERLAP_EVENT = 'tileoverlap';
	return TILE_OVERLAP_EVENT;
}

var WORLD_BOUNDS_EVENT;
var hasRequiredWORLD_BOUNDS_EVENT;

function requireWORLD_BOUNDS_EVENT () {
	if (hasRequiredWORLD_BOUNDS_EVENT) return WORLD_BOUNDS_EVENT;
	hasRequiredWORLD_BOUNDS_EVENT = 1;
	WORLD_BOUNDS_EVENT = 'worldbounds';
	return WORLD_BOUNDS_EVENT;
}

var WORLD_STEP_EVENT;
var hasRequiredWORLD_STEP_EVENT;

function requireWORLD_STEP_EVENT () {
	if (hasRequiredWORLD_STEP_EVENT) return WORLD_STEP_EVENT;
	hasRequiredWORLD_STEP_EVENT = 1;
	WORLD_STEP_EVENT = 'worldstep';
	return WORLD_STEP_EVENT;
}

var events$2;
var hasRequiredEvents$2;

function requireEvents$2 () {
	if (hasRequiredEvents$2) return events$2;
	hasRequiredEvents$2 = 1;
	events$2 = {

	    COLLIDE: requireCOLLIDE_EVENT(),
	    OVERLAP: requireOVERLAP_EVENT(),
	    PAUSE: requirePAUSE_EVENT(),
	    RESUME: requireRESUME_EVENT(),
	    TILE_COLLIDE: requireTILE_COLLIDE_EVENT(),
	    TILE_OVERLAP: requireTILE_OVERLAP_EVENT(),
	    WORLD_BOUNDS: requireWORLD_BOUNDS_EVENT(),
	    WORLD_STEP: requireWORLD_STEP_EVENT()

	};
	return events$2;
}

var SetCollisionObject_1;
var hasRequiredSetCollisionObject;

function requireSetCollisionObject () {
	if (hasRequiredSetCollisionObject) return SetCollisionObject_1;
	hasRequiredSetCollisionObject = 1;
	var SetCollisionObject = function (noneFlip, data)
	{
	    if (data === undefined) { data = {}; }

	    data.none = noneFlip;
	    data.up = false;
	    data.down = false;
	    data.left = false;
	    data.right = false;

	    if (!noneFlip)
	    {
	        data.up = true;
	        data.down = true;
	        data.left = true;
	        data.right = true;
	    }

	    return data;
	};

	SetCollisionObject_1 = SetCollisionObject;
	return SetCollisionObject_1;
}

var Body_1;
var hasRequiredBody;

function requireBody () {
	if (hasRequiredBody) return Body_1;
	hasRequiredBody = 1;
	var Class = requireClass();
	var CollisionComponent = requireCollision();
	var CONST = require_const$2();
	var Events = requireEvents$2();
	var RadToDeg = requireRadToDeg();
	var Rectangle = requireRectangle$2();
	var RectangleContains = requireContains$3();
	var SetCollisionObject = requireSetCollisionObject();
	var Vector2 = requireVector2();

	var Body = new Class({

	    Mixins: [
	        CollisionComponent
	    ],

	    initialize:

	    function Body (world, gameObject)
	    {
	        var width = 64;
	        var height = 64;

	        var dummyGameObject = {
	            x: 0,
	            y: 0,
	            angle: 0,
	            rotation: 0,
	            scaleX: 1,
	            scaleY: 1,
	            displayOriginX: 0,
	            displayOriginY: 0
	        };

	        var hasGameObject = (gameObject !== undefined);

	        if (hasGameObject && gameObject.displayWidth)
	        {
	            width = gameObject.displayWidth;
	            height = gameObject.displayHeight;
	        }

	        if (!hasGameObject)
	        {
	            gameObject = dummyGameObject;
	        }

	        this.world = world;

	        this.gameObject = (hasGameObject) ? gameObject : undefined;

	        this.isBody = true;

	        this.transform = {
	            x: gameObject.x,
	            y: gameObject.y,
	            rotation: gameObject.angle,
	            scaleX: gameObject.scaleX,
	            scaleY: gameObject.scaleY,
	            displayOriginX: gameObject.displayOriginX,
	            displayOriginY: gameObject.displayOriginY
	        };

	        this.debugShowBody = world.defaults.debugShowBody;

	        this.debugShowVelocity = world.defaults.debugShowVelocity;

	        this.debugBodyColor = world.defaults.bodyDebugColor;

	        this.enable = true;

	        this.isCircle = false;

	        this.radius = 0;

	        this.offset = new Vector2();

	        this.position = new Vector2(
	            gameObject.x - gameObject.scaleX * gameObject.displayOriginX,
	            gameObject.y - gameObject.scaleY * gameObject.displayOriginY
	        );

	        this.prev = this.position.clone();

	        this.prevFrame = this.position.clone();

	        this.allowRotation = true;

	        this.rotation = gameObject.angle;

	        this.preRotation = gameObject.angle;

	        this.width = width;

	        this.height = height;

	        this.sourceWidth = width;

	        this.sourceHeight = height;

	        if (gameObject.frame)
	        {
	            this.sourceWidth = gameObject.frame.realWidth;
	            this.sourceHeight = gameObject.frame.realHeight;
	        }

	        this.halfWidth = Math.abs(width / 2);

	        this.halfHeight = Math.abs(height / 2);

	        this.center = new Vector2(this.position.x + this.halfWidth, this.position.y + this.halfHeight);

	        this.velocity = new Vector2();

	        this.newVelocity = new Vector2();

	        this.deltaMax = new Vector2();

	        this.acceleration = new Vector2();

	        this.allowDrag = true;

	        this.drag = new Vector2();

	        this.allowGravity = true;

	        this.gravity = new Vector2();

	        this.bounce = new Vector2();

	        this.worldBounce = null;

	        this.customBoundsRectangle = world.bounds;

	        this.onWorldBounds = false;

	        this.onCollide = false;

	        this.onOverlap = false;

	        this.maxVelocity = new Vector2(10000, 10000);

	        this.maxSpeed = -1;

	        this.friction = new Vector2(1, 0);

	        this.useDamping = false;

	        this.angularVelocity = 0;

	        this.angularAcceleration = 0;

	        this.angularDrag = 0;

	        this.maxAngular = 1000;

	        this.mass = 1;

	        this.angle = 0;

	        this.speed = 0;

	        this.facing = CONST.FACING_NONE;

	        this.immovable = false;

	        this.pushable = true;

	        this.slideFactor = new Vector2(1, 1);

	        this.moves = true;

	        this.customSeparateX = false;

	        this.customSeparateY = false;

	        this.overlapX = 0;

	        this.overlapY = 0;

	        this.overlapR = 0;

	        this.embedded = false;

	        this.collideWorldBounds = false;

	        this.checkCollision = SetCollisionObject(false);

	        this.touching = SetCollisionObject(true);

	        this.wasTouching = SetCollisionObject(true);

	        this.blocked = SetCollisionObject(true);

	        this.syncBounds = false;

	        this.physicsType = CONST.DYNAMIC_BODY;

	        this.collisionCategory = 0x0001;

	        this.collisionMask = 1;

	        this._sx = gameObject.scaleX;

	        this._sy = gameObject.scaleY;

	        this._dx = 0;

	        this._dy = 0;

	        this._tx = 0;

	        this._ty = 0;

	        this._bounds = new Rectangle();

	        this.directControl = false;

	        this.autoFrame = this.position.clone();
	    },

	    updateBounds: function ()
	    {
	        var sprite = this.gameObject;

	        var transform = this.transform;

	        if (sprite.parentContainer)
	        {
	            var matrix = sprite.getWorldTransformMatrix(this.world._tempMatrix, this.world._tempMatrix2);

	            transform.x = matrix.tx;
	            transform.y = matrix.ty;
	            transform.rotation = RadToDeg(matrix.rotation);
	            transform.scaleX = matrix.scaleX;
	            transform.scaleY = matrix.scaleY;
	            transform.displayOriginX = sprite.displayOriginX;
	            transform.displayOriginY = sprite.displayOriginY;
	        }
	        else
	        {
	            transform.x = sprite.x;
	            transform.y = sprite.y;
	            transform.rotation = sprite.angle;
	            transform.scaleX = sprite.scaleX;
	            transform.scaleY = sprite.scaleY;
	            transform.displayOriginX = sprite.displayOriginX;
	            transform.displayOriginY = sprite.displayOriginY;
	        }

	        var recalc = false;

	        if (this.syncBounds)
	        {
	            var b = sprite.getBounds(this._bounds);

	            this.width = b.width;
	            this.height = b.height;
	            recalc = true;
	        }
	        else
	        {
	            var asx = Math.abs(transform.scaleX);
	            var asy = Math.abs(transform.scaleY);

	            if (this._sx !== asx || this._sy !== asy)
	            {
	                this.width = this.sourceWidth * asx;
	                this.height = this.sourceHeight * asy;
	                this._sx = asx;
	                this._sy = asy;
	                recalc = true;
	            }
	        }

	        if (recalc)
	        {
	            this.halfWidth = Math.floor(this.width / 2);
	            this.halfHeight = Math.floor(this.height / 2);
	            this.updateCenter();
	        }
	    },

	    updateCenter: function ()
	    {
	        this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight);
	    },

	    updateFromGameObject: function ()
	    {
	        this.updateBounds();

	        var transform = this.transform;

	        this.position.x = transform.x + transform.scaleX * (this.offset.x - transform.displayOriginX);
	        this.position.y = transform.y + transform.scaleY * (this.offset.y - transform.displayOriginY);

	        this.updateCenter();
	    },

	    resetFlags: function (clear)
	    {
	        if (clear === undefined)
	        {
	            clear = false;
	        }

	        var wasTouching = this.wasTouching;
	        var touching = this.touching;
	        var blocked = this.blocked;

	        if (clear)
	        {
	            SetCollisionObject(true, wasTouching);
	        }
	        else
	        {
	            wasTouching.none = touching.none;
	            wasTouching.up = touching.up;
	            wasTouching.down = touching.down;
	            wasTouching.left = touching.left;
	            wasTouching.right = touching.right;
	        }

	        SetCollisionObject(true, touching);
	        SetCollisionObject(true, blocked);

	        this.overlapR = 0;
	        this.overlapX = 0;
	        this.overlapY = 0;

	        this.embedded = false;
	    },

	    preUpdate: function (willStep, delta)
	    {
	        if (willStep)
	        {
	            this.resetFlags();
	        }

	        if (this.gameObject)
	        {
	            this.updateFromGameObject();
	        }

	        this.rotation = this.transform.rotation;
	        this.preRotation = this.rotation;

	        if (this.moves)
	        {
	            var pos = this.position;

	            this.prev.x = pos.x;
	            this.prev.y = pos.y;

	            this.prevFrame.x = pos.x;
	            this.prevFrame.y = pos.y;
	        }

	        if (willStep)
	        {
	            this.update(delta);
	        }
	    },

	    update: function (delta)
	    {
	        var prev = this.prev;
	        var pos = this.position;
	        var vel = this.velocity;

	        prev.set(pos.x, pos.y);

	        if (!this.moves)
	        {
	            this._dx = pos.x - prev.x;
	            this._dy = pos.y - prev.y;

	            return;
	        }

	        if (this.directControl)
	        {
	            var autoFrame = this.autoFrame;

	            vel.set(
	                (pos.x - autoFrame.x) / delta,
	                (pos.y - autoFrame.y) / delta
	            );

	            this.world.updateMotion(this, delta);

	            this._dx = pos.x - autoFrame.x;
	            this._dy = pos.y - autoFrame.y;
	        }
	        else
	        {
	            this.world.updateMotion(this, delta);

	            this.newVelocity.set(vel.x * delta, vel.y * delta);

	            pos.add(this.newVelocity);

	            this._dx = pos.x - prev.x;
	            this._dy = pos.y - prev.y;
	        }

	        var vx = vel.x;
	        var vy = vel.y;

	        this.updateCenter();

	        this.angle = Math.atan2(vy, vx);
	        this.speed = Math.sqrt(vx * vx + vy * vy);

	        if (this.collideWorldBounds && this.checkWorldBounds() && this.onWorldBounds)
	        {
	            var blocked = this.blocked;

	            this.world.emit(Events.WORLD_BOUNDS, this, blocked.up, blocked.down, blocked.left, blocked.right);
	        }
	    },

	    postUpdate: function ()
	    {
	        var pos = this.position;

	        var dx = pos.x - this.prevFrame.x;
	        var dy = pos.y - this.prevFrame.y;

	        var gameObject = this.gameObject;

	        if (this.moves)
	        {
	            var mx = this.deltaMax.x;
	            var my = this.deltaMax.y;

	            if (mx !== 0 && dx !== 0)
	            {
	                if (dx < 0 && dx < -mx)
	                {
	                    dx = -mx;
	                }
	                else if (dx > 0 && dx > mx)
	                {
	                    dx = mx;
	                }
	            }

	            if (my !== 0 && dy !== 0)
	            {
	                if (dy < 0 && dy < -my)
	                {
	                    dy = -my;
	                }
	                else if (dy > 0 && dy > my)
	                {
	                    dy = my;
	                }
	            }

	            if (gameObject)
	            {
	                gameObject.x += dx;
	                gameObject.y += dy;
	            }
	        }

	        if (dx < 0)
	        {
	            this.facing = CONST.FACING_LEFT;
	        }
	        else if (dx > 0)
	        {
	            this.facing = CONST.FACING_RIGHT;
	        }

	        if (dy < 0)
	        {
	            this.facing = CONST.FACING_UP;
	        }
	        else if (dy > 0)
	        {
	            this.facing = CONST.FACING_DOWN;
	        }

	        if (this.allowRotation && gameObject)
	        {
	            gameObject.angle += this.deltaZ();
	        }

	        this._tx = dx;
	        this._ty = dy;

	        this.autoFrame.set(pos.x, pos.y);
	    },

	    setBoundsRectangle: function (bounds)
	    {
	        this.customBoundsRectangle = (!bounds) ? this.world.bounds : bounds;

	        return this;
	    },

	    checkWorldBounds: function ()
	    {
	        var pos = this.position;
	        var vel = this.velocity;
	        var blocked = this.blocked;
	        var bounds = this.customBoundsRectangle;
	        var check = this.world.checkCollision;

	        var bx = (this.worldBounce) ? -this.worldBounce.x : -this.bounce.x;
	        var by = (this.worldBounce) ? -this.worldBounce.y : -this.bounce.y;

	        var wasSet = false;

	        if (pos.x < bounds.x && check.left)
	        {
	            pos.x = bounds.x;
	            vel.x *= bx;
	            blocked.left = true;
	            wasSet = true;
	        }
	        else if (this.right > bounds.right && check.right)
	        {
	            pos.x = bounds.right - this.width;
	            vel.x *= bx;
	            blocked.right = true;
	            wasSet = true;
	        }

	        if (pos.y < bounds.y && check.up)
	        {
	            pos.y = bounds.y;
	            vel.y *= by;
	            blocked.up = true;
	            wasSet = true;
	        }
	        else if (this.bottom > bounds.bottom && check.down)
	        {
	            pos.y = bounds.bottom - this.height;
	            vel.y *= by;
	            blocked.down = true;
	            wasSet = true;
	        }

	        if (wasSet)
	        {
	            this.blocked.none = false;
	            this.updateCenter();
	        }

	        return wasSet;
	    },

	    setOffset: function (x, y)
	    {
	        if (y === undefined) { y = x; }

	        this.offset.set(x, y);

	        return this;
	    },

	    setGameObject: function (gameObject, enable)
	    {
	        if (enable === undefined) { enable = true; }

	        if (!gameObject || !gameObject.hasTransformComponent)
	        {

	            return this;
	        }

	        var world = this.world;

	        if (this.gameObject && this.gameObject.body)
	        {
	            world.disable(this.gameObject);

	            this.gameObject.body = null;
	        }

	        if (gameObject.body)
	        {

	            world.disable(gameObject);
	        }

	        this.gameObject = gameObject;

	        gameObject.body = this;

	        this.setSize();

	        this.enable = enable;

	        return this;
	    },

	    setSize: function (width, height, center)
	    {
	        if (center === undefined) { center = true; }

	        var gameObject = this.gameObject;

	        if (gameObject)
	        {
	            if (!width && gameObject.frame)
	            {
	                width = gameObject.frame.realWidth;
	            }

	            if (!height && gameObject.frame)
	            {
	                height = gameObject.frame.realHeight;
	            }
	        }

	        this.sourceWidth = width;
	        this.sourceHeight = height;

	        this.width = this.sourceWidth * this._sx;
	        this.height = this.sourceHeight * this._sy;

	        this.halfWidth = Math.floor(this.width / 2);
	        this.halfHeight = Math.floor(this.height / 2);

	        this.updateCenter();

	        if (center && gameObject && gameObject.getCenter)
	        {
	            var ox = (gameObject.width - width) / 2;
	            var oy = (gameObject.height - height) / 2;

	            this.offset.set(ox, oy);
	        }

	        this.isCircle = false;
	        this.radius = 0;

	        return this;
	    },

	    setCircle: function (radius, offsetX, offsetY)
	    {
	        if (offsetX === undefined) { offsetX = this.offset.x; }
	        if (offsetY === undefined) { offsetY = this.offset.y; }

	        if (radius > 0)
	        {
	            this.isCircle = true;
	            this.radius = radius;

	            this.sourceWidth = radius * 2;
	            this.sourceHeight = radius * 2;

	            this.width = this.sourceWidth * this._sx;
	            this.height = this.sourceHeight * this._sy;

	            this.halfWidth = Math.floor(this.width / 2);
	            this.halfHeight = Math.floor(this.height / 2);

	            this.offset.set(offsetX, offsetY);

	            this.updateCenter();
	        }
	        else
	        {
	            this.isCircle = false;
	        }

	        return this;
	    },

	    reset: function (x, y)
	    {
	        this.stop();

	        var gameObject = this.gameObject;

	        if (gameObject)
	        {
	            gameObject.setPosition(x, y);

	            this.rotation = gameObject.angle;
	            this.preRotation = gameObject.angle;
	        }

	        var pos = this.position;

	        if (gameObject && gameObject.getTopLeft)
	        {
	            gameObject.getTopLeft(pos);
	        }
	        else
	        {
	            pos.set(x, y);
	        }

	        this.prev.copy(pos);
	        this.prevFrame.copy(pos);
	        this.autoFrame.copy(pos);

	        if (gameObject)
	        {
	            this.updateBounds();
	        }

	        this.updateCenter();

	        if (this.collideWorldBounds)
	        {
	            this.checkWorldBounds();
	        }

	        this.resetFlags(true);
	    },

	    stop: function ()
	    {
	        this.velocity.set(0);
	        this.acceleration.set(0);
	        this.speed = 0;
	        this.angularVelocity = 0;
	        this.angularAcceleration = 0;

	        return this;
	    },

	    getBounds: function (obj)
	    {
	        obj.x = this.x;
	        obj.y = this.y;
	        obj.right = this.right;
	        obj.bottom = this.bottom;

	        return obj;
	    },

	    hitTest: function (x, y)
	    {
	        if (!this.isCircle)
	        {
	            return RectangleContains(this, x, y);
	        }

	        if (this.radius > 0 && x >= this.left && x <= this.right && y >= this.top && y <= this.bottom)
	        {
	            var dx = (this.center.x - x) * (this.center.x - x);
	            var dy = (this.center.y - y) * (this.center.y - y);

	            return (dx + dy) <= (this.radius * this.radius);
	        }

	        return false;
	    },

	    onFloor: function ()
	    {
	        return this.blocked.down;
	    },

	    onCeiling: function ()
	    {
	        return this.blocked.up;
	    },

	    onWall: function ()
	    {
	        return (this.blocked.left || this.blocked.right);
	    },

	    deltaAbsX: function ()
	    {
	        return (this._dx > 0) ? this._dx : -this._dx;
	    },

	    deltaAbsY: function ()
	    {
	        return (this._dy > 0) ? this._dy : -this._dy;
	    },

	    deltaX: function ()
	    {
	        return this._dx;
	    },

	    deltaY: function ()
	    {
	        return this._dy;
	    },

	    deltaXFinal: function ()
	    {
	        return this._tx;
	    },

	    deltaYFinal: function ()
	    {
	        return this._ty;
	    },

	    deltaZ: function ()
	    {
	        return this.rotation - this.preRotation;
	    },

	    destroy: function ()
	    {
	        this.enable = false;

	        if (this.world)
	        {
	            this.world.pendingDestroy.set(this);
	        }
	    },

	    drawDebug: function (graphic)
	    {
	        var pos = this.position;

	        var x = pos.x + this.halfWidth;
	        var y = pos.y + this.halfHeight;

	        if (this.debugShowBody)
	        {
	            graphic.lineStyle(graphic.defaultStrokeWidth, this.debugBodyColor);

	            if (this.isCircle)
	            {
	                graphic.strokeCircle(x, y, this.width / 2);
	            }
	            else
	            {

	                if (this.checkCollision.up)
	                {
	                    graphic.lineBetween(pos.x, pos.y, pos.x + this.width, pos.y);
	                }

	                if (this.checkCollision.right)
	                {
	                    graphic.lineBetween(pos.x + this.width, pos.y, pos.x + this.width, pos.y + this.height);
	                }

	                if (this.checkCollision.down)
	                {
	                    graphic.lineBetween(pos.x, pos.y + this.height, pos.x + this.width, pos.y + this.height);
	                }

	                if (this.checkCollision.left)
	                {
	                    graphic.lineBetween(pos.x, pos.y, pos.x, pos.y + this.height);
	                }
	            }
	        }

	        if (this.debugShowVelocity)
	        {
	            graphic.lineStyle(graphic.defaultStrokeWidth, this.world.defaults.velocityDebugColor, 1);
	            graphic.lineBetween(x, y, x + this.velocity.x / 2, y + this.velocity.y / 2);
	        }
	    },

	    willDrawDebug: function ()
	    {
	        return (this.debugShowBody || this.debugShowVelocity);
	    },

	    setDirectControl: function (value)
	    {
	        if (value === undefined) { value = true; }

	        this.directControl = value;

	        return this;
	    },

	    setCollideWorldBounds: function (value, bounceX, bounceY, onWorldBounds)
	    {
	        if (value === undefined) { value = true; }

	        this.collideWorldBounds = value;

	        var setBounceX = (bounceX !== undefined);
	        var setBounceY = (bounceY !== undefined);

	        if (setBounceX || setBounceY)
	        {
	            if (!this.worldBounce)
	            {
	                this.worldBounce = new Vector2();
	            }

	            if (setBounceX)
	            {
	                this.worldBounce.x = bounceX;
	            }

	            if (setBounceY)
	            {
	                this.worldBounce.y = bounceY;
	            }
	        }

	        if (onWorldBounds !== undefined)
	        {
	            this.onWorldBounds = onWorldBounds;
	        }

	        return this;
	    },

	    setVelocity: function (x, y)
	    {
	        this.velocity.set(x, y);

	        x = this.velocity.x;
	        y = this.velocity.y;

	        this.speed = Math.sqrt(x * x + y * y);

	        return this;
	    },

	    setVelocityX: function (value)
	    {
	        return this.setVelocity(value, this.velocity.y);
	    },

	    setVelocityY: function (value)
	    {
	        return this.setVelocity(this.velocity.x, value);
	    },

	    setMaxVelocity: function (x, y)
	    {
	        this.maxVelocity.set(x, y);

	        return this;
	    },

	    setMaxVelocityX: function (value)
	    {
	        this.maxVelocity.x = value;

	        return this;
	    },

	    setMaxVelocityY: function (value)
	    {
	        this.maxVelocity.y = value;

	        return this;
	    },

	    setMaxSpeed: function (value)
	    {
	        this.maxSpeed = value;

	        return this;
	    },

	    setSlideFactor: function (x, y)
	    {
	        this.slideFactor.set(x, y);

	        return this;
	    },

	    setBounce: function (x, y)
	    {
	        this.bounce.set(x, y);

	        return this;
	    },

	    setBounceX: function (value)
	    {
	        this.bounce.x = value;

	        return this;
	    },

	    setBounceY: function (value)
	    {
	        this.bounce.y = value;

	        return this;
	    },

	    setAcceleration: function (x, y)
	    {
	        this.acceleration.set(x, y);

	        return this;
	    },

	    setAccelerationX: function (value)
	    {
	        this.acceleration.x = value;

	        return this;
	    },

	    setAccelerationY: function (value)
	    {
	        this.acceleration.y = value;

	        return this;
	    },

	    setAllowDrag: function (value)
	    {
	        if (value === undefined) { value = true; }

	        this.allowDrag = value;

	        return this;
	    },

	    setAllowGravity: function (value)
	    {
	        if (value === undefined) { value = true; }

	        this.allowGravity = value;

	        return this;
	    },

	    setAllowRotation: function (value)
	    {
	        if (value === undefined) { value = true; }

	        this.allowRotation = value;

	        return this;
	    },

	    setDrag: function (x, y)
	    {
	        this.drag.set(x, y);

	        return this;
	    },

	    setDamping: function (value)
	    {
	        this.useDamping = value;

	        return this;
	    },

	    setDragX: function (value)
	    {
	        this.drag.x = value;

	        return this;
	    },

	    setDragY: function (value)
	    {
	        this.drag.y = value;

	        return this;
	    },

	    setGravity: function (x, y)
	    {
	        this.gravity.set(x, y);

	        return this;
	    },

	    setGravityX: function (value)
	    {
	        this.gravity.x = value;

	        return this;
	    },

	    setGravityY: function (value)
	    {
	        this.gravity.y = value;

	        return this;
	    },

	    setFriction: function (x, y)
	    {
	        this.friction.set(x, y);

	        return this;
	    },

	    setFrictionX: function (value)
	    {
	        this.friction.x = value;

	        return this;
	    },

	    setFrictionY: function (value)
	    {
	        this.friction.y = value;

	        return this;
	    },

	    setAngularVelocity: function (value)
	    {
	        this.angularVelocity = value;

	        return this;
	    },

	    setAngularAcceleration: function (value)
	    {
	        this.angularAcceleration = value;

	        return this;
	    },

	    setAngularDrag: function (value)
	    {
	        this.angularDrag = value;

	        return this;
	    },

	    setMass: function (value)
	    {
	        this.mass = value;

	        return this;
	    },

	    setImmovable: function (value)
	    {
	        if (value === undefined) { value = true; }

	        this.immovable = value;

	        return this;
	    },

	    setEnable: function (value)
	    {
	        if (value === undefined) { value = true; }

	        this.enable = value;

	        return this;
	    },

	    processX: function (x, vx, left, right)
	    {
	        this.x += x;

	        this.updateCenter();

	        if (vx !== null)
	        {
	            this.velocity.x = vx * this.slideFactor.x;
	        }

	        var blocked = this.blocked;

	        if (left)
	        {
	            blocked.left = true;
	            blocked.none = false;
	        }

	        if (right)
	        {
	            blocked.right = true;
	            blocked.none = false;
	        }
	    },

	    processY: function (y, vy, up, down)
	    {
	        this.y += y;

	        this.updateCenter();

	        if (vy !== null)
	        {
	            this.velocity.y = vy * this.slideFactor.y;
	        }

	        var blocked = this.blocked;

	        if (up)
	        {
	            blocked.up = true;
	            blocked.none = false;
	        }

	        if (down)
	        {
	            blocked.down = true;
	            blocked.none = false;
	        }
	    },

	    x: {

	        get: function ()
	        {
	            return this.position.x;
	        },

	        set: function (value)
	        {
	            this.position.x = value;
	        }

	    },

	    y: {

	        get: function ()
	        {
	            return this.position.y;
	        },

	        set: function (value)
	        {
	            this.position.y = value;
	        }

	    },

	    left: {

	        get: function ()
	        {
	            return this.position.x;
	        }

	    },

	    right: {

	        get: function ()
	        {
	            return this.position.x + this.width;
	        }

	    },

	    top: {

	        get: function ()
	        {
	            return this.position.y;
	        }

	    },

	    bottom: {

	        get: function ()
	        {
	            return this.position.y + this.height;
	        }

	    }

	});

	Body_1 = Body;
	return Body_1;
}

var PhysicsGroup_1;
var hasRequiredPhysicsGroup;

function requirePhysicsGroup () {
	if (hasRequiredPhysicsGroup) return PhysicsGroup_1;
	hasRequiredPhysicsGroup = 1;
	var ArcadeSprite = requireArcadeSprite();
	var Class = requireClass();
	var CollisionComponent = requireCollision();
	var CONST = require_const$2();
	var GetFastValue = requireGetFastValue();
	var Group = requireGroup();
	var IsPlainObject = requireIsPlainObject();

	var PhysicsGroup = new Class({

	    Extends: Group,

	    Mixins: [
	        CollisionComponent
	    ],

	    initialize:

	    function PhysicsGroup (world, scene, children, config)
	    {
	        if (!children && !config)
	        {
	            config = {
	                internalCreateCallback: this.createCallbackHandler,
	                internalRemoveCallback: this.removeCallbackHandler
	            };
	        }
	        else if (IsPlainObject(children))
	        {

	            config = children;
	            children = null;

	            config.internalCreateCallback = this.createCallbackHandler;
	            config.internalRemoveCallback = this.removeCallbackHandler;
	        }
	        else if (Array.isArray(children) && IsPlainObject(children[0]))
	        {

	            var _this = this;

	            children.forEach(function (singleConfig)
	            {
	                singleConfig.internalCreateCallback = _this.createCallbackHandler;
	                singleConfig.internalRemoveCallback = _this.removeCallbackHandler;
	                singleConfig.classType = GetFastValue(singleConfig, 'classType', ArcadeSprite);
	            });

	            config = null;
	        }
	        else
	        {

	            config = {
	                internalCreateCallback: this.createCallbackHandler,
	                internalRemoveCallback: this.removeCallbackHandler
	            };
	        }

	        this.world = world;

	        if (config)
	        {
	            config.classType = GetFastValue(config, 'classType', ArcadeSprite);
	        }

	        this.physicsType = CONST.DYNAMIC_BODY;

	        this.collisionCategory = 0x0001;

	        this.collisionMask = 2147483647;

	        this.defaults = {
	            setCollideWorldBounds: GetFastValue(config, 'collideWorldBounds', false),
	            setBoundsRectangle: GetFastValue(config, 'customBoundsRectangle', null),
	            setAccelerationX: GetFastValue(config, 'accelerationX', 0),
	            setAccelerationY: GetFastValue(config, 'accelerationY', 0),
	            setAllowDrag: GetFastValue(config, 'allowDrag', true),
	            setAllowGravity: GetFastValue(config, 'allowGravity', true),
	            setAllowRotation: GetFastValue(config, 'allowRotation', true),
	            setDamping: GetFastValue(config, 'useDamping', false),
	            setBounceX: GetFastValue(config, 'bounceX', 0),
	            setBounceY: GetFastValue(config, 'bounceY', 0),
	            setDragX: GetFastValue(config, 'dragX', 0),
	            setDragY: GetFastValue(config, 'dragY', 0),
	            setEnable: GetFastValue(config, 'enable', true),
	            setGravityX: GetFastValue(config, 'gravityX', 0),
	            setGravityY: GetFastValue(config, 'gravityY', 0),
	            setFrictionX: GetFastValue(config, 'frictionX', 0),
	            setFrictionY: GetFastValue(config, 'frictionY', 0),
	            setMaxSpeed: GetFastValue(config, 'maxSpeed', -1),
	            setMaxVelocityX: GetFastValue(config, 'maxVelocityX', 10000),
	            setMaxVelocityY: GetFastValue(config, 'maxVelocityY', 10000),
	            setVelocityX: GetFastValue(config, 'velocityX', 0),
	            setVelocityY: GetFastValue(config, 'velocityY', 0),
	            setAngularVelocity: GetFastValue(config, 'angularVelocity', 0),
	            setAngularAcceleration: GetFastValue(config, 'angularAcceleration', 0),
	            setAngularDrag: GetFastValue(config, 'angularDrag', 0),
	            setMass: GetFastValue(config, 'mass', 1),
	            setImmovable: GetFastValue(config, 'immovable', false)
	        };

	        Group.call(this, scene, children, config);

	        this.type = 'PhysicsGroup';
	    },

	    createCallbackHandler: function (child)
	    {
	        if (!child.body)
	        {
	            this.world.enableBody(child, CONST.DYNAMIC_BODY);
	        }

	        var body = child.body;

	        for (var key in this.defaults)
	        {
	            body[key](this.defaults[key]);
	        }
	    },

	    removeCallbackHandler: function (child)
	    {
	        if (child.body)
	        {
	            this.world.disableBody(child);
	        }
	    },

	    setVelocity: function (x, y, step)
	    {
	        if (step === undefined) { step = 0; }

	        var items = this.getChildren();

	        for (var i = 0; i < items.length; i++)
	        {
	            items[i].body.velocity.set(x + (i * step), y + (i * step));
	        }

	        return this;
	    },

	    setVelocityX: function (value, step)
	    {
	        if (step === undefined) { step = 0; }

	        var items = this.getChildren();

	        for (var i = 0; i < items.length; i++)
	        {
	            items[i].body.velocity.x = value + (i * step);
	        }

	        return this;
	    },

	    setVelocityY: function (value, step)
	    {
	        if (step === undefined) { step = 0; }

	        var items = this.getChildren();

	        for (var i = 0; i < items.length; i++)
	        {
	            items[i].body.velocity.y = value + (i * step);
	        }

	        return this;
	    }

	});

	PhysicsGroup_1 = PhysicsGroup;
	return PhysicsGroup_1;
}

var StaticBody_1;
var hasRequiredStaticBody;

function requireStaticBody () {
	if (hasRequiredStaticBody) return StaticBody_1;
	hasRequiredStaticBody = 1;
	var CircleContains = requireContains$4();
	var Class = requireClass();
	var CollisionComponent = requireCollision();
	var CONST = require_const$2();
	var RectangleContains = requireContains$3();
	var SetCollisionObject = requireSetCollisionObject();
	var Vector2 = requireVector2();

	var StaticBody = new Class({

	    Mixins: [
	        CollisionComponent
	    ],

	    initialize:

	    function StaticBody (world, gameObject)
	    {
	        var width = 64;
	        var height = 64;

	        var dummyGameObject = {
	            x: 0,
	            y: 0,
	            angle: 0,
	            rotation: 0,
	            scaleX: 1,
	            scaleY: 1,
	            displayOriginX: 0,
	            displayOriginY: 0
	        };

	        var hasGameObject = (gameObject !== undefined);

	        if (hasGameObject && gameObject.displayWidth)
	        {
	            width = gameObject.displayWidth;
	            height = gameObject.displayHeight;
	        }

	        if (!hasGameObject)
	        {
	            gameObject = dummyGameObject;
	        }

	        this.world = world;

	        this.gameObject = (hasGameObject) ? gameObject : undefined;

	        this.isBody = true;

	        this.debugShowBody = world.defaults.debugShowStaticBody;

	        this.debugBodyColor = world.defaults.staticBodyDebugColor;

	        this.enable = true;

	        this.isCircle = false;

	        this.radius = 0;

	        this.offset = new Vector2();

	        this.position = new Vector2(gameObject.x - (width * gameObject.originX), gameObject.y - (height * gameObject.originY));

	        this.width = width;

	        this.height = height;

	        this.halfWidth = Math.abs(this.width / 2);

	        this.halfHeight = Math.abs(this.height / 2);

	        this.center = new Vector2(this.position.x + this.halfWidth, this.position.y + this.halfHeight);

	        this.velocity = Vector2.ZERO;

	        this.allowGravity = false;

	        this.gravity = Vector2.ZERO;

	        this.bounce = Vector2.ZERO;

	        this.onWorldBounds = false;

	        this.onCollide = false;

	        this.onOverlap = false;

	        this.mass = 1;

	        this.immovable = true;

	        this.pushable = false;

	        this.customSeparateX = false;

	        this.customSeparateY = false;

	        this.overlapX = 0;

	        this.overlapY = 0;

	        this.overlapR = 0;

	        this.embedded = false;

	        this.collideWorldBounds = false;

	        this.checkCollision = SetCollisionObject(false);

	        this.touching = SetCollisionObject(true);

	        this.wasTouching = SetCollisionObject(true);

	        this.blocked = SetCollisionObject(true);

	        this.physicsType = CONST.STATIC_BODY;

	        this.collisionCategory = 0x0001;

	        this.collisionMask = 1;

	        this._dx = 0;

	        this._dy = 0;
	    },

	    setGameObject: function (gameObject, update, enable)
	    {
	        if (update === undefined) { update = true; }
	        if (enable === undefined) { enable = true; }

	        if (!gameObject || !gameObject.hasTransformComponent)
	        {

	            return this;
	        }

	        var world = this.world;

	        if (this.gameObject && this.gameObject.body)
	        {
	            world.disable(this.gameObject);

	            this.gameObject.body = null;
	        }

	        if (gameObject.body)
	        {

	            world.disable(gameObject);
	        }

	        this.gameObject = gameObject;

	        gameObject.body = this;

	        this.setSize();

	        if (update)
	        {
	            this.updateFromGameObject();
	        }

	        this.enable = enable;

	        return this;
	    },

	    updateFromGameObject: function ()
	    {
	        this.world.staticTree.remove(this);

	        var gameObject = this.gameObject;

	        gameObject.getTopLeft(this.position);

	        this.width = gameObject.displayWidth;
	        this.height = gameObject.displayHeight;

	        this.halfWidth = Math.abs(this.width / 2);
	        this.halfHeight = Math.abs(this.height / 2);

	        this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight);

	        this.world.staticTree.insert(this);

	        return this;
	    },

	    setOffset: function (x, y)
	    {
	        if (y === undefined) { y = x; }

	        this.world.staticTree.remove(this);

	        this.position.x -= this.offset.x;
	        this.position.y -= this.offset.y;

	        this.offset.set(x, y);

	        this.position.x += this.offset.x;
	        this.position.y += this.offset.y;

	        this.updateCenter();

	        this.world.staticTree.insert(this);

	        return this;
	    },

	    setSize: function (width, height, center)
	    {
	        if (center === undefined) { center = true; }

	        var gameObject = this.gameObject;

	        if (gameObject && gameObject.frame)
	        {
	            if (!width)
	            {
	                width = gameObject.frame.realWidth;
	            }

	            if (!height)
	            {
	                height = gameObject.frame.realHeight;
	            }
	        }

	        this.world.staticTree.remove(this);

	        this.width = width;
	        this.height = height;

	        this.halfWidth = Math.floor(width / 2);
	        this.halfHeight = Math.floor(height / 2);

	        if (center && gameObject && gameObject.getCenter)
	        {
	            var ox = gameObject.displayWidth / 2;
	            var oy = gameObject.displayHeight / 2;

	            this.position.x -= this.offset.x;
	            this.position.y -= this.offset.y;

	            this.offset.set(ox - this.halfWidth, oy - this.halfHeight);

	            this.position.x += this.offset.x;
	            this.position.y += this.offset.y;
	        }

	        this.updateCenter();

	        this.isCircle = false;
	        this.radius = 0;

	        this.world.staticTree.insert(this);

	        return this;
	    },

	    setCircle: function (radius, offsetX, offsetY)
	    {
	        if (offsetX === undefined) { offsetX = this.offset.x; }
	        if (offsetY === undefined) { offsetY = this.offset.y; }

	        if (radius > 0)
	        {
	            this.world.staticTree.remove(this);

	            this.isCircle = true;

	            this.radius = radius;

	            this.width = radius * 2;
	            this.height = radius * 2;

	            this.halfWidth = Math.floor(this.width / 2);
	            this.halfHeight = Math.floor(this.height / 2);

	            this.offset.set(offsetX, offsetY);

	            this.updateCenter();

	            this.world.staticTree.insert(this);
	        }
	        else
	        {
	            this.isCircle = false;
	        }

	        return this;
	    },

	    updateCenter: function ()
	    {
	        this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight);
	    },

	    reset: function (x, y)
	    {
	        var gameObject = this.gameObject;

	        if (x === undefined) { x = gameObject.x; }
	        if (y === undefined) { y = gameObject.y; }

	        this.world.staticTree.remove(this);

	        gameObject.setPosition(x, y);

	        gameObject.getTopLeft(this.position);

	        this.position.x += this.offset.x;
	        this.position.y += this.offset.y;

	        this.updateCenter();

	        this.world.staticTree.insert(this);
	    },

	    stop: function ()
	    {
	        return this;
	    },

	    getBounds: function (obj)
	    {
	        obj.x = this.x;
	        obj.y = this.y;
	        obj.right = this.right;
	        obj.bottom = this.bottom;

	        return obj;
	    },

	    hitTest: function (x, y)
	    {
	        return (this.isCircle) ? CircleContains(this, x, y) : RectangleContains(this, x, y);
	    },

	    postUpdate: function ()
	    {
	    },

	    deltaAbsX: function ()
	    {
	        return 0;
	    },

	    deltaAbsY: function ()
	    {
	        return 0;
	    },

	    deltaX: function ()
	    {
	        return 0;
	    },

	    deltaY: function ()
	    {
	        return 0;
	    },

	    deltaZ: function ()
	    {
	        return 0;
	    },

	    destroy: function ()
	    {
	        this.enable = false;

	        this.world.pendingDestroy.set(this);
	    },

	    drawDebug: function (graphic)
	    {
	        var pos = this.position;

	        var x = pos.x + this.halfWidth;
	        var y = pos.y + this.halfHeight;

	        if (this.debugShowBody)
	        {
	            graphic.lineStyle(graphic.defaultStrokeWidth, this.debugBodyColor, 1);

	            if (this.isCircle)
	            {
	                graphic.strokeCircle(x, y, this.width / 2);
	            }
	            else
	            {
	                graphic.strokeRect(pos.x, pos.y, this.width, this.height);
	            }

	        }
	    },

	    willDrawDebug: function ()
	    {
	        return this.debugShowBody;
	    },

	    setMass: function (value)
	    {
	        if (value <= 0)
	        {

	            value = 0.1;
	        }

	        this.mass = value;

	        return this;
	    },

	    x: {

	        get: function ()
	        {
	            return this.position.x;
	        },

	        set: function (value)
	        {
	            this.world.staticTree.remove(this);

	            this.position.x = value;

	            this.world.staticTree.insert(this);
	        }

	    },

	    y: {

	        get: function ()
	        {
	            return this.position.y;
	        },

	        set: function (value)
	        {
	            this.world.staticTree.remove(this);

	            this.position.y = value;

	            this.world.staticTree.insert(this);
	        }

	    },

	    left: {

	        get: function ()
	        {
	            return this.position.x;
	        }

	    },

	    right: {

	        get: function ()
	        {
	            return this.position.x + this.width;
	        }

	    },

	    top: {

	        get: function ()
	        {
	            return this.position.y;
	        }

	    },

	    bottom: {

	        get: function ()
	        {
	            return this.position.y + this.height;
	        }

	    }

	});

	StaticBody_1 = StaticBody;
	return StaticBody_1;
}

var StaticPhysicsGroup_1;
var hasRequiredStaticPhysicsGroup;

function requireStaticPhysicsGroup () {
	if (hasRequiredStaticPhysicsGroup) return StaticPhysicsGroup_1;
	hasRequiredStaticPhysicsGroup = 1;
	var ArcadeSprite = requireArcadeSprite();
	var Class = requireClass();
	var CollisionComponent = requireCollision();
	var CONST = require_const$2();
	var GetFastValue = requireGetFastValue();
	var Group = requireGroup();
	var IsPlainObject = requireIsPlainObject();

	var StaticPhysicsGroup = new Class({

	    Extends: Group,

	    Mixins: [
	        CollisionComponent
	    ],

	    initialize:

	    function StaticPhysicsGroup (world, scene, children, config)
	    {
	        if (!children && !config)
	        {
	            config = {
	                internalCreateCallback: this.createCallbackHandler,
	                internalRemoveCallback: this.removeCallbackHandler,
	                createMultipleCallback: this.createMultipleCallbackHandler,
	                classType: ArcadeSprite
	            };
	        }
	        else if (IsPlainObject(children))
	        {

	            config = children;
	            children = null;

	            config.internalCreateCallback = this.createCallbackHandler;
	            config.internalRemoveCallback = this.removeCallbackHandler;
	            config.createMultipleCallback = this.createMultipleCallbackHandler;
	            config.classType = GetFastValue(config, 'classType', ArcadeSprite);
	        }
	        else if (Array.isArray(children) && IsPlainObject(children[0]))
	        {

	            config = children;
	            children = null;

	            config.forEach(function (singleConfig)
	            {
	                singleConfig.internalCreateCallback = this.createCallbackHandler;
	                singleConfig.internalRemoveCallback = this.removeCallbackHandler;
	                singleConfig.createMultipleCallback = this.createMultipleCallbackHandler;
	                singleConfig.classType = GetFastValue(singleConfig, 'classType', ArcadeSprite);
	            });
	        }
	        else
	        {

	            config = {
	                internalCreateCallback: this.createCallbackHandler,
	                internalRemoveCallback: this.removeCallbackHandler
	            };
	        }

	        this.world = world;

	        this.physicsType = CONST.STATIC_BODY;

	        this.collisionCategory = 0x0001;

	        this.collisionMask = 1;

	        Group.call(this, scene, children, config);

	        this.type = 'StaticPhysicsGroup';
	    },

	    createCallbackHandler: function (child)
	    {
	        if (!child.body)
	        {
	            this.world.enableBody(child, CONST.STATIC_BODY);
	        }
	    },

	    removeCallbackHandler: function (child)
	    {
	        if (child.body)
	        {
	            this.world.disableBody(child);
	        }
	    },

	    createMultipleCallbackHandler: function ()
	    {
	        this.refresh();
	    },

	    refresh: function ()
	    {
	        var children = this.children.entries;

	        for (var i = 0; i < children.length; i++)
	        {
	            children[i].body.reset();
	        }

	        return this;
	    }

	});

	StaticPhysicsGroup_1 = StaticPhysicsGroup;
	return StaticPhysicsGroup_1;
}

var Factory_1;
var hasRequiredFactory;

function requireFactory () {
	if (hasRequiredFactory) return Factory_1;
	hasRequiredFactory = 1;
	var ArcadeImage = requireArcadeImage();
	var ArcadeSprite = requireArcadeSprite();
	var Body = requireBody();
	var Class = requireClass();
	var CONST = require_const$2();
	var PhysicsGroup = requirePhysicsGroup();
	var StaticBody = requireStaticBody();
	var StaticPhysicsGroup = requireStaticPhysicsGroup();

	var Factory = new Class({

	    initialize:

	    function Factory (world)
	    {

	        this.world = world;

	        this.scene = world.scene;

	        this.sys = world.scene.sys;
	    },

	    collider: function (object1, object2, collideCallback, processCallback, callbackContext)
	    {
	        return this.world.addCollider(object1, object2, collideCallback, processCallback, callbackContext);
	    },

	    overlap: function (object1, object2, collideCallback, processCallback, callbackContext)
	    {
	        return this.world.addOverlap(object1, object2, collideCallback, processCallback, callbackContext);
	    },

	    existing: function (gameObject, isStatic)
	    {
	        var type = (isStatic) ? CONST.STATIC_BODY : CONST.DYNAMIC_BODY;

	        this.world.enableBody(gameObject, type);

	        return gameObject;
	    },

	    staticImage: function (x, y, key, frame)
	    {
	        var image = new ArcadeImage(this.scene, x, y, key, frame);

	        this.sys.displayList.add(image);

	        this.world.enableBody(image, CONST.STATIC_BODY);

	        return image;
	    },

	    image: function (x, y, key, frame)
	    {
	        var image = new ArcadeImage(this.scene, x, y, key, frame);

	        this.sys.displayList.add(image);

	        this.world.enableBody(image, CONST.DYNAMIC_BODY);

	        return image;
	    },

	    staticSprite: function (x, y, key, frame)
	    {
	        var sprite = new ArcadeSprite(this.scene, x, y, key, frame);

	        this.sys.displayList.add(sprite);
	        this.sys.updateList.add(sprite);

	        this.world.enableBody(sprite, CONST.STATIC_BODY);

	        return sprite;
	    },

	    sprite: function (x, y, key, frame)
	    {
	        var sprite = new ArcadeSprite(this.scene, x, y, key, frame);

	        this.sys.displayList.add(sprite);
	        this.sys.updateList.add(sprite);

	        this.world.enableBody(sprite, CONST.DYNAMIC_BODY);

	        return sprite;
	    },

	    staticGroup: function (children, config)
	    {
	        return this.sys.updateList.add(new StaticPhysicsGroup(this.world, this.world.scene, children, config));
	    },

	    group: function (children, config)
	    {
	        return this.sys.updateList.add(new PhysicsGroup(this.world, this.world.scene, children, config));
	    },

	    body: function (x, y, width, height)
	    {
	        var body = new Body(this.world);

	        body.position.set(x, y);

	        if (width && height)
	        {
	            body.setSize(width, height);
	        }

	        this.world.add(body, CONST.DYNAMIC_BODY);

	        return body;
	    },

	    staticBody: function (x, y, width, height)
	    {
	        var body = new StaticBody(this.world);

	        body.position.set(x, y);

	        if (width && height)
	        {
	            body.setSize(width, height);
	        }

	        this.world.add(body, CONST.STATIC_BODY);

	        return body;
	    },

	    destroy: function ()
	    {
	        this.world = null;
	        this.scene = null;
	        this.sys = null;
	    }

	});

	Factory_1 = Factory;
	return Factory_1;
}

var Collider_1;
var hasRequiredCollider;

function requireCollider () {
	if (hasRequiredCollider) return Collider_1;
	hasRequiredCollider = 1;
	var Class = requireClass();

	var Collider = new Class({

	    initialize:

	    function Collider (world, overlapOnly, object1, object2, collideCallback, processCallback, callbackContext)
	    {

	        this.world = world;

	        this.name = '';

	        this.active = true;

	        this.overlapOnly = overlapOnly;

	        this.object1 = object1;

	        this.object2 = object2;

	        this.collideCallback = collideCallback;

	        this.processCallback = processCallback;

	        this.callbackContext = callbackContext;
	    },

	    setName: function (name)
	    {
	        this.name = name;

	        return this;
	    },

	    update: function ()
	    {
	        this.world.collideObjects(
	            this.object1,
	            this.object2,
	            this.collideCallback,
	            this.processCallback,
	            this.callbackContext,
	            this.overlapOnly
	        );
	    },

	    destroy: function ()
	    {
	        this.world.removeCollider(this);

	        this.active = false;

	        this.world = null;

	        this.object1 = null;
	        this.object2 = null;

	        this.collideCallback = null;
	        this.processCallback = null;
	        this.callbackContext = null;
	    }

	});

	Collider_1 = Collider;
	return Collider_1;
}

var GetOverlapX_1;
var hasRequiredGetOverlapX;

function requireGetOverlapX () {
	if (hasRequiredGetOverlapX) return GetOverlapX_1;
	hasRequiredGetOverlapX = 1;
	var CONST = require_const$2();

	var GetOverlapX = function (body1, body2, overlapOnly, bias)
	{
	    var overlap = 0;
	    var maxOverlap = body1.deltaAbsX() + body2.deltaAbsX() + bias;

	    if (body1._dx === 0 && body2._dx === 0)
	    {

	        body1.embedded = true;
	        body2.embedded = true;
	    }
	    else if (body1._dx > body2._dx)
	    {

	        overlap = body1.right - body2.x;

	        if ((overlap > maxOverlap && !overlapOnly) || body1.checkCollision.right === false || body2.checkCollision.left === false)
	        {
	            overlap = 0;
	        }
	        else
	        {
	            body1.touching.none = false;
	            body1.touching.right = true;

	            body2.touching.none = false;
	            body2.touching.left = true;

	            if (body2.physicsType === CONST.STATIC_BODY && !overlapOnly)
	            {
	                body1.blocked.none = false;
	                body1.blocked.right = true;
	            }

	            if (body1.physicsType === CONST.STATIC_BODY && !overlapOnly)
	            {
	                body2.blocked.none = false;
	                body2.blocked.left = true;
	            }
	        }
	    }
	    else if (body1._dx < body2._dx)
	    {

	        overlap = body1.x - body2.width - body2.x;

	        if ((-overlap > maxOverlap && !overlapOnly) || body1.checkCollision.left === false || body2.checkCollision.right === false)
	        {
	            overlap = 0;
	        }
	        else
	        {
	            body1.touching.none = false;
	            body1.touching.left = true;

	            body2.touching.none = false;
	            body2.touching.right = true;

	            if (body2.physicsType === CONST.STATIC_BODY && !overlapOnly)
	            {
	                body1.blocked.none = false;
	                body1.blocked.left = true;
	            }

	            if (body1.physicsType === CONST.STATIC_BODY && !overlapOnly)
	            {
	                body2.blocked.none = false;
	                body2.blocked.right = true;
	            }
	        }
	    }

	    body1.overlapX = overlap;
	    body2.overlapX = overlap;

	    return overlap;
	};

	GetOverlapX_1 = GetOverlapX;
	return GetOverlapX_1;
}

var GetOverlapY_1;
var hasRequiredGetOverlapY;

function requireGetOverlapY () {
	if (hasRequiredGetOverlapY) return GetOverlapY_1;
	hasRequiredGetOverlapY = 1;
	var CONST = require_const$2();

	var GetOverlapY = function (body1, body2, overlapOnly, bias)
	{
	    var overlap = 0;
	    var maxOverlap = body1.deltaAbsY() + body2.deltaAbsY() + bias;

	    if (body1._dy === 0 && body2._dy === 0)
	    {

	        body1.embedded = true;
	        body2.embedded = true;
	    }
	    else if (body1._dy > body2._dy)
	    {

	        overlap = body1.bottom - body2.y;

	        if ((overlap > maxOverlap && !overlapOnly) || body1.checkCollision.down === false || body2.checkCollision.up === false)
	        {
	            overlap = 0;
	        }
	        else
	        {
	            body1.touching.none = false;
	            body1.touching.down = true;

	            body2.touching.none = false;
	            body2.touching.up = true;

	            if (body2.physicsType === CONST.STATIC_BODY && !overlapOnly)
	            {
	                body1.blocked.none = false;
	                body1.blocked.down = true;
	            }

	            if (body1.physicsType === CONST.STATIC_BODY && !overlapOnly)
	            {
	                body2.blocked.none = false;
	                body2.blocked.up = true;
	            }
	        }
	    }
	    else if (body1._dy < body2._dy)
	    {

	        overlap = body1.y - body2.bottom;

	        if ((-overlap > maxOverlap && !overlapOnly) || body1.checkCollision.up === false || body2.checkCollision.down === false)
	        {
	            overlap = 0;
	        }
	        else
	        {
	            body1.touching.none = false;
	            body1.touching.up = true;

	            body2.touching.none = false;
	            body2.touching.down = true;

	            if (body2.physicsType === CONST.STATIC_BODY && !overlapOnly)
	            {
	                body1.blocked.none = false;
	                body1.blocked.up = true;
	            }

	            if (body1.physicsType === CONST.STATIC_BODY && !overlapOnly)
	            {
	                body2.blocked.none = false;
	                body2.blocked.down = true;
	            }
	        }
	    }

	    body1.overlapY = overlap;
	    body2.overlapY = overlap;

	    return overlap;
	};

	GetOverlapY_1 = GetOverlapY;
	return GetOverlapY_1;
}

var GetTilesWithin_1;
var hasRequiredGetTilesWithin;

function requireGetTilesWithin () {
	if (hasRequiredGetTilesWithin) return GetTilesWithin_1;
	hasRequiredGetTilesWithin = 1;
	var GetFastValue = requireGetFastValue();

	var GetTilesWithin = function (tileX, tileY, width, height, filteringOptions, layer)
	{
	    if (tileX === undefined) { tileX = 0; }
	    if (tileY === undefined) { tileY = 0; }
	    if (width === undefined) { width = layer.width; }
	    if (height === undefined) { height = layer.height; }
	    if (!filteringOptions) { filteringOptions = {}; }

	    var isNotEmpty = GetFastValue(filteringOptions, 'isNotEmpty', false);
	    var isColliding = GetFastValue(filteringOptions, 'isColliding', false);
	    var hasInterestingFace = GetFastValue(filteringOptions, 'hasInterestingFace', false);

	    if (tileX < 0)
	    {
	        width += tileX;
	        tileX = 0;
	    }

	    if (tileY < 0)
	    {
	        height += tileY;
	        tileY = 0;
	    }

	    if (tileX + width > layer.width)
	    {
	        width = Math.max(layer.width - tileX, 0);
	    }

	    if (tileY + height > layer.height)
	    {
	        height = Math.max(layer.height - tileY, 0);
	    }

	    var results = [];

	    for (var ty = tileY; ty < tileY + height; ty++)
	    {
	        for (var tx = tileX; tx < tileX + width; tx++)
	        {
	            var tile = layer.data[ty][tx];

	            if (tile !== null)
	            {
	                if (isNotEmpty && tile.index === -1)
	                {
	                    continue;
	                }

	                if (isColliding && !tile.collides)
	                {
	                    continue;
	                }

	                if (hasInterestingFace && !tile.hasInterestingFace)
	                {
	                    continue;
	                }

	                results.push(tile);
	            }
	        }
	    }

	    return results;
	};

	GetTilesWithin_1 = GetTilesWithin;
	return GetTilesWithin_1;
}

var GetTilesWithinWorldXY_1;
var hasRequiredGetTilesWithinWorldXY;

function requireGetTilesWithinWorldXY () {
	if (hasRequiredGetTilesWithinWorldXY) return GetTilesWithinWorldXY_1;
	hasRequiredGetTilesWithinWorldXY = 1;
	var GetTilesWithin = requireGetTilesWithin();
	var Vector2 = requireVector2();

	var pointStart = new Vector2();
	var pointEnd = new Vector2();

	var GetTilesWithinWorldXY = function (worldX, worldY, width, height, filteringOptions, camera, layer)
	{
	    var worldToTileXY = layer.tilemapLayer.tilemap._convert.WorldToTileXY;

	    worldToTileXY(worldX, worldY, true, pointStart, camera, layer);

	    var xStart = pointStart.x;
	    var yStart = pointStart.y;

	    worldToTileXY(worldX + width, worldY + height, false, pointEnd, camera, layer);

	    var xEnd = Math.ceil(pointEnd.x);
	    var yEnd = Math.ceil(pointEnd.y);

	    return GetTilesWithin(xStart, yStart, xEnd - xStart, yEnd - yStart, filteringOptions, layer);
	};

	GetTilesWithinWorldXY_1 = GetTilesWithinWorldXY;
	return GetTilesWithinWorldXY_1;
}

var ProcessTileCallbacks_1;
var hasRequiredProcessTileCallbacks;

function requireProcessTileCallbacks () {
	if (hasRequiredProcessTileCallbacks) return ProcessTileCallbacks_1;
	hasRequiredProcessTileCallbacks = 1;
	var ProcessTileCallbacks = function (tile, sprite)
	{

	    if (tile.collisionCallback)
	    {
	        return !tile.collisionCallback.call(tile.collisionCallbackContext, sprite, tile);
	    }
	    else if (tile.layer.callbacks[tile.index])
	    {
	        return !tile.layer.callbacks[tile.index].callback.call(
	            tile.layer.callbacks[tile.index].callbackContext, sprite, tile
	        );
	    }

	    return true;
	};

	ProcessTileCallbacks_1 = ProcessTileCallbacks;
	return ProcessTileCallbacks_1;
}

var RTree;
var hasRequiredRTree;

function requireRTree () {
	if (hasRequiredRTree) return RTree;
	hasRequiredRTree = 1;
	var quickselect = requireQuickSelect();

	function rbush (maxEntries)
	{

	    if (!(this instanceof rbush)) return new rbush(maxEntries);

	    this._maxEntries = Math.max(4, maxEntries || 9);
	    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));

	    this.clear();
	}

	rbush.prototype = {

	    all: function ()
	    {
	        return this._all(this.data, []);
	    },

	    search: function (bbox)
	    {
	        var node = this.data,
	            result = [],
	            toBBox = this.toBBox;

	        if (!intersects(bbox, node)) return result;

	        var nodesToSearch = [],
	            i, len, child, childBBox;

	        while (node) {
	            for (i = 0, len = node.children.length; i < len; i++) {

	                child = node.children[i];
	                childBBox = node.leaf ? toBBox(child) : child;

	                if (intersects(bbox, childBBox)) {
	                    if (node.leaf) result.push(child);
	                    else if (contains(bbox, childBBox)) this._all(child, result);
	                    else nodesToSearch.push(child);
	                }
	            }
	            node = nodesToSearch.pop();
	        }

	        return result;
	    },

	    collides: function (bbox)
	    {
	        var node = this.data,
	            toBBox = this.toBBox;

	        if (!intersects(bbox, node)) return false;

	        var nodesToSearch = [],
	            i, len, child, childBBox;

	        while (node) {
	            for (i = 0, len = node.children.length; i < len; i++) {

	                child = node.children[i];
	                childBBox = node.leaf ? toBBox(child) : child;

	                if (intersects(bbox, childBBox)) {
	                    if (node.leaf || contains(bbox, childBBox)) return true;
	                    nodesToSearch.push(child);
	                }
	            }
	            node = nodesToSearch.pop();
	        }

	        return false;
	    },

	    load: function (data)
	    {
	        if (!(data && data.length)) return this;

	        if (data.length < this._minEntries) {
	            for (var i = 0, len = data.length; i < len; i++) {
	                this.insert(data[i]);
	            }
	            return this;
	        }

	        var node = this._build(data.slice(), 0, data.length - 1, 0);

	        if (!this.data.children.length) {

	            this.data = node;

	        } else if (this.data.height === node.height) {

	            this._splitRoot(this.data, node);

	        } else {
	            if (this.data.height < node.height) {

	                var tmpNode = this.data;
	                this.data = node;
	                node = tmpNode;
	            }

	            this._insert(node, this.data.height - node.height - 1, true);
	        }

	        return this;
	    },

	    insert: function (item)
	    {
	        if (item) this._insert(item, this.data.height - 1);
	        return this;
	    },

	    clear: function ()
	    {
	        this.data = createNode([]);
	        return this;
	    },

	    remove: function (item, equalsFn)
	    {
	        if (!item) return this;

	        var node = this.data,
	            bbox = this.toBBox(item),
	            path = [],
	            indexes = [],
	            i, parent, index, goingUp;

	        while (node || path.length) {

	            if (!node) { 
	                node = path.pop();
	                parent = path[path.length - 1];
	                i = indexes.pop();
	                goingUp = true;
	            }

	            if (node.leaf) { 
	                index = findItem(item, node.children, equalsFn);

	                if (index !== -1) {

	                    node.children.splice(index, 1);
	                    path.push(node);
	                    this._condense(path);
	                    return this;
	                }
	            }

	            if (!goingUp && !node.leaf && contains(node, bbox)) { 
	                path.push(node);
	                indexes.push(i);
	                i = 0;
	                parent = node;
	                node = node.children[0];

	            } else if (parent) { 
	                i++;
	                node = parent.children[i];
	                goingUp = false;

	            } else node = null; 
	        }

	        return this;
	    },

	    toBBox: function (item) { return item; },

	    compareMinX: compareNodeMinX,
	    compareMinY: compareNodeMinY,

	    toJSON: function () { return this.data; },

	    fromJSON: function (data)
	    {
	        this.data = data;
	        return this;
	    },

	    _all: function (node, result)
	    {
	        var nodesToSearch = [];
	        while (node) {
	            if (node.leaf) result.push.apply(result, node.children);
	            else nodesToSearch.push.apply(nodesToSearch, node.children);

	            node = nodesToSearch.pop();
	        }
	        return result;
	    },

	    _build: function (items, left, right, height)
	    {
	        var N = right - left + 1,
	            M = this._maxEntries,
	            node;

	        if (N <= M) {

	            node = createNode(items.slice(left, right + 1));
	            calcBBox(node, this.toBBox);
	            return node;
	        }

	        if (!height) {

	            height = Math.ceil(Math.log(N) / Math.log(M));

	            M = Math.ceil(N / Math.pow(M, height - 1));
	        }

	        node = createNode([]);
	        node.leaf = false;
	        node.height = height;

	        var N2 = Math.ceil(N / M),
	            N1 = N2 * Math.ceil(Math.sqrt(M)),
	            i, j, right2, right3;

	        multiSelect(items, left, right, N1, this.compareMinX);

	        for (i = left; i <= right; i += N1) {

	            right2 = Math.min(i + N1 - 1, right);

	            multiSelect(items, i, right2, N2, this.compareMinY);

	            for (j = i; j <= right2; j += N2) {

	                right3 = Math.min(j + N2 - 1, right2);

	                node.children.push(this._build(items, j, right3, height - 1));
	            }
	        }

	        calcBBox(node, this.toBBox);

	        return node;
	    },

	    _chooseSubtree: function (bbox, node, level, path)
	    {
	        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;

	        while (true) {
	            path.push(node);

	            if (node.leaf || path.length - 1 === level) break;

	            minArea = minEnlargement = Infinity;

	            for (i = 0, len = node.children.length; i < len; i++) {
	                child = node.children[i];
	                area = bboxArea(child);
	                enlargement = enlargedArea(bbox, child) - area;

	                if (enlargement < minEnlargement) {
	                    minEnlargement = enlargement;
	                    minArea = area < minArea ? area : minArea;
	                    targetNode = child;

	                } else if (enlargement === minEnlargement) {

	                    if (area < minArea) {
	                        minArea = area;
	                        targetNode = child;
	                    }
	                }
	            }

	            node = targetNode || node.children[0];
	        }

	        return node;
	    },

	    _insert: function (item, level, isNode)
	    {
	        var toBBox = this.toBBox,
	            bbox = isNode ? item : toBBox(item),
	            insertPath = [];

	        var node = this._chooseSubtree(bbox, this.data, level, insertPath);

	        node.children.push(item);
	        extend(node, bbox);

	        while (level >= 0) {
	            if (insertPath[level].children.length > this._maxEntries) {
	                this._split(insertPath, level);
	                level--;
	            } else break;
	        }

	        this._adjustParentBBoxes(bbox, insertPath, level);
	    },

	    _split: function (insertPath, level)
	    {
	        var node = insertPath[level],
	            M = node.children.length,
	            m = this._minEntries;

	        this._chooseSplitAxis(node, m, M);

	        var splitIndex = this._chooseSplitIndex(node, m, M);

	        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
	        newNode.height = node.height;
	        newNode.leaf = node.leaf;

	        calcBBox(node, this.toBBox);
	        calcBBox(newNode, this.toBBox);

	        if (level) insertPath[level - 1].children.push(newNode);
	        else this._splitRoot(node, newNode);
	    },

	    _splitRoot: function (node, newNode)
	    {

	        this.data = createNode([node, newNode]);
	        this.data.height = node.height + 1;
	        this.data.leaf = false;
	        calcBBox(this.data, this.toBBox);
	    },

	    _chooseSplitIndex: function (node, m, M)
	    {
	        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;

	        minOverlap = minArea = Infinity;

	        for (i = m; i <= M - m; i++) {
	            bbox1 = distBBox(node, 0, i, this.toBBox);
	            bbox2 = distBBox(node, i, M, this.toBBox);

	            overlap = intersectionArea(bbox1, bbox2);
	            area = bboxArea(bbox1) + bboxArea(bbox2);

	            if (overlap < minOverlap) {
	                minOverlap = overlap;
	                index = i;

	                minArea = area < minArea ? area : minArea;

	            } else if (overlap === minOverlap) {

	                if (area < minArea) {
	                    minArea = area;
	                    index = i;
	                }
	            }
	        }

	        return index;
	    },

	    _chooseSplitAxis: function (node, m, M)
	    {
	        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,
	            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,
	            xMargin = this._allDistMargin(node, m, M, compareMinX),
	            yMargin = this._allDistMargin(node, m, M, compareMinY);

	        if (xMargin < yMargin) node.children.sort(compareMinX);
	    },

	    _allDistMargin: function (node, m, M, compare)
	    {
	        node.children.sort(compare);

	        var toBBox = this.toBBox,
	            leftBBox = distBBox(node, 0, m, toBBox),
	            rightBBox = distBBox(node, M - m, M, toBBox),
	            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),
	            i, child;

	        for (i = m; i < M - m; i++) {
	            child = node.children[i];
	            extend(leftBBox, node.leaf ? toBBox(child) : child);
	            margin += bboxMargin(leftBBox);
	        }

	        for (i = M - m - 1; i >= m; i--) {
	            child = node.children[i];
	            extend(rightBBox, node.leaf ? toBBox(child) : child);
	            margin += bboxMargin(rightBBox);
	        }

	        return margin;
	    },

	    _adjustParentBBoxes: function (bbox, path, level)
	    {

	        for (var i = level; i >= 0; i--) {
	            extend(path[i], bbox);
	        }
	    },

	    _condense: function (path)
	    {

	        for (var i = path.length - 1, siblings; i >= 0; i--) {
	            if (path[i].children.length === 0) {
	                if (i > 0) {
	                    siblings = path[i - 1].children;
	                    siblings.splice(siblings.indexOf(path[i]), 1);

	                } else this.clear();

	            } else calcBBox(path[i], this.toBBox);
	        }
	    },

	    compareMinX: function (a, b)
	    {
	        return a.left - b.left;
	    },

	    compareMinY: function (a, b)
	    {
	        return a.top - b.top;
	    },

	    toBBox: function (a)
	    {
	        return {
	            minX: a.left,
	            minY: a.top,
	            maxX: a.right,
	            maxY: a.bottom
	        };
	    }
	};

	function findItem (item, items, equalsFn)
	{
	    if (!equalsFn) return items.indexOf(item);

	    for (var i = 0; i < items.length; i++) {
	        if (equalsFn(item, items[i])) return i;
	    }
	    return -1;
	}

	function calcBBox (node, toBBox)
	{
	    distBBox(node, 0, node.children.length, toBBox, node);
	}

	function distBBox (node, k, p, toBBox, destNode)
	{
	    if (!destNode) destNode = createNode(null);
	    destNode.minX = Infinity;
	    destNode.minY = Infinity;
	    destNode.maxX = -Infinity;
	    destNode.maxY = -Infinity;

	    for (var i = k, child; i < p; i++) {
	        child = node.children[i];
	        extend(destNode, node.leaf ? toBBox(child) : child);
	    }

	    return destNode;
	}

	function extend (a, b)
	{
	    a.minX = Math.min(a.minX, b.minX);
	    a.minY = Math.min(a.minY, b.minY);
	    a.maxX = Math.max(a.maxX, b.maxX);
	    a.maxY = Math.max(a.maxY, b.maxY);
	    return a;
	}

	function compareNodeMinX (a, b) { return a.minX - b.minX; }
	function compareNodeMinY (a, b) { return a.minY - b.minY; }

	function bboxArea (a) { return (a.maxX - a.minX) * (a.maxY - a.minY); }
	function bboxMargin (a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }

	function enlargedArea (a, b)
	{
	    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *
	           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
	}

	function intersectionArea (a, b)
	{
	    var minX = Math.max(a.minX, b.minX),
	        minY = Math.max(a.minY, b.minY),
	        maxX = Math.min(a.maxX, b.maxX),
	        maxY = Math.min(a.maxY, b.maxY);

	    return Math.max(0, maxX - minX) *
	           Math.max(0, maxY - minY);
	}

	function contains (a, b)
	{
	    return a.minX <= b.minX &&
	           a.minY <= b.minY &&
	           b.maxX <= a.maxX &&
	           b.maxY <= a.maxY;
	}

	function intersects (a, b)
	{
	    return b.minX <= a.maxX &&
	           b.minY <= a.maxY &&
	           b.maxX >= a.minX &&
	           b.maxY >= a.minY;
	}

	function createNode (children)
	{
	    return {
	        children: children,
	        height: 1,
	        leaf: true,
	        minX: Infinity,
	        minY: Infinity,
	        maxX: -Infinity,
	        maxY: -Infinity
	    };
	}

	function multiSelect (arr, left, right, n, compare)
	{
	    var stack = [left, right],
	        mid;

	    while (stack.length)
	    {
	        right = stack.pop();
	        left = stack.pop();

	        if (right - left <= n) continue;

	        mid = left + Math.ceil((right - left) / n / 2) * n;
	        quickselect(arr, mid, left, right, compare);

	        stack.push(left, mid, mid, right);
	    }
	}

	RTree = rbush;
	return RTree;
}

var ProcessTileSeparationX_1;
var hasRequiredProcessTileSeparationX;

function requireProcessTileSeparationX () {
	if (hasRequiredProcessTileSeparationX) return ProcessTileSeparationX_1;
	hasRequiredProcessTileSeparationX = 1;
	var ProcessTileSeparationX = function (body, x)
	{
	    if (x < 0)
	    {
	        body.blocked.none = false;
	        body.blocked.left = true;
	    }
	    else if (x > 0)
	    {
	        body.blocked.none = false;
	        body.blocked.right = true;
	    }

	    body.position.x -= x;
	    body.updateCenter();

	    if (body.bounce.x === 0)
	    {
	        body.velocity.x = 0;
	    }
	    else
	    {
	        body.velocity.x = -body.velocity.x * body.bounce.x;
	    }
	};

	ProcessTileSeparationX_1 = ProcessTileSeparationX;
	return ProcessTileSeparationX_1;
}

var TileCheckX_1;
var hasRequiredTileCheckX;

function requireTileCheckX () {
	if (hasRequiredTileCheckX) return TileCheckX_1;
	hasRequiredTileCheckX = 1;
	var ProcessTileSeparationX = requireProcessTileSeparationX();

	var TileCheckX = function (body, tile, tileLeft, tileRight, tileBias, isLayer)
	{
	    var ox = 0;

	    var faceLeft = tile.faceLeft;
	    var faceRight = tile.faceRight;
	    var collideLeft = tile.collideLeft;
	    var collideRight = tile.collideRight;

	    if (!isLayer)
	    {
	        faceLeft = true;
	        faceRight = true;
	        collideLeft = true;
	        collideRight = true;
	    }

	    if (body.deltaX() < 0 && collideRight && body.checkCollision.left)
	    {

	        if (faceRight && body.x < tileRight)
	        {
	            ox = body.x - tileRight;

	            if (ox < -tileBias)
	            {
	                ox = 0;
	            }
	        }
	    }
	    else if (body.deltaX() > 0 && collideLeft && body.checkCollision.right)
	    {

	        if (faceLeft && body.right > tileLeft)
	        {
	            ox = body.right - tileLeft;

	            if (ox > tileBias)
	            {
	                ox = 0;
	            }
	        }
	    }

	    if (ox !== 0)
	    {
	        if (body.customSeparateX)
	        {
	            body.overlapX = ox;
	        }
	        else
	        {
	            ProcessTileSeparationX(body, ox);
	        }
	    }

	    return ox;
	};

	TileCheckX_1 = TileCheckX;
	return TileCheckX_1;
}

var ProcessTileSeparationY_1;
var hasRequiredProcessTileSeparationY;

function requireProcessTileSeparationY () {
	if (hasRequiredProcessTileSeparationY) return ProcessTileSeparationY_1;
	hasRequiredProcessTileSeparationY = 1;
	var ProcessTileSeparationY = function (body, y)
	{
	    if (y < 0)
	    {
	        body.blocked.none = false;
	        body.blocked.up = true;
	    }
	    else if (y > 0)
	    {
	        body.blocked.none = false;
	        body.blocked.down = true;
	    }

	    body.position.y -= y;
	    body.updateCenter();

	    if (body.bounce.y === 0)
	    {
	        body.velocity.y = 0;
	    }
	    else
	    {
	        body.velocity.y = -body.velocity.y * body.bounce.y;
	    }
	};

	ProcessTileSeparationY_1 = ProcessTileSeparationY;
	return ProcessTileSeparationY_1;
}

var TileCheckY_1;
var hasRequiredTileCheckY;

function requireTileCheckY () {
	if (hasRequiredTileCheckY) return TileCheckY_1;
	hasRequiredTileCheckY = 1;
	var ProcessTileSeparationY = requireProcessTileSeparationY();

	var TileCheckY = function (body, tile, tileTop, tileBottom, tileBias, isLayer)
	{
	    var oy = 0;

	    var faceTop = tile.faceTop;
	    var faceBottom = tile.faceBottom;
	    var collideUp = tile.collideUp;
	    var collideDown = tile.collideDown;

	    if (!isLayer)
	    {
	        faceTop = true;
	        faceBottom = true;
	        collideUp = true;
	        collideDown = true;
	    }

	    if (body.deltaY() < 0 && collideDown && body.checkCollision.up)
	    {

	        if (faceBottom && body.y < tileBottom)
	        {
	            oy = body.y - tileBottom;

	            if (oy < -tileBias)
	            {
	                oy = 0;
	            }
	        }
	    }
	    else if (body.deltaY() > 0 && collideUp && body.checkCollision.down)
	    {

	        if (faceTop && body.bottom > tileTop)
	        {
	            oy = body.bottom - tileTop;

	            if (oy > tileBias)
	            {
	                oy = 0;
	            }
	        }
	    }

	    if (oy !== 0)
	    {
	        if (body.customSeparateY)
	        {
	            body.overlapY = oy;
	        }
	        else
	        {
	            ProcessTileSeparationY(body, oy);
	        }
	    }

	    return oy;
	};

	TileCheckY_1 = TileCheckY;
	return TileCheckY_1;
}

var TileIntersectsBody_1;
var hasRequiredTileIntersectsBody;

function requireTileIntersectsBody () {
	if (hasRequiredTileIntersectsBody) return TileIntersectsBody_1;
	hasRequiredTileIntersectsBody = 1;
	var TileIntersectsBody = function (tileWorldRect, body)
	{

	    return !(
	        body.right <= tileWorldRect.left ||
	        body.bottom <= tileWorldRect.top ||
	        body.position.x >= tileWorldRect.right ||
	        body.position.y >= tileWorldRect.bottom
	    );
	};

	TileIntersectsBody_1 = TileIntersectsBody;
	return TileIntersectsBody_1;
}

var SeparateTile_1;
var hasRequiredSeparateTile;

function requireSeparateTile () {
	if (hasRequiredSeparateTile) return SeparateTile_1;
	hasRequiredSeparateTile = 1;
	var TileCheckX = requireTileCheckX();
	var TileCheckY = requireTileCheckY();
	var TileIntersectsBody = requireTileIntersectsBody();

	var SeparateTile = function (i, body, tile, tileWorldRect, tilemapLayer, tileBias, isLayer)
	{
	    var tileLeft = tileWorldRect.left;
	    var tileTop = tileWorldRect.top;
	    var tileRight = tileWorldRect.right;
	    var tileBottom = tileWorldRect.bottom;
	    var faceHorizontal = tile.faceLeft || tile.faceRight;
	    var faceVertical = tile.faceTop || tile.faceBottom;

	    if (!isLayer)
	    {
	        faceHorizontal = true;
	        faceVertical = true;
	    }

	    if (!faceHorizontal && !faceVertical)
	    {
	        return false;
	    }

	    var ox = 0;
	    var oy = 0;
	    var minX = 0;
	    var minY = 1;

	    if (body.deltaAbsX() > body.deltaAbsY())
	    {

	        minX = -1;
	    }
	    else if (body.deltaAbsX() < body.deltaAbsY())
	    {

	        minY = -1;
	    }

	    if (body.deltaX() !== 0 && body.deltaY() !== 0 && faceHorizontal && faceVertical)
	    {

	        minX = Math.min(Math.abs(body.position.x - tileRight), Math.abs(body.right - tileLeft));
	        minY = Math.min(Math.abs(body.position.y - tileBottom), Math.abs(body.bottom - tileTop));
	    }

	    if (minX < minY)
	    {
	        if (faceHorizontal)
	        {
	            ox = TileCheckX(body, tile, tileLeft, tileRight, tileBias, isLayer);

	            if (ox !== 0 && !TileIntersectsBody(tileWorldRect, body))
	            {
	                return true;
	            }
	        }

	        if (faceVertical)
	        {
	            oy = TileCheckY(body, tile, tileTop, tileBottom, tileBias, isLayer);
	        }
	    }
	    else
	    {
	        if (faceVertical)
	        {
	            oy = TileCheckY(body, tile, tileTop, tileBottom, tileBias, isLayer);

	            if (oy !== 0 && !TileIntersectsBody(tileWorldRect, body))
	            {
	                return true;
	            }
	        }

	        if (faceHorizontal)
	        {
	            ox = TileCheckX(body, tile, tileLeft, tileRight, tileBias, isLayer);
	        }
	    }

	    return (ox !== 0 || oy !== 0);
	};

	SeparateTile_1 = SeparateTile;
	return SeparateTile_1;
}

var ProcessX;
var hasRequiredProcessX;

function requireProcessX () {
	if (hasRequiredProcessX) return ProcessX;
	hasRequiredProcessX = 1;
	var body1;
	var body2;
	var body1Pushable;
	var body2Pushable;
	var body1MassImpact;
	var body2MassImpact;
	var body1FullImpact;
	var body2FullImpact;
	var body1MovingLeft;
	var body1MovingRight;
	var body1Stationary;
	var body2MovingLeft;
	var body2MovingRight;
	var body2Stationary;
	var body1OnLeft;
	var body2OnLeft;
	var overlap;

	var Set = function (b1, b2, ov)
	{
	    body1 = b1;
	    body2 = b2;

	    var v1 = body1.velocity.x;
	    var v2 = body2.velocity.x;

	    body1Pushable = body1.pushable;
	    body1MovingLeft = body1._dx < 0;
	    body1MovingRight = body1._dx > 0;
	    body1Stationary = body1._dx === 0;
	    body1OnLeft = Math.abs(body1.right - body2.x) <= Math.abs(body2.right - body1.x);
	    body1FullImpact = v2 - v1 * body1.bounce.x;

	    body2Pushable = body2.pushable;
	    body2MovingLeft = body2._dx < 0;
	    body2MovingRight = body2._dx > 0;
	    body2Stationary = body2._dx === 0;
	    body2OnLeft = !body1OnLeft;
	    body2FullImpact = v1 - v2 * body2.bounce.x;

	    overlap = Math.abs(ov);

	    return BlockCheck();
	};

	var BlockCheck = function ()
	{

	    if (body1MovingRight && body1OnLeft && body2.blocked.right)
	    {
	        body1.processX(-overlap, body1FullImpact, false, true);

	        return 1;
	    }

	    if (body1MovingLeft && body2OnLeft && body2.blocked.left)
	    {
	        body1.processX(overlap, body1FullImpact, true);

	        return 1;
	    }

	    if (body2MovingRight && body2OnLeft && body1.blocked.right)
	    {
	        body2.processX(-overlap, body2FullImpact, false, true);

	        return 2;
	    }

	    if (body2MovingLeft && body1OnLeft && body1.blocked.left)
	    {
	        body2.processX(overlap, body2FullImpact, true);

	        return 2;
	    }

	    return 0;
	};

	var Check = function ()
	{
	    var v1 = body1.velocity.x;
	    var v2 = body2.velocity.x;

	    var nv1 = Math.sqrt((v2 * v2 * body2.mass) / body1.mass) * ((v2 > 0) ? 1 : -1);
	    var nv2 = Math.sqrt((v1 * v1 * body1.mass) / body2.mass) * ((v1 > 0) ? 1 : -1);
	    var avg = (nv1 + nv2) * 0.5;

	    nv1 -= avg;
	    nv2 -= avg;

	    body1MassImpact = avg + nv1 * body1.bounce.x;
	    body2MassImpact = avg + nv2 * body2.bounce.x;

	    if (body1MovingLeft && body2OnLeft)
	    {
	        return Run(0);
	    }

	    if (body2MovingLeft && body1OnLeft)
	    {
	        return Run(1);
	    }

	    if (body1MovingRight && body1OnLeft)
	    {
	        return Run(2);
	    }

	    if (body2MovingRight && body2OnLeft)
	    {
	        return Run(3);
	    }

	    return false;
	};

	var Run = function (side)
	{
	    if (body1Pushable && body2Pushable)
	    {

	        overlap *= 0.5;

	        if (side === 0 || side === 3)
	        {

	            body1.processX(overlap, body1MassImpact);
	            body2.processX(-overlap, body2MassImpact);
	        }
	        else
	        {

	            body1.processX(-overlap, body1MassImpact);
	            body2.processX(overlap, body2MassImpact);
	        }
	    }
	    else if (body1Pushable && !body2Pushable)
	    {

	        if (side === 0 || side === 3)
	        {

	            body1.processX(overlap, body1FullImpact, true);
	        }
	        else
	        {

	            body1.processX(-overlap, body1FullImpact, false, true);
	        }
	    }
	    else if (!body1Pushable && body2Pushable)
	    {

	        if (side === 0 || side === 3)
	        {

	            body2.processX(-overlap, body2FullImpact, false, true);
	        }
	        else
	        {

	            body2.processX(overlap, body2FullImpact, true);
	        }
	    }
	    else
	    {

	        var halfOverlap = overlap * 0.5;

	        if (side === 0)
	        {

	            if (body2Stationary)
	            {
	                body1.processX(overlap, 0, true);
	                body2.processX(0, null, false, true);
	            }
	            else if (body2MovingRight)
	            {
	                body1.processX(halfOverlap, 0, true);
	                body2.processX(-halfOverlap, 0, false, true);
	            }
	            else
	            {

	                body1.processX(halfOverlap, body2.velocity.x, true);
	                body2.processX(-halfOverlap, null, false, true);
	            }
	        }
	        else if (side === 1)
	        {

	            if (body1Stationary)
	            {
	                body1.processX(0, null, false, true);
	                body2.processX(overlap, 0, true);
	            }
	            else if (body1MovingRight)
	            {
	                body1.processX(-halfOverlap, 0, false, true);
	                body2.processX(halfOverlap, 0, true);
	            }
	            else
	            {

	                body1.processX(-halfOverlap, null, false, true);
	                body2.processX(halfOverlap, body1.velocity.x, true);
	            }
	        }
	        else if (side === 2)
	        {

	            if (body2Stationary)
	            {
	                body1.processX(-overlap, 0, false, true);
	                body2.processX(0, null, true);
	            }
	            else if (body2MovingLeft)
	            {
	                body1.processX(-halfOverlap, 0, false, true);
	                body2.processX(halfOverlap, 0, true);
	            }
	            else
	            {

	                body1.processX(-halfOverlap, body2.velocity.x, false, true);
	                body2.processX(halfOverlap, null, true);
	            }
	        }
	        else if (side === 3)
	        {

	            if (body1Stationary)
	            {
	                body1.processX(0, null, true);
	                body2.processX(-overlap, 0, false, true);
	            }
	            else if (body1MovingLeft)
	            {
	                body1.processX(halfOverlap, 0, true);
	                body2.processX(-halfOverlap, 0, false, true);
	            }
	            else
	            {

	                body1.processX(halfOverlap, body2.velocity.y, true);
	                body2.processX(-halfOverlap, null, false, true);
	            }
	        }
	    }

	    return true;
	};

	var RunImmovableBody1 = function (blockedState)
	{
	    if (blockedState === 1)
	    {

	        body2.velocity.x = 0;
	    }
	    else if (body1OnLeft)
	    {
	        body2.processX(overlap, body2FullImpact, true);
	    }
	    else
	    {
	        body2.processX(-overlap, body2FullImpact, false, true);
	    }

	    if (body1.moves)
	    {
	        var body1Distance = body1.directControl ? (body1.y - body1.autoFrame.y) : (body1.y - body1.prev.y);

	        body2.y += body1Distance * body1.friction.y;
	        body2._dy = body2.y - body2.prev.y;
	    }
	};

	var RunImmovableBody2 = function (blockedState)
	{
	    if (blockedState === 2)
	    {

	        body1.velocity.x = 0;
	    }
	    else if (body2OnLeft)
	    {
	        body1.processX(overlap, body1FullImpact, true);
	    }
	    else
	    {
	        body1.processX(-overlap, body1FullImpact, false, true);
	    }

	    if (body2.moves)
	    {
	        var body2Distance = body2.directControl ? (body2.y - body2.autoFrame.y) : (body2.y - body2.prev.y);

	        body1.y += body2Distance * body2.friction.y;
	        body1._dy = body1.y - body1.prev.y;
	    }
	};

	ProcessX = {
	    BlockCheck: BlockCheck,
	    Check: Check,
	    Set: Set,
	    Run: Run,
	    RunImmovableBody1: RunImmovableBody1,
	    RunImmovableBody2: RunImmovableBody2
	};
	return ProcessX;
}

var SeparateX_1;
var hasRequiredSeparateX;

function requireSeparateX () {
	if (hasRequiredSeparateX) return SeparateX_1;
	hasRequiredSeparateX = 1;
	var GetOverlapX = requireGetOverlapX();
	var ProcessX = requireProcessX();

	var SeparateX = function (body1, body2, overlapOnly, bias, overlap)
	{
	    if (overlap === undefined) { overlap = GetOverlapX(body1, body2, overlapOnly, bias); }

	    var body1Immovable = body1.immovable;
	    var body2Immovable = body2.immovable;

	    if (overlapOnly || overlap === 0 || (body1Immovable && body2Immovable) || body1.customSeparateX || body2.customSeparateX)
	    {

	        return (overlap !== 0) || (body1.embedded && body2.embedded);
	    }

	    var blockedState = ProcessX.Set(body1, body2, overlap);

	    if (!body1Immovable && !body2Immovable)
	    {
	        if (blockedState > 0)
	        {
	            return true;
	        }

	        return ProcessX.Check();
	    }
	    else if (body1Immovable)
	    {
	        ProcessX.RunImmovableBody1(blockedState);
	    }
	    else if (body2Immovable)
	    {
	        ProcessX.RunImmovableBody2(blockedState);
	    }

	    return true;
	};

	SeparateX_1 = SeparateX;
	return SeparateX_1;
}

var ProcessY;
var hasRequiredProcessY;

function requireProcessY () {
	if (hasRequiredProcessY) return ProcessY;
	hasRequiredProcessY = 1;
	var body1;
	var body2;
	var body1Pushable;
	var body2Pushable;
	var body1MassImpact;
	var body2MassImpact;
	var body1FullImpact;
	var body2FullImpact;
	var body1MovingUp;
	var body1MovingDown;
	var body1Stationary;
	var body2MovingUp;
	var body2MovingDown;
	var body2Stationary;
	var body1OnTop;
	var body2OnTop;
	var overlap;

	var Set = function (b1, b2, ov)
	{
	    body1 = b1;
	    body2 = b2;

	    var v1 = body1.velocity.y;
	    var v2 = body2.velocity.y;

	    body1Pushable = body1.pushable;
	    body1MovingUp = body1._dy < 0;
	    body1MovingDown = body1._dy > 0;
	    body1Stationary = body1._dy === 0;
	    body1OnTop = Math.abs(body1.bottom - body2.y) <= Math.abs(body2.bottom - body1.y);
	    body1FullImpact = v2 - v1 * body1.bounce.y;

	    body2Pushable = body2.pushable;
	    body2MovingUp = body2._dy < 0;
	    body2MovingDown = body2._dy > 0;
	    body2Stationary = body2._dy === 0;
	    body2OnTop = !body1OnTop;
	    body2FullImpact = v1 - v2 * body2.bounce.y;

	    overlap = Math.abs(ov);

	    return BlockCheck();
	};

	var BlockCheck = function ()
	{

	    if (body1MovingDown && body1OnTop && body2.blocked.down)
	    {
	        body1.processY(-overlap, body1FullImpact, false, true);

	        return 1;
	    }

	    if (body1MovingUp && body2OnTop && body2.blocked.up)
	    {
	        body1.processY(overlap, body1FullImpact, true);

	        return 1;
	    }

	    if (body2MovingDown && body2OnTop && body1.blocked.down)
	    {
	        body2.processY(-overlap, body2FullImpact, false, true);

	        return 2;
	    }

	    if (body2MovingUp && body1OnTop && body1.blocked.up)
	    {
	        body2.processY(overlap, body2FullImpact, true);

	        return 2;
	    }

	    return 0;
	};

	var Check = function ()
	{
	    var v1 = body1.velocity.y;
	    var v2 = body2.velocity.y;

	    var nv1 = Math.sqrt((v2 * v2 * body2.mass) / body1.mass) * ((v2 > 0) ? 1 : -1);
	    var nv2 = Math.sqrt((v1 * v1 * body1.mass) / body2.mass) * ((v1 > 0) ? 1 : -1);
	    var avg = (nv1 + nv2) * 0.5;

	    nv1 -= avg;
	    nv2 -= avg;

	    body1MassImpact = avg + nv1 * body1.bounce.y;
	    body2MassImpact = avg + nv2 * body2.bounce.y;

	    if (body1MovingUp && body2OnTop)
	    {
	        return Run(0);
	    }

	    if (body2MovingUp && body1OnTop)
	    {
	        return Run(1);
	    }

	    if (body1MovingDown && body1OnTop)
	    {
	        return Run(2);
	    }

	    if (body2MovingDown && body2OnTop)
	    {
	        return Run(3);
	    }

	    return false;
	};

	var Run = function (side)
	{
	    if (body1Pushable && body2Pushable)
	    {

	        overlap *= 0.5;

	        if (side === 0 || side === 3)
	        {

	            body1.processY(overlap, body1MassImpact);
	            body2.processY(-overlap, body2MassImpact);
	        }
	        else
	        {

	            body1.processY(-overlap, body1MassImpact);
	            body2.processY(overlap, body2MassImpact);
	        }
	    }
	    else if (body1Pushable && !body2Pushable)
	    {

	        if (side === 0 || side === 3)
	        {

	            body1.processY(overlap, body1FullImpact, true);
	        }
	        else
	        {

	            body1.processY(-overlap, body1FullImpact, false, true);
	        }
	    }
	    else if (!body1Pushable && body2Pushable)
	    {

	        if (side === 0 || side === 3)
	        {

	            body2.processY(-overlap, body2FullImpact, false, true);
	        }
	        else
	        {

	            body2.processY(overlap, body2FullImpact, true);
	        }
	    }
	    else
	    {

	        var halfOverlap = overlap * 0.5;

	        if (side === 0)
	        {

	            if (body2Stationary)
	            {
	                body1.processY(overlap, 0, true);
	                body2.processY(0, null, false, true);
	            }
	            else if (body2MovingDown)
	            {
	                body1.processY(halfOverlap, 0, true);
	                body2.processY(-halfOverlap, 0, false, true);
	            }
	            else
	            {

	                body1.processY(halfOverlap, body2.velocity.y, true);
	                body2.processY(-halfOverlap, null, false, true);
	            }
	        }
	        else if (side === 1)
	        {

	            if (body1Stationary)
	            {
	                body1.processY(0, null, false, true);
	                body2.processY(overlap, 0, true);
	            }
	            else if (body1MovingDown)
	            {
	                body1.processY(-halfOverlap, 0, false, true);
	                body2.processY(halfOverlap, 0, true);
	            }
	            else
	            {

	                body1.processY(-halfOverlap, null, false, true);
	                body2.processY(halfOverlap, body1.velocity.y, true);
	            }
	        }
	        else if (side === 2)
	        {

	            if (body2Stationary)
	            {
	                body1.processY(-overlap, 0, false, true);
	                body2.processY(0, null, true);
	            }
	            else if (body2MovingUp)
	            {
	                body1.processY(-halfOverlap, 0, false, true);
	                body2.processY(halfOverlap, 0, true);
	            }
	            else
	            {

	                body1.processY(-halfOverlap, body2.velocity.y, false, true);
	                body2.processY(halfOverlap, null, true);
	            }
	        }
	        else if (side === 3)
	        {

	            if (body1Stationary)
	            {
	                body1.processY(0, null, true);
	                body2.processY(-overlap, 0, false, true);
	            }
	            else if (body1MovingUp)
	            {
	                body1.processY(halfOverlap, 0, true);
	                body2.processY(-halfOverlap, 0, false, true);
	            }
	            else
	            {

	                body1.processY(halfOverlap, body2.velocity.y, true);
	                body2.processY(-halfOverlap, null, false, true);
	            }
	        }
	    }

	    return true;
	};

	var RunImmovableBody1 = function (blockedState)
	{
	    if (blockedState === 1)
	    {

	        body2.velocity.y = 0;
	    }
	    else if (body1OnTop)
	    {
	        body2.processY(overlap, body2FullImpact, true);
	    }
	    else
	    {
	        body2.processY(-overlap, body2FullImpact, false, true);
	    }

	    if (body1.moves)
	    {
	        var body1Distance = body1.directControl ? (body1.x - body1.autoFrame.x) : (body1.x - body1.prev.x);

	        body2.x += body1Distance * body1.friction.x;
	        body2._dx = body2.x - body2.prev.x;
	    }
	};

	var RunImmovableBody2 = function (blockedState)
	{
	    if (blockedState === 2)
	    {

	        body1.velocity.y = 0;
	    }
	    else if (body2OnTop)
	    {
	        body1.processY(overlap, body1FullImpact, true);
	    }
	    else
	    {
	        body1.processY(-overlap, body1FullImpact, false, true);
	    }

	    if (body2.moves)
	    {
	        var body2Distance = body2.directControl ? (body2.x - body2.autoFrame.x) : (body2.x - body2.prev.x);

	        body1.x += body2Distance * body2.friction.x;
	        body1._dx = body1.x - body1.prev.x;
	    }
	};

	ProcessY = {
	    BlockCheck: BlockCheck,
	    Check: Check,
	    Set: Set,
	    Run: Run,
	    RunImmovableBody1: RunImmovableBody1,
	    RunImmovableBody2: RunImmovableBody2
	};
	return ProcessY;
}

var SeparateY_1;
var hasRequiredSeparateY;

function requireSeparateY () {
	if (hasRequiredSeparateY) return SeparateY_1;
	hasRequiredSeparateY = 1;
	var GetOverlapY = requireGetOverlapY();
	var ProcessY = requireProcessY();

	var SeparateY = function (body1, body2, overlapOnly, bias, overlap)
	{
	    if (overlap === undefined) { overlap = GetOverlapY(body1, body2, overlapOnly, bias); }

	    var body1Immovable = body1.immovable;
	    var body2Immovable = body2.immovable;

	    if (overlapOnly || overlap === 0 || (body1Immovable && body2Immovable) || body1.customSeparateY || body2.customSeparateY)
	    {

	        return (overlap !== 0) || (body1.embedded && body2.embedded);
	    }

	    var blockedState = ProcessY.Set(body1, body2, overlap);

	    if (!body1Immovable && !body2Immovable)
	    {
	        if (blockedState > 0)
	        {
	            return true;
	        }

	        return ProcessY.Check();
	    }
	    else if (body1Immovable)
	    {
	        ProcessY.RunImmovableBody1(blockedState);
	    }
	    else if (body2Immovable)
	    {
	        ProcessY.RunImmovableBody2(blockedState);
	    }

	    return true;
	};

	SeparateY_1 = SeparateY;
	return SeparateY_1;
}

var World_1;
var hasRequiredWorld;

function requireWorld () {
	if (hasRequiredWorld) return World_1;
	hasRequiredWorld = 1;
	var AngleBetweenPoints = requireBetweenPoints();
	var Body = requireBody();
	var Clamp = requireClamp();
	var Class = requireClass();
	var Collider = requireCollider();
	var CONST = require_const$2();
	var DistanceBetween = requireDistanceBetween();
	var DistanceBetweenPoints = requireDistanceBetweenPoints();
	var EventEmitter = requireEventemitter3();
	var Events = requireEvents$2();
	var FuzzyEqual = requireEqual();
	var FuzzyGreaterThan = requireGreaterThan();
	var FuzzyLessThan = requireLessThan();
	var GetOverlapX = requireGetOverlapX();
	var GetOverlapY = requireGetOverlapY();
	var GetTilesWithinWorldXY = requireGetTilesWithinWorldXY();
	var GetValue = requireGetValue();
	var MATH_CONST = require_const$c();
	var ProcessQueue = requireProcessQueue();
	var ProcessTileCallbacks = requireProcessTileCallbacks();
	var Rectangle = requireRectangle$2();
	var RTree = requireRTree();
	var SeparateTile = requireSeparateTile();
	var SeparateX = requireSeparateX();
	var SeparateY = requireSeparateY();
	var Set = require_Set();
	var StaticBody = requireStaticBody();
	var TileIntersectsBody = requireTileIntersectsBody();
	var TransformMatrix = requireTransformMatrix();
	var Vector2 = requireVector2();
	var Wrap = requireWrap$1();

	var World = new Class({

	    Extends: EventEmitter,

	    initialize:

	    function World (scene, config)
	    {
	        EventEmitter.call(this);

	        this.scene = scene;

	        this.bodies = new Set();

	        this.staticBodies = new Set();

	        this.pendingDestroy = new Set();

	        this.colliders = new ProcessQueue();

	        this.gravity = new Vector2(GetValue(config, 'gravity.x', 0), GetValue(config, 'gravity.y', 0));

	        this.bounds = new Rectangle(
	            GetValue(config, 'x', 0),
	            GetValue(config, 'y', 0),
	            GetValue(config, 'width', scene.sys.scale.width),
	            GetValue(config, 'height', scene.sys.scale.height)
	        );

	        this.checkCollision = {
	            up: GetValue(config, 'checkCollision.up', true),
	            down: GetValue(config, 'checkCollision.down', true),
	            left: GetValue(config, 'checkCollision.left', true),
	            right: GetValue(config, 'checkCollision.right', true)
	        };

	        this.fps = GetValue(config, 'fps', 60);

	        this.fixedStep = GetValue(config, 'fixedStep', true);

	        this._elapsed = 0;

	        this._frameTime = 1 / this.fps;

	        this._frameTimeMS = 1000 * this._frameTime;

	        this.stepsLastFrame = 0;

	        this.timeScale = GetValue(config, 'timeScale', 1);

	        this.OVERLAP_BIAS = GetValue(config, 'overlapBias', 4);

	        this.TILE_BIAS = GetValue(config, 'tileBias', 16);

	        this.forceX = GetValue(config, 'forceX', false);

	        this.isPaused = GetValue(config, 'isPaused', false);

	        this._total = 0;

	        this.drawDebug = GetValue(config, 'debug', false);

	        this.debugGraphic;

	        this.defaults = {
	            debugShowBody: GetValue(config, 'debugShowBody', true),
	            debugShowStaticBody: GetValue(config, 'debugShowStaticBody', true),
	            debugShowVelocity: GetValue(config, 'debugShowVelocity', true),
	            bodyDebugColor: GetValue(config, 'debugBodyColor', 0xff00ff),
	            staticBodyDebugColor: GetValue(config, 'debugStaticBodyColor', 0x0000ff),
	            velocityDebugColor: GetValue(config, 'debugVelocityColor', 0x00ff00)
	        };

	        this.maxEntries = GetValue(config, 'maxEntries', 16);

	        this.useTree = GetValue(config, 'useTree', true);

	        this.tree = new RTree(this.maxEntries);

	        this.staticTree = new RTree(this.maxEntries);

	        this.treeMinMax = { minX: 0, minY: 0, maxX: 0, maxY: 0 };

	        this._tempMatrix = new TransformMatrix();

	        this._tempMatrix2 = new TransformMatrix();

	        this.tileFilterOptions = { isColliding: true, isNotEmpty: true, hasInterestingFace: true };

	        if (this.drawDebug)
	        {
	            this.createDebugGraphic();
	        }
	    },

	    enable: function (object, bodyType)
	    {
	        if (bodyType === undefined) { bodyType = CONST.DYNAMIC_BODY; }

	        if (!Array.isArray(object))
	        {
	            object = [ object ];
	        }

	        for (var i = 0; i < object.length; i++)
	        {
	            var entry = object[i];

	            if (entry.isParent)
	            {
	                var children = entry.getChildren();

	                for (var c = 0; c < children.length; c++)
	                {
	                    var child = children[c];

	                    if (child.isParent)
	                    {

	                        this.enable(child, bodyType);
	                    }
	                    else
	                    {
	                        this.enableBody(child, bodyType);
	                    }
	                }
	            }
	            else
	            {
	                this.enableBody(entry, bodyType);
	            }
	        }
	    },

	    enableBody: function (object, bodyType)
	    {
	        if (bodyType === undefined) { bodyType = CONST.DYNAMIC_BODY; }

	        if (object.hasTransformComponent)
	        {
	            if (!object.body)
	            {
	                if (bodyType === CONST.DYNAMIC_BODY)
	                {
	                    object.body = new Body(this, object);
	                }
	                else if (bodyType === CONST.STATIC_BODY)
	                {
	                    object.body = new StaticBody(this, object);
	                }
	            }

	            this.add(object.body);
	        }

	        return object;
	    },

	    add: function (body)
	    {
	        if (body.physicsType === CONST.DYNAMIC_BODY)
	        {
	            this.bodies.set(body);
	        }
	        else if (body.physicsType === CONST.STATIC_BODY)
	        {
	            this.staticBodies.set(body);

	            this.staticTree.insert(body);
	        }

	        body.enable = true;

	        return body;
	    },

	    disable: function (object)
	    {
	        if (!Array.isArray(object))
	        {
	            object = [ object ];
	        }

	        for (var i = 0; i < object.length; i++)
	        {
	            var entry = object[i];

	            if (entry.isParent)
	            {
	                var children = entry.getChildren();

	                for (var c = 0; c < children.length; c++)
	                {
	                    var child = children[c];

	                    if (child.isParent)
	                    {

	                        this.disable(child);
	                    }
	                    else
	                    {
	                        this.disableBody(child.body);
	                    }
	                }
	            }
	            else
	            {
	                this.disableBody(entry.body);
	            }
	        }
	    },

	    disableBody: function (body)
	    {
	        this.remove(body);

	        body.enable = false;
	    },

	    remove: function (body)
	    {
	        if (body.physicsType === CONST.DYNAMIC_BODY)
	        {
	            this.tree.remove(body);
	            this.bodies.delete(body);
	        }
	        else if (body.physicsType === CONST.STATIC_BODY)
	        {
	            this.staticBodies.delete(body);
	            this.staticTree.remove(body);
	        }
	    },

	    createDebugGraphic: function ()
	    {
	        var graphic = this.scene.sys.add.graphics({ x: 0, y: 0 });

	        graphic.setDepth(Number.MAX_VALUE);

	        this.debugGraphic = graphic;

	        this.drawDebug = true;

	        return graphic;
	    },

	    setBounds: function (x, y, width, height, checkLeft, checkRight, checkUp, checkDown)
	    {
	        this.bounds.setTo(x, y, width, height);

	        if (checkLeft !== undefined)
	        {
	            this.setBoundsCollision(checkLeft, checkRight, checkUp, checkDown);
	        }

	        return this;
	    },

	    setBoundsCollision: function (left, right, up, down)
	    {
	        if (left === undefined) { left = true; }
	        if (right === undefined) { right = true; }
	        if (up === undefined) { up = true; }
	        if (down === undefined) { down = true; }

	        this.checkCollision.left = left;
	        this.checkCollision.right = right;
	        this.checkCollision.up = up;
	        this.checkCollision.down = down;

	        return this;
	    },

	    pause: function ()
	    {
	        this.isPaused = true;

	        this.emit(Events.PAUSE);

	        return this;
	    },

	    resume: function ()
	    {
	        this.isPaused = false;

	        this.emit(Events.RESUME);

	        return this;
	    },

	    addCollider: function (object1, object2, collideCallback, processCallback, callbackContext)
	    {
	        if (collideCallback === undefined) { collideCallback = null; }
	        if (processCallback === undefined) { processCallback = null; }
	        if (callbackContext === undefined) { callbackContext = collideCallback; }

	        var collider = new Collider(this, false, object1, object2, collideCallback, processCallback, callbackContext);

	        this.colliders.add(collider);

	        return collider;
	    },

	    addOverlap: function (object1, object2, collideCallback, processCallback, callbackContext)
	    {
	        if (collideCallback === undefined) { collideCallback = null; }
	        if (processCallback === undefined) { processCallback = null; }
	        if (callbackContext === undefined) { callbackContext = collideCallback; }

	        var collider = new Collider(this, true, object1, object2, collideCallback, processCallback, callbackContext);

	        this.colliders.add(collider);

	        return collider;
	    },

	    removeCollider: function (collider)
	    {
	        this.colliders.remove(collider);

	        return this;
	    },

	    setFPS: function (framerate)
	    {
	        this.fps = framerate;
	        this._frameTime = 1 / this.fps;
	        this._frameTimeMS = 1000 * this._frameTime;

	        return this;
	    },

	    update: function (time, delta)
	    {
	        if (this.isPaused || this.bodies.size === 0)
	        {
	            return;
	        }

	        var i;
	        var fixedDelta = this._frameTime;
	        var msPerFrame = this._frameTimeMS * this.timeScale;

	        this._elapsed += delta;

	        var body;
	        var bodies = this.bodies.entries;

	        var willStep = (this._elapsed >= msPerFrame);

	        if (!this.fixedStep)
	        {
	            fixedDelta = delta * 0.001;
	            willStep = true;
	            this._elapsed = 0;
	        }

	        for (i = 0; i < bodies.length; i++)
	        {
	            body = bodies[i];

	            if (body.enable)
	            {
	                body.preUpdate(willStep, fixedDelta);
	            }
	        }

	        if (willStep)
	        {
	            this._elapsed -= msPerFrame;
	            this.stepsLastFrame = 1;

	            if (this.useTree)
	            {
	                this.tree.clear();
	                this.tree.load(bodies);
	            }

	            var colliders = this.colliders.update();

	            for (i = 0; i < colliders.length; i++)
	            {
	                var collider = colliders[i];

	                if (collider.active)
	                {
	                    collider.update();
	                }
	            }

	            this.emit(Events.WORLD_STEP, fixedDelta);
	        }

	        while (this._elapsed >= msPerFrame)
	        {
	            this._elapsed -= msPerFrame;

	            this.step(fixedDelta);
	        }
	    },

	    step: function (delta)
	    {

	        var i;
	        var body;
	        var bodies = this.bodies.entries;
	        var len = bodies.length;

	        for (i = 0; i < len; i++)
	        {
	            body = bodies[i];

	            if (body.enable)
	            {
	                body.update(delta);
	            }
	        }

	        if (this.useTree)
	        {
	            this.tree.clear();
	            this.tree.load(bodies);
	        }

	        var colliders = this.colliders.update();

	        for (i = 0; i < colliders.length; i++)
	        {
	            var collider = colliders[i];

	            if (collider.active)
	            {
	                collider.update();
	            }
	        }

	        this.emit(Events.WORLD_STEP, delta);

	        this.stepsLastFrame++;
	    },

	    singleStep: function ()
	    {
	        this.update(0, this._frameTimeMS);

	        this.postUpdate();
	    },

	    postUpdate: function ()
	    {
	        var i;
	        var body;
	        var bodies = this.bodies.entries;
	        var len = bodies.length;

	        var dynamic = this.bodies;
	        var staticBodies = this.staticBodies;

	        if (this.stepsLastFrame)
	        {
	            this.stepsLastFrame = 0;

	            for (i = 0; i < len; i++)
	            {
	                body = bodies[i];

	                if (body.enable)
	                {
	                    body.postUpdate();
	                }
	            }
	        }

	        if (this.drawDebug)
	        {
	            var graphics = this.debugGraphic;

	            graphics.clear();

	            for (i = 0; i < len; i++)
	            {
	                body = bodies[i];

	                if (body.willDrawDebug())
	                {
	                    body.drawDebug(graphics);
	                }
	            }

	            bodies = staticBodies.entries;
	            len = bodies.length;

	            for (i = 0; i < len; i++)
	            {
	                body = bodies[i];

	                if (body.willDrawDebug())
	                {
	                    body.drawDebug(graphics);
	                }
	            }
	        }

	        var pending = this.pendingDestroy;

	        if (pending.size > 0)
	        {
	            var dynamicTree = this.tree;
	            var staticTree = this.staticTree;

	            bodies = pending.entries;
	            len = bodies.length;

	            for (i = 0; i < len; i++)
	            {
	                body = bodies[i];

	                if (body.physicsType === CONST.DYNAMIC_BODY)
	                {
	                    dynamicTree.remove(body);
	                    dynamic.delete(body);
	                }
	                else if (body.physicsType === CONST.STATIC_BODY)
	                {
	                    staticTree.remove(body);
	                    staticBodies.delete(body);
	                }

	                body.world = undefined;
	                body.gameObject = undefined;
	            }

	            pending.clear();
	        }
	    },

	    updateMotion: function (body, delta)
	    {
	        if (body.allowRotation)
	        {
	            this.computeAngularVelocity(body, delta);
	        }

	        this.computeVelocity(body, delta);
	    },

	    computeAngularVelocity: function (body, delta)
	    {
	        var velocity = body.angularVelocity;
	        var acceleration = body.angularAcceleration;
	        var drag = body.angularDrag;
	        var max = body.maxAngular;

	        if (acceleration)
	        {
	            velocity += acceleration * delta;
	        }
	        else if (body.allowDrag && drag)
	        {
	            drag *= delta;

	            if (FuzzyGreaterThan(velocity - drag, 0, 0.1))
	            {
	                velocity -= drag;
	            }
	            else if (FuzzyLessThan(velocity + drag, 0, 0.1))
	            {
	                velocity += drag;
	            }
	            else
	            {
	                velocity = 0;
	            }
	        }

	        velocity = Clamp(velocity, -max, max);

	        var velocityDelta = velocity - body.angularVelocity;

	        body.angularVelocity += velocityDelta;
	        body.rotation += (body.angularVelocity * delta);
	    },

	    computeVelocity: function (body, delta)
	    {
	        var velocityX = body.velocity.x;
	        var accelerationX = body.acceleration.x;
	        var dragX = body.drag.x;
	        var maxX = body.maxVelocity.x;

	        var velocityY = body.velocity.y;
	        var accelerationY = body.acceleration.y;
	        var dragY = body.drag.y;
	        var maxY = body.maxVelocity.y;

	        var speed = body.speed;
	        var maxSpeed = body.maxSpeed;
	        var allowDrag = body.allowDrag;
	        var useDamping = body.useDamping;

	        if (body.allowGravity)
	        {
	            velocityX += (this.gravity.x + body.gravity.x) * delta;
	            velocityY += (this.gravity.y + body.gravity.y) * delta;
	        }

	        if (accelerationX)
	        {
	            velocityX += accelerationX * delta;
	        }
	        else if (allowDrag && dragX)
	        {
	            if (useDamping)
	            {

	                dragX = Math.pow(dragX, delta);

	                velocityX *= dragX;

	                speed = Math.sqrt(velocityX * velocityX + velocityY * velocityY);

	                if (FuzzyEqual(speed, 0, 0.001))
	                {
	                    velocityX = 0;
	                }
	            }
	            else
	            {

	                dragX *= delta;

	                if (FuzzyGreaterThan(velocityX - dragX, 0, 0.01))
	                {
	                    velocityX -= dragX;
	                }
	                else if (FuzzyLessThan(velocityX + dragX, 0, 0.01))
	                {
	                    velocityX += dragX;
	                }
	                else
	                {
	                    velocityX = 0;
	                }
	            }
	        }

	        if (accelerationY)
	        {
	            velocityY += accelerationY * delta;
	        }
	        else if (allowDrag && dragY)
	        {
	            if (useDamping)
	            {

	                dragY = Math.pow(dragY, delta);

	                velocityY *= dragY;

	                speed = Math.sqrt(velocityX * velocityX + velocityY * velocityY);

	                if (FuzzyEqual(speed, 0, 0.001))
	                {
	                    velocityY = 0;
	                }
	            }
	            else
	            {

	                dragY *= delta;

	                if (FuzzyGreaterThan(velocityY - dragY, 0, 0.01))
	                {
	                    velocityY -= dragY;
	                }
	                else if (FuzzyLessThan(velocityY + dragY, 0, 0.01))
	                {
	                    velocityY += dragY;
	                }
	                else
	                {
	                    velocityY = 0;
	                }
	            }
	        }

	        velocityX = Clamp(velocityX, -maxX, maxX);
	        velocityY = Clamp(velocityY, -maxY, maxY);

	        body.velocity.set(velocityX, velocityY);

	        if (maxSpeed > -1 && body.velocity.length() > maxSpeed)
	        {
	            body.velocity.normalize().scale(maxSpeed);
	            speed = maxSpeed;
	        }

	        body.speed = speed;
	    },

	    separate: function (body1, body2, processCallback, callbackContext, overlapOnly)
	    {
	        var overlapX;
	        var overlapY;

	        var result = false;
	        var runSeparation = true;

	        if (
	            !body1.enable ||
	            !body2.enable ||
	            body1.checkCollision.none ||
	            body2.checkCollision.none ||
	            !this.intersects(body1, body2) ||
	            (body1.collisionMask & body2.collisionCategory) === 0 ||
	            (body2.collisionMask & body1.collisionCategory) === 0)
	        {
	            return result;
	        }

	        if (processCallback && processCallback.call(callbackContext, (body1.gameObject || body1), (body2.gameObject || body2)) === false)
	        {
	            return result;
	        }

	        if (body1.isCircle || body2.isCircle)
	        {
	            var circleResults = this.separateCircle(body1, body2, overlapOnly);

	            if (circleResults.result)
	            {

	                result = true;
	                runSeparation = false;
	            }
	            else
	            {

	                overlapX = circleResults.x;
	                overlapY = circleResults.y;
	                runSeparation = true;
	            }
	        }

	        if (runSeparation)
	        {
	            var resultX = false;
	            var resultY = false;
	            var bias = this.OVERLAP_BIAS;

	            if (overlapOnly)
	            {

	                resultX = SeparateX(body1, body2, overlapOnly, bias, overlapX);
	                resultY = SeparateY(body1, body2, overlapOnly, bias, overlapY);
	            }
	            else if (this.forceX || Math.abs(this.gravity.y + body1.gravity.y) < Math.abs(this.gravity.x + body1.gravity.x))
	            {
	                resultX = SeparateX(body1, body2, overlapOnly, bias, overlapX);

	                if (this.intersects(body1, body2))
	                {
	                    resultY = SeparateY(body1, body2, overlapOnly, bias, overlapY);
	                }
	            }
	            else
	            {
	                resultY = SeparateY(body1, body2, overlapOnly, bias, overlapY);

	                if (this.intersects(body1, body2))
	                {
	                    resultX = SeparateX(body1, body2, overlapOnly, bias, overlapX);
	                }
	            }

	            result = (resultX || resultY);
	        }

	        if (result)
	        {
	            if (overlapOnly)
	            {
	                if (body1.onOverlap || body2.onOverlap)
	                {
	                    this.emit(Events.OVERLAP, body1.gameObject, body2.gameObject, body1, body2);
	                }
	            }
	            else if (body1.onCollide || body2.onCollide)
	            {
	                this.emit(Events.COLLIDE, body1.gameObject, body2.gameObject, body1, body2);
	            }
	        }

	        return result;
	    },

	    separateCircle: function (body1, body2, overlapOnly)
	    {

	        GetOverlapX(body1, body2, false, 0);
	        GetOverlapY(body1, body2, false, 0);

	        var body1IsCircle = body1.isCircle;
	        var body2IsCircle = body2.isCircle;
	        var body1Center = body1.center;
	        var body2Center = body2.center;
	        var body1Immovable = body1.immovable;
	        var body2Immovable = body2.immovable;
	        var body1Velocity = body1.velocity;
	        var body2Velocity = body2.velocity;

	        var overlap = 0;
	        var twoCircles = true;

	        if (body1IsCircle !== body2IsCircle)
	        {
	            twoCircles = false;

	            var circleX = body1Center.x;
	            var circleY = body1Center.y;
	            var circleRadius = body1.halfWidth;

	            var rectX = body2.position.x;
	            var rectY = body2.position.y;
	            var rectRight = body2.right;
	            var rectBottom = body2.bottom;

	            if (body2IsCircle)
	            {
	                circleX = body2Center.x;
	                circleY = body2Center.y;
	                circleRadius = body2.halfWidth;

	                rectX = body1.position.x;
	                rectY = body1.position.y;
	                rectRight = body1.right;
	                rectBottom = body1.bottom;
	            }

	            if (circleY < rectY)
	            {
	                if (circleX < rectX)
	                {
	                    overlap = DistanceBetween(circleX, circleY, rectX, rectY) - circleRadius;
	                }
	                else if (circleX > rectRight)
	                {
	                    overlap = DistanceBetween(circleX, circleY, rectRight, rectY) - circleRadius;
	                }
	            }
	            else if (circleY > rectBottom)
	            {
	                if (circleX < rectX)
	                {
	                    overlap = DistanceBetween(circleX, circleY, rectX, rectBottom) - circleRadius;
	                }
	                else if (circleX > rectRight)
	                {
	                    overlap = DistanceBetween(circleX, circleY, rectRight, rectBottom) - circleRadius;
	                }
	            }

	            overlap *= -1;
	        }
	        else
	        {
	            overlap = (body1.halfWidth + body2.halfWidth) - DistanceBetweenPoints(body1Center, body2Center);
	        }

	        body1.overlapR = overlap;
	        body2.overlapR = overlap;

	        var angle = AngleBetweenPoints(body1Center, body2Center);
	        var overlapX = (overlap + MATH_CONST.EPSILON) * Math.cos(angle);
	        var overlapY = (overlap + MATH_CONST.EPSILON) * Math.sin(angle);

	        var results = { overlap: overlap, result: false, x: overlapX, y: overlapY };

	        if (overlapOnly && (!twoCircles || (twoCircles && overlap !== 0)))
	        {

	            results.result = true;

	            return results;
	        }

	        if ((!twoCircles && overlap === 0) || (body1Immovable && body2Immovable) || body1.customSeparateX || body2.customSeparateX)
	        {

	            results.x = undefined;
	            results.y = undefined;

	            return results;
	        }

	        var deadlock = (!body1.pushable && !body2.pushable);

	        if (twoCircles)
	        {
	            var dx = body1Center.x - body2Center.x;
	            var dy = body1Center.y - body2Center.y;
	            var d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
	            var nx = ((body2Center.x - body1Center.x) / d) || 0;
	            var ny = ((body2Center.y - body1Center.y) / d) || 0;
	            var p = 2 * (body1Velocity.x * nx + body1Velocity.y * ny - body2Velocity.x * nx - body2Velocity.y * ny) / (body1.mass + body2.mass);

	            if (body1Immovable || body2Immovable || !body1.pushable || !body2.pushable)
	            {
	                p *= 2;
	            }

	            if (!body1Immovable && body1.pushable)
	            {
	                body1Velocity.x = (body1Velocity.x - p / body1.mass * nx);
	                body1Velocity.y = (body1Velocity.y - p / body1.mass * ny);
	                body1Velocity.multiply(body1.bounce);
	            }

	            if (!body2Immovable && body2.pushable)
	            {
	                body2Velocity.x = (body2Velocity.x + p / body2.mass * nx);
	                body2Velocity.y = (body2Velocity.y + p / body2.mass * ny);
	                body2Velocity.multiply(body2.bounce);
	            }

	            if (!body1Immovable && !body2Immovable)
	            {
	                overlapX *= 0.5;
	                overlapY *= 0.5;
	            }

	            if (!body1Immovable || body1.pushable || deadlock)
	            {
	                body1.x -= overlapX;
	                body1.y -= overlapY;

	                body1.updateCenter();
	            }

	            if (!body2Immovable || body2.pushable || deadlock)
	            {
	                body2.x += overlapX;
	                body2.y += overlapY;

	                body2.updateCenter();
	            }

	            results.result = true;
	        }
	        else
	        {

	            if (!body1Immovable && (body1.pushable || deadlock))
	            {
	                body1.x -= overlapX;
	                body1.y -= overlapY;

	                body1.updateCenter();
	            }

	            if (!body2Immovable && (body2.pushable || deadlock))
	            {
	                body2.x += overlapX;
	                body2.y += overlapY;

	                body2.updateCenter();
	            }

	            results.x = undefined;
	            results.y = undefined;
	        }

	        return results;
	    },

	    intersects: function (body1, body2)
	    {
	        if (body1 === body2)
	        {
	            return false;
	        }

	        if (!body1.isCircle && !body2.isCircle)
	        {

	            return !(
	                body1.right <= body2.left ||
	                body1.bottom <= body2.top ||
	                body1.left >= body2.right ||
	                body1.top >= body2.bottom
	            );
	        }
	        else if (body1.isCircle)
	        {
	            if (body2.isCircle)
	            {

	                return DistanceBetweenPoints(body1.center, body2.center) <= (body1.halfWidth + body2.halfWidth);
	            }
	            else
	            {

	                return this.circleBodyIntersects(body1, body2);
	            }
	        }
	        else
	        {

	            return this.circleBodyIntersects(body2, body1);
	        }
	    },

	    circleBodyIntersects: function (circle, body)
	    {
	        var x = Clamp(circle.center.x, body.left, body.right);
	        var y = Clamp(circle.center.y, body.top, body.bottom);

	        var dx = (circle.center.x - x) * (circle.center.x - x);
	        var dy = (circle.center.y - y) * (circle.center.y - y);

	        return (dx + dy) <= (circle.halfWidth * circle.halfWidth);
	    },

	    overlap: function (object1, object2, overlapCallback, processCallback, callbackContext)
	    {
	        if (overlapCallback === undefined) { overlapCallback = null; }
	        if (processCallback === undefined) { processCallback = null; }
	        if (callbackContext === undefined) { callbackContext = overlapCallback; }

	        return this.collideObjects(object1, object2, overlapCallback, processCallback, callbackContext, true);
	    },

	    collide: function (object1, object2, collideCallback, processCallback, callbackContext)
	    {
	        if (collideCallback === undefined) { collideCallback = null; }
	        if (processCallback === undefined) { processCallback = null; }
	        if (callbackContext === undefined) { callbackContext = collideCallback; }

	        return this.collideObjects(object1, object2, collideCallback, processCallback, callbackContext, false);
	    },

	    collideObjects: function (object1, object2, collideCallback, processCallback, callbackContext, overlapOnly)
	    {
	        var i;
	        var j;

	        if (object1.isParent && (object1.physicsType === undefined || object2 === undefined || object1 === object2))
	        {
	            object1 = object1.children.entries;
	        }

	        if (object2 && object2.isParent && object2.physicsType === undefined)
	        {
	            object2 = object2.children.entries;
	        }

	        var object1isArray = Array.isArray(object1);
	        var object2isArray = Array.isArray(object2);

	        this._total = 0;

	        if (!object1isArray && !object2isArray)
	        {

	            this.collideHandler(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);
	        }
	        else if (!object1isArray && object2isArray)
	        {

	            for (i = 0; i < object2.length; i++)
	            {
	                this.collideHandler(object1, object2[i], collideCallback, processCallback, callbackContext, overlapOnly);
	            }
	        }
	        else if (object1isArray && !object2isArray)
	        {

	            if (!object2)
	            {

	                for (i = 0; i < object1.length; i++)
	                {
	                    var child = object1[i];

	                    for (j = i + 1; j < object1.length; j++)
	                    {
	                        if (i === j)
	                        {
	                            continue;
	                        }

	                        this.collideHandler(child, object1[j], collideCallback, processCallback, callbackContext, overlapOnly);
	                    }
	                }
	            }
	            else
	            {
	                for (i = 0; i < object1.length; i++)
	                {
	                    this.collideHandler(object1[i], object2, collideCallback, processCallback, callbackContext, overlapOnly);
	                }
	            }
	        }
	        else
	        {

	            for (i = 0; i < object1.length; i++)
	            {
	                for (j = 0; j < object2.length; j++)
	                {
	                    this.collideHandler(object1[i], object2[j], collideCallback, processCallback, callbackContext, overlapOnly);
	                }
	            }
	        }

	        return (this._total > 0);
	    },

	    collideHandler: function (object1, object2, collideCallback, processCallback, callbackContext, overlapOnly)
	    {

	        if (object2 === undefined && object1.isParent)
	        {
	            return this.collideGroupVsGroup(object1, object1, collideCallback, processCallback, callbackContext, overlapOnly);
	        }

	        if (!object1 || !object2)
	        {
	            return false;
	        }

	        if (object1.body || object1.isBody)
	        {
	            if (object2.body || object2.isBody)
	            {
	                return this.collideSpriteVsSprite(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);
	            }
	            else if (object2.isParent)
	            {
	                return this.collideSpriteVsGroup(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);
	            }
	            else if (object2.isTilemap)
	            {
	                return this.collideSpriteVsTilemapLayer(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);
	            }
	        }

	        else if (object1.isParent)
	        {
	            if (object2.body || object2.isBody)
	            {
	                return this.collideSpriteVsGroup(object2, object1, collideCallback, processCallback, callbackContext, overlapOnly);
	            }
	            else if (object2.isParent)
	            {
	                return this.collideGroupVsGroup(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);
	            }
	            else if (object2.isTilemap)
	            {
	                return this.collideGroupVsTilemapLayer(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);
	            }
	        }

	        else if (object1.isTilemap)
	        {
	            if (object2.body || object2.isBody)
	            {
	                return this.collideSpriteVsTilemapLayer(object2, object1, collideCallback, processCallback, callbackContext, overlapOnly);
	            }
	            else if (object2.isParent)
	            {
	                return this.collideGroupVsTilemapLayer(object2, object1, collideCallback, processCallback, callbackContext, overlapOnly);
	            }
	        }
	    },

	    canCollide: function (body1, body2)
	    {
	        return (
	            (body1 && body2) &&
	            (body1.collisionMask & body2.collisionCategory) !== 0 &&
	            (body2.collisionMask & body1.collisionCategory) !== 0
	        );
	    },

	    collideSpriteVsSprite: function (sprite1, sprite2, collideCallback, processCallback, callbackContext, overlapOnly)
	    {
	        var body1 = (sprite1.isBody) ? sprite1 : sprite1.body;
	        var body2 = (sprite2.isBody) ? sprite2 : sprite2.body;

	        if (!this.canCollide(body1, body2))
	        {
	            return false;
	        }

	        if (this.separate(body1, body2, processCallback, callbackContext, overlapOnly))
	        {
	            if (collideCallback)
	            {
	                collideCallback.call(callbackContext, sprite1, sprite2);
	            }

	            this._total++;
	        }

	        return true;
	    },

	    collideSpriteVsGroup: function (sprite, group, collideCallback, processCallback, callbackContext, overlapOnly)
	    {
	        var bodyA = (sprite.isBody) ? sprite : sprite.body;

	        if (group.getLength() === 0 || !bodyA || !bodyA.enable || bodyA.checkCollision.none || !this.canCollide(bodyA, group))
	        {
	            return;
	        }

	        var i;
	        var len;
	        var bodyB;

	        if (this.useTree || group.physicsType === CONST.STATIC_BODY)
	        {
	            var minMax = this.treeMinMax;

	            minMax.minX = bodyA.left;
	            minMax.minY = bodyA.top;
	            minMax.maxX = bodyA.right;
	            minMax.maxY = bodyA.bottom;

	            var results = (group.physicsType === CONST.DYNAMIC_BODY) ? this.tree.search(minMax) : this.staticTree.search(minMax);

	            len = results.length;

	            for (i = 0; i < len; i++)
	            {
	                bodyB = results[i];

	                if (bodyA === bodyB || !bodyB.enable || bodyB.checkCollision.none || !group.contains(bodyB.gameObject))
	                {

	                    continue;
	                }

	                if (this.separate(bodyA, bodyB, processCallback, callbackContext, overlapOnly))
	                {
	                    if (collideCallback)
	                    {
	                        collideCallback.call(callbackContext, bodyA.gameObject, bodyB.gameObject);
	                    }

	                    this._total++;
	                }
	            }
	        }
	        else
	        {
	            var children = group.getChildren();
	            var skipIndex = group.children.entries.indexOf(sprite);

	            len = children.length;

	            for (i = 0; i < len; i++)
	            {
	                bodyB = children[i].body;

	                if (!bodyB || i === skipIndex || !bodyB.enable)
	                {
	                    continue;
	                }

	                if (this.separate(bodyA, bodyB, processCallback, callbackContext, overlapOnly))
	                {
	                    if (collideCallback)
	                    {
	                        collideCallback.call(callbackContext, bodyA.gameObject, bodyB.gameObject);
	                    }

	                    this._total++;
	                }
	            }
	        }
	    },

	    collideGroupVsTilemapLayer: function (group, tilemapLayer, collideCallback, processCallback, callbackContext, overlapOnly)
	    {
	        if (!this.canCollide(group, tilemapLayer))
	        {
	            return false;
	        }

	        var children = group.getChildren();

	        if (children.length === 0)
	        {
	            return false;
	        }

	        var didCollide = false;

	        for (var i = 0; i < children.length; i++)
	        {
	            if (children[i].body || children[i].isBody)
	            {
	                if (this.collideSpriteVsTilemapLayer(children[i], tilemapLayer, collideCallback, processCallback, callbackContext, overlapOnly))
	                {
	                    didCollide = true;
	                }
	            }
	        }

	        return didCollide;
	    },

	    collideTiles: function (sprite, tiles, collideCallback, processCallback, callbackContext)
	    {
	        if (tiles.length === 0 || (sprite.body && !sprite.body.enable) || (sprite.isBody && !sprite.enable))
	        {
	            return false;
	        }
	        else
	        {
	            return this.collideSpriteVsTilesHandler(sprite, tiles, collideCallback, processCallback, callbackContext, false, false);
	        }
	    },

	    overlapTiles: function (sprite, tiles, overlapCallback, processCallback, callbackContext)
	    {
	        if (tiles.length === 0 || (sprite.body && !sprite.body.enable) || (sprite.isBody && !sprite.enable))
	        {
	            return false;
	        }
	        else
	        {
	            return this.collideSpriteVsTilesHandler(sprite, tiles, overlapCallback, processCallback, callbackContext, true, false);
	        }
	    },

	    collideSpriteVsTilemapLayer: function (sprite, tilemapLayer, collideCallback, processCallback, callbackContext, overlapOnly)
	    {
	        var body = (sprite.isBody) ? sprite : sprite.body;

	        if (!body.enable || body.checkCollision.none || !this.canCollide(body, tilemapLayer))
	        {
	            return false;
	        }

	        var layerData = tilemapLayer.layer;

	        var x = body.x - (layerData.tileWidth * tilemapLayer.scaleX);
	        var y = body.y - (layerData.tileHeight * tilemapLayer.scaleY);
	        var w = body.width + (layerData.tileWidth * tilemapLayer.scaleX);
	        var h = body.height + layerData.tileHeight * tilemapLayer.scaleY;

	        var options = (overlapOnly) ? null : this.tileFilterOptions;

	        var mapData = GetTilesWithinWorldXY(x, y, w, h, options, tilemapLayer.scene.cameras.main, tilemapLayer.layer);

	        if (mapData.length === 0)
	        {
	            return false;
	        }
	        else
	        {
	            return this.collideSpriteVsTilesHandler(sprite, mapData, collideCallback, processCallback, callbackContext, overlapOnly, true);
	        }
	    },

	    collideSpriteVsTilesHandler: function (sprite, tiles, collideCallback, processCallback, callbackContext, overlapOnly, isLayer)
	    {
	        var body = (sprite.isBody) ? sprite : sprite.body;

	        var tile;
	        var tileWorldRect = { left: 0, right: 0, top: 0, bottom: 0 };
	        var tilemapLayer;
	        var collision = false;

	        for (var i = 0; i < tiles.length; i++)
	        {
	            tile = tiles[i];

	            tilemapLayer = tile.tilemapLayer;

	            var point = tilemapLayer.tileToWorldXY(tile.x, tile.y);

	            tileWorldRect.left = point.x;
	            tileWorldRect.top = point.y;

	            tileWorldRect.right = tileWorldRect.left + tile.width * tilemapLayer.scaleX;
	            tileWorldRect.bottom = tileWorldRect.top + tile.height * tilemapLayer.scaleY;

	            if (
	                TileIntersectsBody(tileWorldRect, body) &&
	                (!processCallback || processCallback.call(callbackContext, sprite, tile)) &&
	                ProcessTileCallbacks(tile, sprite) &&
	                (overlapOnly || SeparateTile(i, body, tile, tileWorldRect, tilemapLayer, this.TILE_BIAS, isLayer)))
	            {
	                this._total++;

	                collision = true;

	                if (collideCallback)
	                {
	                    collideCallback.call(callbackContext, sprite, tile);
	                }

	                if (overlapOnly && body.onOverlap)
	                {
	                    this.emit(Events.TILE_OVERLAP, sprite, tile, body);
	                }
	                else if (body.onCollide)
	                {
	                    this.emit(Events.TILE_COLLIDE, sprite, tile, body);
	                }
	            }
	        }

	        return collision;
	    },

	    collideGroupVsGroup: function (group1, group2, collideCallback, processCallback, callbackContext, overlapOnly)
	    {
	        if (group1.getLength() === 0 || group2.getLength() === 0 || !this.canCollide(group1, group2))
	        {
	            return;
	        }

	        var children = group1.getChildren();

	        for (var i = 0; i < children.length; i++)
	        {
	            this.collideSpriteVsGroup(children[i], group2, collideCallback, processCallback, callbackContext, overlapOnly);
	        }
	    },

	    wrap: function (object, padding)
	    {
	        if (object.body)
	        {
	            this.wrapObject(object, padding);
	        }
	        else if (object.getChildren)
	        {
	            this.wrapArray(object.getChildren(), padding);
	        }
	        else if (Array.isArray(object))
	        {
	            this.wrapArray(object, padding);
	        }
	        else
	        {
	            this.wrapObject(object, padding);
	        }
	    },

	    wrapArray: function (objects, padding)
	    {
	        for (var i = 0; i < objects.length; i++)
	        {
	            this.wrapObject(objects[i], padding);
	        }
	    },

	    wrapObject: function (object, padding)
	    {
	        if (padding === undefined) { padding = 0; }

	        object.x = Wrap(object.x, this.bounds.left - padding, this.bounds.right + padding);
	        object.y = Wrap(object.y, this.bounds.top - padding, this.bounds.bottom + padding);
	    },

	    shutdown: function ()
	    {
	        this.tree.clear();
	        this.staticTree.clear();
	        this.bodies.clear();
	        this.staticBodies.clear();
	        this.colliders.destroy();

	        this.removeAllListeners();
	    },

	    destroy: function ()
	    {
	        this.shutdown();

	        this.scene = null;

	        if (this.debugGraphic)
	        {
	            this.debugGraphic.destroy();
	            this.debugGraphic = null;
	        }
	    }

	});

	World_1 = World;
	return World_1;
}

var ArcadePhysics_1;
var hasRequiredArcadePhysics;

function requireArcadePhysics () {
	if (hasRequiredArcadePhysics) return ArcadePhysics_1;
	hasRequiredArcadePhysics = 1;
	var Class = requireClass();
	var DegToRad = requireDegToRad();
	var DistanceBetween = requireDistanceBetween();
	var DistanceSquared = requireDistanceSquared();
	var Factory = requireFactory();
	var GetFastValue = requireGetFastValue();
	var Merge = requireMerge();
	var OverlapCirc = requireOverlapCirc();
	var OverlapRect = requireOverlapRect();
	var PluginCache = requirePluginCache();
	var SceneEvents = requireEvents$l();
	var Vector2 = requireVector2();
	var World = requireWorld();

	var ArcadePhysics = new Class({

	    initialize:

	    function ArcadePhysics (scene)
	    {

	        this.scene = scene;

	        this.systems = scene.sys;

	        this.config = this.getConfig();

	        this.world;

	        this.add;

	        this._category = 0x0001;

	        scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
	        scene.sys.events.on(SceneEvents.START, this.start, this);
	    },

	    boot: function ()
	    {
	        this.world = new World(this.scene, this.config);
	        this.add = new Factory(this.world);

	        this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);
	    },

	    start: function ()
	    {
	        if (!this.world)
	        {
	            this.world = new World(this.scene, this.config);
	            this.add = new Factory(this.world);
	        }

	        var eventEmitter = this.systems.events;

	        if (!GetFastValue(this.config, 'customUpdate', false))
	        {
	            eventEmitter.on(SceneEvents.UPDATE, this.world.update, this.world);
	        }

	        eventEmitter.on(SceneEvents.POST_UPDATE, this.world.postUpdate, this.world);
	        eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);
	    },

	    enableUpdate: function ()
	    {
	        this.systems.events.on(SceneEvents.UPDATE, this.world.update, this.world);
	    },

	    disableUpdate: function ()
	    {
	        this.systems.events.off(SceneEvents.UPDATE, this.world.update, this.world);
	    },

	    getConfig: function ()
	    {
	        var gameConfig = this.systems.game.config.physics;
	        var sceneConfig = this.systems.settings.physics;

	        var config = Merge(
	            GetFastValue(sceneConfig, 'arcade', {}),
	            GetFastValue(gameConfig, 'arcade', {})
	        );

	        return config;
	    },

	    nextCategory: function ()
	    {
	        this._category = this._category << 1;

	        return this._category;
	    },

	    overlap: function (object1, object2, overlapCallback, processCallback, callbackContext)
	    {
	        if (overlapCallback === undefined) { overlapCallback = null; }
	        if (processCallback === undefined) { processCallback = null; }
	        if (callbackContext === undefined) { callbackContext = overlapCallback; }

	        return this.world.collideObjects(object1, object2, overlapCallback, processCallback, callbackContext, true);
	    },

	    collide: function (object1, object2, collideCallback, processCallback, callbackContext)
	    {
	        if (collideCallback === undefined) { collideCallback = null; }
	        if (processCallback === undefined) { processCallback = null; }
	        if (callbackContext === undefined) { callbackContext = collideCallback; }

	        return this.world.collideObjects(object1, object2, collideCallback, processCallback, callbackContext, false);
	    },

	    collideTiles: function (sprite, tiles, collideCallback, processCallback, callbackContext)
	    {
	        return this.world.collideTiles(sprite, tiles, collideCallback, processCallback, callbackContext);
	    },

	    overlapTiles: function (sprite, tiles, overlapCallback, processCallback, callbackContext)
	    {
	        return this.world.overlapTiles(sprite, tiles, overlapCallback, processCallback, callbackContext);
	    },

	    pause: function ()
	    {
	        return this.world.pause();
	    },

	    resume: function ()
	    {
	        return this.world.resume();
	    },

	    accelerateTo: function (gameObject, x, y, speed, xSpeedMax, ySpeedMax)
	    {
	        if (speed === undefined) { speed = 60; }

	        var angle = Math.atan2(y - gameObject.y, x - gameObject.x);

	        gameObject.body.acceleration.setToPolar(angle, speed);

	        if (xSpeedMax !== undefined && ySpeedMax !== undefined)
	        {
	            gameObject.body.maxVelocity.set(xSpeedMax, ySpeedMax);
	        }

	        return angle;
	    },

	    accelerateToObject: function (gameObject, destination, speed, xSpeedMax, ySpeedMax)
	    {
	        return this.accelerateTo(gameObject, destination.x, destination.y, speed, xSpeedMax, ySpeedMax);
	    },

	    closest: function (source, targets)
	    {
	        if (!targets)
	        {
	            targets = this.world.bodies.entries;
	        }

	        var min = Number.MAX_VALUE;
	        var closest = null;
	        var x = source.x;
	        var y = source.y;
	        var len = targets.length;

	        for (var i = 0; i < len; i++)
	        {
	            var target = targets[i];
	            var body = target.body || target;

	            if (source === target || source === body || source === body.gameObject || source === body.center)
	            {
	                continue;
	            }

	            var distance = DistanceSquared(x, y, body.center.x, body.center.y);

	            if (distance < min)
	            {
	                closest = target;
	                min = distance;
	            }
	        }

	        return closest;
	    },

	    furthest: function (source, targets)
	    {
	        if (!targets)
	        {
	            targets = this.world.bodies.entries;
	        }

	        var max = -1;
	        var farthest = null;
	        var x = source.x;
	        var y = source.y;
	        var len = targets.length;

	        for (var i = 0; i < len; i++)
	        {
	            var target = targets[i];
	            var body = target.body || target;

	            if (source === target || source === body || source === body.gameObject || source === body.center)
	            {
	                continue;
	            }

	            var distance = DistanceSquared(x, y, body.center.x, body.center.y);

	            if (distance > max)
	            {
	                farthest = target;
	                max = distance;
	            }

	        }

	        return farthest;
	    },

	    moveTo: function (gameObject, x, y, speed, maxTime)
	    {
	        if (speed === undefined) { speed = 60; }
	        if (maxTime === undefined) { maxTime = 0; }

	        var angle = Math.atan2(y - gameObject.y, x - gameObject.x);

	        if (maxTime > 0)
	        {

	            speed = DistanceBetween(gameObject.x, gameObject.y, x, y) / (maxTime / 1000);
	        }

	        gameObject.body.velocity.setToPolar(angle, speed);

	        return angle;
	    },

	    moveToObject: function (gameObject, destination, speed, maxTime)
	    {
	        return this.moveTo(gameObject, destination.x, destination.y, speed, maxTime);
	    },

	    velocityFromAngle: function (angle, speed, vec2)
	    {
	        if (speed === undefined) { speed = 60; }
	        if (vec2 === undefined) { vec2 = new Vector2(); }

	        return vec2.setToPolar(DegToRad(angle), speed);
	    },

	    velocityFromRotation: function (rotation, speed, vec2)
	    {
	        if (speed === undefined) { speed = 60; }
	        if (vec2 === undefined) { vec2 = new Vector2(); }

	        return vec2.setToPolar(rotation, speed);
	    },

	    overlapRect: function (x, y, width, height, includeDynamic, includeStatic)
	    {
	        return OverlapRect(this.world, x, y, width, height, includeDynamic, includeStatic);
	    },

	    overlapCirc: function (x, y, radius, includeDynamic, includeStatic)
	    {
	        return OverlapCirc(this.world, x, y, radius, includeDynamic, includeStatic);
	    },

	    shutdown: function ()
	    {
	        if (!this.world)
	        {

	            return;
	        }

	        var eventEmitter = this.systems.events;

	        eventEmitter.off(SceneEvents.UPDATE, this.world.update, this.world);
	        eventEmitter.off(SceneEvents.POST_UPDATE, this.world.postUpdate, this.world);
	        eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);

	        this.add.destroy();
	        this.world.destroy();

	        this.add = null;
	        this.world = null;
	        this._category = 1;
	    },

	    destroy: function ()
	    {
	        this.shutdown();

	        this.scene.sys.events.off(SceneEvents.START, this.start, this);

	        this.scene = null;
	        this.systems = null;
	    }

	});

	PluginCache.register('ArcadePhysics', ArcadePhysics, 'arcadePhysics');

	ArcadePhysics_1 = ArcadePhysics;
	return ArcadePhysics_1;
}

var tilemap;
var hasRequiredTilemap$1;

function requireTilemap$1 () {
	if (hasRequiredTilemap$1) return tilemap;
	hasRequiredTilemap$1 = 1;
	var Tilemap = {

	    ProcessTileCallbacks: requireProcessTileCallbacks(),
	    ProcessTileSeparationX: requireProcessTileSeparationX(),
	    ProcessTileSeparationY: requireProcessTileSeparationY(),
	    SeparateTile: requireSeparateTile(),
	    TileCheckX: requireTileCheckX(),
	    TileCheckY: requireTileCheckY(),
	    TileIntersectsBody: requireTileIntersectsBody()

	};

	tilemap = Tilemap;
	return tilemap;
}

var arcade;
var hasRequiredArcade;

function requireArcade () {
	if (hasRequiredArcade) return arcade;
	hasRequiredArcade = 1;
	var CONST = require_const$2();
	var Extend = requireExtend$1();

	var Arcade = {

	    ArcadePhysics: requireArcadePhysics(),
	    Body: requireBody(),
	    Collider: requireCollider(),
	    Components: requireComponents$1(),
	    Events: requireEvents$2(),
	    Factory: requireFactory(),
	    GetCollidesWith: requireGetCollidesWith(),
	    GetOverlapX: requireGetOverlapX(),
	    GetOverlapY: requireGetOverlapY(),
	    SeparateX: requireSeparateX(),
	    SeparateY: requireSeparateY(),
	    Group: requirePhysicsGroup(),
	    Image: requireArcadeImage(),
	    Sprite: requireArcadeSprite(),
	    StaticBody: requireStaticBody(),
	    StaticGroup: requireStaticPhysicsGroup(),
	    Tilemap: requireTilemap$1(),
	    World: requireWorld()

	};

	Arcade = Extend(false, Arcade, CONST);

	arcade = Arcade;
	return arcade;
}

var physics;
var hasRequiredPhysics;

function requirePhysics () {
	if (hasRequiredPhysics) return physics;
	hasRequiredPhysics = 1;
	physics = {

	    Arcade: requireArcade(),

	};
	return physics;
}

var BasePlugin_1;
var hasRequiredBasePlugin;

function requireBasePlugin () {
	if (hasRequiredBasePlugin) return BasePlugin_1;
	hasRequiredBasePlugin = 1;
	var Class = requireClass();

	var BasePlugin = new Class({

	    initialize:

	    function BasePlugin (pluginManager)
	    {

	        this.pluginManager = pluginManager;

	        this.game = pluginManager.game;
	    },

	    init: function ()
	    {
	    },

	    start: function ()
	    {

	    },

	    stop: function ()
	    {
	    },

	    destroy: function ()
	    {
	        this.pluginManager = null;
	        this.game = null;
	        this.scene = null;
	        this.systems = null;
	    }

	});

	BasePlugin_1 = BasePlugin;
	return BasePlugin_1;
}

var ScenePlugin_1$1;
var hasRequiredScenePlugin$1;

function requireScenePlugin$1 () {
	if (hasRequiredScenePlugin$1) return ScenePlugin_1$1;
	hasRequiredScenePlugin$1 = 1;
	var BasePlugin = requireBasePlugin();
	var Class = requireClass();
	var SceneEvents = requireEvents$l();

	var ScenePlugin = new Class({

	    Extends: BasePlugin,

	    initialize:

	    function ScenePlugin (scene, pluginManager, pluginKey)
	    {
	        BasePlugin.call(this, pluginManager);

	        this.scene = scene;

	        this.systems = scene.sys;

	        this.pluginKey = pluginKey;

	        scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
	    },

	    boot: function ()
	    {
	    },

	    destroy: function ()
	    {
	        this.pluginManager = null;
	        this.game = null;
	        this.scene = null;
	        this.systems = null;
	    }

	});

	ScenePlugin_1$1 = ScenePlugin;
	return ScenePlugin_1$1;
}

var plugins;
var hasRequiredPlugins;

function requirePlugins () {
	if (hasRequiredPlugins) return plugins;
	hasRequiredPlugins = 1;
	plugins = {

	    BasePlugin: requireBasePlugin(),
	    DefaultPlugins: requireDefaultPlugins(),
	    PluginCache: requirePluginCache(),
	    PluginManager: requirePluginManager(),
	    ScenePlugin: requireScenePlugin$1()

	};
	return plugins;
}

var renderer = {exports: {}};

var snapshot;
var hasRequiredSnapshot;

function requireSnapshot () {
	if (hasRequiredSnapshot) return snapshot;
	hasRequiredSnapshot = 1;
	snapshot = {

	    Canvas: requireCanvasSnapshot(),
	    WebGL: requireWebGLSnapshot()

	};
	return snapshot;
}

var canvas;
var hasRequiredCanvas;

function requireCanvas () {
	if (hasRequiredCanvas) return canvas;
	hasRequiredCanvas = 1;
	canvas = {

	    CanvasRenderer: requireCanvasRenderer(),
	    GetBlendModes: requireGetBlendModes(),
	    SetTransform: requireSetTransform()

	};
	return canvas;
}

var pipelines;
var hasRequiredPipelines;

function requirePipelines () {
	if (hasRequiredPipelines) return pipelines;
	hasRequiredPipelines = 1;
	var CONST = require_const$9();
	var Extend = requireExtend$1();

	var Pipelines = {

	    FX: requireFx(),

	    BitmapMaskPipeline: requireBitmapMaskPipeline(),
	    Events: requireEvents$b(),
	    FXPipeline: requireFXPipeline(),
	    LightPipeline: requireLightPipeline(),
	    MobilePipeline: requireMobilePipeline(),
	    MultiPipeline: requireMultiPipeline(),
	    PointLightPipeline: requirePointLightPipeline(),
	    PostFXPipeline: requirePostFXPipeline(),
	    PreFXPipeline: requirePreFXPipeline(),
	    RopePipeline: requireRopePipeline(),
	    SinglePipeline: requireSinglePipeline(),
	    UtilityPipeline: requireUtilityPipeline()

	};

	Pipelines = Extend(false, Pipelines, CONST);

	pipelines = Pipelines;
	return pipelines;
}

var wrappers;
var hasRequiredWrappers;

function requireWrappers () {
	if (hasRequiredWrappers) return wrappers;
	hasRequiredWrappers = 1;
	var Wrappers = {
	    WebGLAttribLocationWrapper: requireWebGLAttribLocationWrapper(),
	    WebGLBufferWrapper: requireWebGLBufferWrapper(),
	    WebGLProgramWrapper: requireWebGLProgramWrapper(),
	    WebGLTextureWrapper: requireWebGLTextureWrapper(),
	    WebGLFramebufferWrapper: requireWebGLFramebufferWrapper(),
	    WebGLUniformLocationWrapper: requireWebGLUniformLocationWrapper()
	};

	wrappers = Wrappers;
	return wrappers;
}

var webgl;
var hasRequiredWebgl;

function requireWebgl () {
	if (hasRequiredWebgl) return webgl;
	hasRequiredWebgl = 1;
	var WEBGL_CONST = require_const$8();
	var Extend = requireExtend$1();

	var WebGL = {

	    PipelineManager: requirePipelineManager(),
	    Pipelines: requirePipelines(),
	    RenderTarget: requireRenderTarget(),
	    Utils: requireUtils$1(),
	    WebGLPipeline: requireWebGLPipeline(),
	    WebGLRenderer: requireWebGLRenderer(),
	    WebGLShader: requireWebGLShader(),
	    Wrappers: requireWrappers()

	};

	WebGL = Extend(false, WebGL, WEBGL_CONST);

	webgl = WebGL;
	return webgl;
}

var hasRequiredRenderer;

function requireRenderer () {
	if (hasRequiredRenderer) return renderer.exports;
	hasRequiredRenderer = 1;
	renderer.exports = {

	    Events: requireEvents$d(),
	    Snapshot: requireSnapshot()

	};

	if (typeof CANVAS_RENDERER)
	{
	    renderer.exports.Canvas = requireCanvas();
	}

	if (typeof WEBGL_RENDERER)
	{
	    renderer.exports.WebGL = requireWebgl();
	}
	return renderer.exports;
}

var scale;
var hasRequiredScale;

function requireScale () {
	if (hasRequiredScale) return scale;
	hasRequiredScale = 1;
	var Extend = requireExtend$1();
	var CONST = require_const$7();

	var Scale = {

	    Center: requireCENTER_CONST(),
	    Events: requireEvents$e(),
	    Orientation: requireORIENTATION_CONST$1(),
	    ScaleManager: requireScaleManager(),
	    ScaleModes: requireSCALE_MODE_CONST(),
	    Zoom: requireZOOM_CONST()

	};

	Scale = Extend(false, Scale, CONST.CENTER);
	Scale = Extend(false, Scale, CONST.ORIENTATION);
	Scale = Extend(false, Scale, CONST.SCALE_MODE);
	Scale = Extend(false, Scale, CONST.ZOOM);

	scale = Scale;
	return scale;
}

var ScenePlugin_1;
var hasRequiredScenePlugin;

function requireScenePlugin () {
	if (hasRequiredScenePlugin) return ScenePlugin_1;
	hasRequiredScenePlugin = 1;
	var Clamp = requireClamp();
	var Class = requireClass();
	var Events = requireEvents$l();
	var GetFastValue = requireGetFastValue();
	var PluginCache = requirePluginCache();

	var ScenePlugin = new Class({

	    initialize:

	    function ScenePlugin (scene)
	    {

	        this.scene = scene;

	        this.systems = scene.sys;

	        this.settings = scene.sys.settings;

	        this.key = scene.sys.settings.key;

	        this.manager = scene.sys.game.scene;

	        this.transitionProgress = 0;

	        this._elapsed = 0;

	        this._target = null;

	        this._duration = 0;

	        this._onUpdate;

	        this._onUpdateScope;

	        this._willSleep = false;

	        this._willRemove = false;

	        scene.sys.events.once(Events.BOOT, this.boot, this);
	        scene.sys.events.on(Events.START, this.pluginStart, this);
	    },

	    boot: function ()
	    {
	        this.systems.events.once(Events.DESTROY, this.destroy, this);
	    },

	    pluginStart: function ()
	    {
	        this._target = null;

	        this.systems.events.once(Events.SHUTDOWN, this.shutdown, this);
	    },

	    start: function (key, data)
	    {
	        if (key === undefined) { key = this.key; }

	        this.manager.queueOp('stop', this.key);
	        this.manager.queueOp('start', key, data);

	        return this;
	    },

	    restart: function (data)
	    {
	        var key = this.key;

	        this.manager.queueOp('stop', key);
	        this.manager.queueOp('start', key, data);

	        return this;
	    },

	    transition: function (config)
	    {
	        if (config === undefined) { config = {}; }

	        var key = GetFastValue(config, 'target', false);

	        var target = this.manager.getScene(key);

	        if (!key || !this.checkValidTransition(target))
	        {
	            return false;
	        }

	        var duration = GetFastValue(config, 'duration', 1000);

	        this._elapsed = 0;
	        this._target = target;
	        this._duration = duration;
	        this._willSleep = GetFastValue(config, 'sleep', false);
	        this._willRemove = GetFastValue(config, 'remove', false);

	        var callback = GetFastValue(config, 'onUpdate', null);

	        if (callback)
	        {
	            this._onUpdate = callback;
	            this._onUpdateScope = GetFastValue(config, 'onUpdateScope', this.scene);
	        }

	        var allowInput = GetFastValue(config, 'allowInput', false);

	        this.settings.transitionAllowInput = allowInput;

	        var targetSettings = target.sys.settings;

	        targetSettings.isTransition = true;
	        targetSettings.transitionFrom = this.scene;
	        targetSettings.transitionDuration = duration;
	        targetSettings.transitionAllowInput = allowInput;

	        if (GetFastValue(config, 'moveAbove', false))
	        {
	            this.manager.moveAbove(this.key, key);
	        }
	        else if (GetFastValue(config, 'moveBelow', false))
	        {
	            this.manager.moveBelow(this.key, key);
	        }

	        if (target.sys.isSleeping())
	        {
	            target.sys.wake(GetFastValue(config, 'data'));
	        }
	        else
	        {
	            this.manager.start(key, GetFastValue(config, 'data'));
	        }

	        var onStartCallback = GetFastValue(config, 'onStart', null);

	        var onStartScope = GetFastValue(config, 'onStartScope', this.scene);

	        if (onStartCallback)
	        {
	            onStartCallback.call(onStartScope, this.scene, target, duration);
	        }

	        this.systems.events.emit(Events.TRANSITION_OUT, target, duration);

	        return true;
	    },

	    checkValidTransition: function (target)
	    {

	        if (!target || target.sys.isActive() || target.sys.isTransitioning() || target === this.scene || this.systems.isTransitioning())
	        {
	            return false;
	        }

	        return true;
	    },

	    step: function (time, delta)
	    {
	        this._elapsed += delta;

	        this.transitionProgress = Clamp(this._elapsed / this._duration, 0, 1);

	        if (this._onUpdate)
	        {
	            this._onUpdate.call(this._onUpdateScope, this.transitionProgress);
	        }

	        if (this._elapsed >= this._duration)
	        {
	            this.transitionComplete();
	        }
	    },

	    transitionComplete: function ()
	    {
	        var targetSys = this._target.sys;
	        var targetSettings = this._target.sys.settings;

	        targetSys.events.emit(Events.TRANSITION_COMPLETE, this.scene);

	        targetSettings.isTransition = false;
	        targetSettings.transitionFrom = null;

	        this._duration = 0;
	        this._target = null;
	        this._onUpdate = null;
	        this._onUpdateScope = null;

	        if (this._willRemove)
	        {
	            this.manager.remove(this.key);
	        }
	        else if (this._willSleep)
	        {
	            this.systems.sleep();
	        }
	        else
	        {
	            this.manager.stop(this.key);
	        }
	    },

	    add: function (key, sceneConfig, autoStart, data)
	    {
	        return this.manager.add(key, sceneConfig, autoStart, data);
	    },

	    launch: function (key, data)
	    {
	        if (key && key !== this.key)
	        {
	            this.manager.queueOp('start', key, data);
	        }

	        return this;
	    },

	    run: function (key, data)
	    {
	        if (key && key !== this.key)
	        {
	            this.manager.queueOp('run', key, data);
	        }

	        return this;
	    },

	    pause: function (key, data)
	    {
	        if (key === undefined) { key = this.key; }

	        this.manager.queueOp('pause', key, data);

	        return this;
	    },

	    resume: function (key, data)
	    {
	        if (key === undefined) { key = this.key; }

	        this.manager.queueOp('resume', key, data);

	        return this;
	    },

	    sleep: function (key, data)
	    {
	        if (key === undefined) { key = this.key; }

	        this.manager.queueOp('sleep', key, data);

	        return this;
	    },

	    wake: function (key, data)
	    {
	        if (key === undefined) { key = this.key; }

	        this.manager.queueOp('wake', key, data);

	        return this;
	    },

	    switch: function (key, data)
	    {
	        if (key !== this.key)
	        {
	            this.manager.queueOp('switch', this.key, key, data);
	        }

	        return this;
	    },

	    stop: function (key, data)
	    {
	        if (key === undefined) { key = this.key; }

	        this.manager.queueOp('stop', key, data);

	        return this;
	    },

	    setActive: function (value, key, data)
	    {
	        if (key === undefined) { key = this.key; }

	        var scene = this.manager.getScene(key);

	        if (scene)
	        {
	            scene.sys.setActive(value, data);
	        }

	        return this;
	    },

	    setVisible: function (value, key)
	    {
	        if (key === undefined) { key = this.key; }

	        var scene = this.manager.getScene(key);

	        if (scene)
	        {
	            scene.sys.setVisible(value);
	        }

	        return this;
	    },

	    isSleeping: function (key)
	    {
	        if (key === undefined) { key = this.key; }

	        return this.manager.isSleeping(key);
	    },

	    isActive: function (key)
	    {
	        if (key === undefined) { key = this.key; }

	        return this.manager.isActive(key);
	    },

	    isPaused: function (key)
	    {
	        if (key === undefined) { key = this.key; }

	        return this.manager.isPaused(key);
	    },

	    isVisible: function (key)
	    {
	        if (key === undefined) { key = this.key; }

	        return this.manager.isVisible(key);
	    },

	    swapPosition: function (keyA, keyB)
	    {
	        if (keyB === undefined) { keyB = this.key; }

	        if (keyA !== keyB)
	        {
	            this.manager.swapPosition(keyA, keyB);
	        }

	        return this;
	    },

	    moveAbove: function (keyA, keyB)
	    {
	        if (keyB === undefined) { keyB = this.key; }

	        if (keyA !== keyB)
	        {
	            this.manager.moveAbove(keyA, keyB);
	        }

	        return this;
	    },

	    moveBelow: function (keyA, keyB)
	    {
	        if (keyB === undefined) { keyB = this.key; }

	        if (keyA !== keyB)
	        {
	            this.manager.moveBelow(keyA, keyB);
	        }

	        return this;
	    },

	    remove: function (key)
	    {
	        if (key === undefined) { key = this.key; }

	        this.manager.remove(key);

	        return this;
	    },

	    moveUp: function (key)
	    {
	        if (key === undefined) { key = this.key; }

	        this.manager.moveUp(key);

	        return this;
	    },

	    moveDown: function (key)
	    {
	        if (key === undefined) { key = this.key; }

	        this.manager.moveDown(key);

	        return this;
	    },

	    bringToTop: function (key)
	    {
	        if (key === undefined) { key = this.key; }

	        this.manager.bringToTop(key);

	        return this;
	    },

	    sendToBack: function (key)
	    {
	        if (key === undefined) { key = this.key; }

	        this.manager.sendToBack(key);

	        return this;
	    },

	    get: function (key)
	    {
	        return this.manager.getScene(key);
	    },

	    getStatus: function (key)
	    {
	        var scene = this.manager.getScene(key);

	        if (scene)
	        {
	            return scene.sys.getStatus();
	        }
	    },

	    getIndex: function (key)
	    {
	        if (key === undefined) { key = this.key; }

	        return this.manager.getIndex(key);
	    },

	    shutdown: function ()
	    {
	        var eventEmitter = this.systems.events;

	        eventEmitter.off(Events.SHUTDOWN, this.shutdown, this);
	        eventEmitter.off(Events.TRANSITION_OUT);
	    },

	    destroy: function ()
	    {
	        this.shutdown();

	        this.scene.sys.events.off(Events.START, this.start, this);

	        this.scene = null;
	        this.systems = null;
	        this.settings = null;
	        this.manager = null;
	    }

	});

	PluginCache.register('ScenePlugin', ScenePlugin, 'scenePlugin');

	ScenePlugin_1 = ScenePlugin;
	return ScenePlugin_1;
}

var scene;
var hasRequiredScene;

function requireScene () {
	if (hasRequiredScene) return scene;
	hasRequiredScene = 1;
	var CONST = require_const$5();
	var Extend = requireExtend$1();

	var Scene = {

	    Events: requireEvents$l(),
	    GetPhysicsPlugins: requireGetPhysicsPlugins(),
	    GetScenePlugins: requireGetScenePlugins(),
	    SceneManager: requireSceneManager(),
	    ScenePlugin: requireScenePlugin(),
	    Settings: requireSettings(),
	    Systems: requireSystems()

	};

	Scene = Extend(false, Scene, CONST);

	scene = Scene;
	return scene;
}

var structs;
var hasRequiredStructs;

function requireStructs () {
	if (hasRequiredStructs) return structs;
	hasRequiredStructs = 1;
	structs = {

	    Events: requireEvents$7(),
	    List: requireList(),
	    Map: require_Map(),
	    ProcessQueue: requireProcessQueue(),
	    RTree: requireRTree(),
	    Set: require_Set(),
	    Size: requireSize$1()

	};
	return structs;
}

var _const$1;
var hasRequired_const$1;

function require_const$1 () {
	if (hasRequired_const$1) return _const$1;
	hasRequired_const$1 = 1;
	var CONST = {

	    LINEAR: 0,

	    NEAREST: 1

	};

	_const$1 = CONST;
	return _const$1;
}

var textures;
var hasRequiredTextures;

function requireTextures () {
	if (hasRequiredTextures) return textures;
	hasRequiredTextures = 1;
	var Extend = requireExtend$1();
	var FilterMode = require_const$1();

	var Textures = {

	    CanvasTexture: requireCanvasTexture(),
	    DynamicTexture: requireDynamicTexture(),
	    Events: requireEvents$c(),
	    FilterMode: FilterMode,
	    Frame: requireFrame(),
	    Parsers: requireParsers$1(),
	    Texture: requireTexture(),
	    TextureManager: requireTextureManager(),
	    TextureSource: requireTextureSource()

	};

	Textures = Extend(false, Textures, FilterMode);

	textures = Textures;
	return textures;
}

var ORIENTATION_CONST;
var hasRequiredORIENTATION_CONST;

function requireORIENTATION_CONST () {
	if (hasRequiredORIENTATION_CONST) return ORIENTATION_CONST;
	hasRequiredORIENTATION_CONST = 1;
	ORIENTATION_CONST = {

	    ORTHOGONAL: 0,

	    ISOMETRIC: 1,

	    STAGGERED: 2,

	    HEXAGONAL: 3

	};
	return ORIENTATION_CONST;
}

var _const;
var hasRequired_const;

function require_const () {
	if (hasRequired_const) return _const;
	hasRequired_const = 1;
	var CONST = {

	    ORIENTATION: requireORIENTATION_CONST()

	};

	_const = CONST;
	return _const;
}

var IsInLayerBounds_1;
var hasRequiredIsInLayerBounds;

function requireIsInLayerBounds () {
	if (hasRequiredIsInLayerBounds) return IsInLayerBounds_1;
	hasRequiredIsInLayerBounds = 1;
	var IsInLayerBounds = function (tileX, tileY, layer)
	{
	    return (tileX >= 0 && tileX < layer.width && tileY >= 0 && tileY < layer.height);
	};

	IsInLayerBounds_1 = IsInLayerBounds;
	return IsInLayerBounds_1;
}

var GetTileAt_1;
var hasRequiredGetTileAt;

function requireGetTileAt () {
	if (hasRequiredGetTileAt) return GetTileAt_1;
	hasRequiredGetTileAt = 1;
	var IsInLayerBounds = requireIsInLayerBounds();

	var GetTileAt = function (tileX, tileY, nonNull, layer)
	{
	    if (IsInLayerBounds(tileX, tileY, layer))
	    {
	        var tile = layer.data[tileY][tileX] || null;

	        if (!tile)
	        {
	            return null;
	        }
	        else if (tile.index === -1)
	        {
	            return nonNull ? tile : null;
	        }
	        else
	        {
	            return tile;
	        }
	    }
	    else
	    {
	        return null;
	    }
	};

	GetTileAt_1 = GetTileAt;
	return GetTileAt_1;
}

var CalculateFacesAt_1;
var hasRequiredCalculateFacesAt;

function requireCalculateFacesAt () {
	if (hasRequiredCalculateFacesAt) return CalculateFacesAt_1;
	hasRequiredCalculateFacesAt = 1;
	var GetTileAt = requireGetTileAt();

	var CalculateFacesAt = function (tileX, tileY, layer)
	{
	    var tile = GetTileAt(tileX, tileY, true, layer);
	    var above = GetTileAt(tileX, tileY - 1, true, layer);
	    var below = GetTileAt(tileX, tileY + 1, true, layer);
	    var left = GetTileAt(tileX - 1, tileY, true, layer);
	    var right = GetTileAt(tileX + 1, tileY, true, layer);
	    var tileCollides = tile && tile.collides;

	    if (tileCollides)
	    {
	        tile.faceTop = true;
	        tile.faceBottom = true;
	        tile.faceLeft = true;
	        tile.faceRight = true;
	    }

	    if (above && above.collides)
	    {
	        if (tileCollides)
	        {
	            tile.faceTop = false;
	        }

	        above.faceBottom = !tileCollides;
	    }

	    if (below && below.collides)
	    {
	        if (tileCollides)
	        {
	            tile.faceBottom = false;
	        }

	        below.faceTop = !tileCollides;
	    }

	    if (left && left.collides)
	    {
	        if (tileCollides)
	        {
	            tile.faceLeft = false;
	        }

	        left.faceRight = !tileCollides;
	    }

	    if (right && right.collides)
	    {
	        if (tileCollides)
	        {
	            tile.faceRight = false;
	        }

	        right.faceLeft = !tileCollides;
	    }

	    if (tile && !tile.collides)
	    {
	        tile.resetFaces();
	    }

	    return tile;
	};

	CalculateFacesAt_1 = CalculateFacesAt;
	return CalculateFacesAt_1;
}

var CalculateFacesWithin_1;
var hasRequiredCalculateFacesWithin;

function requireCalculateFacesWithin () {
	if (hasRequiredCalculateFacesWithin) return CalculateFacesWithin_1;
	hasRequiredCalculateFacesWithin = 1;
	var GetTileAt = requireGetTileAt();
	var GetTilesWithin = requireGetTilesWithin();

	var CalculateFacesWithin = function (tileX, tileY, width, height, layer)
	{
	    var above = null;
	    var below = null;
	    var left = null;
	    var right = null;

	    var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);

	    for (var i = 0; i < tiles.length; i++)
	    {
	        var tile = tiles[i];

	        if (tile)
	        {
	            if (tile.collides)
	            {
	                above = GetTileAt(tile.x, tile.y - 1, true, layer);
	                below = GetTileAt(tile.x, tile.y + 1, true, layer);
	                left = GetTileAt(tile.x - 1, tile.y, true, layer);
	                right = GetTileAt(tile.x + 1, tile.y, true, layer);

	                tile.faceTop = (above && above.collides) ? false : true;
	                tile.faceBottom = (below && below.collides) ? false : true;
	                tile.faceLeft = (left && left.collides) ? false : true;
	                tile.faceRight = (right && right.collides) ? false : true;
	            }
	            else
	            {
	                tile.resetFaces();
	            }
	        }
	    }
	};

	CalculateFacesWithin_1 = CalculateFacesWithin;
	return CalculateFacesWithin_1;
}

var CheckIsoBounds_1;
var hasRequiredCheckIsoBounds;

function requireCheckIsoBounds () {
	if (hasRequiredCheckIsoBounds) return CheckIsoBounds_1;
	hasRequiredCheckIsoBounds = 1;
	var Vector2 = requireVector2();

	var point = new Vector2();

	var CheckIsoBounds = function (tileX, tileY, layer, camera)
	{
	    var tilemapLayer = layer.tilemapLayer;

	    var cullPaddingX = tilemapLayer.cullPaddingX;
	    var cullPaddingY = tilemapLayer.cullPaddingY;

	    var pos = tilemapLayer.tilemap.tileToWorldXY(tileX, tileY, point, camera, tilemapLayer);

	    return pos.x > camera.worldView.x + tilemapLayer.scaleX * layer.tileWidth * (-cullPaddingX - 0.5)
	        && pos.x < camera.worldView.right + tilemapLayer.scaleX * layer.tileWidth * (cullPaddingX - 0.5)
	        && pos.y > camera.worldView.y + tilemapLayer.scaleY * layer.tileHeight * (-cullPaddingY - 1.0)
	        && pos.y < camera.worldView.bottom + tilemapLayer.scaleY * layer.tileHeight * (cullPaddingY - 0.5);
	};

	CheckIsoBounds_1 = CheckIsoBounds;
	return CheckIsoBounds_1;
}

var Tile_1;
var hasRequiredTile;

function requireTile () {
	if (hasRequiredTile) return Tile_1;
	hasRequiredTile = 1;
	var Class = requireClass();
	var Components = requireComponents$2();
	var CONST = requireORIENTATION_CONST();
	var DeepCopy = requireDeepCopy();
	var Rectangle = requireRectangle();

	var Tile = new Class({

	    Mixins: [
	        Components.AlphaSingle,
	        Components.Flip,
	        Components.Visible
	    ],

	    initialize:

	    function Tile (layer, index, x, y, width, height, baseWidth, baseHeight)
	    {

	        this.layer = layer;

	        this.index = index;

	        this.x = x;

	        this.y = y;

	        this.width = width;

	        this.height = height;

	        this.right;

	        this.bottom;

	        this.baseWidth = (baseWidth !== undefined) ? baseWidth : width;

	        this.baseHeight = (baseHeight !== undefined) ? baseHeight : height;

	        this.pixelX = 0;

	        this.pixelY = 0;

	        this.updatePixelXY();

	        this.properties = {};

	        this.rotation = 0;

	        this.collideLeft = false;

	        this.collideRight = false;

	        this.collideUp = false;

	        this.collideDown = false;

	        this.faceLeft = false;

	        this.faceRight = false;

	        this.faceTop = false;

	        this.faceBottom = false;

	        this.collisionCallback = undefined;

	        this.collisionCallbackContext = this;

	        this.tint = 0xffffff;

	        this.tintFill = false;

	        this.physics = {};
	    },

	    containsPoint: function (x, y)
	    {
	        return !(x < this.pixelX || y < this.pixelY || x > this.right || y > this.bottom);
	    },

	    copy: function (tile)
	    {
	        this.index = tile.index;
	        this.alpha = tile.alpha;
	        this.properties = DeepCopy(tile.properties);
	        this.visible = tile.visible;
	        this.setFlip(tile.flipX, tile.flipY);
	        this.tint = tile.tint;
	        this.rotation = tile.rotation;
	        this.collideUp = tile.collideUp;
	        this.collideDown = tile.collideDown;
	        this.collideLeft = tile.collideLeft;
	        this.collideRight = tile.collideRight;
	        this.collisionCallback = tile.collisionCallback;
	        this.collisionCallbackContext = tile.collisionCallbackContext;

	        return this;
	    },

	    getCollisionGroup: function ()
	    {
	        return this.tileset ? this.tileset.getTileCollisionGroup(this.index) : null;
	    },

	    getTileData: function ()
	    {
	        return this.tileset ? this.tileset.getTileData(this.index) : null;
	    },

	    getLeft: function (camera)
	    {
	        var tilemapLayer = this.tilemapLayer;

	        if (tilemapLayer)
	        {
	            var point = tilemapLayer.tileToWorldXY(this.x, this.y, undefined, camera);

	            return point.x;
	        }

	        return this.x * this.baseWidth;
	    },

	    getRight: function (camera)
	    {
	        var tilemapLayer = this.tilemapLayer;

	        return (tilemapLayer) ? this.getLeft(camera) + this.width * tilemapLayer.scaleX : this.getLeft(camera) + this.width;
	    },

	    getTop: function (camera)
	    {
	        var tilemapLayer = this.tilemapLayer;

	        if (tilemapLayer)
	        {
	            var point = tilemapLayer.tileToWorldXY(this.x, this.y, undefined, camera);

	            return point.y;
	        }

	        return this.y * this.baseWidth - (this.height - this.baseHeight);
	    },

	    getBottom: function (camera)
	    {
	        var tilemapLayer = this.tilemapLayer;

	        return tilemapLayer
	            ? this.getTop(camera) + this.height * tilemapLayer.scaleY
	            : this.getTop(camera) + this.height;
	    },

	    getBounds: function (camera, output)
	    {
	        if (output === undefined) { output = new Rectangle(); }

	        output.x = this.getLeft(camera);
	        output.y = this.getTop(camera);
	        output.width = this.getRight(camera) - output.x;
	        output.height = this.getBottom(camera) - output.y;

	        return output;
	    },

	    getCenterX: function (camera)
	    {
	        return (this.getLeft(camera) + this.getRight(camera)) / 2;
	    },

	    getCenterY: function (camera)
	    {
	        return (this.getTop(camera) + this.getBottom(camera)) / 2;
	    },

	    intersects: function (x, y, right, bottom)
	    {
	        return !(
	            right <= this.pixelX || bottom <= this.pixelY ||
	            x >= this.right || y >= this.bottom
	        );
	    },

	    isInteresting: function (collides, faces)
	    {
	        if (collides && faces)
	        {
	            return (this.canCollide || this.hasInterestingFace);
	        }
	        else if (collides)
	        {
	            return this.collides;
	        }
	        else if (faces)
	        {
	            return this.hasInterestingFace;
	        }

	        return false;
	    },

	    resetCollision: function (recalculateFaces)
	    {
	        if (recalculateFaces === undefined) { recalculateFaces = true; }

	        this.collideLeft = false;
	        this.collideRight = false;
	        this.collideUp = false;
	        this.collideDown = false;

	        this.faceTop = false;
	        this.faceBottom = false;
	        this.faceLeft = false;
	        this.faceRight = false;

	        if (recalculateFaces)
	        {
	            var tilemapLayer = this.tilemapLayer;

	            if (tilemapLayer)
	            {
	                this.tilemapLayer.calculateFacesAt(this.x, this.y);
	            }
	        }

	        return this;
	    },

	    resetFaces: function ()
	    {
	        this.faceTop = false;
	        this.faceBottom = false;
	        this.faceLeft = false;
	        this.faceRight = false;

	        return this;
	    },

	    setCollision: function (left, right, up, down, recalculateFaces)
	    {
	        if (right === undefined) { right = left; }
	        if (up === undefined) { up = left; }
	        if (down === undefined) { down = left; }
	        if (recalculateFaces === undefined) { recalculateFaces = true; }

	        this.collideLeft = left;
	        this.collideRight = right;
	        this.collideUp = up;
	        this.collideDown = down;

	        this.faceLeft = left;
	        this.faceRight = right;
	        this.faceTop = up;
	        this.faceBottom = down;

	        if (recalculateFaces)
	        {
	            var tilemapLayer = this.tilemapLayer;

	            if (tilemapLayer)
	            {
	                this.tilemapLayer.calculateFacesAt(this.x, this.y);
	            }
	        }

	        return this;
	    },

	    setCollisionCallback: function (callback, context)
	    {
	        if (callback === null)
	        {
	            this.collisionCallback = undefined;
	            this.collisionCallbackContext = undefined;
	        }
	        else
	        {
	            this.collisionCallback = callback;
	            this.collisionCallbackContext = context;
	        }

	        return this;
	    },

	    setSize: function (tileWidth, tileHeight, baseWidth, baseHeight)
	    {
	        if (tileWidth !== undefined) { this.width = tileWidth; }
	        if (tileHeight !== undefined) { this.height = tileHeight; }
	        if (baseWidth !== undefined) { this.baseWidth = baseWidth; }
	        if (baseHeight !== undefined) { this.baseHeight = baseHeight; }

	        this.updatePixelXY();

	        return this;
	    },

	    updatePixelXY: function ()
	    {
	        var orientation = this.layer.orientation;

	        if (orientation === CONST.ORTHOGONAL)
	        {

	            this.pixelX = this.x * this.baseWidth;
	            this.pixelY = this.y * this.baseHeight;
	        }
	        else if (orientation === CONST.ISOMETRIC)
	        {

	            this.pixelX = (this.x - this.y) * this.baseWidth * 0.5;
	            this.pixelY = (this.x + this.y) * this.baseHeight * 0.5;
	        }
	        else if (orientation === CONST.STAGGERED)
	        {
	            this.pixelX = this.x * this.baseWidth + this.y % 2 * (this.baseWidth / 2);
	            this.pixelY = this.y * (this.baseHeight / 2);
	        }
	        else if (orientation === CONST.HEXAGONAL)
	        {
	            var staggerAxis = this.layer.staggerAxis;
	            var staggerIndex = this.layer.staggerIndex;
	            var len = this.layer.hexSideLength;
	            var rowWidth;
	            var rowHeight;

	            if (staggerAxis === 'y')
	            {
	                rowHeight = ((this.baseHeight - len) / 2 + len);

	                if (staggerIndex === 'odd')
	                {
	                    this.pixelX = this.x * this.baseWidth + this.y % 2 * (this.baseWidth / 2);
	                }
	                else
	                {
	                    this.pixelX = this.x * this.baseWidth - this.y % 2 * (this.baseWidth / 2);
	                }

	                this.pixelY = this.y * rowHeight;
	            }
	            else if (staggerAxis === 'x')
	            {
	                rowWidth = ((this.baseWidth - len) / 2 + len);

	                this.pixelX = this.x * rowWidth;

	                if (staggerIndex === 'odd')
	                {
	                    this.pixelY = this.y * this.baseHeight + this.x % 2 * (this.baseHeight / 2);
	                }
	                else
	                {
	                    this.pixelY = this.y * this.baseHeight - this.x % 2 * (this.baseHeight / 2);
	                }
	            }
	        }

	        this.right = this.pixelX + this.baseWidth;
	        this.bottom = this.pixelY + this.baseHeight;

	        return this;
	    },

	    destroy: function ()
	    {
	        this.collisionCallback = undefined;
	        this.collisionCallbackContext = undefined;
	        this.properties = undefined;
	    },

	    canCollide: {

	        get: function ()
	        {
	            return (this.collideLeft || this.collideRight || this.collideUp || this.collideDown || (this.collisionCallback !== undefined));
	        }

	    },

	    collides: {

	        get: function ()
	        {
	            return (this.collideLeft || this.collideRight || this.collideUp || this.collideDown);
	        }

	    },

	    hasInterestingFace: {

	        get: function ()
	        {
	            return (this.faceTop || this.faceBottom || this.faceLeft || this.faceRight);
	        }

	    },

	    tileset: {

	        get: function ()
	        {
	            var tilemapLayer = this.layer.tilemapLayer;

	            if (tilemapLayer)
	            {
	                var tileset = tilemapLayer.gidMap[this.index];

	                if (tileset)
	                {
	                    return tileset;
	                }
	            }

	            return null;
	        }

	    },

	    tilemapLayer: {

	        get: function ()
	        {
	            return this.layer.tilemapLayer;
	        }

	    },

	    tilemap: {

	        get: function ()
	        {
	            var tilemapLayer = this.tilemapLayer;

	            return tilemapLayer ? tilemapLayer.tilemap : null;
	        }

	    }

	});

	Tile_1 = Tile;
	return Tile_1;
}

var Copy_1;
var hasRequiredCopy;

function requireCopy () {
	if (hasRequiredCopy) return Copy_1;
	hasRequiredCopy = 1;
	var CalculateFacesWithin = requireCalculateFacesWithin();
	var GetTilesWithin = requireGetTilesWithin();
	var IsInLayerBounds = requireIsInLayerBounds();
	var Tile = requireTile();

	var Copy = function (srcTileX, srcTileY, width, height, destTileX, destTileY, recalculateFaces, layer)
	{
	    if (recalculateFaces === undefined) { recalculateFaces = true; }

	    var srcTiles = GetTilesWithin(srcTileX, srcTileY, width, height, null, layer);

	    var copyTiles = [];

	    srcTiles.forEach(function (tile)
	    {
	        var newTile = new Tile(
	            tile.layer,
	            tile.index,
	            tile.x,
	            tile.y,
	            tile.width,
	            tile.height,
	            tile.baseWidth,
	            tile.baseHeight
	        );

	        newTile.copy(tile);

	        copyTiles.push(newTile);
	    });

	    var offsetX = destTileX - srcTileX;
	    var offsetY = destTileY - srcTileY;

	    for (var i = 0; i < copyTiles.length; i++)
	    {
	        var copy = copyTiles[i];
	        var tileX = copy.x + offsetX;
	        var tileY = copy.y + offsetY;

	        if (IsInLayerBounds(tileX, tileY, layer))
	        {
	            if (layer.data[tileY][tileX])
	            {
	                copy.x = tileX;
	                copy.y = tileY;
	                copy.updatePixelXY();

	                layer.data[tileY][tileX] = copy;
	            }
	        }
	    }

	    if (recalculateFaces)
	    {

	        CalculateFacesWithin(destTileX - 1, destTileY - 1, width + 2, height + 2, layer);
	    }

	    srcTiles.length = 0;
	    copyTiles.length = 0;
	};

	Copy_1 = Copy;
	return Copy_1;
}

var ReplaceByIndex_1;
var hasRequiredReplaceByIndex;

function requireReplaceByIndex () {
	if (hasRequiredReplaceByIndex) return ReplaceByIndex_1;
	hasRequiredReplaceByIndex = 1;
	var GetTilesWithin = requireGetTilesWithin();

	var ReplaceByIndex = function (findIndex, newIndex, tileX, tileY, width, height, layer)
	{
	    var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);

	    for (var i = 0; i < tiles.length; i++)
	    {
	        if (tiles[i] && tiles[i].index === findIndex)
	        {
	            tiles[i].index = newIndex;
	        }
	    }
	};

	ReplaceByIndex_1 = ReplaceByIndex;
	return ReplaceByIndex_1;
}

var CreateFromTiles_1;
var hasRequiredCreateFromTiles;

function requireCreateFromTiles () {
	if (hasRequiredCreateFromTiles) return CreateFromTiles_1;
	hasRequiredCreateFromTiles = 1;
	var DeepCopy = requireDeepCopy();
	var GetTilesWithin = requireGetTilesWithin();
	var ReplaceByIndex = requireReplaceByIndex();

	var CreateFromTiles = function (indexes, replacements, spriteConfig, scene, camera, layer)
	{
	    if (!spriteConfig) { spriteConfig = {}; }

	    if (!Array.isArray(indexes))
	    {
	        indexes = [ indexes ];
	    }

	    var tilemapLayer = layer.tilemapLayer;

	    if (!scene) { scene = tilemapLayer.scene; }
	    if (!camera) { camera = scene.cameras.main; }

	    var layerWidth = layer.width;
	    var layerHeight = layer.height;

	    var tiles = GetTilesWithin(0, 0, layerWidth, layerHeight, null, layer);
	    var sprites = [];
	    var i;

	    var mergeExtras = function (config, tile, properties)
	    {
	        for (var i = 0; i < properties.length; i++)
	        {
	            var property = properties[i];

	            if (!config.hasOwnProperty(property))
	            {
	                config[property] = tile[property];
	            }
	        }
	    };

	    for (i = 0; i < tiles.length; i++)
	    {
	        var tile = tiles[i];
	        var config = DeepCopy(spriteConfig);

	        if (indexes.indexOf(tile.index) !== -1)
	        {
	            var point = tilemapLayer.tileToWorldXY(tile.x, tile.y, undefined, camera,layer);

	            config.x = point.x;
	            config.y = point.y;

	            mergeExtras(config, tile, [ 'rotation', 'flipX', 'flipY', 'alpha', 'visible', 'tint' ]);

	            if (!config.hasOwnProperty('origin'))
	            {
	                config.x += tile.width * 0.5;
	                config.y += tile.height * 0.5;
	            }

	            if (config.hasOwnProperty('useSpriteSheet'))
	            {
	                config.key = tile.tileset.image;
	                config.frame = tile.index - tile.tileset.firstgid;
	            }

	            sprites.push(scene.make.sprite(config));
	        }
	    }

	    if (Array.isArray(replacements))
	    {

	        for (i = 0; i < indexes.length; i++)
	        {
	            ReplaceByIndex(indexes[i], replacements[i], 0, 0, layerWidth, layerHeight, layer);
	        }
	    }
	    else if (replacements !== null)
	    {

	        for (i = 0; i < indexes.length; i++)
	        {
	            ReplaceByIndex(indexes[i], replacements, 0, 0, layerWidth, layerHeight, layer);
	        }
	    }

	    return sprites;
	};

	CreateFromTiles_1 = CreateFromTiles;
	return CreateFromTiles_1;
}

var CullBounds_1;
var hasRequiredCullBounds;

function requireCullBounds () {
	if (hasRequiredCullBounds) return CullBounds_1;
	hasRequiredCullBounds = 1;
	var Rectangle = requireRectangle$2();
	var SnapCeil = requireSnapCeil();
	var SnapFloor = requireSnapFloor();

	var bounds = new Rectangle();

	var CullBounds = function (layer, camera)
	{
	    var tilemap = layer.tilemapLayer.tilemap;
	    var tilemapLayer = layer.tilemapLayer;

	    var tileW = Math.floor(tilemap.tileWidth * tilemapLayer.scaleX);
	    var tileH = Math.floor(tilemap.tileHeight * tilemapLayer.scaleY);

	    var boundsLeft = SnapFloor(camera.worldView.x - tilemapLayer.x, tileW, 0, true) - tilemapLayer.cullPaddingX;
	    var boundsRight = SnapCeil(camera.worldView.right - tilemapLayer.x, tileW, 0, true) + tilemapLayer.cullPaddingX;

	    var boundsTop = SnapFloor(camera.worldView.y - tilemapLayer.y, tileH, 0, true) - tilemapLayer.cullPaddingY;
	    var boundsBottom = SnapCeil(camera.worldView.bottom - tilemapLayer.y, tileH, 0, true) + tilemapLayer.cullPaddingY;

	    return bounds.setTo(
	        boundsLeft,
	        boundsTop,
	        (boundsRight - boundsLeft),
	        (boundsBottom - boundsTop)
	    );
	};

	CullBounds_1 = CullBounds;
	return CullBounds_1;
}

var RunCull_1;
var hasRequiredRunCull;

function requireRunCull () {
	if (hasRequiredRunCull) return RunCull_1;
	hasRequiredRunCull = 1;
	var RunCull = function (layer, bounds, renderOrder, outputArray)
	{
	    var mapData = layer.data;
	    var mapWidth = layer.width;
	    var mapHeight = layer.height;

	    var tilemapLayer = layer.tilemapLayer;

	    var drawLeft = Math.max(0, bounds.left);
	    var drawRight = Math.min(mapWidth, bounds.right);
	    var drawTop = Math.max(0, bounds.top);
	    var drawBottom = Math.min(mapHeight, bounds.bottom);

	    var x;
	    var y;
	    var tile;

	    if (renderOrder === 0)
	    {

	        for (y = drawTop; y < drawBottom; y++)
	        {
	            for (x = drawLeft; mapData[y] && x < drawRight; x++)
	            {
	                tile = mapData[y][x];

	                if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0)
	                {
	                    continue;
	                }

	                outputArray.push(tile);
	            }
	        }
	    }
	    else if (renderOrder === 1)
	    {

	        for (y = drawTop; y < drawBottom; y++)
	        {
	            for (x = drawRight; mapData[y] && x >= drawLeft; x--)
	            {
	                tile = mapData[y][x];

	                if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0)
	                {
	                    continue;
	                }

	                outputArray.push(tile);
	            }
	        }
	    }
	    else if (renderOrder === 2)
	    {

	        for (y = drawBottom; y >= drawTop; y--)
	        {
	            for (x = drawLeft; mapData[y] && x < drawRight; x++)
	            {
	                tile = mapData[y][x];

	                if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0)
	                {
	                    continue;
	                }

	                outputArray.push(tile);
	            }
	        }
	    }
	    else if (renderOrder === 3)
	    {

	        for (y = drawBottom; y >= drawTop; y--)
	        {
	            for (x = drawRight; mapData[y] && x >= drawLeft; x--)
	            {
	                tile = mapData[y][x];

	                if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0)
	                {
	                    continue;
	                }

	                outputArray.push(tile);
	            }
	        }
	    }

	    tilemapLayer.tilesDrawn = outputArray.length;
	    tilemapLayer.tilesTotal = mapWidth * mapHeight;

	    return outputArray;
	};

	RunCull_1 = RunCull;
	return RunCull_1;
}

var CullTiles_1;
var hasRequiredCullTiles;

function requireCullTiles () {
	if (hasRequiredCullTiles) return CullTiles_1;
	hasRequiredCullTiles = 1;
	var CullBounds = requireCullBounds();
	var RunCull = requireRunCull();

	var CullTiles = function (layer, camera, outputArray, renderOrder)
	{
	    if (outputArray === undefined) { outputArray = []; }
	    if (renderOrder === undefined) { renderOrder = 0; }

	    outputArray.length = 0;

	    var tilemapLayer = layer.tilemapLayer;

	    var bounds = CullBounds(layer, camera);

	    if (tilemapLayer.skipCull || tilemapLayer.scrollFactorX !== 1 || tilemapLayer.scrollFactorY !== 1)
	    {
	        bounds.left = 0;
	        bounds.right = layer.width;
	        bounds.top = 0;
	        bounds.bottom = layer.height;
	    }

	    RunCull(layer, bounds, renderOrder, outputArray);

	    return outputArray;
	};

	CullTiles_1 = CullTiles;
	return CullTiles_1;
}

var SetTileCollision_1;
var hasRequiredSetTileCollision;

function requireSetTileCollision () {
	if (hasRequiredSetTileCollision) return SetTileCollision_1;
	hasRequiredSetTileCollision = 1;
	var SetTileCollision = function (tile, collides)
	{
	    if (collides)
	    {
	        tile.setCollision(true, true, true, true, false);
	    }
	    else
	    {
	        tile.resetCollision(false);
	    }
	};

	SetTileCollision_1 = SetTileCollision;
	return SetTileCollision_1;
}

var Fill_1;
var hasRequiredFill;

function requireFill () {
	if (hasRequiredFill) return Fill_1;
	hasRequiredFill = 1;
	var GetTilesWithin = requireGetTilesWithin();
	var CalculateFacesWithin = requireCalculateFacesWithin();
	var SetTileCollision = requireSetTileCollision();

	var Fill = function (index, tileX, tileY, width, height, recalculateFaces, layer)
	{
	    var doesIndexCollide = (layer.collideIndexes.indexOf(index) !== -1);

	    var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);

	    for (var i = 0; i < tiles.length; i++)
	    {
	        tiles[i].index = index;

	        SetTileCollision(tiles[i], doesIndexCollide);
	    }

	    if (recalculateFaces)
	    {

	        CalculateFacesWithin(tileX - 1, tileY - 1, width + 2, height + 2, layer);
	    }
	};

	Fill_1 = Fill;
	return Fill_1;
}

var FilterTiles_1;
var hasRequiredFilterTiles;

function requireFilterTiles () {
	if (hasRequiredFilterTiles) return FilterTiles_1;
	hasRequiredFilterTiles = 1;
	var GetTilesWithin = requireGetTilesWithin();

	var FilterTiles = function (callback, context, tileX, tileY, width, height, filteringOptions, layer)
	{
	    var tiles = GetTilesWithin(tileX, tileY, width, height, filteringOptions, layer);

	    return tiles.filter(callback, context);
	};

	FilterTiles_1 = FilterTiles;
	return FilterTiles_1;
}

var FindByIndex_1;
var hasRequiredFindByIndex;

function requireFindByIndex () {
	if (hasRequiredFindByIndex) return FindByIndex_1;
	hasRequiredFindByIndex = 1;
	var FindByIndex = function (findIndex, skip, reverse, layer)
	{
	    if (skip === undefined) { skip = 0; }
	    if (reverse === undefined) { reverse = false; }

	    var count = 0;
	    var tx;
	    var ty;
	    var tile;

	    if (reverse)
	    {
	        for (ty = layer.height - 1; ty >= 0; ty--)
	        {
	            for (tx = layer.width - 1; tx >= 0; tx--)
	            {
	                tile = layer.data[ty][tx];
	                if (tile && tile.index === findIndex)
	                {
	                    if (count === skip)
	                    {
	                        return tile;
	                    }
	                    else
	                    {
	                        count += 1;
	                    }
	                }
	            }
	        }
	    }
	    else
	    {
	        for (ty = 0; ty < layer.height; ty++)
	        {
	            for (tx = 0; tx < layer.width; tx++)
	            {
	                tile = layer.data[ty][tx];
	                if (tile && tile.index === findIndex)
	                {
	                    if (count === skip)
	                    {
	                        return tile;
	                    }
	                    else
	                    {
	                        count += 1;
	                    }
	                }
	            }
	        }
	    }

	    return null;
	};

	FindByIndex_1 = FindByIndex;
	return FindByIndex_1;
}

var FindTile_1;
var hasRequiredFindTile;

function requireFindTile () {
	if (hasRequiredFindTile) return FindTile_1;
	hasRequiredFindTile = 1;
	var GetTilesWithin = requireGetTilesWithin();

	var FindTile = function (callback, context, tileX, tileY, width, height, filteringOptions, layer)
	{
	    var tiles = GetTilesWithin(tileX, tileY, width, height, filteringOptions, layer);

	    return tiles.find(callback, context) || null;
	};

	FindTile_1 = FindTile;
	return FindTile_1;
}

var ForEachTile_1;
var hasRequiredForEachTile;

function requireForEachTile () {
	if (hasRequiredForEachTile) return ForEachTile_1;
	hasRequiredForEachTile = 1;
	var GetTilesWithin = requireGetTilesWithin();

	var ForEachTile = function (callback, context, tileX, tileY, width, height, filteringOptions, layer)
	{
	    var tiles = GetTilesWithin(tileX, tileY, width, height, filteringOptions, layer);

	    tiles.forEach(callback, context);
	};

	ForEachTile_1 = ForEachTile;
	return ForEachTile_1;
}

var HexagonalCullBounds_1;
var hasRequiredHexagonalCullBounds;

function requireHexagonalCullBounds () {
	if (hasRequiredHexagonalCullBounds) return HexagonalCullBounds_1;
	hasRequiredHexagonalCullBounds = 1;
	var SnapCeil = requireSnapCeil();
	var SnapFloor = requireSnapFloor();

	var HexagonalCullBounds = function (layer, camera)
	{
	    var tilemap = layer.tilemapLayer.tilemap;
	    var tilemapLayer = layer.tilemapLayer;

	    var tileW = Math.floor(tilemap.tileWidth * tilemapLayer.scaleX);
	    var tileH = Math.floor(tilemap.tileHeight * tilemapLayer.scaleY);

	    var len = layer.hexSideLength;

	    var boundsLeft;
	    var boundsRight;
	    var boundsTop;
	    var boundsBottom;

	    if (layer.staggerAxis === 'y')
	    {
	        var rowH = ((tileH - len) / 2 + len);

	        boundsLeft = SnapFloor(camera.worldView.x - tilemapLayer.x, tileW, 0, true) - tilemapLayer.cullPaddingX;
	        boundsRight = SnapCeil(camera.worldView.right - tilemapLayer.x, tileW, 0, true) + tilemapLayer.cullPaddingX;

	        boundsTop = SnapFloor(camera.worldView.y - tilemapLayer.y, rowH, 0, true) - tilemapLayer.cullPaddingY;
	        boundsBottom = SnapCeil(camera.worldView.bottom - tilemapLayer.y, rowH, 0, true) + tilemapLayer.cullPaddingY;
	    }
	    else
	    {
	        var rowW = ((tileW - len) / 2 + len);

	        boundsLeft = SnapFloor(camera.worldView.x - tilemapLayer.x, rowW, 0, true) - tilemapLayer.cullPaddingX;
	        boundsRight = SnapCeil(camera.worldView.right - tilemapLayer.x, rowW, 0, true) + tilemapLayer.cullPaddingX;

	        boundsTop = SnapFloor(camera.worldView.y - tilemapLayer.y, tileH, 0, true) - tilemapLayer.cullPaddingY;
	        boundsBottom = SnapCeil(camera.worldView.bottom - tilemapLayer.y, tileH, 0, true) + tilemapLayer.cullPaddingY;
	    }

	    return {
	        left: boundsLeft,
	        right: boundsRight,
	        top: boundsTop,
	        bottom: boundsBottom
	    };
	};

	HexagonalCullBounds_1 = HexagonalCullBounds;
	return HexagonalCullBounds_1;
}

var HexagonalCullTiles_1;
var hasRequiredHexagonalCullTiles;

function requireHexagonalCullTiles () {
	if (hasRequiredHexagonalCullTiles) return HexagonalCullTiles_1;
	hasRequiredHexagonalCullTiles = 1;
	var CullBounds = requireHexagonalCullBounds();
	var RunCull = requireRunCull();

	var HexagonalCullTiles = function (layer, camera, outputArray, renderOrder)
	{
	    if (outputArray === undefined) { outputArray = []; }
	    if (renderOrder === undefined) { renderOrder = 0; }

	    outputArray.length = 0;

	    var tilemapLayer = layer.tilemapLayer;

	    var bounds = CullBounds(layer, camera);

	    if (tilemapLayer.skipCull && tilemapLayer.scrollFactorX === 1 && tilemapLayer.scrollFactorY === 1)
	    {
	        bounds.left = 0;
	        bounds.right = layer.width;
	        bounds.top = 0;
	        bounds.bottom = layer.height;
	    }

	    RunCull(layer, bounds, renderOrder, outputArray);

	    return outputArray;
	};

	HexagonalCullTiles_1 = HexagonalCullTiles;
	return HexagonalCullTiles_1;
}

var IsometricCullTiles_1;
var hasRequiredIsometricCullTiles;

function requireIsometricCullTiles () {
	if (hasRequiredIsometricCullTiles) return IsometricCullTiles_1;
	hasRequiredIsometricCullTiles = 1;
	var CheckIsoBounds = requireCheckIsoBounds();

	var IsometricCullTiles = function (layer, camera, outputArray, renderOrder)
	{
	    if (outputArray === undefined) { outputArray = []; }
	    if (renderOrder === undefined) { renderOrder = 0; }

	    outputArray.length = 0;

	    var tilemapLayer = layer.tilemapLayer;

	    var mapData = layer.data;
	    var mapWidth = layer.width;
	    var mapHeight = layer.height;
	    var skipCull = tilemapLayer.skipCull;

	    var drawLeft = 0;
	    var drawRight = mapWidth;
	    var drawTop = 0;
	    var drawBottom = mapHeight;

	    var x;
	    var y;
	    var tile;

	    if (renderOrder === 0)
	    {

	        for (y = drawTop; y < drawBottom; y++)
	        {
	            for (x = drawLeft; x < drawRight; x++)
	            {
	                tile = mapData[y][x];

	                if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0)
	                {
	                    continue;
	                }

	                if (!skipCull && !CheckIsoBounds(x, y, layer, camera))
	                {
	                    continue;
	                }

	                outputArray.push(tile);
	            }
	        }
	    }
	    else if (renderOrder === 1)
	    {

	        for (y = drawTop; y < drawBottom; y++)
	        {
	            for (x = drawRight; x >= drawLeft; x--)
	            {
	                tile = mapData[y][x];

	                if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0)
	                {
	                    continue;
	                }

	                if (!skipCull && !CheckIsoBounds(x, y, layer, camera))
	                {
	                    continue;
	                }

	                outputArray.push(tile);
	            }
	        }
	    }
	    else if (renderOrder === 2)
	    {

	        for (y = drawBottom; y >= drawTop; y--)
	        {
	            for (x = drawLeft; x < drawRight; x++)
	            {
	                tile = mapData[y][x];

	                if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0)
	                {
	                    continue;
	                }

	                if (!skipCull && !CheckIsoBounds(x, y, layer, camera))
	                {
	                    continue;
	                }

	                outputArray.push(tile);
	            }
	        }
	    }
	    else if (renderOrder === 3)
	    {

	        for (y = drawBottom; y >= drawTop; y--)
	        {
	            for (x = drawRight; x >= drawLeft; x--)
	            {
	                tile = mapData[y][x];

	                if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0)
	                {
	                    continue;
	                }

	                if (!skipCull && !CheckIsoBounds(x, y, layer, camera))
	                {
	                    continue;
	                }

	                outputArray.push(tile);
	            }
	        }
	    }

	    tilemapLayer.tilesDrawn = outputArray.length;
	    tilemapLayer.tilesTotal = mapWidth * mapHeight;

	    return outputArray;
	};

	IsometricCullTiles_1 = IsometricCullTiles;
	return IsometricCullTiles_1;
}

var StaggeredCullBounds_1;
var hasRequiredStaggeredCullBounds;

function requireStaggeredCullBounds () {
	if (hasRequiredStaggeredCullBounds) return StaggeredCullBounds_1;
	hasRequiredStaggeredCullBounds = 1;
	var SnapCeil = requireSnapCeil();
	var SnapFloor = requireSnapFloor();

	var StaggeredCullBounds = function (layer, camera)
	{
	    var tilemap = layer.tilemapLayer.tilemap;
	    var tilemapLayer = layer.tilemapLayer;

	    var tileW = Math.floor(tilemap.tileWidth * tilemapLayer.scaleX);
	    var tileH = Math.floor(tilemap.tileHeight * tilemapLayer.scaleY);

	    var boundsLeft = SnapFloor(camera.worldView.x - tilemapLayer.x, tileW, 0, true) - tilemapLayer.cullPaddingX;
	    var boundsRight = SnapCeil(camera.worldView.right - tilemapLayer.x, tileW, 0, true) + tilemapLayer.cullPaddingX;

	    var boundsTop = SnapFloor(camera.worldView.y - tilemapLayer.y, tileH / 2, 0, true) - tilemapLayer.cullPaddingY;
	    var boundsBottom = SnapCeil(camera.worldView.bottom - tilemapLayer.y, tileH / 2, 0, true) + tilemapLayer.cullPaddingY;

	    return {
	        left: boundsLeft,
	        right: boundsRight,
	        top: boundsTop,
	        bottom: boundsBottom
	    };
	};

	StaggeredCullBounds_1 = StaggeredCullBounds;
	return StaggeredCullBounds_1;
}

var StaggeredCullTiles_1;
var hasRequiredStaggeredCullTiles;

function requireStaggeredCullTiles () {
	if (hasRequiredStaggeredCullTiles) return StaggeredCullTiles_1;
	hasRequiredStaggeredCullTiles = 1;
	var CullBounds = requireStaggeredCullBounds();
	var RunCull = requireRunCull();

	var StaggeredCullTiles = function (layer, camera, outputArray, renderOrder)
	{
	    if (outputArray === undefined) { outputArray = []; }
	    if (renderOrder === undefined) { renderOrder = 0; }

	    outputArray.length = 0;

	    var tilemapLayer = layer.tilemapLayer;

	    var bounds = CullBounds(layer, camera);

	    if (tilemapLayer.skipCull && tilemapLayer.scrollFactorX === 1 && tilemapLayer.scrollFactorY === 1)
	    {
	        bounds.left = 0;
	        bounds.right = layer.width;
	        bounds.top = 0;
	        bounds.bottom = layer.height;
	    }

	    RunCull(layer, bounds, renderOrder, outputArray);

	    return outputArray;
	};

	StaggeredCullTiles_1 = StaggeredCullTiles;
	return StaggeredCullTiles_1;
}

var GetCullTilesFunction_1;
var hasRequiredGetCullTilesFunction;

function requireGetCullTilesFunction () {
	if (hasRequiredGetCullTilesFunction) return GetCullTilesFunction_1;
	hasRequiredGetCullTilesFunction = 1;
	var CONST = requireORIENTATION_CONST();
	var CullTiles = requireCullTiles();
	var HexagonalCullTiles = requireHexagonalCullTiles();
	var IsometricCullTiles = requireIsometricCullTiles();
	var NOOP = requireNOOP();
	var StaggeredCullTiles = requireStaggeredCullTiles();

	var GetCullTilesFunction = function (orientation)
	{
	    if (orientation === CONST.ORTHOGONAL)
	    {
	        return CullTiles;
	    }
	    else if (orientation === CONST.HEXAGONAL)
	    {
	        return HexagonalCullTiles;
	    }
	    else if (orientation === CONST.STAGGERED)
	    {
	        return StaggeredCullTiles;
	    }
	    else if (orientation === CONST.ISOMETRIC)
	    {
	        return IsometricCullTiles;
	    }
	    else
	    {
	        return NOOP;
	    }
	};

	GetCullTilesFunction_1 = GetCullTilesFunction;
	return GetCullTilesFunction_1;
}

var GetTileAtWorldXY_1;
var hasRequiredGetTileAtWorldXY;

function requireGetTileAtWorldXY () {
	if (hasRequiredGetTileAtWorldXY) return GetTileAtWorldXY_1;
	hasRequiredGetTileAtWorldXY = 1;
	var GetTileAt = requireGetTileAt();
	var Vector2 = requireVector2();

	var point = new Vector2();

	var GetTileAtWorldXY = function (worldX, worldY, nonNull, camera, layer)
	{
	    layer.tilemapLayer.worldToTileXY(worldX, worldY, true, point, camera);

	    return GetTileAt(point.x, point.y, nonNull, layer);
	};

	GetTileAtWorldXY_1 = GetTileAtWorldXY;
	return GetTileAtWorldXY_1;
}

var GetTileCorners_1;
var hasRequiredGetTileCorners;

function requireGetTileCorners () {
	if (hasRequiredGetTileCorners) return GetTileCorners_1;
	hasRequiredGetTileCorners = 1;
	var Vector2 = requireVector2();

	var GetTileCorners = function (tileX, tileY, camera, layer)
	{
	    var tileWidth = layer.baseTileWidth;
	    var tileHeight = layer.baseTileHeight;
	    var tilemapLayer = layer.tilemapLayer;

	    var worldX = 0;
	    var worldY = 0;

	    if (tilemapLayer)
	    {
	        if (!camera) { camera = tilemapLayer.scene.cameras.main; }

	        worldX = tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX);
	        worldY = (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));

	        tileWidth *= tilemapLayer.scaleX;
	        tileHeight *= tilemapLayer.scaleY;
	    }

	    var x = worldX + tileX * tileWidth;
	    var y = worldY + tileY * tileHeight;

	    return [
	        new Vector2(x, y),
	        new Vector2(x + tileWidth, y),
	        new Vector2(x + tileWidth, y + tileHeight),
	        new Vector2(x, y + tileHeight)
	    ];
	};

	GetTileCorners_1 = GetTileCorners;
	return GetTileCorners_1;
}

var HexagonalTileToWorldXY_1;
var hasRequiredHexagonalTileToWorldXY;

function requireHexagonalTileToWorldXY () {
	if (hasRequiredHexagonalTileToWorldXY) return HexagonalTileToWorldXY_1;
	hasRequiredHexagonalTileToWorldXY = 1;
	var Vector2 = requireVector2();

	var HexagonalTileToWorldXY = function (tileX, tileY, point, camera, layer)
	{
	    if (!point) { point = new Vector2(); }

	    var tileWidth = layer.baseTileWidth;
	    var tileHeight = layer.baseTileHeight;
	    var tilemapLayer = layer.tilemapLayer;

	    var worldX = 0;
	    var worldY = 0;

	    if (tilemapLayer)
	    {
	        if (!camera) { camera = tilemapLayer.scene.cameras.main; }

	        worldX = tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX);
	        worldY = tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY);

	        tileWidth *= tilemapLayer.scaleX;
	        tileHeight *= tilemapLayer.scaleY;
	    }

	    var tileWidthHalf = tileWidth / 2;
	    var tileHeightHalf = tileHeight / 2;

	    var x;
	    var y;
	    var staggerAxis = layer.staggerAxis;
	    var staggerIndex = layer.staggerIndex;

	    if (staggerAxis === 'y')
	    {
	        x = worldX + (tileWidth * tileX) + tileWidth;
	        y = worldY + ((1.5 * tileY) * tileHeightHalf) + tileHeightHalf;

	        if (tileY % 2 === 0)
	        {
	            if (staggerIndex === 'odd')
	            {
	                x -= tileWidthHalf;
	            }
	            else
	            {
	                x += tileWidthHalf;
	            }
	        }
	    }
	    else if ((staggerAxis === 'x') && (staggerIndex === 'odd'))
	    {
	        x = worldX + ((1.5 * tileX) * tileWidthHalf) + tileWidthHalf;
	        y = worldY + (tileHeight * tileX) + tileHeight;

	        if (tileX % 2 === 0)
	        {
	            if (staggerIndex === 'odd')
	            {
	                y -= tileHeightHalf;
	            }
	            else
	            {
	                y += tileHeightHalf;
	            }
	        }
	    }

	    return point.set(x, y);
	};

	HexagonalTileToWorldXY_1 = HexagonalTileToWorldXY;
	return HexagonalTileToWorldXY_1;
}

var HexagonalGetTileCorners_1;
var hasRequiredHexagonalGetTileCorners;

function requireHexagonalGetTileCorners () {
	if (hasRequiredHexagonalGetTileCorners) return HexagonalGetTileCorners_1;
	hasRequiredHexagonalGetTileCorners = 1;
	var HexagonalTileToWorldXY = requireHexagonalTileToWorldXY();
	var Vector2 = requireVector2();

	var tempVec = new Vector2();

	var HexagonalGetTileCorners = function (tileX, tileY, camera, layer)
	{
	    var tileWidth = layer.baseTileWidth;
	    var tileHeight = layer.baseTileHeight;
	    var tilemapLayer = layer.tilemapLayer;

	    if (tilemapLayer)
	    {
	        tileWidth *= tilemapLayer.scaleX;
	        tileHeight *= tilemapLayer.scaleY;
	    }

	    var center = HexagonalTileToWorldXY(tileX, tileY, tempVec, camera, layer);

	    var corners = [];

	    var b0 = 0.5773502691896257; 

	    var hexWidth;
	    var hexHeight;

	    if (layer.staggerAxis === 'y')
	    {
	        hexWidth = b0 * tileWidth;
	        hexHeight = tileHeight / 2;
	    }
	    else
	    {
	        hexWidth = tileWidth / 2;
	        hexHeight = b0 * tileHeight;
	    }

	    for (var i = 0; i < 6; i++)
	    {
	        var angle = 2 * Math.PI * (0.5 - i) / 6;

	        corners.push(new Vector2(center.x + (hexWidth * Math.cos(angle)), center.y + (hexHeight * Math.sin(angle))));
	    }

	    return corners;
	};

	HexagonalGetTileCorners_1 = HexagonalGetTileCorners;
	return HexagonalGetTileCorners_1;
}

var GetTileCornersFunction_1;
var hasRequiredGetTileCornersFunction;

function requireGetTileCornersFunction () {
	if (hasRequiredGetTileCornersFunction) return GetTileCornersFunction_1;
	hasRequiredGetTileCornersFunction = 1;
	var CONST = requireORIENTATION_CONST();
	var HexagonalGetTileCorners = requireHexagonalGetTileCorners();
	var NOOP = requireNOOP();
	var GetTileCorners = requireGetTileCorners();

	var GetTileCornersFunction = function (orientation)
	{
	    if (orientation === CONST.ORTHOGONAL)
	    {
	        return GetTileCorners;
	    }
	    else if (orientation === CONST.ISOMETRIC)
	    {
	        return NOOP;
	    }
	    else if (orientation === CONST.HEXAGONAL)
	    {
	        return HexagonalGetTileCorners;
	    }
	    else if (orientation === CONST.STAGGERED)
	    {
	        return NOOP;
	    }
	    else
	    {
	        return NOOP;
	    }
	};

	GetTileCornersFunction_1 = GetTileCornersFunction;
	return GetTileCornersFunction_1;
}

var GetTilesWithinShape_1;
var hasRequiredGetTilesWithinShape;

function requireGetTilesWithinShape () {
	if (hasRequiredGetTilesWithinShape) return GetTilesWithinShape_1;
	hasRequiredGetTilesWithinShape = 1;
	var Geom = requireGeom();
	var GetTilesWithin = requireGetTilesWithin();
	var Intersects = requireIntersects();
	var NOOP = requireNOOP();
	var Vector2 = requireVector2();
	var CONST = requireORIENTATION_CONST();

	var TriangleToRectangle = function (triangle, rect)
	{
	    return Intersects.RectangleToTriangle(rect, triangle);
	};

	var point = new Vector2();
	var pointStart = new Vector2();
	var pointEnd = new Vector2();

	var GetTilesWithinShape = function (shape, filteringOptions, camera, layer)
	{
	    if (layer.orientation !== CONST.ORTHOGONAL)
	    {
	        console.warn('GetTilesWithinShape only works with orthogonal tilemaps');
	        return [];
	    }

	    if (shape === undefined) { return []; }

	    var intersectTest = NOOP;

	    if (shape instanceof Geom.Circle)
	    {
	        intersectTest = Intersects.CircleToRectangle;
	    }
	    else if (shape instanceof Geom.Rectangle)
	    {
	        intersectTest = Intersects.RectangleToRectangle;
	    }
	    else if (shape instanceof Geom.Triangle)
	    {
	        intersectTest = TriangleToRectangle;
	    }
	    else if (shape instanceof Geom.Line)
	    {
	        intersectTest = Intersects.LineToRectangle;
	    }

	    layer.tilemapLayer.worldToTileXY(shape.left, shape.top, true, pointStart, camera);

	    var xStart = pointStart.x;
	    var yStart = pointStart.y;

	    layer.tilemapLayer.worldToTileXY(shape.right, shape.bottom, false, pointEnd, camera);

	    var xEnd = Math.ceil(pointEnd.x);
	    var yEnd = Math.ceil(pointEnd.y);

	    var width = Math.max(xEnd - xStart, 1);
	    var height = Math.max(yEnd - yStart, 1);

	    var tiles = GetTilesWithin(xStart, yStart, width, height, filteringOptions, layer);

	    var tileWidth = layer.tileWidth;
	    var tileHeight = layer.tileHeight;

	    if (layer.tilemapLayer)
	    {
	        tileWidth *= layer.tilemapLayer.scaleX;
	        tileHeight *= layer.tilemapLayer.scaleY;
	    }

	    var results = [];
	    var tileRect = new Geom.Rectangle(0, 0, tileWidth, tileHeight);

	    for (var i = 0; i < tiles.length; i++)
	    {
	        var tile = tiles[i];

	        layer.tilemapLayer.tileToWorldXY(tile.x, tile.y, point, camera);

	        tileRect.x = point.x;
	        tileRect.y = point.y;

	        if (intersectTest(shape, tileRect))
	        {
	            results.push(tile);
	        }
	    }

	    return results;
	};

	GetTilesWithinShape_1 = GetTilesWithinShape;
	return GetTilesWithinShape_1;
}

var TileToWorldX_1;
var hasRequiredTileToWorldX;

function requireTileToWorldX () {
	if (hasRequiredTileToWorldX) return TileToWorldX_1;
	hasRequiredTileToWorldX = 1;
	var TileToWorldX = function (tileX, camera, layer)
	{
	    var tileWidth = layer.baseTileWidth;
	    var tilemapLayer = layer.tilemapLayer;
	    var layerWorldX = 0;

	    if (tilemapLayer)
	    {
	        if (!camera) { camera = tilemapLayer.scene.cameras.main; }

	        layerWorldX = tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX);

	        tileWidth *= tilemapLayer.scaleX;
	    }

	    return layerWorldX + tileX * tileWidth;
	};

	TileToWorldX_1 = TileToWorldX;
	return TileToWorldX_1;
}

var GetTileToWorldXFunction_1;
var hasRequiredGetTileToWorldXFunction;

function requireGetTileToWorldXFunction () {
	if (hasRequiredGetTileToWorldXFunction) return GetTileToWorldXFunction_1;
	hasRequiredGetTileToWorldXFunction = 1;
	var CONST = requireORIENTATION_CONST();
	var NOOP = requireNOOP();
	var TileToWorldX = requireTileToWorldX();

	var GetTileToWorldXFunction = function (orientation)
	{
	    if (orientation === CONST.ORTHOGONAL)
	    {
	        return TileToWorldX;
	    }
	    else
	    {
	        return NOOP;
	    }
	};

	GetTileToWorldXFunction_1 = GetTileToWorldXFunction;
	return GetTileToWorldXFunction_1;
}

var IsometricTileToWorldXY_1;
var hasRequiredIsometricTileToWorldXY;

function requireIsometricTileToWorldXY () {
	if (hasRequiredIsometricTileToWorldXY) return IsometricTileToWorldXY_1;
	hasRequiredIsometricTileToWorldXY = 1;
	var Vector2 = requireVector2();

	var IsometricTileToWorldXY = function (tileX, tileY, point, camera, layer)
	{
	    if (!point) { point = new Vector2(); }

	    var tileWidth = layer.baseTileWidth;
	    var tileHeight = layer.baseTileHeight;
	    var tilemapLayer = layer.tilemapLayer;

	    var layerWorldX = 0;
	    var layerWorldY = 0;

	    if (tilemapLayer)
	    {
	        if (!camera) { camera = tilemapLayer.scene.cameras.main; }

	        layerWorldX = tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX);

	        tileWidth *= tilemapLayer.scaleX;

	        layerWorldY = (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));

	        tileHeight *= tilemapLayer.scaleY;
	    }

	    var x = layerWorldX + (tileX - tileY) * (tileWidth / 2);
	    var y = layerWorldY + (tileX + tileY) * (tileHeight / 2);

	    return point.set(x, y);
	};

	IsometricTileToWorldXY_1 = IsometricTileToWorldXY;
	return IsometricTileToWorldXY_1;
}

var StaggeredTileToWorldXY_1;
var hasRequiredStaggeredTileToWorldXY;

function requireStaggeredTileToWorldXY () {
	if (hasRequiredStaggeredTileToWorldXY) return StaggeredTileToWorldXY_1;
	hasRequiredStaggeredTileToWorldXY = 1;
	var Vector2 = requireVector2();

	var StaggeredTileToWorldXY = function (tileX, tileY, point, camera, layer)
	{
	    if (!point) { point = new Vector2(); }

	    var tileWidth = layer.baseTileWidth;
	    var tileHeight = layer.baseTileHeight;
	    var tilemapLayer = layer.tilemapLayer;

	    var layerWorldX = 0;
	    var layerWorldY = 0;

	    if (tilemapLayer)
	    {
	        if (!camera) { camera = tilemapLayer.scene.cameras.main; }

	        layerWorldX = tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX);

	        tileWidth *= tilemapLayer.scaleX;

	        layerWorldY = (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));

	        tileHeight *= tilemapLayer.scaleY;
	    }

	    var x = layerWorldX + tileX * tileWidth + tileY % 2 * (tileWidth / 2);
	    var y = layerWorldY + tileY * (tileHeight / 2);

	    return point.set(x, y);
	};

	StaggeredTileToWorldXY_1 = StaggeredTileToWorldXY;
	return StaggeredTileToWorldXY_1;
}

var TileToWorldY_1;
var hasRequiredTileToWorldY;

function requireTileToWorldY () {
	if (hasRequiredTileToWorldY) return TileToWorldY_1;
	hasRequiredTileToWorldY = 1;
	var TileToWorldY = function (tileY, camera, layer)
	{
	    var tileHeight = layer.baseTileHeight;
	    var tilemapLayer = layer.tilemapLayer;
	    var layerWorldY = 0;

	    if (tilemapLayer)
	    {
	        if (!camera) { camera = tilemapLayer.scene.cameras.main; }

	        layerWorldY = (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));

	        tileHeight *= tilemapLayer.scaleY;
	    }

	    return layerWorldY + tileY * tileHeight;
	};

	TileToWorldY_1 = TileToWorldY;
	return TileToWorldY_1;
}

var TileToWorldXY_1;
var hasRequiredTileToWorldXY;

function requireTileToWorldXY () {
	if (hasRequiredTileToWorldXY) return TileToWorldXY_1;
	hasRequiredTileToWorldXY = 1;
	var TileToWorldX = requireTileToWorldX();
	var TileToWorldY = requireTileToWorldY();
	var Vector2 = requireVector2();

	var TileToWorldXY = function (tileX, tileY, point, camera, layer)
	{
	    if (!point) { point = new Vector2(0, 0); }

	    point.x = TileToWorldX(tileX, camera, layer);
	    point.y = TileToWorldY(tileY, camera, layer);

	    return point;
	};

	TileToWorldXY_1 = TileToWorldXY;
	return TileToWorldXY_1;
}

var GetTileToWorldXYFunction_1;
var hasRequiredGetTileToWorldXYFunction;

function requireGetTileToWorldXYFunction () {
	if (hasRequiredGetTileToWorldXYFunction) return GetTileToWorldXYFunction_1;
	hasRequiredGetTileToWorldXYFunction = 1;
	var CONST = requireORIENTATION_CONST();
	var HexagonalTileToWorldXY = requireHexagonalTileToWorldXY();
	var IsometricTileToWorldXY = requireIsometricTileToWorldXY();
	var NOOP = requireNOOP();
	var StaggeredTileToWorldXY = requireStaggeredTileToWorldXY();
	var TileToWorldXY = requireTileToWorldXY();

	var GetTileToWorldXYFunction = function (orientation)
	{
	    if (orientation === CONST.ORTHOGONAL)
	    {
	        return TileToWorldXY;
	    }
	    else if (orientation === CONST.ISOMETRIC)
	    {
	        return IsometricTileToWorldXY;
	    }
	    else if (orientation === CONST.HEXAGONAL)
	    {
	        return HexagonalTileToWorldXY;
	    }
	    else if (orientation === CONST.STAGGERED)
	    {
	        return StaggeredTileToWorldXY;
	    }
	    else
	    {
	        return NOOP;
	    }
	};

	GetTileToWorldXYFunction_1 = GetTileToWorldXYFunction;
	return GetTileToWorldXYFunction_1;
}

var StaggeredTileToWorldY_1;
var hasRequiredStaggeredTileToWorldY;

function requireStaggeredTileToWorldY () {
	if (hasRequiredStaggeredTileToWorldY) return StaggeredTileToWorldY_1;
	hasRequiredStaggeredTileToWorldY = 1;
	var StaggeredTileToWorldY = function (tileY, camera, layer)
	{
	    var tileHeight = layer.baseTileHeight;
	    var tilemapLayer = layer.tilemapLayer;
	    var layerWorldY = 0;

	    if (tilemapLayer)
	    {
	        if (camera === undefined) { camera = tilemapLayer.scene.cameras.main; }

	        layerWorldY = (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));

	        tileHeight *= tilemapLayer.scaleY;
	    }

	    return layerWorldY + tileY * (tileHeight / 2) + tileHeight;
	};

	StaggeredTileToWorldY_1 = StaggeredTileToWorldY;
	return StaggeredTileToWorldY_1;
}

var GetTileToWorldYFunction_1;
var hasRequiredGetTileToWorldYFunction;

function requireGetTileToWorldYFunction () {
	if (hasRequiredGetTileToWorldYFunction) return GetTileToWorldYFunction_1;
	hasRequiredGetTileToWorldYFunction = 1;
	var CONST = requireORIENTATION_CONST();
	var NOOP = requireNOOP();
	var StaggeredTileToWorldY = requireStaggeredTileToWorldY();
	var TileToWorldY = requireTileToWorldY();

	var GetTileToWorldYFunction = function (orientation)
	{
	    if (orientation === CONST.ORTHOGONAL)
	    {
	        return TileToWorldY;
	    }
	    else if (orientation === CONST.STAGGERED)
	    {
	        return StaggeredTileToWorldY;
	    }
	    else
	    {
	        return NOOP;
	    }
	};

	GetTileToWorldYFunction_1 = GetTileToWorldYFunction;
	return GetTileToWorldYFunction_1;
}

var NULL_1;
var hasRequiredNULL;

function requireNULL () {
	if (hasRequiredNULL) return NULL_1;
	hasRequiredNULL = 1;
	var NULL = function ()
	{
	    return null;
	};

	NULL_1 = NULL;
	return NULL_1;
}

var WorldToTileXY_1;
var hasRequiredWorldToTileXY;

function requireWorldToTileXY () {
	if (hasRequiredWorldToTileXY) return WorldToTileXY_1;
	hasRequiredWorldToTileXY = 1;
	var Vector2 = requireVector2();

	var WorldToTileXY = function (worldX, worldY, snapToFloor, point, camera, layer)
	{
	    if (snapToFloor === undefined) { snapToFloor = true; }
	    if (!point) { point = new Vector2(); }

	    var tileWidth = layer.baseTileWidth;
	    var tileHeight = layer.baseTileHeight;
	    var tilemapLayer = layer.tilemapLayer;

	    if (tilemapLayer)
	    {
	        if (!camera) { camera = tilemapLayer.scene.cameras.main; }

	        worldX = worldX - (tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX));
	        worldY = worldY - (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));

	        tileWidth *= tilemapLayer.scaleX;
	        tileHeight *= tilemapLayer.scaleY;
	    }

	    var x = worldX / tileWidth;
	    var y = worldY / tileHeight;

	    if (snapToFloor)
	    {
	        x = Math.floor(x);
	        y = Math.floor(y);
	    }

	    return point.set(x, y);
	};

	WorldToTileXY_1 = WorldToTileXY;
	return WorldToTileXY_1;
}

var WorldToTileX_1;
var hasRequiredWorldToTileX;

function requireWorldToTileX () {
	if (hasRequiredWorldToTileX) return WorldToTileX_1;
	hasRequiredWorldToTileX = 1;
	var WorldToTileXY = requireWorldToTileXY();
	var Vector2 = requireVector2();

	var tempVec = new Vector2();

	var WorldToTileX = function (worldX, snapToFloor, camera, layer)
	{
	    WorldToTileXY(worldX, 0, snapToFloor, tempVec, camera, layer);

	    return tempVec.x;
	};

	WorldToTileX_1 = WorldToTileX;
	return WorldToTileX_1;
}

var GetWorldToTileXFunction_1;
var hasRequiredGetWorldToTileXFunction;

function requireGetWorldToTileXFunction () {
	if (hasRequiredGetWorldToTileXFunction) return GetWorldToTileXFunction_1;
	hasRequiredGetWorldToTileXFunction = 1;
	var CONST = requireORIENTATION_CONST();
	var NULL = requireNULL();
	var WorldToTileX = requireWorldToTileX();

	var GetWorldToTileXFunction = function (orientation)
	{
	    if (orientation === CONST.ORTHOGONAL)
	    {
	        return WorldToTileX;
	    }
	    else
	    {
	        return NULL;
	    }
	};

	GetWorldToTileXFunction_1 = GetWorldToTileXFunction;
	return GetWorldToTileXFunction_1;
}

var HexagonalWorldToTileXY_1;
var hasRequiredHexagonalWorldToTileXY;

function requireHexagonalWorldToTileXY () {
	if (hasRequiredHexagonalWorldToTileXY) return HexagonalWorldToTileXY_1;
	hasRequiredHexagonalWorldToTileXY = 1;
	var Vector2 = requireVector2();

	var HexagonalWorldToTileXY = function (worldX, worldY, snapToFloor, point, camera, layer)
	{
	    if (!point) { point = new Vector2(); }

	    var tileWidth = layer.baseTileWidth;
	    var tileHeight = layer.baseTileHeight;
	    var tilemapLayer = layer.tilemapLayer;

	    if (tilemapLayer)
	    {
	        if (!camera) { camera = tilemapLayer.scene.cameras.main; }

	        worldX = worldX - (tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX));
	        worldY = worldY - (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));

	        tileWidth *= tilemapLayer.scaleX;
	        tileHeight *= tilemapLayer.scaleY;
	    }

	    var b0 = 0.5773502691896257; 
	    var b1 = -0.3333333333333333; 
	    var b2 = 0;
	    var b3 = 0.6666666666666666; 

	    var tileWidthHalf = tileWidth / 2;
	    var tileHeightHalf = tileHeight / 2;

	    var px;
	    var py;
	    var q;
	    var r;
	    var s;

	    if (layer.staggerAxis === 'y')
	    {

	        px = (worldX - tileWidthHalf) / (b0 * tileWidth);
	        py = (worldY - tileHeightHalf) / tileHeightHalf;

	        q = b0 * px + b1 * py;
	        r = b2 * px + b3 * py;
	    }
	    else
	    {

	        px = (worldX - tileWidthHalf) / tileWidthHalf;
	        py = (worldY - tileHeightHalf) / (b0 * tileHeight);

	        q = b1 * px + b0 * py;
	        r = b3 * px + b2 * py;
	    }

	    s = -q - r;

	    var qi = Math.round(q);
	    var ri = Math.round(r);
	    var si = Math.round(s);

	    var qDiff = Math.abs(qi - q);
	    var rDiff = Math.abs(ri - r);
	    var sDiff = Math.abs(si - s);

	    if (qDiff > rDiff && qDiff > sDiff)
	    {
	        qi = -ri - si;
	    }
	    else if (rDiff > sDiff)
	    {
	        ri = -qi - si;
	    }

	    var x;
	    var y = ri;

	    if (layer.staggerIndex === 'odd')
	    {
	        x = (y % 2 === 0) ? (ri / 2) + qi : (ri / 2) + qi - 0.5;
	    }
	    else
	    {
	        x = (y % 2 === 0) ? (ri / 2) + qi : (ri / 2) + qi + 0.5;
	    }

	    return point.set(x, y);
	};

	HexagonalWorldToTileXY_1 = HexagonalWorldToTileXY;
	return HexagonalWorldToTileXY_1;
}

var IsometricWorldToTileXY_1;
var hasRequiredIsometricWorldToTileXY;

function requireIsometricWorldToTileXY () {
	if (hasRequiredIsometricWorldToTileXY) return IsometricWorldToTileXY_1;
	hasRequiredIsometricWorldToTileXY = 1;
	var Vector2 = requireVector2();

	var IsometricWorldToTileXY = function (worldX, worldY, snapToFloor, point, camera, layer, originTop)
	{
	    if (!point) { point = new Vector2(); }

	    var tileWidth = layer.baseTileWidth;
	    var tileHeight = layer.baseTileHeight;
	    var tilemapLayer = layer.tilemapLayer;

	    if (tilemapLayer)
	    {
	        if (!camera) { camera = tilemapLayer.scene.cameras.main; }

	        worldY = worldY - (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));

	        tileHeight *= tilemapLayer.scaleY;

	        worldX = worldX - (tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX));

	        tileWidth *= tilemapLayer.scaleX;
	    }

	    var tileWidthHalf = tileWidth / 2;
	    var tileHeightHalf = tileHeight / 2;

	    worldX = worldX - tileWidthHalf;

	    if (!originTop)
	    {
	        worldY = worldY - tileHeight;
	    }

	    var x = 0.5 * (worldX / tileWidthHalf + worldY / tileHeightHalf);
	    var y = 0.5 * (-worldX / tileWidthHalf + worldY / tileHeightHalf);

	    if (snapToFloor)
	    {
	        x = Math.floor(x);
	        y = Math.floor(y);
	    }

	    return point.set(x, y);
	};

	IsometricWorldToTileXY_1 = IsometricWorldToTileXY;
	return IsometricWorldToTileXY_1;
}

var StaggeredWorldToTileXY_1;
var hasRequiredStaggeredWorldToTileXY;

function requireStaggeredWorldToTileXY () {
	if (hasRequiredStaggeredWorldToTileXY) return StaggeredWorldToTileXY_1;
	hasRequiredStaggeredWorldToTileXY = 1;
	var Vector2 = requireVector2();

	var StaggeredWorldToTileXY = function (worldX, worldY, snapToFloor, point, camera, layer)
	{
	    if (!point) { point = new Vector2(); }

	    var tileWidth = layer.baseTileWidth;
	    var tileHeight = layer.baseTileHeight;
	    var tilemapLayer = layer.tilemapLayer;

	    if (tilemapLayer)
	    {
	        if (!camera) { camera = tilemapLayer.scene.cameras.main; }

	        worldY = worldY - (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));

	        tileHeight *= tilemapLayer.scaleY;

	        worldX = worldX - (tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX));

	        tileWidth *= tilemapLayer.scaleX;
	    }

	    var y = (snapToFloor) ? Math.floor((worldY / (tileHeight / 2))) : (worldY / (tileHeight / 2));
	    var x = (snapToFloor) ? Math.floor((worldX + (y % 2) * 0.5 * tileWidth) / tileWidth) : (worldX + (y % 2) * 0.5 * tileWidth) / tileWidth;

	    return point.set(x, y);
	};

	StaggeredWorldToTileXY_1 = StaggeredWorldToTileXY;
	return StaggeredWorldToTileXY_1;
}

var GetWorldToTileXYFunction_1;
var hasRequiredGetWorldToTileXYFunction;

function requireGetWorldToTileXYFunction () {
	if (hasRequiredGetWorldToTileXYFunction) return GetWorldToTileXYFunction_1;
	hasRequiredGetWorldToTileXYFunction = 1;
	var CONST = requireORIENTATION_CONST();
	var HexagonalWorldToTileXY = requireHexagonalWorldToTileXY();
	var IsometricWorldToTileXY = requireIsometricWorldToTileXY();
	var NOOP = requireNOOP();
	var StaggeredWorldToTileXY = requireStaggeredWorldToTileXY();
	var WorldToTileXY = requireWorldToTileXY();

	var GetWorldToTileXYFunction = function (orientation)
	{
	    if (orientation === CONST.ORTHOGONAL)
	    {
	        return WorldToTileXY;
	    }
	    else if (orientation === CONST.ISOMETRIC)
	    {
	        return IsometricWorldToTileXY;
	    }
	    else if (orientation === CONST.HEXAGONAL)
	    {
	        return HexagonalWorldToTileXY;
	    }
	    else if (orientation === CONST.STAGGERED)
	    {
	        return StaggeredWorldToTileXY;
	    }
	    else
	    {
	        return NOOP;
	    }
	};

	GetWorldToTileXYFunction_1 = GetWorldToTileXYFunction;
	return GetWorldToTileXYFunction_1;
}

var StaggeredWorldToTileY_1;
var hasRequiredStaggeredWorldToTileY;

function requireStaggeredWorldToTileY () {
	if (hasRequiredStaggeredWorldToTileY) return StaggeredWorldToTileY_1;
	hasRequiredStaggeredWorldToTileY = 1;
	var StaggeredWorldToTileY = function (worldY, snapToFloor, camera, layer)
	{
	    var tileHeight = layer.baseTileHeight;
	    var tilemapLayer = layer.tilemapLayer;

	    if (tilemapLayer)
	    {
	        if (!camera) { camera = tilemapLayer.scene.cameras.main; }

	        worldY = worldY - (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));

	        tileHeight *= tilemapLayer.scaleY;
	    }

	    return (snapToFloor) ? Math.floor(worldY / (tileHeight / 2)) : worldY / (tileHeight / 2);
	};

	StaggeredWorldToTileY_1 = StaggeredWorldToTileY;
	return StaggeredWorldToTileY_1;
}

var WorldToTileY_1;
var hasRequiredWorldToTileY;

function requireWorldToTileY () {
	if (hasRequiredWorldToTileY) return WorldToTileY_1;
	hasRequiredWorldToTileY = 1;
	var WorldToTileXY = requireWorldToTileXY();
	var Vector2 = requireVector2();

	var tempVec = new Vector2();

	var WorldToTileY = function (worldY, snapToFloor, camera, layer)
	{
	    WorldToTileXY(0, worldY, snapToFloor, tempVec, camera, layer);

	    return tempVec.y;
	};

	WorldToTileY_1 = WorldToTileY;
	return WorldToTileY_1;
}

var GetWorldToTileYFunction_1;
var hasRequiredGetWorldToTileYFunction;

function requireGetWorldToTileYFunction () {
	if (hasRequiredGetWorldToTileYFunction) return GetWorldToTileYFunction_1;
	hasRequiredGetWorldToTileYFunction = 1;
	var CONST = requireORIENTATION_CONST();
	var NULL = requireNULL();
	var StaggeredWorldToTileY = requireStaggeredWorldToTileY();
	var WorldToTileY = requireWorldToTileY();

	var GetWorldToTileYFunction = function (orientation)
	{
	    if (orientation === CONST.ORTHOGONAL)
	    {
	        return WorldToTileY;
	    }
	    else if (orientation === CONST.STAGGERED)
	    {
	        return StaggeredWorldToTileY;
	    }
	    else
	    {
	        return NULL;
	    }
	};

	GetWorldToTileYFunction_1 = GetWorldToTileYFunction;
	return GetWorldToTileYFunction_1;
}

var HasTileAt_1;
var hasRequiredHasTileAt;

function requireHasTileAt () {
	if (hasRequiredHasTileAt) return HasTileAt_1;
	hasRequiredHasTileAt = 1;
	var IsInLayerBounds = requireIsInLayerBounds();

	var HasTileAt = function (tileX, tileY, layer)
	{
	    if (IsInLayerBounds(tileX, tileY, layer))
	    {
	        var tile = layer.data[tileY][tileX];

	        return (tile !== null && tile.index > -1);
	    }
	    else
	    {
	        return false;
	    }
	};

	HasTileAt_1 = HasTileAt;
	return HasTileAt_1;
}

var HasTileAtWorldXY_1;
var hasRequiredHasTileAtWorldXY;

function requireHasTileAtWorldXY () {
	if (hasRequiredHasTileAtWorldXY) return HasTileAtWorldXY_1;
	hasRequiredHasTileAtWorldXY = 1;
	var HasTileAt = requireHasTileAt();
	var Vector2 = requireVector2();

	var point = new Vector2();

	var HasTileAtWorldXY = function (worldX, worldY, camera, layer)
	{
	    layer.tilemapLayer.worldToTileXY(worldX, worldY, true, point, camera);

	    var tileX = point.x;
	    var tileY = point.y;

	    return HasTileAt(tileX, tileY, layer);
	};

	HasTileAtWorldXY_1 = HasTileAtWorldXY;
	return HasTileAtWorldXY_1;
}

var PutTileAt_1;
var hasRequiredPutTileAt;

function requirePutTileAt () {
	if (hasRequiredPutTileAt) return PutTileAt_1;
	hasRequiredPutTileAt = 1;
	var Tile = requireTile();
	var IsInLayerBounds = requireIsInLayerBounds();
	var CalculateFacesAt = requireCalculateFacesAt();
	var SetTileCollision = requireSetTileCollision();

	var PutTileAt = function (tile, tileX, tileY, recalculateFaces, layer)
	{
	    if (recalculateFaces === undefined) { recalculateFaces = true; }

	    if (!IsInLayerBounds(tileX, tileY, layer))
	    {
	        return null;
	    }

	    var index;
	    var oldTile = layer.data[tileY][tileX];
	    var oldTileCollides = oldTile && oldTile.collides;

	    if (tile instanceof Tile)
	    {
	        if (layer.data[tileY][tileX] === null)
	        {
	            layer.data[tileY][tileX] = new Tile(layer, tile.index, tileX, tileY, layer.tileWidth, layer.tileHeight);
	        }

	        layer.data[tileY][tileX].copy(tile);
	    }
	    else
	    {
	        index = tile;

	        if (layer.data[tileY][tileX] === null)
	        {
	            layer.data[tileY][tileX] = new Tile(layer, index, tileX, tileY, layer.tileWidth, layer.tileHeight);
	        }
	        else
	        {
	            layer.data[tileY][tileX].index = index;
	        }
	    }

	    var newTile = layer.data[tileY][tileX];
	    var collides = layer.collideIndexes.indexOf(newTile.index) !== -1;

	    index = tile instanceof Tile ? tile.index : tile;

	    if (index === -1)
	    {
	        newTile.width = layer.tileWidth;
	        newTile.height = layer.tileHeight;
	    }
	    else
	    {
	        var tilemap = layer.tilemapLayer.tilemap;
	        var tiles = tilemap.tiles;
	        var sid = tiles[index][2];
	        var set = tilemap.tilesets[sid];

	        newTile.width = set.tileWidth;
	        newTile.height = set.tileHeight;
	    }

	    SetTileCollision(newTile, collides);

	    if (recalculateFaces && (oldTileCollides !== newTile.collides))
	    {
	        CalculateFacesAt(tileX, tileY, layer);
	    }

	    return newTile;
	};

	PutTileAt_1 = PutTileAt;
	return PutTileAt_1;
}

var PutTileAtWorldXY_1;
var hasRequiredPutTileAtWorldXY;

function requirePutTileAtWorldXY () {
	if (hasRequiredPutTileAtWorldXY) return PutTileAtWorldXY_1;
	hasRequiredPutTileAtWorldXY = 1;
	var PutTileAt = requirePutTileAt();
	var Vector2 = requireVector2();

	var point = new Vector2();

	var PutTileAtWorldXY = function (tile, worldX, worldY, recalculateFaces, camera, layer)
	{
	    layer.tilemapLayer.worldToTileXY(worldX, worldY, true, point, camera, layer);

	    return PutTileAt(tile, point.x, point.y, recalculateFaces, layer);
	};

	PutTileAtWorldXY_1 = PutTileAtWorldXY;
	return PutTileAtWorldXY_1;
}

var PutTilesAt_1;
var hasRequiredPutTilesAt;

function requirePutTilesAt () {
	if (hasRequiredPutTilesAt) return PutTilesAt_1;
	hasRequiredPutTilesAt = 1;
	var CalculateFacesWithin = requireCalculateFacesWithin();
	var PutTileAt = requirePutTileAt();

	var PutTilesAt = function (tilesArray, tileX, tileY, recalculateFaces, layer)
	{
	    if (recalculateFaces === undefined) { recalculateFaces = true; }

	    if (!Array.isArray(tilesArray))
	    {
	        return null;
	    }

	    if (!Array.isArray(tilesArray[0]))
	    {
	        tilesArray = [ tilesArray ];
	    }

	    var height = tilesArray.length;
	    var width = tilesArray[0].length;

	    for (var ty = 0; ty < height; ty++)
	    {
	        for (var tx = 0; tx < width; tx++)
	        {
	            var tile = tilesArray[ty][tx];

	            PutTileAt(tile, tileX + tx, tileY + ty, false, layer);
	        }
	    }

	    if (recalculateFaces)
	    {

	        CalculateFacesWithin(tileX - 1, tileY - 1, width + 2, height + 2, layer);
	    }
	};

	PutTilesAt_1 = PutTilesAt;
	return PutTilesAt_1;
}

var Randomize_1;
var hasRequiredRandomize;

function requireRandomize () {
	if (hasRequiredRandomize) return Randomize_1;
	hasRequiredRandomize = 1;
	var GetTilesWithin = requireGetTilesWithin();
	var GetRandom = requireGetRandom();

	var Randomize = function (tileX, tileY, width, height, indexes, layer)
	{
	    var i;
	    var tiles = GetTilesWithin(tileX, tileY, width, height, {}, layer);

	    if (!indexes)
	    {
	        indexes = [];

	        for (i = 0; i < tiles.length; i++)
	        {
	            if (indexes.indexOf(tiles[i].index) === -1)
	            {
	                indexes.push(tiles[i].index);
	            }
	        }
	    }

	    for (i = 0; i < tiles.length; i++)
	    {
	        tiles[i].index = GetRandom(indexes);
	    }
	};

	Randomize_1 = Randomize;
	return Randomize_1;
}

var RemoveTileAt_1;
var hasRequiredRemoveTileAt;

function requireRemoveTileAt () {
	if (hasRequiredRemoveTileAt) return RemoveTileAt_1;
	hasRequiredRemoveTileAt = 1;
	var Tile = requireTile();
	var IsInLayerBounds = requireIsInLayerBounds();
	var CalculateFacesAt = requireCalculateFacesAt();

	var RemoveTileAt = function (tileX, tileY, replaceWithNull, recalculateFaces, layer)
	{
	    if (replaceWithNull === undefined) { replaceWithNull = true; }
	    if (recalculateFaces === undefined) { recalculateFaces = true; }

	    if (!IsInLayerBounds(tileX, tileY, layer))
	    {
	        return null;
	    }

	    var tile = layer.data[tileY][tileX];

	    if (!tile)
	    {
	        return null;
	    }
	    else
	    {
	        layer.data[tileY][tileX] = (replaceWithNull) ? null : new Tile(layer, -1, tileX, tileY, layer.tileWidth, layer.tileHeight);
	    }

	    if (recalculateFaces && tile && tile.collides)
	    {
	        CalculateFacesAt(tileX, tileY, layer);
	    }

	    return tile;
	};

	RemoveTileAt_1 = RemoveTileAt;
	return RemoveTileAt_1;
}

var RemoveTileAtWorldXY_1;
var hasRequiredRemoveTileAtWorldXY;

function requireRemoveTileAtWorldXY () {
	if (hasRequiredRemoveTileAtWorldXY) return RemoveTileAtWorldXY_1;
	hasRequiredRemoveTileAtWorldXY = 1;
	var RemoveTileAt = requireRemoveTileAt();
	var Vector2 = requireVector2();

	var point = new Vector2();

	var RemoveTileAtWorldXY = function (worldX, worldY, replaceWithNull, recalculateFaces, camera, layer)
	{
	    layer.tilemapLayer.worldToTileXY(worldX, worldY, true, point, camera, layer);

	    return RemoveTileAt(point.x, point.y, replaceWithNull, recalculateFaces, layer);
	};

	RemoveTileAtWorldXY_1 = RemoveTileAtWorldXY;
	return RemoveTileAtWorldXY_1;
}

var RenderDebug_1;
var hasRequiredRenderDebug;

function requireRenderDebug () {
	if (hasRequiredRenderDebug) return RenderDebug_1;
	hasRequiredRenderDebug = 1;
	var GetTilesWithin = requireGetTilesWithin();
	var Color = requireColor();

	var defaultTileColor = new Color(105, 210, 231, 150);
	var defaultCollidingTileColor = new Color(243, 134, 48, 200);
	var defaultFaceColor = new Color(40, 39, 37, 150);

	var RenderDebug = function (graphics, styleConfig, layer)
	{
	    if (styleConfig === undefined) { styleConfig = {}; }

	    var tileColor = (styleConfig.tileColor !== undefined) ? styleConfig.tileColor : defaultTileColor;
	    var collidingTileColor = (styleConfig.collidingTileColor !== undefined) ? styleConfig.collidingTileColor : defaultCollidingTileColor;
	    var faceColor = (styleConfig.faceColor !== undefined) ? styleConfig.faceColor : defaultFaceColor;

	    var tiles = GetTilesWithin(0, 0, layer.width, layer.height, null, layer);

	    graphics.translateCanvas(layer.tilemapLayer.x, layer.tilemapLayer.y);
	    graphics.scaleCanvas(layer.tilemapLayer.scaleX, layer.tilemapLayer.scaleY);

	    for (var i = 0; i < tiles.length; i++)
	    {
	        var tile = tiles[i];

	        var offset = tile.tileset ? tile.tileset.tileOffset : { x: 0, y: 0 };
	        var tw = tile.width;
	        var th = tile.height;
	        var x = tile.pixelX - offset.x;
	        var y = tile.pixelY - offset.y;

	        var color = tile.collides ? collidingTileColor : tileColor;

	        if (color !== null)
	        {
	            graphics.fillStyle(color.color, color.alpha / 255);
	            graphics.fillRect(x, y, tw, th);
	        }

	        x += 1;
	        y += 1;
	        tw -= 2;
	        th -= 2;

	        if (faceColor !== null)
	        {
	            graphics.lineStyle(1, faceColor.color, faceColor.alpha / 255);

	            if (tile.faceTop) { graphics.lineBetween(x, y, x + tw, y); }
	            if (tile.faceRight) { graphics.lineBetween(x + tw, y, x + tw, y + th); }
	            if (tile.faceBottom) { graphics.lineBetween(x, y + th, x + tw, y + th); }
	            if (tile.faceLeft) { graphics.lineBetween(x, y, x, y + th); }
	        }
	    }
	};

	RenderDebug_1 = RenderDebug;
	return RenderDebug_1;
}

var SetLayerCollisionIndex_1;
var hasRequiredSetLayerCollisionIndex;

function requireSetLayerCollisionIndex () {
	if (hasRequiredSetLayerCollisionIndex) return SetLayerCollisionIndex_1;
	hasRequiredSetLayerCollisionIndex = 1;
	var SetLayerCollisionIndex = function (tileIndex, collides, layer)
	{
	    var loc = layer.collideIndexes.indexOf(tileIndex);

	    if (collides && loc === -1)
	    {
	        layer.collideIndexes.push(tileIndex);
	    }
	    else if (!collides && loc !== -1)
	    {
	        layer.collideIndexes.splice(loc, 1);
	    }
	};

	SetLayerCollisionIndex_1 = SetLayerCollisionIndex;
	return SetLayerCollisionIndex_1;
}

var SetCollision_1;
var hasRequiredSetCollision;

function requireSetCollision () {
	if (hasRequiredSetCollision) return SetCollision_1;
	hasRequiredSetCollision = 1;
	var SetTileCollision = requireSetTileCollision();
	var CalculateFacesWithin = requireCalculateFacesWithin();
	var SetLayerCollisionIndex = requireSetLayerCollisionIndex();

	var SetCollision = function (indexes, collides, recalculateFaces, layer, updateLayer)
	{
	    if (collides === undefined) { collides = true; }
	    if (recalculateFaces === undefined) { recalculateFaces = true; }
	    if (updateLayer === undefined) { updateLayer = true; }

	    if (!Array.isArray(indexes))
	    {
	        indexes = [ indexes ];
	    }

	    for (var i = 0; i < indexes.length; i++)
	    {
	        SetLayerCollisionIndex(indexes[i], collides, layer);
	    }

	    if (updateLayer)
	    {
	        for (var ty = 0; ty < layer.height; ty++)
	        {
	            for (var tx = 0; tx < layer.width; tx++)
	            {
	                var tile = layer.data[ty][tx];

	                if (tile && indexes.indexOf(tile.index) !== -1)
	                {
	                    SetTileCollision(tile, collides);
	                }
	            }
	        }
	    }

	    if (recalculateFaces)
	    {
	        CalculateFacesWithin(0, 0, layer.width, layer.height, layer);
	    }
	};

	SetCollision_1 = SetCollision;
	return SetCollision_1;
}

var SetCollisionBetween_1;
var hasRequiredSetCollisionBetween;

function requireSetCollisionBetween () {
	if (hasRequiredSetCollisionBetween) return SetCollisionBetween_1;
	hasRequiredSetCollisionBetween = 1;
	var SetTileCollision = requireSetTileCollision();
	var CalculateFacesWithin = requireCalculateFacesWithin();
	var SetLayerCollisionIndex = requireSetLayerCollisionIndex();

	var SetCollisionBetween = function (start, stop, collides, recalculateFaces, layer, updateLayer)
	{
	    if (collides === undefined) { collides = true; }
	    if (recalculateFaces === undefined) { recalculateFaces = true; }
	    if (updateLayer === undefined) { updateLayer = true; }

	    if (start > stop)
	    {
	        return;
	    }

	    for (var index = start; index <= stop; index++)
	    {
	        SetLayerCollisionIndex(index, collides, layer);
	    }

	    if (updateLayer)
	    {
	        for (var ty = 0; ty < layer.height; ty++)
	        {
	            for (var tx = 0; tx < layer.width; tx++)
	            {
	                var tile = layer.data[ty][tx];

	                if (tile)
	                {
	                    if (tile.index >= start && tile.index <= stop)
	                    {
	                        SetTileCollision(tile, collides);
	                    }
	                }
	            }
	        }
	    }

	    if (recalculateFaces)
	    {
	        CalculateFacesWithin(0, 0, layer.width, layer.height, layer);
	    }
	};

	SetCollisionBetween_1 = SetCollisionBetween;
	return SetCollisionBetween_1;
}

var SetCollisionByExclusion_1;
var hasRequiredSetCollisionByExclusion;

function requireSetCollisionByExclusion () {
	if (hasRequiredSetCollisionByExclusion) return SetCollisionByExclusion_1;
	hasRequiredSetCollisionByExclusion = 1;
	var SetTileCollision = requireSetTileCollision();
	var CalculateFacesWithin = requireCalculateFacesWithin();
	var SetLayerCollisionIndex = requireSetLayerCollisionIndex();

	var SetCollisionByExclusion = function (indexes, collides, recalculateFaces, layer)
	{
	    if (collides === undefined) { collides = true; }
	    if (recalculateFaces === undefined) { recalculateFaces = true; }

	    if (!Array.isArray(indexes))
	    {
	        indexes = [ indexes ];
	    }

	    for (var ty = 0; ty < layer.height; ty++)
	    {
	        for (var tx = 0; tx < layer.width; tx++)
	        {
	            var tile = layer.data[ty][tx];

	            if (tile && indexes.indexOf(tile.index) === -1)
	            {
	                SetTileCollision(tile, collides);
	                SetLayerCollisionIndex(tile.index, collides, layer);
	            }
	        }
	    }

	    if (recalculateFaces)
	    {
	        CalculateFacesWithin(0, 0, layer.width, layer.height, layer);
	    }
	};

	SetCollisionByExclusion_1 = SetCollisionByExclusion;
	return SetCollisionByExclusion_1;
}

var SetCollisionByProperty_1;
var hasRequiredSetCollisionByProperty;

function requireSetCollisionByProperty () {
	if (hasRequiredSetCollisionByProperty) return SetCollisionByProperty_1;
	hasRequiredSetCollisionByProperty = 1;
	var SetTileCollision = requireSetTileCollision();
	var CalculateFacesWithin = requireCalculateFacesWithin();
	var HasValue = requireHasValue();

	var SetCollisionByProperty = function (properties, collides, recalculateFaces, layer)
	{
	    if (collides === undefined) { collides = true; }
	    if (recalculateFaces === undefined) { recalculateFaces = true; }

	    for (var ty = 0; ty < layer.height; ty++)
	    {
	        for (var tx = 0; tx < layer.width; tx++)
	        {
	            var tile = layer.data[ty][tx];

	            if (!tile) { continue; }

	            for (var property in properties)
	            {
	                if (!HasValue(tile.properties, property)) { continue; }

	                var values = properties[property];

	                if (!Array.isArray(values))
	                {
	                    values = [ values ];
	                }

	                for (var i = 0; i < values.length; i++)
	                {
	                    if (tile.properties[property] === values[i])
	                    {
	                        SetTileCollision(tile, collides);
	                    }
	                }
	            }
	        }
	    }

	    if (recalculateFaces)
	    {
	        CalculateFacesWithin(0, 0, layer.width, layer.height, layer);
	    }
	};

	SetCollisionByProperty_1 = SetCollisionByProperty;
	return SetCollisionByProperty_1;
}

var SetCollisionFromCollisionGroup_1;
var hasRequiredSetCollisionFromCollisionGroup;

function requireSetCollisionFromCollisionGroup () {
	if (hasRequiredSetCollisionFromCollisionGroup) return SetCollisionFromCollisionGroup_1;
	hasRequiredSetCollisionFromCollisionGroup = 1;
	var SetTileCollision = requireSetTileCollision();
	var CalculateFacesWithin = requireCalculateFacesWithin();

	var SetCollisionFromCollisionGroup = function (collides, recalculateFaces, layer)
	{
	    if (collides === undefined) { collides = true; }
	    if (recalculateFaces === undefined) { recalculateFaces = true; }

	    for (var ty = 0; ty < layer.height; ty++)
	    {
	        for (var tx = 0; tx < layer.width; tx++)
	        {
	            var tile = layer.data[ty][tx];

	            if (!tile) { continue; }

	            var collisionGroup = tile.getCollisionGroup();

	            if (collisionGroup && collisionGroup.objects && collisionGroup.objects.length > 0)
	            {
	                SetTileCollision(tile, collides);
	            }
	        }
	    }

	    if (recalculateFaces)
	    {
	        CalculateFacesWithin(0, 0, layer.width, layer.height, layer);
	    }
	};

	SetCollisionFromCollisionGroup_1 = SetCollisionFromCollisionGroup;
	return SetCollisionFromCollisionGroup_1;
}

var SetTileIndexCallback_1;
var hasRequiredSetTileIndexCallback;

function requireSetTileIndexCallback () {
	if (hasRequiredSetTileIndexCallback) return SetTileIndexCallback_1;
	hasRequiredSetTileIndexCallback = 1;
	var SetTileIndexCallback = function (indexes, callback, callbackContext, layer)
	{
	    if (typeof indexes === 'number')
	    {
	        layer.callbacks[indexes] = (callback !== null)
	            ? { callback: callback, callbackContext: callbackContext }
	            : undefined;
	    }
	    else
	    {
	        for (var i = 0, len = indexes.length; i < len; i++)
	        {
	            layer.callbacks[indexes[i]] = (callback !== null)
	                ? { callback: callback, callbackContext: callbackContext }
	                : undefined;
	        }
	    }
	};

	SetTileIndexCallback_1 = SetTileIndexCallback;
	return SetTileIndexCallback_1;
}

var SetTileLocationCallback_1;
var hasRequiredSetTileLocationCallback;

function requireSetTileLocationCallback () {
	if (hasRequiredSetTileLocationCallback) return SetTileLocationCallback_1;
	hasRequiredSetTileLocationCallback = 1;
	var GetTilesWithin = requireGetTilesWithin();

	var SetTileLocationCallback = function (tileX, tileY, width, height, callback, callbackContext, layer)
	{
	    var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);

	    for (var i = 0; i < tiles.length; i++)
	    {
	        tiles[i].setCollisionCallback(callback, callbackContext);
	    }
	};

	SetTileLocationCallback_1 = SetTileLocationCallback;
	return SetTileLocationCallback_1;
}

var Shuffle_1;
var hasRequiredShuffle;

function requireShuffle () {
	if (hasRequiredShuffle) return Shuffle_1;
	hasRequiredShuffle = 1;
	var GetTilesWithin = requireGetTilesWithin();
	var ShuffleArray = requireShuffle$2();

	var Shuffle = function (tileX, tileY, width, height, layer)
	{
	    var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);

	    var indexes = tiles.map(function (tile) { return tile.index; });

	    ShuffleArray(indexes);

	    for (var i = 0; i < tiles.length; i++)
	    {
	        tiles[i].index = indexes[i];
	    }
	};

	Shuffle_1 = Shuffle;
	return Shuffle_1;
}

var SwapByIndex_1;
var hasRequiredSwapByIndex;

function requireSwapByIndex () {
	if (hasRequiredSwapByIndex) return SwapByIndex_1;
	hasRequiredSwapByIndex = 1;
	var GetTilesWithin = requireGetTilesWithin();

	var SwapByIndex = function (indexA, indexB, tileX, tileY, width, height, layer)
	{
	    var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);

	    for (var i = 0; i < tiles.length; i++)
	    {
	        if (tiles[i])
	        {
	            if (tiles[i].index === indexA)
	            {
	                tiles[i].index = indexB;
	            }
	            else if (tiles[i].index === indexB)
	            {
	                tiles[i].index = indexA;
	            }
	        }
	    }
	};

	SwapByIndex_1 = SwapByIndex;
	return SwapByIndex_1;
}

var WeightedRandomize_1;
var hasRequiredWeightedRandomize;

function requireWeightedRandomize () {
	if (hasRequiredWeightedRandomize) return WeightedRandomize_1;
	hasRequiredWeightedRandomize = 1;
	var GetTilesWithin = requireGetTilesWithin();
	var MATH = requireMath();

	var WeightedRandomize = function (tileX, tileY, width, height, weightedIndexes, layer)
	{
	    if (!weightedIndexes) { return; }

	    var i;
	    var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);

	    var weightTotal = 0;

	    for (i = 0; i < weightedIndexes.length; i++)
	    {
	        weightTotal += weightedIndexes[i].weight;
	    }

	    if (weightTotal <= 0) { return; }

	    for (i = 0; i < tiles.length; i++)
	    {
	        var rand = MATH.RND.frac() * weightTotal;
	        var sum = 0;
	        var randomIndex = -1;

	        for (var j = 0; j < weightedIndexes.length; j++)
	        {
	            sum += weightedIndexes[j].weight;

	            if (rand <= sum)
	            {
	                var chosen = weightedIndexes[j].index;

	                randomIndex = Array.isArray(chosen)
	                    ? chosen[Math.floor(MATH.RND.frac() * chosen.length)]
	                    : chosen;
	                break;
	            }
	        }

	        tiles[i].index = randomIndex;
	    }
	};

	WeightedRandomize_1 = WeightedRandomize;
	return WeightedRandomize_1;
}

var components;
var hasRequiredComponents;

function requireComponents () {
	if (hasRequiredComponents) return components;
	hasRequiredComponents = 1;
	components = {

	    CalculateFacesAt: requireCalculateFacesAt(),
	    CalculateFacesWithin: requireCalculateFacesWithin(),
	    CheckIsoBounds: requireCheckIsoBounds(),
	    Copy: requireCopy(),
	    CreateFromTiles: requireCreateFromTiles(),
	    CullBounds: requireCullBounds(),
	    CullTiles: requireCullTiles(),
	    Fill: requireFill(),
	    FilterTiles: requireFilterTiles(),
	    FindByIndex: requireFindByIndex(),
	    FindTile: requireFindTile(),
	    ForEachTile: requireForEachTile(),
	    GetCullTilesFunction: requireGetCullTilesFunction(),
	    GetTileAt: requireGetTileAt(),
	    GetTileAtWorldXY: requireGetTileAtWorldXY(),
	    GetTileCorners: requireGetTileCorners(),
	    GetTileCornersFunction: requireGetTileCornersFunction(),
	    GetTilesWithin: requireGetTilesWithin(),
	    GetTilesWithinShape: requireGetTilesWithinShape(),
	    GetTilesWithinWorldXY: requireGetTilesWithinWorldXY(),
	    GetTileToWorldXFunction: requireGetTileToWorldXFunction(),
	    GetTileToWorldXYFunction: requireGetTileToWorldXYFunction(),
	    GetTileToWorldYFunction: requireGetTileToWorldYFunction(),
	    GetWorldToTileXFunction: requireGetWorldToTileXFunction(),
	    GetWorldToTileXYFunction: requireGetWorldToTileXYFunction(),
	    GetWorldToTileYFunction: requireGetWorldToTileYFunction(),
	    HasTileAt: requireHasTileAt(),
	    HasTileAtWorldXY: requireHasTileAtWorldXY(),
	    HexagonalCullBounds: requireHexagonalCullBounds(),
	    HexagonalCullTiles: requireHexagonalCullTiles(),
	    HexagonalGetTileCorners: requireHexagonalGetTileCorners(),
	    HexagonalTileToWorldXY: requireHexagonalTileToWorldXY(),
	    HexagonalWorldToTileXY: requireHexagonalWorldToTileXY(),
	    IsInLayerBounds: requireIsInLayerBounds(),
	    IsometricCullTiles: requireIsometricCullTiles(),
	    IsometricTileToWorldXY: requireIsometricTileToWorldXY(),
	    IsometricWorldToTileXY: requireIsometricWorldToTileXY(),
	    PutTileAt: requirePutTileAt(),
	    PutTileAtWorldXY: requirePutTileAtWorldXY(),
	    PutTilesAt: requirePutTilesAt(),
	    Randomize: requireRandomize(),
	    RemoveTileAt: requireRemoveTileAt(),
	    RemoveTileAtWorldXY: requireRemoveTileAtWorldXY(),
	    RenderDebug: requireRenderDebug(),
	    ReplaceByIndex: requireReplaceByIndex(),
	    RunCull: requireRunCull(),
	    SetCollision: requireSetCollision(),
	    SetCollisionBetween: requireSetCollisionBetween(),
	    SetCollisionByExclusion: requireSetCollisionByExclusion(),
	    SetCollisionByProperty: requireSetCollisionByProperty(),
	    SetCollisionFromCollisionGroup: requireSetCollisionFromCollisionGroup(),
	    SetLayerCollisionIndex: requireSetLayerCollisionIndex(),
	    SetTileCollision: requireSetTileCollision(),
	    SetTileIndexCallback: requireSetTileIndexCallback(),
	    SetTileLocationCallback: requireSetTileLocationCallback(),
	    Shuffle: requireShuffle(),
	    StaggeredCullBounds: requireStaggeredCullBounds(),
	    StaggeredCullTiles: requireStaggeredCullTiles(),
	    StaggeredTileToWorldXY: requireStaggeredTileToWorldXY(),
	    StaggeredTileToWorldY: requireStaggeredTileToWorldY(),
	    StaggeredWorldToTileXY: requireStaggeredWorldToTileXY(),
	    StaggeredWorldToTileY: requireStaggeredWorldToTileY(),
	    SwapByIndex: requireSwapByIndex(),
	    TileToWorldX: requireTileToWorldX(),
	    TileToWorldXY: requireTileToWorldXY(),
	    TileToWorldY: requireTileToWorldY(),
	    WeightedRandomize: requireWeightedRandomize(),
	    WorldToTileX: requireWorldToTileX(),
	    WorldToTileXY: requireWorldToTileXY(),
	    WorldToTileY: requireWorldToTileY()

	};
	return components;
}

var FromOrientationString_1;
var hasRequiredFromOrientationString;

function requireFromOrientationString () {
	if (hasRequiredFromOrientationString) return FromOrientationString_1;
	hasRequiredFromOrientationString = 1;
	var CONST = requireORIENTATION_CONST();

	var FromOrientationString = function (orientation)
	{
	    orientation = orientation.toLowerCase();

	    if (orientation === 'isometric')
	    {
	        return CONST.ISOMETRIC;
	    }
	    else if (orientation === 'staggered')
	    {
	        return CONST.STAGGERED;
	    }
	    else if (orientation === 'hexagonal')
	    {
	        return CONST.HEXAGONAL;
	    }
	    else
	    {
	        return CONST.ORTHOGONAL;
	    }
	};

	FromOrientationString_1 = FromOrientationString;
	return FromOrientationString_1;
}

var LayerData_1;
var hasRequiredLayerData;

function requireLayerData () {
	if (hasRequiredLayerData) return LayerData_1;
	hasRequiredLayerData = 1;
	var Class = requireClass();
	var CONST = requireORIENTATION_CONST();
	var GetFastValue = requireGetFastValue();

	var LayerData = new Class({

	    initialize:

	    function LayerData (config)
	    {
	        if (config === undefined) { config = {}; }

	        this.name = GetFastValue(config, 'name', 'layer');

	        this.id = GetFastValue(config, 'id', 0);

	        this.x = GetFastValue(config, 'x', 0);

	        this.y = GetFastValue(config, 'y', 0);

	        this.width = GetFastValue(config, 'width', 0);

	        this.height = GetFastValue(config, 'height', 0);

	        this.tileWidth = GetFastValue(config, 'tileWidth', 0);

	        this.tileHeight = GetFastValue(config, 'tileHeight', 0);

	        this.baseTileWidth = GetFastValue(config, 'baseTileWidth', this.tileWidth);

	        this.baseTileHeight = GetFastValue(config, 'baseTileHeight', this.tileHeight);

	        this.orientation = GetFastValue(config, 'orientation', CONST.ORTHOGONAL);

	        this.widthInPixels = GetFastValue(config, 'widthInPixels', this.width * this.baseTileWidth);

	        this.heightInPixels = GetFastValue(config, 'heightInPixels', this.height * this.baseTileHeight);

	        this.alpha = GetFastValue(config, 'alpha', 1);

	        this.visible = GetFastValue(config, 'visible', true);

	        this.properties = GetFastValue(config, 'properties', []);

	        this.indexes = GetFastValue(config, 'indexes', []);

	        this.collideIndexes = GetFastValue(config, 'collideIndexes', []);

	        this.callbacks = GetFastValue(config, 'callbacks', []);

	        this.bodies = GetFastValue(config, 'bodies', []);

	        this.data = GetFastValue(config, 'data', []);

	        this.tilemapLayer = GetFastValue(config, 'tilemapLayer', null);

	        this.hexSideLength = GetFastValue(config, 'hexSideLength', 0);

	        this.staggerAxis = GetFastValue(config, 'staggerAxis', 'y');

	        this.staggerIndex = GetFastValue(config, 'staggerIndex', 'odd');
	    }

	});

	LayerData_1 = LayerData;
	return LayerData_1;
}

var MapData_1;
var hasRequiredMapData;

function requireMapData () {
	if (hasRequiredMapData) return MapData_1;
	hasRequiredMapData = 1;
	var Class = requireClass();
	var CONST = requireORIENTATION_CONST();
	var GetFastValue = requireGetFastValue();

	var MapData = new Class({

	    initialize:

	    function MapData (config)
	    {
	        if (config === undefined) { config = {}; }

	        this.name = GetFastValue(config, 'name', 'map');

	        this.width = GetFastValue(config, 'width', 0);

	        this.height = GetFastValue(config, 'height', 0);

	        this.infinite = GetFastValue(config, 'infinite', false);

	        this.tileWidth = GetFastValue(config, 'tileWidth', 0);

	        this.tileHeight = GetFastValue(config, 'tileHeight', 0);

	        this.widthInPixels = GetFastValue(config, 'widthInPixels', this.width * this.tileWidth);

	        this.heightInPixels = GetFastValue(config, 'heightInPixels', this.height * this.tileHeight);

	        this.format = GetFastValue(config, 'format', null);

	        this.orientation = GetFastValue(config, 'orientation', CONST.ORTHOGONAL);

	        this.renderOrder = GetFastValue(config, 'renderOrder', 'right-down');

	        this.version = GetFastValue(config, 'version', '1');

	        this.properties = GetFastValue(config, 'properties', {});

	        this.layers = GetFastValue(config, 'layers', []);

	        this.images = GetFastValue(config, 'images', []);

	        this.objects = GetFastValue(config, 'objects', []);

	        if (!Array.isArray(this.objects))
	        {
	            this.objects = [];
	        }

	        this.collision = GetFastValue(config, 'collision', {});

	        this.tilesets = GetFastValue(config, 'tilesets', []);

	        this.imageCollections = GetFastValue(config, 'imageCollections', []);

	        this.tiles = GetFastValue(config, 'tiles', []);

	        this.hexSideLength = GetFastValue(config, 'hexSideLength', 0);

	        this.staggerAxis = GetFastValue(config, 'staggerAxis', 'y');

	        this.staggerIndex = GetFastValue(config, 'staggerIndex', 'odd');
	    }

	});

	MapData_1 = MapData;
	return MapData_1;
}

var Parse2DArray_1;
var hasRequiredParse2DArray;

function requireParse2DArray () {
	if (hasRequiredParse2DArray) return Parse2DArray_1;
	hasRequiredParse2DArray = 1;
	var Formats = requireFormats();
	var LayerData = requireLayerData();
	var MapData = requireMapData();
	var Tile = requireTile();

	var Parse2DArray = function (name, data, tileWidth, tileHeight, insertNull)
	{
	    var layerData = new LayerData({
	        tileWidth: tileWidth,
	        tileHeight: tileHeight
	    });

	    var mapData = new MapData({
	        name: name,
	        tileWidth: tileWidth,
	        tileHeight: tileHeight,
	        format: Formats.ARRAY_2D,
	        layers: [ layerData ]
	    });

	    var tiles = [];
	    var height = data.length;
	    var width = 0;

	    for (var y = 0; y < data.length; y++)
	    {
	        tiles[y] = [];
	        var row = data[y];

	        for (var x = 0; x < row.length; x++)
	        {
	            var tileIndex = parseInt(row[x], 10);

	            if (isNaN(tileIndex) || tileIndex === -1)
	            {
	                tiles[y][x] = insertNull
	                    ? null
	                    : new Tile(layerData, -1, x, y, tileWidth, tileHeight);
	            }
	            else
	            {
	                tiles[y][x] = new Tile(layerData, tileIndex, x, y, tileWidth, tileHeight);
	            }
	        }

	        if (width === 0)
	        {
	            width = row.length;
	        }
	    }

	    mapData.width = layerData.width = width;
	    mapData.height = layerData.height = height;
	    mapData.widthInPixels = layerData.widthInPixels = width * tileWidth;
	    mapData.heightInPixels = layerData.heightInPixels = height * tileHeight;
	    layerData.data = tiles;

	    return mapData;
	};

	Parse2DArray_1 = Parse2DArray;
	return Parse2DArray_1;
}

var ParseCSV_1;
var hasRequiredParseCSV;

function requireParseCSV () {
	if (hasRequiredParseCSV) return ParseCSV_1;
	hasRequiredParseCSV = 1;
	var Formats = requireFormats();
	var Parse2DArray = requireParse2DArray();

	var ParseCSV = function (name, data, tileWidth, tileHeight, insertNull)
	{
	    var array2D = data
	        .trim()
	        .split('\n')
	        .map(function (row) { return row.split(','); });

	    var map = Parse2DArray(name, array2D, tileWidth, tileHeight, insertNull);
	    map.format = Formats.CSV;

	    return map;
	};

	ParseCSV_1 = ParseCSV;
	return ParseCSV_1;
}

var AssignTileProperties_1;
var hasRequiredAssignTileProperties;

function requireAssignTileProperties () {
	if (hasRequiredAssignTileProperties) return AssignTileProperties_1;
	hasRequiredAssignTileProperties = 1;
	var Extend = requireExtend$1();

	var AssignTileProperties = function (mapData)
	{
	    var layerData;
	    var tile;
	    var sid;
	    var set;
	    var row;

	    for (var i = 0; i < mapData.layers.length; i++)
	    {
	        layerData = mapData.layers[i];

	        set = null;

	        for (var j = 0; j < layerData.data.length; j++)
	        {
	            row = layerData.data[j];

	            for (var k = 0; k < row.length; k++)
	            {
	                tile = row[k];

	                if (tile === null || tile.index < 0)
	                {
	                    continue;
	                }

	                sid = mapData.tiles[tile.index][2];
	                set = mapData.tilesets[sid];

	                tile.width = set.tileWidth;
	                tile.height = set.tileHeight;

	                if (set.tileProperties && set.tileProperties[tile.index - set.firstgid])
	                {
	                    tile.properties = Extend(
	                        tile.properties, set.tileProperties[tile.index - set.firstgid]
	                    );
	                }
	            }
	        }
	    }
	};

	AssignTileProperties_1 = AssignTileProperties;
	return AssignTileProperties_1;
}

var Tileset_1;
var hasRequiredTileset;

function requireTileset () {
	if (hasRequiredTileset) return Tileset_1;
	hasRequiredTileset = 1;
	var Class = requireClass();
	var Vector2 = requireVector2();

	var Tileset = new Class({

	    initialize:

	    function Tileset (name, firstgid, tileWidth, tileHeight, tileMargin, tileSpacing, tileProperties, tileData, tileOffset)
	    {
	        if (tileWidth === undefined || tileWidth <= 0) { tileWidth = 32; }
	        if (tileHeight === undefined || tileHeight <= 0) { tileHeight = 32; }
	        if (tileMargin === undefined) { tileMargin = 0; }
	        if (tileSpacing === undefined) { tileSpacing = 0; }
	        if (tileProperties === undefined) { tileProperties = {}; }
	        if (tileData === undefined) { tileData = {}; }

	        this.name = name;

	        this.firstgid = firstgid;

	        this.tileWidth = tileWidth;

	        this.tileHeight = tileHeight;

	        this.tileMargin = tileMargin;

	        this.tileSpacing = tileSpacing;

	        this.tileProperties = tileProperties;

	        this.tileData = tileData;

	        this.tileOffset = new Vector2();

	        if (tileOffset !== undefined)
	        {
	            this.tileOffset.set(tileOffset.x, tileOffset.y);
	        }

	        this.image = null;

	        this.glTexture = null;

	        this.rows = 0;

	        this.columns = 0;

	        this.total = 0;

	        this.texCoordinates = [];
	    },

	    getTileProperties: function (tileIndex)
	    {
	        if (!this.containsTileIndex(tileIndex)) { return null; }

	        return this.tileProperties[tileIndex - this.firstgid];
	    },

	    getTileData: function (tileIndex)
	    {
	        if (!this.containsTileIndex(tileIndex)) { return null; }

	        return this.tileData[tileIndex - this.firstgid];
	    },

	    getTileCollisionGroup: function (tileIndex)
	    {
	        var data = this.getTileData(tileIndex);

	        return (data && data.objectgroup) ? data.objectgroup : null;
	    },

	    containsTileIndex: function (tileIndex)
	    {
	        return (
	            tileIndex >= this.firstgid &&
	            tileIndex < (this.firstgid + this.total)
	        );
	    },

	    getTileTextureCoordinates: function (tileIndex)
	    {
	        if (!this.containsTileIndex(tileIndex)) { return null; }

	        return this.texCoordinates[tileIndex - this.firstgid];
	    },

	    setImage: function (texture)
	    {
	        this.image = texture;

	        var frame = texture.get();

	        var bounds = texture.getFrameBounds();

	        this.glTexture = frame.source.glTexture;

	        if (frame.width > bounds.width || frame.height > bounds.height)
	        {
	            this.updateTileData(frame.width, frame.height);
	        }
	        else
	        {
	            this.updateTileData(bounds.width, bounds.height, bounds.x, bounds.y);
	        }

	        return this;
	    },

	    setTileSize: function (tileWidth, tileHeight)
	    {
	        if (tileWidth !== undefined) { this.tileWidth = tileWidth; }
	        if (tileHeight !== undefined) { this.tileHeight = tileHeight; }

	        if (this.image)
	        {
	            this.updateTileData(this.image.source[0].width, this.image.source[0].height);
	        }

	        return this;
	    },

	    setSpacing: function (margin, spacing)
	    {
	        if (margin !== undefined) { this.tileMargin = margin; }
	        if (spacing !== undefined) { this.tileSpacing = spacing; }

	        if (this.image)
	        {
	            this.updateTileData(this.image.source[0].width, this.image.source[0].height);
	        }

	        return this;
	    },

	    updateTileData: function (imageWidth, imageHeight, offsetX, offsetY)
	    {
	        if (offsetX === undefined) { offsetX = 0; }
	        if (offsetY === undefined) { offsetY = 0; }

	        var rowCount = (imageHeight - this.tileMargin * 2 + this.tileSpacing) / (this.tileHeight + this.tileSpacing);
	        var colCount = (imageWidth - this.tileMargin * 2 + this.tileSpacing) / (this.tileWidth + this.tileSpacing);

	        if (rowCount % 1 !== 0 || colCount % 1 !== 0)
	        {
	            console.warn('Image tile area not tile size multiple in: ' + this.name);
	        }

	        rowCount = Math.floor(rowCount);
	        colCount = Math.floor(colCount);

	        this.rows = rowCount;
	        this.columns = colCount;

	        this.total = rowCount * colCount;

	        this.texCoordinates.length = 0;

	        var tx = this.tileMargin + offsetX;
	        var ty = this.tileMargin + offsetY;

	        for (var y = 0; y < this.rows; y++)
	        {
	            for (var x = 0; x < this.columns; x++)
	            {
	                this.texCoordinates.push({ x: tx, y: ty });
	                tx += this.tileWidth + this.tileSpacing;
	            }

	            tx = this.tileMargin + offsetX;
	            ty += this.tileHeight + this.tileSpacing;
	        }

	        return this;
	    }

	});

	Tileset_1 = Tileset;
	return Tileset_1;
}

var BuildTilesetIndex_1;
var hasRequiredBuildTilesetIndex;

function requireBuildTilesetIndex () {
	if (hasRequiredBuildTilesetIndex) return BuildTilesetIndex_1;
	hasRequiredBuildTilesetIndex = 1;
	var Tileset = requireTileset();

	var BuildTilesetIndex = function (mapData)
	{
	    var i;
	    var set;
	    var tiles = [];

	    for (i = 0; i < mapData.imageCollections.length; i++)
	    {
	        var collection = mapData.imageCollections[i];
	        var images = collection.images;

	        for (var j = 0; j < images.length; j++)
	        {
	            var image = images[j];
	            var offset = {
	                x: 0,
	                y: image.height - mapData.tileHeight
	            };

	            set = new Tileset(image.image, image.gid, image.width, image.height, 0, 0, undefined, undefined, offset);

	            set.updateTileData(image.width, image.height);

	            mapData.tilesets.push(set);
	        }
	    }

	    for (i = 0; i < mapData.tilesets.length; i++)
	    {
	        set = mapData.tilesets[i];

	        var x = set.tileMargin;
	        var y = set.tileMargin;

	        var count = 0;
	        var countX = 0;
	        var countY = 0;

	        for (var t = set.firstgid; t < set.firstgid + set.total; t++)
	        {

	            tiles[t] = [ x, y, i ];

	            x += set.tileWidth + set.tileSpacing;

	            count++;

	            if (count === set.total)
	            {
	                break;
	            }

	            countX++;

	            if (countX === set.columns)
	            {
	                x = set.tileMargin;
	                y += set.tileHeight + set.tileSpacing;

	                countX = 0;
	                countY++;

	                if (countY === set.rows)
	                {
	                    break;
	                }
	            }
	        }
	    }

	    return tiles;
	};

	BuildTilesetIndex_1 = BuildTilesetIndex;
	return BuildTilesetIndex_1;
}

var CreateGroupLayer_1;
var hasRequiredCreateGroupLayer;

function requireCreateGroupLayer () {
	if (hasRequiredCreateGroupLayer) return CreateGroupLayer_1;
	hasRequiredCreateGroupLayer = 1;
	var GetFastValue = requireGetFastValue();

	var CreateGroupLayer = function (json, group, parentState)
	{
	    if (!group)
	    {

	        return {
	            i: 0, 
	            layers: json.layers, 

	            name: '',
	            opacity: 1,
	            visible: true,
	            x: 0,
	            y: 0
	        };
	    }

	    var layerX = group.x + GetFastValue(group, 'startx', 0) * json.tilewidth + GetFastValue(group, 'offsetx', 0);
	    var layerY = group.y + GetFastValue(group, 'starty', 0) * json.tileheight + GetFastValue(group, 'offsety', 0);

	    return {
	        i: 0,
	        layers: group.layers,
	        name: parentState.name + group.name + '/',
	        opacity: parentState.opacity * group.opacity,
	        visible: parentState.visible && group.visible,
	        x: parentState.x + layerX,
	        y: parentState.y + layerY
	    };
	};

	CreateGroupLayer_1 = CreateGroupLayer;
	return CreateGroupLayer_1;
}

var ParseImageLayers_1;
var hasRequiredParseImageLayers;

function requireParseImageLayers () {
	if (hasRequiredParseImageLayers) return ParseImageLayers_1;
	hasRequiredParseImageLayers = 1;
	var GetFastValue = requireGetFastValue();
	var CreateGroupLayer = requireCreateGroupLayer();

	var ParseImageLayers = function (json)
	{
	    var images = [];

	    var groupStack = [];
	    var curGroupState = CreateGroupLayer(json);

	    while (curGroupState.i < curGroupState.layers.length || groupStack.length > 0)
	    {
	        if (curGroupState.i >= curGroupState.layers.length)
	        {

	            if (groupStack.length < 1)
	            {
	                console.warn(
	                    'TilemapParser.parseTiledJSON - Invalid layer group hierarchy'
	                );
	                break;
	            }

	            curGroupState = groupStack.pop();
	            continue;
	        }

	        var curi = curGroupState.layers[curGroupState.i];
	        curGroupState.i++;

	        if (curi.type !== 'imagelayer')
	        {
	            if (curi.type === 'group')
	            {

	                var nextGroupState = CreateGroupLayer(json, curi, curGroupState);

	                groupStack.push(curGroupState);
	                curGroupState = nextGroupState;
	            }

	            continue;
	        }

	        var layerOffsetX = GetFastValue(curi, 'offsetx', 0) + GetFastValue(curi, 'startx', 0);
	        var layerOffsetY = GetFastValue(curi, 'offsety', 0) + GetFastValue(curi, 'starty', 0);
	        images.push({
	            name: (curGroupState.name + curi.name),
	            image: curi.image,
	            x: (curGroupState.x + layerOffsetX + curi.x),
	            y: (curGroupState.y + layerOffsetY + curi.y),
	            alpha: (curGroupState.opacity * curi.opacity),
	            visible: (curGroupState.visible && curi.visible),
	            properties: GetFastValue(curi, 'properties', {})
	        });
	    }

	    return images;
	};

	ParseImageLayers_1 = ParseImageLayers;
	return ParseImageLayers_1;
}

var Pick_1;
var hasRequiredPick;

function requirePick () {
	if (hasRequiredPick) return Pick_1;
	hasRequiredPick = 1;
	var HasValue = requireHasValue();

	var Pick = function (object, keys)
	{
	    var obj = {};

	    for (var i = 0; i < keys.length; i++)
	    {
	        var key = keys[i];

	        if (HasValue(object, key))
	        {
	            obj[key] = object[key];
	        }
	    }

	    return obj;
	};

	Pick_1 = Pick;
	return Pick_1;
}

var ParseGID_1;
var hasRequiredParseGID;

function requireParseGID () {
	if (hasRequiredParseGID) return ParseGID_1;
	hasRequiredParseGID = 1;
	var FLIPPED_HORIZONTAL = 0x80000000;
	var FLIPPED_VERTICAL = 0x40000000;
	var FLIPPED_ANTI_DIAGONAL = 0x20000000; 

	var ParseGID = function (gid)
	{
	    var flippedHorizontal = Boolean(gid & FLIPPED_HORIZONTAL);
	    var flippedVertical = Boolean(gid & FLIPPED_VERTICAL);
	    var flippedAntiDiagonal = Boolean(gid & FLIPPED_ANTI_DIAGONAL);
	    gid = gid & ~(FLIPPED_HORIZONTAL | FLIPPED_VERTICAL | FLIPPED_ANTI_DIAGONAL);

	    var rotation = 0;
	    var flipped = false;

	    if (flippedHorizontal && flippedVertical && flippedAntiDiagonal)
	    {
	        rotation = Math.PI / 2;
	        flipped = true;
	    }
	    else if (flippedHorizontal && flippedVertical && !flippedAntiDiagonal)
	    {
	        rotation = Math.PI;
	        flipped = false;
	    }
	    else if (flippedHorizontal && !flippedVertical && flippedAntiDiagonal)
	    {
	        rotation = Math.PI / 2;
	        flipped = false;
	    }
	    else if (flippedHorizontal && !flippedVertical && !flippedAntiDiagonal)
	    {
	        rotation = 0;
	        flipped = true;
	    }
	    else if (!flippedHorizontal && flippedVertical && flippedAntiDiagonal)
	    {
	        rotation = 3 * Math.PI / 2;
	        flipped = false;
	    }
	    else if (!flippedHorizontal && flippedVertical && !flippedAntiDiagonal)
	    {
	        rotation = Math.PI;
	        flipped = true;
	    }
	    else if (!flippedHorizontal && !flippedVertical && flippedAntiDiagonal)
	    {
	        rotation = 3 * Math.PI / 2;
	        flipped = true;
	    }
	    else if (!flippedHorizontal && !flippedVertical && !flippedAntiDiagonal)
	    {
	        rotation = 0;
	        flipped = false;
	    }

	    return {
	        gid: gid,
	        flippedHorizontal: flippedHorizontal,
	        flippedVertical: flippedVertical,
	        flippedAntiDiagonal: flippedAntiDiagonal,
	        rotation: rotation,
	        flipped: flipped
	    };
	};

	ParseGID_1 = ParseGID;
	return ParseGID_1;
}

var ParseObject_1;
var hasRequiredParseObject;

function requireParseObject () {
	if (hasRequiredParseObject) return ParseObject_1;
	hasRequiredParseObject = 1;
	var Pick = requirePick();
	var ParseGID = requireParseGID();

	var copyPoints = function (p) { return { x: p.x, y: p.y }; };

	var commonObjectProps = [ 'id', 'name', 'type', 'rotation', 'properties', 'visible', 'x', 'y', 'width', 'height' ];

	var ParseObject = function (tiledObject, offsetX, offsetY)
	{
	    if (offsetX === undefined) { offsetX = 0; }
	    if (offsetY === undefined) { offsetY = 0; }

	    var parsedObject = Pick(tiledObject, commonObjectProps);

	    parsedObject.x += offsetX;
	    parsedObject.y += offsetY;

	    if (tiledObject.gid)
	    {

	        var gidInfo = ParseGID(tiledObject.gid);
	        parsedObject.gid = gidInfo.gid;
	        parsedObject.flippedHorizontal = gidInfo.flippedHorizontal;
	        parsedObject.flippedVertical = gidInfo.flippedVertical;
	        parsedObject.flippedAntiDiagonal = gidInfo.flippedAntiDiagonal;
	    }
	    else if (tiledObject.polyline)
	    {
	        parsedObject.polyline = tiledObject.polyline.map(copyPoints);
	    }
	    else if (tiledObject.polygon)
	    {
	        parsedObject.polygon = tiledObject.polygon.map(copyPoints);
	    }
	    else if (tiledObject.ellipse)
	    {
	        parsedObject.ellipse = tiledObject.ellipse;
	    }
	    else if (tiledObject.text)
	    {
	        parsedObject.text = tiledObject.text;
	    }
	    else if (tiledObject.point)
	    {
	        parsedObject.point = true;
	    }
	    else
	    {

	        parsedObject.rectangle = true;
	    }

	    return parsedObject;
	};

	ParseObject_1 = ParseObject;
	return ParseObject_1;
}

var ObjectLayer_1;
var hasRequiredObjectLayer;

function requireObjectLayer () {
	if (hasRequiredObjectLayer) return ObjectLayer_1;
	hasRequiredObjectLayer = 1;
	var Class = requireClass();
	var GetFastValue = requireGetFastValue();

	var ObjectLayer = new Class({

	    initialize:

	    function ObjectLayer (config)
	    {
	        if (config === undefined) { config = {}; }

	        this.name = GetFastValue(config, 'name', 'object layer');

	        this.id = GetFastValue(config, 'id', 0);

	        this.opacity = GetFastValue(config, 'opacity', 1);

	        this.properties = GetFastValue(config, 'properties', {});

	        this.propertyTypes = GetFastValue(config, 'propertytypes', {});

	        this.type = GetFastValue(config, 'type', 'objectgroup');

	        this.visible = GetFastValue(config, 'visible', true);

	        this.objects = GetFastValue(config, 'objects', []);

	        if (!Array.isArray(this.objects))
	        {
	            this.objects = [];
	        }
	    }

	});

	ObjectLayer_1 = ObjectLayer;
	return ObjectLayer_1;
}

var ParseObjectLayers_1;
var hasRequiredParseObjectLayers;

function requireParseObjectLayers () {
	if (hasRequiredParseObjectLayers) return ParseObjectLayers_1;
	hasRequiredParseObjectLayers = 1;
	var GetFastValue = requireGetFastValue();
	var ParseObject = requireParseObject();
	var ObjectLayer = requireObjectLayer();
	var CreateGroupLayer = requireCreateGroupLayer();

	var ParseObjectLayers = function (json)
	{
	    var objectLayers = [];

	    var groupStack = [];
	    var curGroupState = CreateGroupLayer(json);

	    while (curGroupState.i < curGroupState.layers.length || groupStack.length > 0)
	    {
	        if (curGroupState.i >= curGroupState.layers.length)
	        {

	            if (groupStack.length < 1)
	            {
	                console.warn(
	                    'TilemapParser.parseTiledJSON - Invalid layer group hierarchy'
	                );
	                break;
	            }

	            curGroupState = groupStack.pop();
	            continue;
	        }

	        var curo = curGroupState.layers[curGroupState.i];
	        curGroupState.i++;

	        curo.opacity *= curGroupState.opacity;
	        curo.visible = curGroupState.visible && curo.visible;

	        if (curo.type !== 'objectgroup')
	        {
	            if (curo.type === 'group')
	            {

	                var nextGroupState = CreateGroupLayer(json, curo, curGroupState);

	                groupStack.push(curGroupState);
	                curGroupState = nextGroupState;
	            }

	            continue;
	        }

	        curo.name = curGroupState.name + curo.name;
	        var offsetX = curGroupState.x + GetFastValue(curo, 'startx', 0) + GetFastValue(curo, 'offsetx', 0);
	        var offsetY = curGroupState.y + GetFastValue(curo, 'starty', 0) + GetFastValue(curo, 'offsety', 0);

	        var objects = [];
	        for (var j = 0; j < curo.objects.length; j++)
	        {
	            var parsedObject = ParseObject(curo.objects[j], offsetX, offsetY);

	            objects.push(parsedObject);
	        }

	        var objectLayer = new ObjectLayer(curo);
	        objectLayer.objects = objects;

	        objectLayers.push(objectLayer);
	    }

	    return objectLayers;
	};

	ParseObjectLayers_1 = ParseObjectLayers;
	return ParseObjectLayers_1;
}

var Base64Decode_1;
var hasRequiredBase64Decode;

function requireBase64Decode () {
	if (hasRequiredBase64Decode) return Base64Decode_1;
	hasRequiredBase64Decode = 1;
	var Base64Decode = function (data)
	{
	    var binaryString = window.atob(data);
	    var len = binaryString.length;
	    var bytes = new Array(len / 4);

	    for (var i = 0; i < len; i += 4)
	    {
	        bytes[i / 4] = (
	            binaryString.charCodeAt(i) |
	            binaryString.charCodeAt(i + 1) << 8 |
	            binaryString.charCodeAt(i + 2) << 16 |
	            binaryString.charCodeAt(i + 3) << 24
	        ) >>> 0;
	    }

	    return bytes;
	};

	Base64Decode_1 = Base64Decode;
	return Base64Decode_1;
}

var ParseTileLayers_1$1;
var hasRequiredParseTileLayers$1;

function requireParseTileLayers$1 () {
	if (hasRequiredParseTileLayers$1) return ParseTileLayers_1$1;
	hasRequiredParseTileLayers$1 = 1;
	var Base64Decode = requireBase64Decode();
	var CONST = requireORIENTATION_CONST();
	var CreateGroupLayer = requireCreateGroupLayer();
	var FromOrientationString = requireFromOrientationString();
	var GetFastValue = requireGetFastValue();
	var LayerData = requireLayerData();
	var ParseGID = requireParseGID();
	var Tile = requireTile();

	var ParseTileLayers = function (json, insertNull)
	{
	    var infiniteMap = GetFastValue(json, 'infinite', false);
	    var tileLayers = [];

	    var groupStack = [];
	    var curGroupState = CreateGroupLayer(json);

	    while (curGroupState.i < curGroupState.layers.length || groupStack.length > 0)
	    {
	        if (curGroupState.i >= curGroupState.layers.length)
	        {

	            if (groupStack.length < 1)
	            {
	                console.warn(
	                    'TilemapParser.parseTiledJSON - Invalid layer group hierarchy'
	                );
	                break;
	            }

	            curGroupState = groupStack.pop();
	            continue;
	        }

	        var curl = curGroupState.layers[curGroupState.i];
	        curGroupState.i++;

	        if (curl.type !== 'tilelayer')
	        {
	            if (curl.type === 'group')
	            {

	                var nextGroupState = CreateGroupLayer(json, curl, curGroupState);

	                groupStack.push(curGroupState);
	                curGroupState = nextGroupState;
	            }

	            continue;
	        }

	        if (curl.compression)
	        {
	            console.warn(
	                'TilemapParser.parseTiledJSON - Layer compression is unsupported, skipping layer \''
	                + curl.name + '\''
	            );
	            continue;
	        }
	        else if (curl.encoding && curl.encoding === 'base64')
	        {

	            if (curl.chunks)
	            {
	                for (var i = 0; i < curl.chunks.length; i++)
	                {
	                    curl.chunks[i].data = Base64Decode(curl.chunks[i].data);
	                }
	            }

	            if (curl.data)
	            {
	                curl.data = Base64Decode(curl.data);
	            }

	            delete curl.encoding; 
	        }

	        var layerData;
	        var gidInfo;
	        var tile;
	        var blankTile;
	        var triangleHeight;
	        var triangleWidth;

	        var output = [];
	        var x = 0;

	        if (infiniteMap)
	        {
	            var layerOffsetX = (GetFastValue(curl, 'startx', 0) + curl.x);
	            var layerOffsetY = (GetFastValue(curl, 'starty', 0) + curl.y);

	            layerData = new LayerData({
	                name: (curGroupState.name + curl.name),
	                id: curl.id,
	                x: (curGroupState.x + GetFastValue(curl, 'offsetx', 0) + layerOffsetX * json.tilewidth),
	                y: (curGroupState.y + GetFastValue(curl, 'offsety', 0) + layerOffsetY * json.tileheight),
	                width: curl.width,
	                height: curl.height,
	                tileWidth: json.tilewidth,
	                tileHeight: json.tileheight,
	                alpha: (curGroupState.opacity * curl.opacity),
	                visible: (curGroupState.visible && curl.visible),
	                properties: GetFastValue(curl, 'properties', []),
	                orientation: FromOrientationString(json.orientation)
	            });

	            if (layerData.orientation === CONST.HEXAGONAL)
	            {
	                layerData.hexSideLength = json.hexsidelength;
	                layerData.staggerAxis = json.staggeraxis;
	                layerData.staggerIndex = json.staggerindex;

	                if (layerData.staggerAxis === 'y')
	                {
	                    triangleHeight = (layerData.tileHeight - layerData.hexSideLength) / 2;
	                    layerData.widthInPixels = layerData.tileWidth * (layerData.width + 0.5);
	                    layerData.heightInPixels = layerData.height * (layerData.hexSideLength + triangleHeight) + triangleHeight;
	                }
	                else
	                {
	                    triangleWidth = (layerData.tileWidth - layerData.hexSideLength) / 2;
	                    layerData.widthInPixels = layerData.width * (layerData.hexSideLength + triangleWidth) + triangleWidth;
	                    layerData.heightInPixels = layerData.tileHeight * (layerData.height + 0.5);
	                }
	            }

	            for (var c = 0; c < curl.height; c++)
	            {
	                output[c] = [ null ];

	                for (var j = 0; j < curl.width; j++)
	                {
	                    output[c][j] = null;
	                }
	            }

	            for (c = 0, len = curl.chunks.length; c < len; c++)
	            {
	                var chunk = curl.chunks[c];

	                var offsetX = (chunk.x - layerOffsetX);
	                var offsetY = (chunk.y - layerOffsetY);

	                var y = 0;

	                for (var t = 0, len2 = chunk.data.length; t < len2; t++)
	                {
	                    var newOffsetX = x + offsetX;
	                    var newOffsetY = y + offsetY;

	                    gidInfo = ParseGID(chunk.data[t]);

	                    if (gidInfo.gid > 0)
	                    {
	                        tile = new Tile(layerData, gidInfo.gid, newOffsetX, newOffsetY, json.tilewidth, json.tileheight);

	                        tile.rotation = gidInfo.rotation;
	                        tile.flipX = gidInfo.flipped;

	                        output[newOffsetY][newOffsetX] = tile;
	                    }
	                    else
	                    {
	                        blankTile = insertNull
	                            ? null
	                            : new Tile(layerData, -1, newOffsetX, newOffsetY, json.tilewidth, json.tileheight);

	                        output[newOffsetY][newOffsetX] = blankTile;
	                    }

	                    x++;

	                    if (x === chunk.width)
	                    {
	                        y++;
	                        x = 0;
	                    }
	                }
	            }
	        }
	        else
	        {
	            layerData = new LayerData({
	                name: (curGroupState.name + curl.name),
	                id: curl.id,
	                x: (curGroupState.x + GetFastValue(curl, 'offsetx', 0) + curl.x),
	                y: (curGroupState.y + GetFastValue(curl, 'offsety', 0) + curl.y),
	                width: curl.width,
	                height: curl.height,
	                tileWidth: json.tilewidth,
	                tileHeight: json.tileheight,
	                alpha: (curGroupState.opacity * curl.opacity),
	                visible: (curGroupState.visible && curl.visible),
	                properties: GetFastValue(curl, 'properties', []),
	                orientation: FromOrientationString(json.orientation)
	            });

	            if (layerData.orientation === CONST.HEXAGONAL)
	            {
	                layerData.hexSideLength = json.hexsidelength;
	                layerData.staggerAxis = json.staggeraxis;
	                layerData.staggerIndex = json.staggerindex;

	                if (layerData.staggerAxis === 'y')
	                {
	                    triangleHeight = (layerData.tileHeight - layerData.hexSideLength) / 2;
	                    layerData.widthInPixels = layerData.tileWidth * (layerData.width + 0.5);
	                    layerData.heightInPixels = layerData.height * (layerData.hexSideLength + triangleHeight) + triangleHeight;
	                }
	                else
	                {
	                    triangleWidth = (layerData.tileWidth - layerData.hexSideLength) / 2;
	                    layerData.widthInPixels = layerData.width * (layerData.hexSideLength + triangleWidth) + triangleWidth;
	                    layerData.heightInPixels = layerData.tileHeight * (layerData.height + 0.5);
	                }
	            }
	            var row = [];

	            for (var k = 0, len = curl.data.length; k < len; k++)
	            {
	                gidInfo = ParseGID(curl.data[k]);

	                if (gidInfo.gid > 0)
	                {
	                    tile = new Tile(layerData, gidInfo.gid, x, output.length, json.tilewidth, json.tileheight);

	                    tile.rotation = gidInfo.rotation;
	                    tile.flipX = gidInfo.flipped;

	                    row.push(tile);
	                }
	                else
	                {
	                    blankTile = insertNull
	                        ? null
	                        : new Tile(layerData, -1, x, output.length, json.tilewidth, json.tileheight);
	                    row.push(blankTile);
	                }

	                x++;

	                if (x === curl.width)
	                {
	                    output.push(row);
	                    x = 0;
	                    row = [];
	                }
	            }
	        }

	        layerData.data = output;
	        tileLayers.push(layerData);
	    }

	    return tileLayers;
	};

	ParseTileLayers_1$1 = ParseTileLayers;
	return ParseTileLayers_1$1;
}

var ImageCollection_1;
var hasRequiredImageCollection;

function requireImageCollection () {
	if (hasRequiredImageCollection) return ImageCollection_1;
	hasRequiredImageCollection = 1;
	var Class = requireClass();

	var ImageCollection = new Class({

	    initialize:

	    function ImageCollection (name, firstgid, width, height, margin, spacing, properties)
	    {
	        if (width === undefined || width <= 0) { width = 32; }
	        if (height === undefined || height <= 0) { height = 32; }
	        if (margin === undefined) { margin = 0; }
	        if (spacing === undefined) { spacing = 0; }

	        this.name = name;

	        this.firstgid = firstgid | 0;

	        this.imageWidth = width | 0;

	        this.imageHeight = height | 0;

	        this.imageMargin = margin | 0;

	        this.imageSpacing = spacing | 0;

	        this.properties = properties || {};

	        this.images = [];

	        this.total = 0;
	    },

	    containsImageIndex: function (imageIndex)
	    {
	        return (imageIndex >= this.firstgid && imageIndex < (this.firstgid + this.total));
	    },

	    addImage: function (gid, image, width, height)
	    {
	        this.images.push({ gid: gid, image: image, width: width, height: height });
	        this.total++;

	        return this;
	    }

	});

	ImageCollection_1 = ImageCollection;
	return ImageCollection_1;
}

var ParseWangsets_1;
var hasRequiredParseWangsets;

function requireParseWangsets () {
	if (hasRequiredParseWangsets) return ParseWangsets_1;
	hasRequiredParseWangsets = 1;
	var ParseWangsets = function (wangsets, datas)
	{
	    for (var w = 0; w < wangsets.length; w++)
	    {
	        var wangset = wangsets[w];
	        var identifier = w;

	        if (wangset.name && wangset.name !== '')
	        {
	            identifier = wangset.name;
	        }

	        if (Array.isArray(wangset.wangtiles) && wangset.wangtiles.length > 0)
	        {
	            var edgeColors = {};
	            var cornerColors = {};

	            var c;
	            var color;
	            var colorIndex;

	            if (Array.isArray(wangset.edgecolors))
	            {
	                for (c = 0; c < wangset.edgecolors.length; c++)
	                {
	                    colorIndex = 1 + c;
	                    color = wangset.edgecolors[c];

	                    if (color.name !== '')
	                    {
	                        edgeColors[colorIndex] = color.name;
	                    }
	                }
	            }

	            if (Array.isArray(wangset.cornercolors))
	            {
	                for (c = 0; c < wangset.cornercolors.length; c++)
	                {
	                    colorIndex = 1 + c;
	                    color = wangset.cornercolors[c];

	                    if (color.name !== '')
	                    {
	                        cornerColors[colorIndex] = color.name;
	                    }
	                }
	            }

	            if (Array.isArray(wangset.colors))
	            {
	                for (c = 0; c < wangset.colors.length; c++)
	                {
	                    color = wangset.colors[c];
	                    colorIndex = 1 + c;

	                    if (color.name !== '')
	                    {
	                        edgeColors[colorIndex] = cornerColors[colorIndex] = color.name;
	                    }
	                }
	            }

	            var idLayout = [
	                edgeColors, cornerColors, edgeColors, cornerColors,
	                edgeColors, cornerColors, edgeColors, cornerColors
	            ];

	            for (var t = 0; t < wangset.wangtiles.length; t++)
	            {
	                var wangtile = wangset.wangtiles[t];

	                var obj = (datas[wangtile.tileid] || (datas[wangtile.tileid] = {}));

	                obj = (obj.wangid || (obj.wangid = {}));

	                var wangid = [];

	                for (var i = 0; i < Math.min(idLayout.length, wangtile.wangid.length); i++)
	                {
	                    color = wangtile.wangid[i];

	                    if (color === 0)
	                    {
	                        wangid.push(undefined);
	                        continue;
	                    }

	                    var renamed = idLayout[i][color];

	                    if (renamed !== undefined)
	                    {
	                        wangid.push(renamed);
	                        continue;
	                    }

	                    wangid.push(color);
	                }

	                obj[identifier] = wangid;
	            }
	        }
	    }
	};

	ParseWangsets_1 = ParseWangsets;
	return ParseWangsets_1;
}

var ParseTilesets_1$1;
var hasRequiredParseTilesets$1;

function requireParseTilesets$1 () {
	if (hasRequiredParseTilesets$1) return ParseTilesets_1$1;
	hasRequiredParseTilesets$1 = 1;
	var Tileset = requireTileset();
	var ImageCollection = requireImageCollection();
	var ParseObject = requireParseObject();
	var ParseWangsets = requireParseWangsets();

	var ParseTilesets = function (json)
	{
	    var tilesets = [];
	    var imageCollections = [];
	    var lastSet = null;
	    var stringID;

	    for (var i = 0; i < json.tilesets.length; i++)
	    {

	        var set = json.tilesets[i];

	        if (set.source)
	        {
	            console.warn('External tilesets unsupported. Use Embed Tileset and re-export');
	        }
	        else if (set.image)
	        {
	            var newSet = new Tileset(set.name, set.firstgid, set.tilewidth, set.tileheight, set.margin, set.spacing, undefined, undefined, set.tileoffset);

	            if (json.version > 1)
	            {
	                var datas = undefined;
	                var props = undefined;

	                if (Array.isArray(set.tiles))
	                {
	                    datas = datas || {};
	                    props = props || {};

	                    for (var t = 0; t < set.tiles.length; t++)
	                    {
	                        var tile = set.tiles[t];

	                        if (tile.properties)
	                        {
	                            var newPropData = {};

	                            tile.properties.forEach(function (propData)
	                            {
	                                newPropData[propData['name']] = propData['value'];
	                            });

	                            props[tile.id] = newPropData;
	                        }

	                        if (tile.objectgroup)
	                        {
	                            (datas[tile.id] || (datas[tile.id] = {})).objectgroup = tile.objectgroup;

	                            if (tile.objectgroup.objects)
	                            {
	                                var parsedObjects2 = tile.objectgroup.objects.map(function (obj)
	                                {
	                                    return ParseObject(obj);
	                                });

	                                datas[tile.id].objectgroup.objects = parsedObjects2;
	                            }
	                        }

	                        if (tile.animation)
	                        {
	                            (datas[tile.id] || (datas[tile.id] = {})).animation = tile.animation;
	                        }

	                        if (tile.type)
	                        {
	                            (datas[tile.id] || (datas[tile.id] = {})).type = tile.type;
	                        }
	                    }
	                }

	                if (Array.isArray(set.wangsets))
	                {
	                    datas = datas || {};
	                    props = props || {};

	                    ParseWangsets(set.wangsets, datas);
	                }

	                if (datas) 
	                {
	                    newSet.tileData = datas;
	                    newSet.tileProperties = props;
	                }
	            }
	            else
	            {

	                if (set.tileproperties)
	                {
	                    newSet.tileProperties = set.tileproperties;
	                }

	                if (set.tiles)
	                {
	                    newSet.tileData = set.tiles;

	                    for (stringID in newSet.tileData)
	                    {
	                        var objectGroup = newSet.tileData[stringID].objectgroup;

	                        if (objectGroup && objectGroup.objects)
	                        {
	                            var parsedObjects1 = objectGroup.objects.map(function (obj)
	                            {
	                                return ParseObject(obj);
	                            });

	                            newSet.tileData[stringID].objectgroup.objects = parsedObjects1;
	                        }
	                    }
	                }
	            }

	            newSet.updateTileData(set.imagewidth, set.imageheight);

	            tilesets.push(newSet);
	        }
	        else
	        {
	            var newCollection = new ImageCollection(set.name, set.firstgid, set.tilewidth, set.tileheight, set.margin, set.spacing, set.properties);

	            var maxId = 0;

	            for (t = 0; t < set.tiles.length; t++)
	            {
	                tile = set.tiles[t];

	                var image = tile.image;
	                var tileId = parseInt(tile.id, 10);
	                var gid = set.firstgid + tileId;
	                var width = tile.imagewidth;
	                var height = tile.imageheight;
	                newCollection.addImage(gid, image, width, height);

	                maxId = Math.max(tileId, maxId);
	            }

	            newCollection.maxId = maxId;

	            imageCollections.push(newCollection);
	        }

	        if (lastSet)
	        {
	            lastSet.lastgid = set.firstgid - 1;
	        }

	        lastSet = set;
	    }

	    return { tilesets: tilesets, imageCollections: imageCollections };
	};

	ParseTilesets_1$1 = ParseTilesets;
	return ParseTilesets_1$1;
}

var ParseJSONTiled_1;
var hasRequiredParseJSONTiled;

function requireParseJSONTiled () {
	if (hasRequiredParseJSONTiled) return ParseJSONTiled_1;
	hasRequiredParseJSONTiled = 1;
	var AssignTileProperties = requireAssignTileProperties();
	var BuildTilesetIndex = requireBuildTilesetIndex();
	var CONST = requireORIENTATION_CONST();
	var DeepCopy = requireDeepCopy();
	var Formats = requireFormats();
	var FromOrientationString = requireFromOrientationString();
	var MapData = requireMapData();
	var ParseImageLayers = requireParseImageLayers();
	var ParseObjectLayers = requireParseObjectLayers();
	var ParseTileLayers = requireParseTileLayers$1();
	var ParseTilesets = requireParseTilesets$1();

	var ParseJSONTiled = function (name, source, insertNull)
	{
	    var json = DeepCopy(source);

	    var mapData = new MapData({
	        width: json.width,
	        height: json.height,
	        name: name,
	        tileWidth: json.tilewidth,
	        tileHeight: json.tileheight,
	        orientation: FromOrientationString(json.orientation),
	        format: Formats.TILED_JSON,
	        version: json.version,
	        properties: json.properties,
	        renderOrder: json.renderorder,
	        infinite: json.infinite
	    });

	    if (mapData.orientation === CONST.HEXAGONAL)
	    {
	        mapData.hexSideLength = json.hexsidelength;
	        mapData.staggerAxis = json.staggeraxis;
	        mapData.staggerIndex = json.staggerindex;

	        if (mapData.staggerAxis === 'y')
	        {
	            var triangleHeight = (mapData.tileHeight - mapData.hexSideLength) / 2;
	            mapData.widthInPixels = mapData.tileWidth * (mapData.width + 0.5);
	            mapData.heightInPixels = mapData.height * (mapData.hexSideLength + triangleHeight) + triangleHeight;
	        }
	        else
	        {
	            var triangleWidth = (mapData.tileWidth - mapData.hexSideLength) / 2;
	            mapData.widthInPixels = mapData.width * (mapData.hexSideLength + triangleWidth) + triangleWidth;
	            mapData.heightInPixels = mapData.tileHeight * (mapData.height + 0.5);
	        }
	    }

	    mapData.layers = ParseTileLayers(json, insertNull);
	    mapData.images = ParseImageLayers(json);

	    var sets = ParseTilesets(json);

	    mapData.tilesets = sets.tilesets;
	    mapData.imageCollections = sets.imageCollections;

	    mapData.objects = ParseObjectLayers(json);

	    mapData.tiles = BuildTilesetIndex(mapData);

	    AssignTileProperties(mapData);

	    return mapData;
	};

	ParseJSONTiled_1 = ParseJSONTiled;
	return ParseJSONTiled_1;
}

var ParseTileLayers_1;
var hasRequiredParseTileLayers;

function requireParseTileLayers () {
	if (hasRequiredParseTileLayers) return ParseTileLayers_1;
	hasRequiredParseTileLayers = 1;
	var LayerData = requireLayerData();
	var Tile = requireTile();

	var ParseTileLayers = function (json, insertNull)
	{
	    var tileLayers = [];

	    for (var i = 0; i < json.layer.length; i++)
	    {
	        var layer = json.layer[i];

	        var layerData = new LayerData({
	            name: layer.name,
	            width: layer.width,
	            height: layer.height,
	            tileWidth: layer.tilesize,
	            tileHeight: layer.tilesize,
	            visible: layer.visible === 1
	        });

	        var row = [];
	        var tileGrid = [];

	        for (var y = 0; y < layer.data.length; y++)
	        {
	            for (var x = 0; x < layer.data[y].length; x++)
	            {

	                var index = layer.data[y][x] - 1;

	                var tile;

	                if (index > -1)
	                {
	                    tile = new Tile(layerData, index, x, y, layer.tilesize, layer.tilesize);
	                }
	                else
	                {
	                    tile = insertNull
	                        ? null
	                        : new Tile(layerData, -1, x, y, layer.tilesize, layer.tilesize);
	                }

	                row.push(tile);
	            }

	            tileGrid.push(row);
	            row = [];
	        }

	        layerData.data = tileGrid;

	        tileLayers.push(layerData);
	    }

	    return tileLayers;
	};

	ParseTileLayers_1 = ParseTileLayers;
	return ParseTileLayers_1;
}

var ParseTilesets_1;
var hasRequiredParseTilesets;

function requireParseTilesets () {
	if (hasRequiredParseTilesets) return ParseTilesets_1;
	hasRequiredParseTilesets = 1;
	var Tileset = requireTileset();

	var ParseTilesets = function (json)
	{
	    var tilesets = [];
	    var tilesetsNames = [];

	    for (var i = 0; i < json.layer.length; i++)
	    {
	        var layer = json.layer[i];

	        var tilesetName = layer.tilesetName;

	        if (tilesetName !== '' && tilesetsNames.indexOf(tilesetName) === -1)
	        {
	            tilesetsNames.push(tilesetName);

	            tilesets.push(new Tileset(tilesetName, 0, layer.tilesize, layer.tilesize, 0, 0));
	        }
	    }

	    return tilesets;
	};

	ParseTilesets_1 = ParseTilesets;
	return ParseTilesets_1;
}

var ParseWeltmeister_1;
var hasRequiredParseWeltmeister;

function requireParseWeltmeister () {
	if (hasRequiredParseWeltmeister) return ParseWeltmeister_1;
	hasRequiredParseWeltmeister = 1;
	var Formats = requireFormats();
	var MapData = requireMapData();
	var ParseTileLayers = requireParseTileLayers();
	var ParseTilesets = requireParseTilesets();

	var ParseWeltmeister = function (name, json, insertNull)
	{
	    if (json.layer.length === 0)
	    {
	        console.warn('No layers found in the Weltmeister map: ' + name);
	        return null;
	    }

	    var width = 0;
	    var height = 0;

	    for (var i = 0; i < json.layer.length; i++)
	    {
	        if (json.layer[i].width > width) { width = json.layer[i].width; }
	        if (json.layer[i].height > height) { height = json.layer[i].height; }
	    }

	    var mapData = new MapData({
	        width: width,
	        height: height,
	        name: name,
	        tileWidth: json.layer[0].tilesize,
	        tileHeight: json.layer[0].tilesize,
	        format: Formats.WELTMEISTER
	    });

	    mapData.layers = ParseTileLayers(json, insertNull);
	    mapData.tilesets = ParseTilesets(json);

	    return mapData;
	};

	ParseWeltmeister_1 = ParseWeltmeister;
	return ParseWeltmeister_1;
}

var Parse_1;
var hasRequiredParse;

function requireParse () {
	if (hasRequiredParse) return Parse_1;
	hasRequiredParse = 1;
	var Formats = requireFormats();
	var Parse2DArray = requireParse2DArray();
	var ParseCSV = requireParseCSV();
	var ParseJSONTiled = requireParseJSONTiled();
	var ParseWeltmeister = requireParseWeltmeister();

	var Parse = function (name, mapFormat, data, tileWidth, tileHeight, insertNull)
	{
	    var newMap;

	    switch (mapFormat)
	    {
	        case (Formats.ARRAY_2D):
	            newMap = Parse2DArray(name, data, tileWidth, tileHeight, insertNull);
	            break;
	        case (Formats.CSV):
	            newMap = ParseCSV(name, data, tileWidth, tileHeight, insertNull);
	            break;
	        case (Formats.TILED_JSON):
	            newMap = ParseJSONTiled(name, data, insertNull);
	            break;
	        case (Formats.WELTMEISTER):
	            newMap = ParseWeltmeister(name, data, insertNull);
	            break;
	        default:
	            console.warn('Unrecognized tilemap data format: ' + mapFormat);
	            newMap = null;
	    }

	    return newMap;
	};

	Parse_1 = Parse;
	return Parse_1;
}

var impact;
var hasRequiredImpact;

function requireImpact () {
	if (hasRequiredImpact) return impact;
	hasRequiredImpact = 1;
	impact = {

	    ParseTileLayers: requireParseTileLayers(),
	    ParseTilesets: requireParseTilesets(),
	    ParseWeltmeister: requireParseWeltmeister()

	};
	return impact;
}

var tiled;
var hasRequiredTiled;

function requireTiled () {
	if (hasRequiredTiled) return tiled;
	hasRequiredTiled = 1;
	tiled = {

	    AssignTileProperties: requireAssignTileProperties(),
	    Base64Decode: requireBase64Decode(),
	    BuildTilesetIndex: requireBuildTilesetIndex(),
	    CreateGroupLayer: requireCreateGroupLayer(),
	    ParseGID: requireParseGID(),
	    ParseImageLayers: requireParseImageLayers(),
	    ParseJSONTiled: requireParseJSONTiled(),
	    ParseObject: requireParseObject(),
	    ParseObjectLayers: requireParseObjectLayers(),
	    ParseTileLayers: requireParseTileLayers$1(),
	    ParseTilesets: requireParseTilesets$1()

	};
	return tiled;
}

var parsers;
var hasRequiredParsers;

function requireParsers () {
	if (hasRequiredParsers) return parsers;
	hasRequiredParsers = 1;
	parsers = {

	    FromOrientationString: requireFromOrientationString(),
	    Parse: requireParse(),
	    Parse2DArray: requireParse2DArray(),
	    ParseCSV: requireParseCSV(),

	    Impact: requireImpact(),
	    Tiled: requireTiled()

	};
	return parsers;
}

var ObjectHelper_1;
var hasRequiredObjectHelper;

function requireObjectHelper () {
	if (hasRequiredObjectHelper) return ObjectHelper_1;
	hasRequiredObjectHelper = 1;
	var Class = requireClass();

	var ObjectHelper = new Class({

	    initialize:

	    function ObjectHelper (tilesets)
	    {

	        this.gids = [];

	        if (tilesets !== undefined)
	        {
	            for (var t = 0; t < tilesets.length; ++t)
	            {
	                var tileset = tilesets[t];

	                for (var i = 0; i < tileset.total; ++i)
	                {
	                    this.gids[tileset.firstgid + i] = tileset;
	                }
	            }
	        }

	        this._gids = this.gids;
	    },

	    enabled: {

	        get: function ()
	        {
	            return !!this.gids;
	        },

	        set: function (v)
	        {
	            this.gids = v ? this._gids : undefined;
	        }

	    },

	    getTypeIncludingTile: function (obj)
	    {
	        if (obj.type !== undefined && obj.type !== '')
	        {
	            return obj.type;
	        }

	        if (!this.gids || obj.gid === undefined)
	        {
	            return undefined;
	        }

	        var tileset = this.gids[obj.gid];

	        if (!tileset)
	        {
	            return undefined;
	        }

	        var tileData = tileset.getTileData(obj.gid);

	        if (!tileData)
	        {
	            return undefined;
	        }

	        return tileData.type;
	    },

	    setTextureAndFrame: function (sprite, key, frame, obj)
	    {
	        if ((key === null) && this.gids && obj.gid !== undefined)
	        {
	            var tileset = this.gids[obj.gid];

	            if (tileset)
	            {
	                if (key === null && tileset.image !== undefined)
	                {
	                    key = tileset.image.key;
	                }

	                if (frame === null)
	                {

	                    frame = obj.gid - tileset.firstgid;
	                }

	                if (!sprite.scene.textures.getFrame(key, frame))
	                {
	                    key = null;
	                    frame = null;
	                }
	            }
	        }

	        sprite.setTexture(key, frame);
	    },

	    setPropertiesFromTiledObject: function (sprite, obj)
	    {
	        if (this.gids !== undefined && obj.gid !== undefined)
	        {
	            var tileset = this.gids[obj.gid];

	            if (tileset !== undefined)
	            {
	                this.setFromJSON(sprite, tileset.getTileProperties(obj.gid));
	            }
	        }

	        this.setFromJSON(sprite, obj.properties);
	    },

	    setFromJSON: function (sprite, properties)
	    {
	        if (!properties)
	        {
	            return;
	        }

	        if (Array.isArray(properties))
	        {
	            for (var i = 0; i < properties.length; i++)
	            {
	                var prop = properties[i];

	                if (sprite[prop.name] !== undefined)
	                {
	                    sprite[prop.name] = prop.value;
	                }
	                else
	                {
	                    sprite.setData(prop.name, prop.value);
	                }
	            }

	            return;
	        }

	        for (var key in properties)
	        {
	            if (sprite[key] !== undefined)
	            {
	                sprite[key] = properties[key];
	            }
	            else
	            {
	                sprite.setData(key, properties[key]);
	            }
	        }
	    }
	});

	ObjectHelper_1 = ObjectHelper;
	return ObjectHelper_1;
}

var TilemapLayerWebGLRenderer_1;
var hasRequiredTilemapLayerWebGLRenderer;

function requireTilemapLayerWebGLRenderer () {
	if (hasRequiredTilemapLayerWebGLRenderer) return TilemapLayerWebGLRenderer_1;
	hasRequiredTilemapLayerWebGLRenderer = 1;
	var Utils = requireUtils$1();

	var TilemapLayerWebGLRenderer = function (renderer, src, camera)
	{
	    var renderTiles = src.cull(camera);

	    var tileCount = renderTiles.length;
	    var alpha = camera.alpha * src.alpha;

	    if (tileCount === 0 || alpha <= 0)
	    {
	        return;
	    }

	    var gidMap = src.gidMap;
	    var pipeline = renderer.pipelines.set(src.pipeline, src);

	    var getTint = Utils.getTintAppendFloatAlpha;

	    var scrollFactorX = src.scrollFactorX;
	    var scrollFactorY = src.scrollFactorY;

	    var x = src.x;
	    var y = src.y;

	    var sx = src.scaleX;
	    var sy = src.scaleY;

	    renderer.pipelines.preBatch(src);

	    for (var i = 0; i < tileCount; i++)
	    {
	        var tile = renderTiles[i];

	        var tileset = gidMap[tile.index];

	        if (!tileset)
	        {
	            continue;
	        }

	        var tileTexCoords = tileset.getTileTextureCoordinates(tile.index);
	        var tileWidth = tileset.tileWidth;
	        var tileHeight = tileset.tileHeight;

	        if (!tileTexCoords || tileWidth === 0 || tileHeight === 0)
	        {
	            continue;
	        }

	        var halfWidth = tileWidth * 0.5;
	        var halfHeight = tileHeight * 0.5;

	        var texture = tileset.glTexture;

	        var textureUnit = pipeline.setTexture2D(texture, src);

	        var frameWidth = tileWidth;
	        var frameHeight = tileHeight;

	        var frameX = tileTexCoords.x;
	        var frameY = tileTexCoords.y;

	        var tOffsetX = tileset.tileOffset.x;
	        var tOffsetY = tileset.tileOffset.y;

	        var tint = getTint(tile.tint, alpha * tile.alpha);

	        pipeline.batchTexture(
	            src,
	            texture,
	            texture.width, texture.height,
	            x + tile.pixelX * sx + (halfWidth * sx - tOffsetX),
	            y + tile.pixelY * sy + (halfHeight * sy - tOffsetY),
	            tileWidth, tileHeight,
	            sx, sy,
	            tile.rotation,
	            tile.flipX, tile.flipY,
	            scrollFactorX, scrollFactorY,
	            halfWidth, halfHeight,
	            frameX, frameY, frameWidth, frameHeight,
	            tint, tint, tint, tint, tile.tintFill,
	            0, 0,
	            camera,
	            null,
	            true,
	            textureUnit,
	            true
	        );
	    }

	    renderer.pipelines.postBatch(src);
	};

	TilemapLayerWebGLRenderer_1 = TilemapLayerWebGLRenderer;
	return TilemapLayerWebGLRenderer_1;
}

var TilemapLayerCanvasRenderer_1;
var hasRequiredTilemapLayerCanvasRenderer;

function requireTilemapLayerCanvasRenderer () {
	if (hasRequiredTilemapLayerCanvasRenderer) return TilemapLayerCanvasRenderer_1;
	hasRequiredTilemapLayerCanvasRenderer = 1;
	var TransformMatrix = requireTransformMatrix();

	var tempMatrix1 = new TransformMatrix();
	var tempMatrix2 = new TransformMatrix();
	var tempMatrix3 = new TransformMatrix();

	var TilemapLayerCanvasRenderer = function (renderer, src, camera, parentMatrix)
	{
	    var renderTiles = src.cull(camera);

	    var tileCount = renderTiles.length;
	    var alpha = camera.alpha * src.alpha;

	    if (tileCount === 0 || alpha <= 0)
	    {
	        return;
	    }

	    var camMatrix = tempMatrix1;
	    var layerMatrix = tempMatrix2;
	    var calcMatrix = tempMatrix3;

	    layerMatrix.applyITRS(src.x, src.y, src.rotation, src.scaleX, src.scaleY);

	    camMatrix.copyFrom(camera.matrix);

	    var ctx = renderer.currentContext;
	    var gidMap = src.gidMap;

	    ctx.save();

	    if (parentMatrix)
	    {

	        camMatrix.multiplyWithOffset(parentMatrix, -camera.scrollX * src.scrollFactorX, -camera.scrollY * src.scrollFactorY);

	        layerMatrix.e = src.x;
	        layerMatrix.f = src.y;

	        camMatrix.multiply(layerMatrix, calcMatrix);

	        calcMatrix.copyToContext(ctx);
	    }
	    else
	    {
	        layerMatrix.e -= camera.scrollX * src.scrollFactorX;
	        layerMatrix.f -= camera.scrollY * src.scrollFactorY;

	        layerMatrix.copyToContext(ctx);
	    }

	    if (!renderer.antialias || src.scaleX > 1 || src.scaleY > 1)
	    {
	        ctx.imageSmoothingEnabled = false;
	    }

	    for (var i = 0; i < tileCount; i++)
	    {
	        var tile = renderTiles[i];

	        var tileset = gidMap[tile.index];

	        if (!tileset)
	        {
	            continue;
	        }

	        var image = tileset.image.getSourceImage();

	        var tileTexCoords = tileset.getTileTextureCoordinates(tile.index);
	        var tileWidth = tileset.tileWidth;
	        var tileHeight = tileset.tileHeight;

	        if (tileTexCoords === null || tileWidth === 0 || tileHeight === 0)
	        {
	            continue;
	        }

	        var halfWidth = tileWidth * 0.5;
	        var halfHeight = tileHeight * 0.5;

	        tileTexCoords.x += tileset.tileOffset.x;
	        tileTexCoords.y += tileset.tileOffset.y;

	        ctx.save();

	        ctx.translate(tile.pixelX + halfWidth, tile.pixelY + halfHeight);

	        if (tile.rotation !== 0)
	        {
	            ctx.rotate(tile.rotation);
	        }

	        if (tile.flipX || tile.flipY)
	        {
	            ctx.scale((tile.flipX) ? -1 : 1, (tile.flipY) ? -1 : 1);
	        }

	        ctx.globalAlpha = alpha * tile.alpha;

	        ctx.drawImage(
	            image,
	            tileTexCoords.x, tileTexCoords.y,
	            tileWidth , tileHeight,
	            -halfWidth, -halfHeight,
	            tileWidth, tileHeight
	        );

	        ctx.restore();
	    }

	    ctx.restore();
	};

	TilemapLayerCanvasRenderer_1 = TilemapLayerCanvasRenderer;
	return TilemapLayerCanvasRenderer_1;
}

var TilemapLayerRender;
var hasRequiredTilemapLayerRender;

function requireTilemapLayerRender () {
	if (hasRequiredTilemapLayerRender) return TilemapLayerRender;
	hasRequiredTilemapLayerRender = 1;
	var NOOP = requireNOOP();
	var renderWebGL = NOOP;
	var renderCanvas = NOOP;

	if (typeof WEBGL_RENDERER)
	{
	    renderWebGL = requireTilemapLayerWebGLRenderer();
	}

	if (typeof CANVAS_RENDERER)
	{
	    renderCanvas = requireTilemapLayerCanvasRenderer();
	}

	TilemapLayerRender = {

	    renderWebGL: renderWebGL,
	    renderCanvas: renderCanvas

	};
	return TilemapLayerRender;
}

var TilemapLayer_1;
var hasRequiredTilemapLayer;

function requireTilemapLayer () {
	if (hasRequiredTilemapLayer) return TilemapLayer_1;
	hasRequiredTilemapLayer = 1;
	var Class = requireClass();
	var CollisionComponent = requireCollision();
	var Components = requireComponents$2();
	var GameObject = requireGameObject();
	var TilemapComponents = requireComponents();
	var TilemapLayerRender = requireTilemapLayerRender();
	var Vector2 = requireVector2();

	var TilemapLayer = new Class({

	    Extends: GameObject,

	    Mixins: [
	        Components.Alpha,
	        Components.BlendMode,
	        Components.ComputedSize,
	        Components.Depth,
	        Components.Flip,
	        Components.GetBounds,
	        Components.Mask,
	        Components.Origin,
	        Components.Pipeline,
	        Components.PostPipeline,
	        Components.Transform,
	        Components.Visible,
	        Components.ScrollFactor,
	        CollisionComponent,
	        TilemapLayerRender
	    ],

	    initialize:

	    function TilemapLayer (scene, tilemap, layerIndex, tileset, x, y)
	    {
	        GameObject.call(this, scene, 'TilemapLayer');

	        this.isTilemap = true;

	        this.tilemap = tilemap;

	        this.layerIndex = layerIndex;

	        this.layer = tilemap.layers[layerIndex];

	        this.layer.tilemapLayer = this;

	        this.tileset = [];

	        this.tilesDrawn = 0;

	        this.tilesTotal = this.layer.width * this.layer.height;

	        this.culledTiles = [];

	        this.skipCull = false;

	        this.cullPaddingX = 1;

	        this.cullPaddingY = 1;

	        this.cullCallback = TilemapComponents.GetCullTilesFunction(this.layer.orientation);

	        this._renderOrder = 0;

	        this.gidMap = [];

	        this.tempVec = new Vector2();

	        this.collisionCategory = 0x0001;

	        this.collisionMask = 1;

	        this.setTilesets(tileset);
	        this.setAlpha(this.layer.alpha);
	        this.setPosition(x, y);
	        this.setOrigin(0, 0);
	        this.setSize(tilemap.tileWidth * this.layer.width, tilemap.tileHeight * this.layer.height);

	        this.initPipeline();
	        this.initPostPipeline(false);
	    },

	    setTilesets: function (tilesets)
	    {
	        var gidMap = [];
	        var setList = [];
	        var map = this.tilemap;

	        if (!Array.isArray(tilesets))
	        {
	            tilesets = [ tilesets ];
	        }

	        for (var i = 0; i < tilesets.length; i++)
	        {
	            var tileset = tilesets[i];

	            if (typeof tileset === 'string')
	            {
	                tileset = map.getTileset(tileset);
	            }

	            if (tileset)
	            {
	                setList.push(tileset);

	                var s = tileset.firstgid;

	                for (var t = 0; t < tileset.total; t++)
	                {
	                    gidMap[s + t] = tileset;
	                }
	            }
	        }

	        this.gidMap = gidMap;
	        this.tileset = setList;
	    },

	    setRenderOrder: function (renderOrder)
	    {
	        var orders = [ 'right-down', 'left-down', 'right-up', 'left-up' ];

	        if (typeof renderOrder === 'string')
	        {
	            renderOrder = orders.indexOf(renderOrder);
	        }

	        if (renderOrder >= 0 && renderOrder < 4)
	        {
	            this._renderOrder = renderOrder;
	        }

	        return this;
	    },

	    calculateFacesAt: function (tileX, tileY)
	    {
	        TilemapComponents.CalculateFacesAt(tileX, tileY, this.layer);

	        return this;
	    },

	    calculateFacesWithin: function (tileX, tileY, width, height)
	    {
	        TilemapComponents.CalculateFacesWithin(tileX, tileY, width, height, this.layer);

	        return this;
	    },

	    createFromTiles: function (indexes, replacements, spriteConfig, scene, camera)
	    {
	        return TilemapComponents.CreateFromTiles(indexes, replacements, spriteConfig, scene, camera, this.layer);
	    },

	    cull: function (camera)
	    {
	        return this.cullCallback(this.layer, camera, this.culledTiles, this._renderOrder);
	    },

	    copy: function (srcTileX, srcTileY, width, height, destTileX, destTileY, recalculateFaces)
	    {
	        TilemapComponents.Copy(srcTileX, srcTileY, width, height, destTileX, destTileY, recalculateFaces, this.layer);

	        return this;
	    },

	    fill: function (index, tileX, tileY, width, height, recalculateFaces)
	    {
	        TilemapComponents.Fill(index, tileX, tileY, width, height, recalculateFaces, this.layer);

	        return this;
	    },

	    filterTiles: function (callback, context, tileX, tileY, width, height, filteringOptions)
	    {
	        return TilemapComponents.FilterTiles(callback, context, tileX, tileY, width, height, filteringOptions, this.layer);
	    },

	    findByIndex: function (findIndex, skip, reverse)
	    {
	        return TilemapComponents.FindByIndex(findIndex, skip, reverse, this.layer);
	    },

	    findTile: function (callback, context, tileX, tileY, width, height, filteringOptions)
	    {
	        return TilemapComponents.FindTile(callback, context, tileX, tileY, width, height, filteringOptions, this.layer);
	    },

	    forEachTile: function (callback, context, tileX, tileY, width, height, filteringOptions)
	    {
	        TilemapComponents.ForEachTile(callback, context, tileX, tileY, width, height, filteringOptions, this.layer);

	        return this;
	    },

	    setTint: function (tint, tileX, tileY, width, height, filteringOptions)
	    {
	        if (tint === undefined) { tint = 0xffffff; }

	        var tintTile = function (tile)
	        {
	            tile.tint = tint;
	            tile.tintFill = false;
	        };

	        return this.forEachTile(tintTile, this, tileX, tileY, width, height, filteringOptions);
	    },

	    setTintFill: function (tint, tileX, tileY, width, height, filteringOptions)
	    {
	        if (tint === undefined) { tint = 0xffffff; }

	        var tintTile = function (tile)
	        {
	            tile.tint = tint;
	            tile.tintFill = true;
	        };

	        return this.forEachTile(tintTile, this, tileX, tileY, width, height, filteringOptions);
	    },

	    getTileAt: function (tileX, tileY, nonNull)
	    {
	        return TilemapComponents.GetTileAt(tileX, tileY, nonNull, this.layer);
	    },

	    getTileAtWorldXY: function (worldX, worldY, nonNull, camera)
	    {
	        return TilemapComponents.GetTileAtWorldXY(worldX, worldY, nonNull, camera, this.layer);
	    },

	    getIsoTileAtWorldXY: function (worldX, worldY, originTop, nonNull, camera)
	    {
	        if (originTop === undefined) { originTop = true; }

	        var point = this.tempVec;

	        TilemapComponents.IsometricWorldToTileXY(worldX, worldY, true, point, camera, this.layer, originTop);

	        return this.getTileAt(point.x, point.y, nonNull);
	    },

	    getTilesWithin: function (tileX, tileY, width, height, filteringOptions)
	    {
	        return TilemapComponents.GetTilesWithin(tileX, tileY, width, height, filteringOptions, this.layer);
	    },

	    getTilesWithinShape: function (shape, filteringOptions, camera)
	    {
	        return TilemapComponents.GetTilesWithinShape(shape, filteringOptions, camera, this.layer);
	    },

	    getTilesWithinWorldXY: function (worldX, worldY, width, height, filteringOptions, camera)
	    {
	        return TilemapComponents.GetTilesWithinWorldXY(worldX, worldY, width, height, filteringOptions, camera, this.layer);
	    },

	    hasTileAt: function (tileX, tileY)
	    {
	        return TilemapComponents.HasTileAt(tileX, tileY, this.layer);
	    },

	    hasTileAtWorldXY: function (worldX, worldY, camera)
	    {
	        return TilemapComponents.HasTileAtWorldXY(worldX, worldY, camera, this.layer);
	    },

	    putTileAt: function (tile, tileX, tileY, recalculateFaces)
	    {
	        return TilemapComponents.PutTileAt(tile, tileX, tileY, recalculateFaces, this.layer);
	    },

	    putTileAtWorldXY: function (tile, worldX, worldY, recalculateFaces, camera)
	    {
	        return TilemapComponents.PutTileAtWorldXY(tile, worldX, worldY, recalculateFaces, camera, this.layer);
	    },

	    putTilesAt: function (tilesArray, tileX, tileY, recalculateFaces)
	    {
	        TilemapComponents.PutTilesAt(tilesArray, tileX, tileY, recalculateFaces, this.layer);

	        return this;
	    },

	    randomize: function (tileX, tileY, width, height, indexes)
	    {
	        TilemapComponents.Randomize(tileX, tileY, width, height, indexes, this.layer);

	        return this;
	    },

	    removeTileAt: function (tileX, tileY, replaceWithNull, recalculateFaces)
	    {
	        return TilemapComponents.RemoveTileAt(tileX, tileY, replaceWithNull, recalculateFaces, this.layer);
	    },

	    removeTileAtWorldXY: function (worldX, worldY, replaceWithNull, recalculateFaces, camera)
	    {
	        return TilemapComponents.RemoveTileAtWorldXY(worldX, worldY, replaceWithNull, recalculateFaces, camera, this.layer);
	    },

	    renderDebug: function (graphics, styleConfig)
	    {
	        TilemapComponents.RenderDebug(graphics, styleConfig, this.layer);

	        return this;
	    },

	    replaceByIndex: function (findIndex, newIndex, tileX, tileY, width, height)
	    {
	        TilemapComponents.ReplaceByIndex(findIndex, newIndex, tileX, tileY, width, height, this.layer);

	        return this;
	    },

	    setSkipCull: function (value)
	    {
	        if (value === undefined) { value = true; }

	        this.skipCull = value;

	        return this;
	    },

	    setCullPadding: function (paddingX, paddingY)
	    {
	        if (paddingX === undefined) { paddingX = 1; }
	        if (paddingY === undefined) { paddingY = 1; }

	        this.cullPaddingX = paddingX;
	        this.cullPaddingY = paddingY;

	        return this;
	    },

	    setCollision: function (indexes, collides, recalculateFaces, updateLayer)
	    {
	        TilemapComponents.SetCollision(indexes, collides, recalculateFaces, this.layer, updateLayer);

	        return this;
	    },

	    setCollisionBetween: function (start, stop, collides, recalculateFaces)
	    {
	        TilemapComponents.SetCollisionBetween(start, stop, collides, recalculateFaces, this.layer);

	        return this;
	    },

	    setCollisionByProperty: function (properties, collides, recalculateFaces)
	    {
	        TilemapComponents.SetCollisionByProperty(properties, collides, recalculateFaces, this.layer);

	        return this;
	    },

	    setCollisionByExclusion: function (indexes, collides, recalculateFaces)
	    {
	        TilemapComponents.SetCollisionByExclusion(indexes, collides, recalculateFaces, this.layer);

	        return this;
	    },

	    setCollisionFromCollisionGroup: function (collides, recalculateFaces)
	    {
	        TilemapComponents.SetCollisionFromCollisionGroup(collides, recalculateFaces, this.layer);

	        return this;
	    },

	    setTileIndexCallback: function (indexes, callback, callbackContext)
	    {
	        TilemapComponents.SetTileIndexCallback(indexes, callback, callbackContext, this.layer);

	        return this;
	    },

	    setTileLocationCallback: function (tileX, tileY, width, height, callback, callbackContext)
	    {
	        TilemapComponents.SetTileLocationCallback(tileX, tileY, width, height, callback, callbackContext, this.layer);

	        return this;
	    },

	    shuffle: function (tileX, tileY, width, height)
	    {
	        TilemapComponents.Shuffle(tileX, tileY, width, height, this.layer);

	        return this;
	    },

	    swapByIndex: function (indexA, indexB, tileX, tileY, width, height)
	    {
	        TilemapComponents.SwapByIndex(indexA, indexB, tileX, tileY, width, height, this.layer);

	        return this;
	    },

	    tileToWorldX: function (tileX, camera)
	    {
	        return this.tilemap.tileToWorldX(tileX, camera, this);
	    },

	    tileToWorldY: function (tileY, camera)
	    {
	        return this.tilemap.tileToWorldY(tileY, camera, this);
	    },

	    tileToWorldXY: function (tileX, tileY, point, camera)
	    {
	        return this.tilemap.tileToWorldXY(tileX, tileY, point, camera, this);
	    },

	    getTileCorners: function (tileX, tileY, camera)
	    {
	        return this.tilemap.getTileCorners(tileX, tileY, camera, this);
	    },

	    weightedRandomize: function (weightedIndexes, tileX, tileY, width, height)
	    {
	        TilemapComponents.WeightedRandomize(tileX, tileY, width, height, weightedIndexes, this.layer);

	        return this;
	    },

	    worldToTileX: function (worldX, snapToFloor, camera)
	    {
	        return this.tilemap.worldToTileX(worldX, snapToFloor, camera, this);
	    },

	    worldToTileY: function (worldY, snapToFloor, camera)
	    {
	        return this.tilemap.worldToTileY(worldY, snapToFloor, camera, this);
	    },

	    worldToTileXY: function (worldX, worldY, snapToFloor, point, camera)
	    {
	        return this.tilemap.worldToTileXY(worldX, worldY, snapToFloor, point, camera, this);
	    },

	    destroy: function (removeFromTilemap)
	    {
	        if (removeFromTilemap === undefined) { removeFromTilemap = true; }

	        if (!this.tilemap)
	        {

	            return;
	        }

	        if (this.layer.tilemapLayer === this)
	        {
	            this.layer.tilemapLayer = undefined;
	        }

	        if (removeFromTilemap)
	        {
	            this.tilemap.removeLayer(this);
	        }

	        this.tilemap = undefined;
	        this.layer = undefined;
	        this.culledTiles.length = 0;
	        this.cullCallback = null;

	        this.gidMap = [];
	        this.tileset = [];

	        GameObject.prototype.destroy.call(this);
	    }

	});

	TilemapLayer_1 = TilemapLayer;
	return TilemapLayer_1;
}

var Tilemap_1;
var hasRequiredTilemap;

function requireTilemap () {
	if (hasRequiredTilemap) return Tilemap_1;
	hasRequiredTilemap = 1;
	var BuildTilesetIndex = requireBuildTilesetIndex();
	var Class = requireClass();
	var DegToRad = requireDegToRad();
	var Formats = requireFormats();
	var GetFastValue = requireGetFastValue();
	var LayerData = requireLayerData();
	var ObjectHelper = requireObjectHelper();
	var ORIENTATION = requireORIENTATION_CONST();
	var Rotate = requireRotate$2();
	var SpliceOne = requireSpliceOne();
	var Sprite = requireSprite();
	var Tile = requireTile();
	var TilemapComponents = requireComponents();
	var TilemapLayer = requireTilemapLayer();
	var Tileset = requireTileset();

	var Tilemap = new Class({

	    initialize:

	        function Tilemap (scene, mapData)
	        {

	            this.scene = scene;

	            this.tileWidth = mapData.tileWidth;

	            this.tileHeight = mapData.tileHeight;

	            this.width = mapData.width;

	            this.height = mapData.height;

	            this.orientation = mapData.orientation;

	            this.renderOrder = mapData.renderOrder;

	            this.format = mapData.format;

	            this.version = mapData.version;

	            this.properties = mapData.properties;

	            this.widthInPixels = mapData.widthInPixels;

	            this.heightInPixels = mapData.heightInPixels;

	            this.imageCollections = mapData.imageCollections;

	            this.images = mapData.images;

	            this.layers = mapData.layers;

	            this.tiles = mapData.tiles;

	            this.tilesets = mapData.tilesets;

	            this.objects = mapData.objects;

	            this.currentLayerIndex = 0;

	            this.hexSideLength = mapData.hexSideLength;

	            var orientation = this.orientation;

	            this._convert = {
	                WorldToTileXY: TilemapComponents.GetWorldToTileXYFunction(orientation),
	                WorldToTileX: TilemapComponents.GetWorldToTileXFunction(orientation),
	                WorldToTileY: TilemapComponents.GetWorldToTileYFunction(orientation),
	                TileToWorldXY: TilemapComponents.GetTileToWorldXYFunction(orientation),
	                TileToWorldX: TilemapComponents.GetTileToWorldXFunction(orientation),
	                TileToWorldY: TilemapComponents.GetTileToWorldYFunction(orientation),
	                GetTileCorners: TilemapComponents.GetTileCornersFunction(orientation)
	            };
	        },

	    setRenderOrder: function (renderOrder)
	    {
	        var orders = [ 'right-down', 'left-down', 'right-up', 'left-up' ];

	        if (typeof renderOrder === 'number')
	        {
	            renderOrder = orders[ renderOrder ];
	        }

	        if (orders.indexOf(renderOrder) > -1)
	        {
	            this.renderOrder = renderOrder;
	        }

	        return this;
	    },

	    addTilesetImage: function (tilesetName, key, tileWidth, tileHeight, tileMargin, tileSpacing, gid, tileOffset)
	    {
	        if (tilesetName === undefined) { return null; }
	        if (key === undefined || key === null) { key = tilesetName; }

	        var textureManager = this.scene.sys.textures;

	        if (!textureManager.exists(key))
	        {
	            console.warn('Texture key "%s" not found', key);
	            return null;
	        }

	        var texture = textureManager.get(key);

	        var index = this.getTilesetIndex(tilesetName);

	        if (index === null && this.format === Formats.TILED_JSON)
	        {
	            console.warn('Tilemap has no tileset "%s". Its tilesets are %o', tilesetName, this.tilesets);
	            return null;
	        }

	        var tileset = this.tilesets[ index ];

	        if (tileset)
	        {
	            if (tileWidth || tileHeight)
	            {
	                tileset.setTileSize(tileWidth, tileHeight);
	            }

	            if (tileMargin || tileSpacing)
	            {
	                tileset.setSpacing(tileMargin, tileSpacing);
	            }

	            tileset.setImage(texture);

	            return tileset;
	        }

	        if (tileWidth === undefined) { tileWidth = this.tileWidth; }
	        if (tileHeight === undefined) { tileHeight = this.tileHeight; }
	        if (tileMargin === undefined) { tileMargin = 0; }
	        if (tileSpacing === undefined) { tileSpacing = 0; }
	        if (gid === undefined) { gid = 0; }
	        if (tileOffset === undefined) { tileOffset = { x: 0, y: 0 }; }

	        tileset = new Tileset(tilesetName, gid, tileWidth, tileHeight, tileMargin, tileSpacing, undefined, undefined, tileOffset);

	        tileset.setImage(texture);

	        this.tilesets.push(tileset);

	        this.tiles = BuildTilesetIndex(this);

	        return tileset;
	    },

	    copy: function (srcTileX, srcTileY, width, height, destTileX, destTileY, recalculateFaces, layer)
	    {
	        layer = this.getLayer(layer);

	        if (layer !== null)
	        {
	            TilemapComponents.Copy(
	                srcTileX, srcTileY,
	                width, height,
	                destTileX, destTileY,
	                recalculateFaces, layer
	            );

	            return this;
	        }
	        else
	        {
	            return null;
	        }
	    },

	    createBlankLayer: function (name, tileset, x, y, width, height, tileWidth, tileHeight)
	    {
	        if (x === undefined) { x = 0; }
	        if (y === undefined) { y = 0; }
	        if (width === undefined) { width = this.width; }
	        if (height === undefined) { height = this.height; }
	        if (tileWidth === undefined) { tileWidth = this.tileWidth; }
	        if (tileHeight === undefined) { tileHeight = this.tileHeight; }

	        var index = this.getLayerIndex(name);

	        if (index !== null)
	        {
	            console.warn('Invalid Tilemap Layer ID: ' + name);
	            return null;
	        }

	        var layerData = new LayerData({
	            name: name,
	            tileWidth: tileWidth,
	            tileHeight: tileHeight,
	            width: width,
	            height: height,
	            orientation: this.orientation,
	            hexSideLength: this.hexSideLength
	        });

	        var row;

	        for (var tileY = 0; tileY < height; tileY++)
	        {
	            row = [];

	            for (var tileX = 0; tileX < width; tileX++)
	            {
	                row.push(new Tile(layerData, -1, tileX, tileY, tileWidth, tileHeight, this.tileWidth, this.tileHeight));
	            }

	            layerData.data.push(row);
	        }

	        this.layers.push(layerData);

	        this.currentLayerIndex = this.layers.length - 1;

	        var layer = new TilemapLayer(this.scene, this, this.currentLayerIndex, tileset, x, y);

	        layer.setRenderOrder(this.renderOrder);

	        this.scene.sys.displayList.add(layer);

	        return layer;
	    },

	    createLayer: function (layerID, tileset, x, y)
	    {
	        var index = this.getLayerIndex(layerID);

	        if (index === null)
	        {
	            console.warn('Invalid Tilemap Layer ID: ' + layerID);

	            if (typeof layerID === 'string')
	            {
	                console.warn('Valid tilelayer names: %o', this.getTileLayerNames());
	            }

	            return null;
	        }

	        var layerData = this.layers[ index ];

	        if (layerData.tilemapLayer)
	        {
	            console.warn('Tilemap Layer ID already exists:' + layerID);
	            return null;
	        }

	        this.currentLayerIndex = index;

	        if (x === undefined)
	        {
	            x = layerData.x;
	        }

	        if (y === undefined)
	        {
	            y = layerData.y;
	        }

	        var layer = new TilemapLayer(this.scene, this, index, tileset, x, y);

	        layer.setRenderOrder(this.renderOrder);

	        this.scene.sys.displayList.add(layer);

	        return layer;
	    },

	    createFromObjects: function (objectLayerName, config, useTileset)
	    {
	        if (useTileset === undefined) { useTileset = true; }

	        var results = [];

	        var objectLayer = this.getObjectLayer(objectLayerName);

	        if (!objectLayer)
	        {
	            console.warn('createFromObjects: Invalid objectLayerName given: ' + objectLayerName);

	            return results;
	        }

	        var objectHelper = new ObjectHelper(useTileset ? this.tilesets : undefined);

	        if (!Array.isArray(config))
	        {
	            config = [ config ];
	        }

	        var objects = objectLayer.objects;

	        for (var c = 0; c < config.length; c++)
	        {
	            var singleConfig = config[ c ];

	            var id = GetFastValue(singleConfig, 'id', null);
	            var gid = GetFastValue(singleConfig, 'gid', null);
	            var name = GetFastValue(singleConfig, 'name', null);
	            var type = GetFastValue(singleConfig, 'type', null);
	            objectHelper.enabled = !GetFastValue(singleConfig, 'ignoreTileset', null);

	            var obj;
	            var toConvert = [];

	            for (var s = 0; s < objects.length; s++)
	            {
	                obj = objects[ s ];

	                if (
	                    (id === null && gid === null && name === null && type === null) ||
	                    (id !== null && obj.id === id) ||
	                    (gid !== null && obj.gid === gid) ||
	                    (name !== null && obj.name === name) ||
	                    (type !== null && objectHelper.getTypeIncludingTile(obj) === type)
	                )
	                {
	                    toConvert.push(obj);
	                }
	            }

	            var classType = GetFastValue(singleConfig, 'classType', Sprite);
	            var scene = GetFastValue(singleConfig, 'scene', this.scene);
	            var container = GetFastValue(singleConfig, 'container', null);
	            var texture = GetFastValue(singleConfig, 'key', null);
	            var frame = GetFastValue(singleConfig, 'frame', null);

	            for (var i = 0; i < toConvert.length; i++)
	            {
	                obj = toConvert[ i ];

	                var sprite = new classType(scene);

	                sprite.setName(obj.name);
	                sprite.setPosition(obj.x, obj.y);
	                objectHelper.setTextureAndFrame(sprite, texture, frame, obj);

	                if (obj.width)
	                {
	                    sprite.displayWidth = obj.width;
	                }

	                if (obj.height)
	                {
	                    sprite.displayHeight = obj.height;
	                }

	                if (this.orientation === ORIENTATION.ISOMETRIC)
	                {
	                    var isometricRatio = this.tileWidth / this.tileHeight;
	                    var isometricPosition = {
	                        x: sprite.x - sprite.y,
	                        y: (sprite.x + sprite.y) / isometricRatio
	                    };

	                    sprite.x = isometricPosition.x;
	                    sprite.y = isometricPosition.y;
	                }

	                var offset = {
	                    x: sprite.originX * obj.width,
	                    y: (sprite.originY - (obj.gid ? 1 : 0)) * obj.height
	                };

	                if (obj.rotation)
	                {
	                    var angle = DegToRad(obj.rotation);

	                    Rotate(offset, angle);

	                    sprite.rotation = angle;
	                }

	                sprite.x += offset.x;
	                sprite.y += offset.y;

	                if (obj.flippedHorizontal !== undefined || obj.flippedVertical !== undefined)
	                {
	                    sprite.setFlip(obj.flippedHorizontal, obj.flippedVertical);
	                }

	                if (!obj.visible)
	                {
	                    sprite.visible = false;
	                }

	                objectHelper.setPropertiesFromTiledObject(sprite, obj);

	                if (container)
	                {
	                    container.add(sprite);
	                }
	                else
	                {
	                    scene.add.existing(sprite);
	                }

	                results.push(sprite);
	            }
	        }

	        return results;
	    },

	    createFromTiles: function (indexes, replacements, spriteConfig, scene, camera, layer)
	    {
	        layer = this.getLayer(layer);

	        if (layer === null) { return null; }

	        return TilemapComponents.CreateFromTiles(indexes, replacements, spriteConfig, scene, camera, layer);
	    },

	    fill: function (index, tileX, tileY, width, height, recalculateFaces, layer)
	    {
	        if (recalculateFaces === undefined) { recalculateFaces = true; }

	        layer = this.getLayer(layer);

	        if (layer === null) { return null; }

	        TilemapComponents.Fill(index, tileX, tileY, width, height, recalculateFaces, layer);

	        return this;
	    },

	    filterObjects: function (objectLayer, callback, context)
	    {
	        if (typeof objectLayer === 'string')
	        {
	            var name = objectLayer;

	            objectLayer = this.getObjectLayer(objectLayer);

	            if (!objectLayer)
	            {
	                console.warn('No object layer found with the name: ' + name);
	                return null;
	            }
	        }

	        return objectLayer.objects.filter(callback, context);
	    },

	    filterTiles: function (callback, context, tileX, tileY, width, height, filteringOptions, layer)
	    {
	        layer = this.getLayer(layer);

	        if (layer === null) { return null; }

	        return TilemapComponents.FilterTiles(callback, context, tileX, tileY, width, height, filteringOptions, layer);
	    },

	    findByIndex: function (findIndex, skip, reverse, layer)
	    {
	        layer = this.getLayer(layer);

	        if (layer === null) { return null; }

	        return TilemapComponents.FindByIndex(findIndex, skip, reverse, layer);
	    },

	    findObject: function (objectLayer, callback, context)
	    {
	        if (typeof objectLayer === 'string')
	        {
	            var name = objectLayer;

	            objectLayer = this.getObjectLayer(objectLayer);

	            if (!objectLayer)
	            {
	                console.warn('No object layer found with the name: ' + name);
	                return null;
	            }
	        }

	        return objectLayer.objects.find(callback, context) || null;
	    },

	    findTile: function (callback, context, tileX, tileY, width, height, filteringOptions, layer)
	    {
	        layer = this.getLayer(layer);

	        if (layer === null) { return null; }

	        return TilemapComponents.FindTile(callback, context, tileX, tileY, width, height, filteringOptions, layer);
	    },

	    forEachTile: function (callback, context, tileX, tileY, width, height, filteringOptions, layer)
	    {
	        layer = this.getLayer(layer);

	        if (layer === null) { return null; }

	        TilemapComponents.ForEachTile(callback, context, tileX, tileY, width, height, filteringOptions, layer);

	        return this;
	    },

	    getImageIndex: function (name)
	    {
	        return this.getIndex(this.images, name);
	    },

	    getImageLayerNames: function ()
	    {
	        if (!this.images || !Array.isArray(this.images))
	        {
	            return [];
	        }

	        return this.images.map(function (image)
	        {
	            return image.name;
	        });
	    },

	    getIndex: function (location, name)
	    {
	        for (var i = 0; i < location.length; i++)
	        {
	            if (location[ i ].name === name)
	            {
	                return i;
	            }
	        }

	        return null;
	    },

	    getLayer: function (layer)
	    {
	        var index = this.getLayerIndex(layer);

	        return (index !== null) ? this.layers[ index ] : null;
	    },

	    getObjectLayer: function (name)
	    {
	        var index = this.getIndex(this.objects, name);

	        return (index !== null) ? this.objects[ index ] : null;
	    },

	    getObjectLayerNames: function ()
	    {
	        if (!this.objects || !Array.isArray(this.objects))
	        {
	            return [];
	        }

	        return this.objects.map(function (object)
	        {
	            return object.name;
	        });
	    },

	    getLayerIndex: function (layer)
	    {
	        if (layer === undefined)
	        {
	            return this.currentLayerIndex;
	        }
	        else if (typeof layer === 'string')
	        {
	            return this.getLayerIndexByName(layer);
	        }
	        else if (typeof layer === 'number' && layer < this.layers.length)
	        {
	            return layer;
	        }
	        else if (layer instanceof TilemapLayer && layer.tilemap === this)
	        {
	            return layer.layerIndex;
	        }
	        else
	        {
	            return null;
	        }
	    },

	    getLayerIndexByName: function (name)
	    {
	        return this.getIndex(this.layers, name);
	    },

	    getTileAt: function (tileX, tileY, nonNull, layer)
	    {
	        layer = this.getLayer(layer);

	        if (layer === null) { return null; }

	        return TilemapComponents.GetTileAt(tileX, tileY, nonNull, layer);
	    },

	    getTileAtWorldXY: function (worldX, worldY, nonNull, camera, layer)
	    {
	        layer = this.getLayer(layer);

	        if (layer === null) { return null; }

	        return TilemapComponents.GetTileAtWorldXY(worldX, worldY, nonNull, camera, layer);
	    },

	    getTileLayerNames: function ()
	    {
	        if (!this.layers || !Array.isArray(this.layers))
	        {
	            return [];
	        }

	        return this.layers.map(function (layer)
	        {
	            return layer.name;
	        });
	    },

	    getTilesWithin: function (tileX, tileY, width, height, filteringOptions, layer)
	    {
	        layer = this.getLayer(layer);

	        if (layer === null) { return null; }

	        return TilemapComponents.GetTilesWithin(tileX, tileY, width, height, filteringOptions, layer);
	    },

	    getTilesWithinShape: function (shape, filteringOptions, camera, layer)
	    {
	        layer = this.getLayer(layer);

	        if (layer === null) { return null; }

	        return TilemapComponents.GetTilesWithinShape(shape, filteringOptions, camera, layer);
	    },

	    getTilesWithinWorldXY: function (worldX, worldY, width, height, filteringOptions, camera, layer)
	    {
	        layer = this.getLayer(layer);

	        if (layer === null) { return null; }

	        return TilemapComponents.GetTilesWithinWorldXY(worldX, worldY, width, height, filteringOptions, camera, layer);
	    },

	    getTileset: function (name)
	    {
	        var index = this.getIndex(this.tilesets, name);

	        return (index !== null) ? this.tilesets[ index ] : null;
	    },

	    getTilesetIndex: function (name)
	    {
	        return this.getIndex(this.tilesets, name);
	    },

	    hasTileAt: function (tileX, tileY, layer)
	    {
	        layer = this.getLayer(layer);

	        if (layer === null) { return null; }

	        return TilemapComponents.HasTileAt(tileX, tileY, layer);
	    },

	    hasTileAtWorldXY: function (worldX, worldY, camera, layer)
	    {
	        layer = this.getLayer(layer);

	        if (layer === null) { return null; }

	        return TilemapComponents.HasTileAtWorldXY(worldX, worldY, camera, layer);
	    },

	    layer: {
	        get: function ()
	        {
	            return this.layers[ this.currentLayerIndex ];
	        },

	        set: function (layer)
	        {
	            this.setLayer(layer);
	        }
	    },

	    putTileAt: function (tile, tileX, tileY, recalculateFaces, layer)
	    {
	        if (recalculateFaces === undefined) { recalculateFaces = true; }

	        layer = this.getLayer(layer);

	        if (layer === null) { return null; }

	        return TilemapComponents.PutTileAt(tile, tileX, tileY, recalculateFaces, layer);
	    },

	    putTileAtWorldXY: function (tile, worldX, worldY, recalculateFaces, camera, layer)
	    {
	        if (recalculateFaces === undefined) { recalculateFaces = true; }

	        layer = this.getLayer(layer);

	        if (layer === null) { return null; }

	        return TilemapComponents.PutTileAtWorldXY(tile, worldX, worldY, recalculateFaces, camera, layer);
	    },

	    putTilesAt: function (tilesArray, tileX, tileY, recalculateFaces, layer)
	    {
	        if (recalculateFaces === undefined) { recalculateFaces = true; }

	        layer = this.getLayer(layer);

	        if (layer === null) { return null; }

	        TilemapComponents.PutTilesAt(tilesArray, tileX, tileY, recalculateFaces, layer);

	        return this;
	    },

	    randomize: function (tileX, tileY, width, height, indexes, layer)
	    {
	        layer = this.getLayer(layer);

	        if (layer === null) { return null; }

	        TilemapComponents.Randomize(tileX, tileY, width, height, indexes, layer);

	        return this;
	    },

	    calculateFacesAt: function (tileX, tileY, layer)
	    {
	        layer = this.getLayer(layer);

	        if (layer === null) { return null; }

	        TilemapComponents.CalculateFacesAt(tileX, tileY, layer);

	        return this;
	    },

	    calculateFacesWithin: function (tileX, tileY, width, height, layer)
	    {
	        layer = this.getLayer(layer);

	        if (layer === null) { return null; }

	        TilemapComponents.CalculateFacesWithin(tileX, tileY, width, height, layer);

	        return this;
	    },

	    removeLayer: function (layer)
	    {
	        var index = this.getLayerIndex(layer);

	        if (index !== null)
	        {
	            SpliceOne(this.layers, index);

	            for (var i = index; i < this.layers.length; i++)
	            {
	                if (this.layers[ i ].tilemapLayer)
	                {
	                    this.layers[ i ].tilemapLayer.layerIndex--;
	                }
	            }

	            if (this.currentLayerIndex === index)
	            {
	                this.currentLayerIndex = 0;
	            }

	            return this;
	        }
	        else
	        {
	            return null;
	        }
	    },

	    destroyLayer: function (layer)
	    {
	        var index = this.getLayerIndex(layer);

	        if (index !== null)
	        {
	            layer = this.layers[ index ];

	            layer.tilemapLayer.destroy();

	            SpliceOne(this.layers, index);

	            if (this.currentLayerIndex === index)
	            {
	                this.currentLayerIndex = 0;
	            }

	            return this;
	        }
	        else
	        {
	            return null;
	        }
	    },

	    removeAllLayers: function ()
	    {
	        var layers = this.layers;

	        for (var i = 0; i < layers.length; i++)
	        {
	            if (layers[ i ].tilemapLayer)
	            {
	                layers[ i ].tilemapLayer.destroy(false);
	            }
	        }

	        layers.length = 0;

	        this.currentLayerIndex = 0;

	        return this;
	    },

	    removeTile: function (tiles, replaceIndex, recalculateFaces)
	    {
	        if (replaceIndex === undefined) { replaceIndex = -1; }
	        if (recalculateFaces === undefined) { recalculateFaces = true; }

	        var removed = [];

	        if (!Array.isArray(tiles))
	        {
	            tiles = [ tiles ];
	        }

	        for (var i = 0; i < tiles.length; i++)
	        {
	            var tile = tiles[ i ];

	            removed.push(this.removeTileAt(tile.x, tile.y, true, recalculateFaces, tile.tilemapLayer));

	            if (replaceIndex > -1)
	            {
	                this.putTileAt(replaceIndex, tile.x, tile.y, recalculateFaces, tile.tilemapLayer);
	            }
	        }

	        return removed;
	    },

	    removeTileAt: function (tileX, tileY, replaceWithNull, recalculateFaces, layer)
	    {
	        if (replaceWithNull === undefined) { replaceWithNull = true; }
	        if (recalculateFaces === undefined) { recalculateFaces = true; }

	        layer = this.getLayer(layer);

	        if (layer === null) { return null; }

	        return TilemapComponents.RemoveTileAt(tileX, tileY, replaceWithNull, recalculateFaces, layer);
	    },

	    removeTileAtWorldXY: function (worldX, worldY, replaceWithNull, recalculateFaces, camera, layer)
	    {
	        if (replaceWithNull === undefined) { replaceWithNull = true; }
	        if (recalculateFaces === undefined) { recalculateFaces = true; }

	        layer = this.getLayer(layer);

	        if (layer === null) { return null; }

	        return TilemapComponents.RemoveTileAtWorldXY(worldX, worldY, replaceWithNull, recalculateFaces, camera, layer);
	    },

	    renderDebug: function (graphics, styleConfig, layer)
	    {
	        layer = this.getLayer(layer);

	        if (layer === null) { return null; }

	        if (this.orientation === ORIENTATION.ORTHOGONAL)
	        {
	            TilemapComponents.RenderDebug(graphics, styleConfig, layer);
	        }

	        return this;
	    },

	    renderDebugFull: function (graphics, styleConfig)
	    {
	        var layers = this.layers;

	        for (var i = 0; i < layers.length; i++)
	        {
	            TilemapComponents.RenderDebug(graphics, styleConfig, layers[ i ]);
	        }

	        return this;
	    },

	    replaceByIndex: function (findIndex, newIndex, tileX, tileY, width, height, layer)
	    {
	        layer = this.getLayer(layer);

	        if (layer === null) { return null; }

	        TilemapComponents.ReplaceByIndex(findIndex, newIndex, tileX, tileY, width, height, layer);

	        return this;
	    },

	    setCollision: function (indexes, collides, recalculateFaces, layer, updateLayer)
	    {
	        if (collides === undefined) { collides = true; }
	        if (recalculateFaces === undefined) { recalculateFaces = true; }
	        if (updateLayer === undefined) { updateLayer = true; }

	        layer = this.getLayer(layer);

	        if (layer === null) { return null; }

	        TilemapComponents.SetCollision(indexes, collides, recalculateFaces, layer, updateLayer);

	        return this;
	    },

	    setCollisionBetween: function (start, stop, collides, recalculateFaces, layer)
	    {
	        if (collides === undefined) { collides = true; }
	        if (recalculateFaces === undefined) { recalculateFaces = true; }

	        layer = this.getLayer(layer);

	        if (layer === null) { return null; }

	        TilemapComponents.SetCollisionBetween(start, stop, collides, recalculateFaces, layer);

	        return this;
	    },

	    setCollisionByProperty: function (properties, collides, recalculateFaces, layer)
	    {
	        if (collides === undefined) { collides = true; }
	        if (recalculateFaces === undefined) { recalculateFaces = true; }

	        layer = this.getLayer(layer);

	        if (layer === null) { return null; }

	        TilemapComponents.SetCollisionByProperty(properties, collides, recalculateFaces, layer);

	        return this;
	    },

	    setCollisionByExclusion: function (indexes, collides, recalculateFaces, layer)
	    {
	        if (collides === undefined) { collides = true; }
	        if (recalculateFaces === undefined) { recalculateFaces = true; }

	        layer = this.getLayer(layer);

	        if (layer === null) { return null; }

	        TilemapComponents.SetCollisionByExclusion(indexes, collides, recalculateFaces, layer);

	        return this;
	    },

	    setCollisionFromCollisionGroup: function (collides, recalculateFaces, layer)
	    {
	        if (collides === undefined) { collides = true; }
	        if (recalculateFaces === undefined) { recalculateFaces = true; }

	        layer = this.getLayer(layer);

	        if (layer === null) { return null; }

	        TilemapComponents.SetCollisionFromCollisionGroup(collides, recalculateFaces, layer);

	        return this;
	    },

	    setTileIndexCallback: function (indexes, callback, callbackContext, layer)
	    {
	        layer = this.getLayer(layer);

	        if (layer === null) { return null; }

	        TilemapComponents.SetTileIndexCallback(indexes, callback, callbackContext, layer);

	        return this;
	    },

	    setTileLocationCallback: function (tileX, tileY, width, height, callback, callbackContext, layer)
	    {
	        layer = this.getLayer(layer);

	        if (layer === null) { return null; }

	        TilemapComponents.SetTileLocationCallback(tileX, tileY, width, height, callback, callbackContext, layer);

	        return this;
	    },

	    setLayer: function (layer)
	    {
	        var index = this.getLayerIndex(layer);

	        if (index !== null)
	        {
	            this.currentLayerIndex = index;
	        }

	        return this;
	    },

	    setBaseTileSize: function (tileWidth, tileHeight)
	    {
	        this.tileWidth = tileWidth;
	        this.tileHeight = tileHeight;
	        this.widthInPixels = this.width * tileWidth;
	        this.heightInPixels = this.height * tileHeight;

	        for (var i = 0; i < this.layers.length; i++)
	        {
	            this.layers[ i ].baseTileWidth = tileWidth;
	            this.layers[ i ].baseTileHeight = tileHeight;

	            var mapData = this.layers[ i ].data;
	            var mapWidth = this.layers[ i ].width;
	            var mapHeight = this.layers[ i ].height;

	            for (var row = 0; row < mapHeight; row++)
	            {
	                for (var col = 0; col < mapWidth; col++)
	                {
	                    var tile = mapData[ row ][ col ];

	                    if (tile !== null)
	                    {
	                        tile.setSize(undefined, undefined, tileWidth, tileHeight);
	                    }
	                }
	            }
	        }

	        return this;
	    },

	    setLayerTileSize: function (tileWidth, tileHeight, layer)
	    {
	        layer = this.getLayer(layer);

	        if (layer === null) { return this; }

	        layer.tileWidth = tileWidth;
	        layer.tileHeight = tileHeight;

	        var mapData = layer.data;
	        var mapWidth = layer.width;
	        var mapHeight = layer.height;

	        for (var row = 0; row < mapHeight; row++)
	        {
	            for (var col = 0; col < mapWidth; col++)
	            {
	                var tile = mapData[ row ][ col ];

	                if (tile !== null)
	                {
	                    tile.setSize(tileWidth, tileHeight);
	                }
	            }
	        }

	        return this;
	    },

	    shuffle: function (tileX, tileY, width, height, layer)
	    {
	        layer = this.getLayer(layer);

	        if (layer === null) { return null; }

	        TilemapComponents.Shuffle(tileX, tileY, width, height, layer);

	        return this;
	    },

	    swapByIndex: function (indexA, indexB, tileX, tileY, width, height, layer)
	    {
	        layer = this.getLayer(layer);

	        if (layer === null) { return null; }

	        TilemapComponents.SwapByIndex(indexA, indexB, tileX, tileY, width, height, layer);

	        return this;
	    },

	    tileToWorldX: function (tileX, camera, layer)
	    {
	        layer = this.getLayer(layer);

	        if (layer === null) { return null; }

	        return this._convert.TileToWorldX(tileX, camera, layer);
	    },

	    tileToWorldY: function (tileY, camera, layer)
	    {
	        layer = this.getLayer(layer);

	        if (layer === null) { return null; }

	        return this._convert.TileToWorldY(tileY, camera, layer);
	    },

	    tileToWorldXY: function (tileX, tileY, vec2, camera, layer)
	    {
	        layer = this.getLayer(layer);

	        if (layer === null) { return null; }

	        return this._convert.TileToWorldXY(tileX, tileY, vec2, camera, layer);
	    },

	    getTileCorners: function (tileX, tileY, camera, layer)
	    {
	        layer = this.getLayer(layer);

	        if (layer === null) { return null; }

	        return this._convert.GetTileCorners(tileX, tileY, camera, layer);
	    },

	    weightedRandomize: function (weightedIndexes, tileX, tileY, width, height, layer)
	    {
	        layer = this.getLayer(layer);

	        if (layer === null) { return null; }

	        TilemapComponents.WeightedRandomize(tileX, tileY, width, height, weightedIndexes, layer);

	        return this;
	    },

	    worldToTileX: function (worldX, snapToFloor, camera, layer)
	    {
	        layer = this.getLayer(layer);

	        if (layer === null) { return null; }

	        return this._convert.WorldToTileX(worldX, snapToFloor, camera, layer);
	    },

	    worldToTileY: function (worldY, snapToFloor, camera, layer)
	    {
	        layer = this.getLayer(layer);

	        if (layer === null) { return null; }

	        return this._convert.WorldToTileY(worldY, snapToFloor, camera, layer);
	    },

	    worldToTileXY: function (worldX, worldY, snapToFloor, vec2, camera, layer)
	    {
	        layer = this.getLayer(layer);

	        if (layer === null) { return null; }

	        return this._convert.WorldToTileXY(worldX, worldY, snapToFloor, vec2, camera, layer);
	    },

	    destroy: function ()
	    {
	        this.removeAllLayers();

	        this.tiles.length = 0;
	        this.tilesets.length = 0;
	        this.objects.length = 0;

	        this.scene = null;
	    }

	});

	Tilemap_1 = Tilemap;
	return Tilemap_1;
}

var ParseToTilemap_1;
var hasRequiredParseToTilemap;

function requireParseToTilemap () {
	if (hasRequiredParseToTilemap) return ParseToTilemap_1;
	hasRequiredParseToTilemap = 1;
	var Formats = requireFormats();
	var MapData = requireMapData();
	var Parse = requireParse();
	var Tilemap = requireTilemap();

	var ParseToTilemap = function (scene, key, tileWidth, tileHeight, width, height, data, insertNull)
	{
	    if (tileWidth === undefined) { tileWidth = 32; }
	    if (tileHeight === undefined) { tileHeight = 32; }
	    if (width === undefined) { width = 10; }
	    if (height === undefined) { height = 10; }
	    if (insertNull === undefined) { insertNull = false; }

	    var mapData = null;

	    if (Array.isArray(data))
	    {
	        var name = key !== undefined ? key : 'map';
	        mapData = Parse(name, Formats.ARRAY_2D, data, tileWidth, tileHeight, insertNull);
	    }
	    else if (key !== undefined)
	    {
	        var tilemapData = scene.cache.tilemap.get(key);

	        if (!tilemapData)
	        {
	            console.warn('No map data found for key ' + key);
	        }
	        else
	        {
	            mapData = Parse(key, tilemapData.format, tilemapData.data, tileWidth, tileHeight, insertNull);
	        }
	    }

	    if (mapData === null)
	    {
	        mapData = new MapData({
	            tileWidth: tileWidth,
	            tileHeight: tileHeight,
	            width: width,
	            height: height
	        });
	    }

	    return new Tilemap(scene, mapData);
	};

	ParseToTilemap_1 = ParseToTilemap;
	return ParseToTilemap_1;
}

var TilemapCreator = {};

var hasRequiredTilemapCreator;

function requireTilemapCreator () {
	if (hasRequiredTilemapCreator) return TilemapCreator;
	hasRequiredTilemapCreator = 1;
	var GameObjectCreator = requireGameObjectCreator();
	var ParseToTilemap = requireParseToTilemap();

	GameObjectCreator.register('tilemap', function (config)
	{

	    var c = (config !== undefined) ? config : {};

	    return ParseToTilemap(
	        this.scene,
	        c.key,
	        c.tileWidth,
	        c.tileHeight,
	        c.width,
	        c.height,
	        c.data,
	        c.insertNull
	    );
	});
	return TilemapCreator;
}

var TilemapFactory = {};

var hasRequiredTilemapFactory;

function requireTilemapFactory () {
	if (hasRequiredTilemapFactory) return TilemapFactory;
	hasRequiredTilemapFactory = 1;
	var GameObjectFactory = requireGameObjectFactory();
	var ParseToTilemap = requireParseToTilemap();

	GameObjectFactory.register('tilemap', function (key, tileWidth, tileHeight, width, height, data, insertNull)
	{

	    if (key === null) { key = undefined; }
	    if (tileWidth === null) { tileWidth = undefined; }
	    if (tileHeight === null) { tileHeight = undefined; }
	    if (width === null) { width = undefined; }
	    if (height === null) { height = undefined; }

	    return ParseToTilemap(this.scene, key, tileWidth, tileHeight, width, height, data, insertNull);
	});
	return TilemapFactory;
}

var tilemaps;
var hasRequiredTilemaps;

function requireTilemaps () {
	if (hasRequiredTilemaps) return tilemaps;
	hasRequiredTilemaps = 1;
	var Extend = requireExtend$1();
	var CONST = require_const();

	var Tilemaps = {

	    Components: requireComponents(),
	    Parsers: requireParsers(),

	    Formats: requireFormats(),
	    ImageCollection: requireImageCollection(),
	    ParseToTilemap: requireParseToTilemap(),
	    Tile: requireTile(),
	    Tilemap: requireTilemap(),
	    TilemapCreator: requireTilemapCreator(),
	    TilemapFactory: requireTilemapFactory(),
	    Tileset: requireTileset(),
	    TilemapLayer: requireTilemapLayer(),
	    Orientation: requireORIENTATION_CONST(),

	    LayerData: requireLayerData(),
	    MapData: requireMapData(),
	    ObjectLayer: requireObjectLayer()

	};

	Tilemaps = Extend(false, Tilemaps, CONST.ORIENTATION);

	tilemaps = Tilemaps;
	return tilemaps;
}

var TimerEvent_1;
var hasRequiredTimerEvent;

function requireTimerEvent () {
	if (hasRequiredTimerEvent) return TimerEvent_1;
	hasRequiredTimerEvent = 1;
	var Class = requireClass();
	var GetFastValue = requireGetFastValue();

	var TimerEvent = new Class({

	    initialize:

	    function TimerEvent (config)
	    {

	        this.delay = 0;

	        this.repeat = 0;

	        this.repeatCount = 0;

	        this.loop = false;

	        this.callback;

	        this.callbackScope;

	        this.args;

	        this.timeScale = 1;

	        this.startAt = 0;

	        this.elapsed = 0;

	        this.paused = false;

	        this.hasDispatched = false;

	        this.reset(config);
	    },

	    reset: function (config)
	    {
	        this.delay = GetFastValue(config, 'delay', 0);

	        this.repeat = GetFastValue(config, 'repeat', 0);

	        this.loop = GetFastValue(config, 'loop', false);

	        this.callback = GetFastValue(config, 'callback', undefined);

	        this.callbackScope = GetFastValue(config, 'callbackScope', this);

	        this.args = GetFastValue(config, 'args', []);

	        this.timeScale = GetFastValue(config, 'timeScale', 1);

	        this.startAt = GetFastValue(config, 'startAt', 0);

	        this.paused = GetFastValue(config, 'paused', false);

	        this.elapsed = this.startAt;
	        this.hasDispatched = false;
	        this.repeatCount = (this.repeat === -1 || this.loop) ? 999999999999 : this.repeat;

	        if (this.delay <= 0 && this.repeatCount > 0)
	        {
	            throw new Error('TimerEvent infinite loop created via zero delay');
	        }

	        return this;
	    },

	    getProgress: function ()
	    {
	        return (this.elapsed / this.delay);
	    },

	    getOverallProgress: function ()
	    {
	        if (this.repeat > 0)
	        {
	            var totalDuration = this.delay + (this.delay * this.repeat);
	            var totalElapsed = this.elapsed + (this.delay * (this.repeat - this.repeatCount));

	            return (totalElapsed / totalDuration);
	        }
	        else
	        {
	            return this.getProgress();
	        }
	    },

	    getRepeatCount: function ()
	    {
	        return this.repeatCount;
	    },

	    getElapsed: function ()
	    {
	        return this.elapsed;
	    },

	    getElapsedSeconds: function ()
	    {
	        return this.elapsed * 0.001;
	    },

	    getRemaining: function ()
	    {
	        return this.delay - this.elapsed;
	    },

	    getRemainingSeconds: function ()
	    {
	        return this.getRemaining() * 0.001;
	    },

	    getOverallRemaining: function ()
	    {
	        return this.delay * (1 + this.repeatCount) - this.elapsed;
	    },

	    getOverallRemainingSeconds: function ()
	    {
	        return this.getOverallRemaining() * 0.001;
	    },

	    remove: function (dispatchCallback)
	    {
	        if (dispatchCallback === undefined) { dispatchCallback = false; }

	        this.elapsed = this.delay;

	        this.hasDispatched = !dispatchCallback;

	        this.repeatCount = 0;
	    },

	    destroy: function ()
	    {
	        this.callback = undefined;
	        this.callbackScope = undefined;
	        this.args = [];
	    }

	});

	TimerEvent_1 = TimerEvent;
	return TimerEvent_1;
}

var Clock_1;
var hasRequiredClock;

function requireClock () {
	if (hasRequiredClock) return Clock_1;
	hasRequiredClock = 1;
	var Class = requireClass();
	var PluginCache = requirePluginCache();
	var SceneEvents = requireEvents$l();
	var TimerEvent = requireTimerEvent();
	var Remove = requireRemove();

	var Clock = new Class({

	    initialize:

	    function Clock (scene)
	    {

	        this.scene = scene;

	        this.systems = scene.sys;

	        this.now = 0;

	        this.startTime = 0;

	        this.timeScale = 1;

	        this.paused = false;

	        this._active = [];

	        this._pendingInsertion = [];

	        this._pendingRemoval = [];

	        scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
	        scene.sys.events.on(SceneEvents.START, this.start, this);
	    },

	    boot: function ()
	    {

	        this.now = this.systems.game.loop.time;

	        this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);
	    },

	    start: function ()
	    {
	        this.startTime = this.systems.game.loop.time;

	        var eventEmitter = this.systems.events;

	        eventEmitter.on(SceneEvents.PRE_UPDATE, this.preUpdate, this);
	        eventEmitter.on(SceneEvents.UPDATE, this.update, this);
	        eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);
	    },

	    addEvent: function (config)
	    {
	        var event;

	        if (config instanceof TimerEvent)
	        {
	            event = config;

	            this.removeEvent(event);

	            event.elapsed = event.startAt;
	            event.hasDispatched = false;
	            event.repeatCount = (event.repeat === -1 || event.loop) ? 999999999999 : event.repeat;

	            if (event.delay <= 0 && event.repeatCount > 0)
	            {
	                throw new Error('TimerEvent infinite loop created via zero delay');
	            }
	        }
	        else
	        {
	            event = new TimerEvent(config);
	        }

	        this._pendingInsertion.push(event);

	        return event;
	    },

	    delayedCall: function (delay, callback, args, callbackScope)
	    {
	        return this.addEvent({ delay: delay, callback: callback, args: args, callbackScope: callbackScope });
	    },

	    clearPendingEvents: function ()
	    {
	        this._pendingInsertion = [];

	        return this;
	    },

	    removeEvent: function (events)
	    {
	        if (!Array.isArray(events))
	        {
	            events = [ events ];
	        }

	        for (var i = 0; i < events.length; i++)
	        {
	            var event = events[i];

	            Remove(this._pendingRemoval, event);
	            Remove(this._pendingInsertion, event);
	            Remove(this._active, event);
	        }

	        return this;
	    },

	    removeAllEvents: function ()
	    {
	        this._pendingRemoval = this._pendingRemoval.concat(this._active);

	        return this;
	    },

	    preUpdate: function ()
	    {
	        var toRemove = this._pendingRemoval.length;
	        var toInsert = this._pendingInsertion.length;

	        if (toRemove === 0 && toInsert === 0)
	        {

	            return;
	        }

	        var i;
	        var event;

	        for (i = 0; i < toRemove; i++)
	        {
	            event = this._pendingRemoval[i];

	            var index = this._active.indexOf(event);

	            if (index > -1)
	            {
	                this._active.splice(index, 1);
	            }

	            event.destroy();
	        }

	        for (i = 0; i < toInsert; i++)
	        {
	            event = this._pendingInsertion[i];

	            this._active.push(event);
	        }

	        this._pendingRemoval.length = 0;
	        this._pendingInsertion.length = 0;
	    },

	    update: function (time, delta)
	    {
	        this.now = time;

	        if (this.paused)
	        {
	            return;
	        }

	        delta *= this.timeScale;

	        for (var i = 0; i < this._active.length; i++)
	        {
	            var event = this._active[i];

	            if (event.paused)
	            {
	                continue;
	            }

	            event.elapsed += delta * event.timeScale;

	            if (event.elapsed >= event.delay)
	            {
	                var remainder = event.elapsed - event.delay;

	                event.elapsed = event.delay;

	                if (!event.hasDispatched && event.callback)
	                {
	                    event.hasDispatched = true;
	                    event.callback.apply(event.callbackScope, event.args);
	                }

	                if (event.repeatCount > 0)
	                {
	                    event.repeatCount--;

	                    if (remainder >= event.delay)
	                    {
	                        while ((remainder >= event.delay) && (event.repeatCount > 0))
	                        {
	                            if (event.callback)
	                            {
	                                event.callback.apply(event.callbackScope, event.args);
	                            }

	                            remainder -= event.delay;
	                            event.repeatCount--;
	                        }
	                    }

	                    event.elapsed = remainder;
	                    event.hasDispatched = false;
	                }
	                else if (event.hasDispatched)
	                {
	                    this._pendingRemoval.push(event);
	                }
	            }
	        }
	    },

	    shutdown: function ()
	    {
	        var i;

	        for (i = 0; i < this._pendingInsertion.length; i++)
	        {
	            this._pendingInsertion[i].destroy();
	        }

	        for (i = 0; i < this._active.length; i++)
	        {
	            this._active[i].destroy();
	        }

	        for (i = 0; i < this._pendingRemoval.length; i++)
	        {
	            this._pendingRemoval[i].destroy();
	        }

	        this._active.length = 0;
	        this._pendingRemoval.length = 0;
	        this._pendingInsertion.length = 0;

	        var eventEmitter = this.systems.events;

	        eventEmitter.off(SceneEvents.PRE_UPDATE, this.preUpdate, this);
	        eventEmitter.off(SceneEvents.UPDATE, this.update, this);
	        eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);
	    },

	    destroy: function ()
	    {
	        this.shutdown();

	        this.scene.sys.events.off(SceneEvents.START, this.start, this);

	        this.scene = null;
	        this.systems = null;
	    }

	});

	PluginCache.register('Clock', Clock, 'time');

	Clock_1 = Clock;
	return Clock_1;
}

var COMPLETE_EVENT;
var hasRequiredCOMPLETE_EVENT;

function requireCOMPLETE_EVENT () {
	if (hasRequiredCOMPLETE_EVENT) return COMPLETE_EVENT;
	hasRequiredCOMPLETE_EVENT = 1;
	COMPLETE_EVENT = 'complete';
	return COMPLETE_EVENT;
}

var events$1;
var hasRequiredEvents$1;

function requireEvents$1 () {
	if (hasRequiredEvents$1) return events$1;
	hasRequiredEvents$1 = 1;
	events$1 = {

	    COMPLETE: requireCOMPLETE_EVENT()

	};
	return events$1;
}

var Timeline_1;
var hasRequiredTimeline;

function requireTimeline () {
	if (hasRequiredTimeline) return Timeline_1;
	hasRequiredTimeline = 1;
	var Class = requireClass();
	var EventEmitter = requireEventemitter3();
	var GameObjectFactory = requireGameObjectFactory();
	var GetFastValue = requireGetFastValue();
	var SceneEvents = requireEvents$l();
	var Events = requireEvents$1();

	var Timeline = new Class({

	    Extends: EventEmitter,

	    initialize:

	    function Timeline (scene, config)
	    {
	        EventEmitter.call(this);

	        this.scene = scene;

	        this.systems = scene.sys;

	        this.elapsed = 0;

	        this.timeScale = 1;

	        this.paused = true;

	        this.complete = false;

	        this.totalComplete = 0;

	        this.loop = 0;

	        this.iteration = 0;

	        this.events = [];

	        var eventEmitter = this.systems.events;

	        eventEmitter.on(SceneEvents.PRE_UPDATE, this.preUpdate, this);
	        eventEmitter.on(SceneEvents.UPDATE, this.update, this);
	        eventEmitter.once(SceneEvents.SHUTDOWN, this.destroy, this);

	        if (config)
	        {
	            this.add(config);
	        }
	    },

	    preUpdate: function (time, delta)
	    {
	        if (this.paused)
	        {
	            return;
	        }

	        this.elapsed += delta * this.timeScale;
	    },

	    update: function ()
	    {
	        if (this.paused || this.complete)
	        {
	            return;
	        }

	        var i;
	        var events = this.events;
	        var removeSweep = false;
	        var sys = this.systems;
	        var target;

	        for (i = 0; i < events.length; i++)
	        {
	            var event = events[i];

	            if (!event.complete && event.time <= this.elapsed)
	            {
	                event.complete = true;

	                this.totalComplete++;

	                target = (event.target) ? event.target : this;

	                if (event.if)
	                {
	                    if (!event.if.call(target, event))
	                    {
	                        continue;
	                    }
	                }

	                if (event.once)
	                {
	                    removeSweep = true;
	                }

	                if (event.set && event.target)
	                {

	                    for (var key in event.set)
	                    {
	                        event.target[key] = event.set[key];
	                    }
	                }

	                if (this.iteration)
	                {
	                    event.repeat++;
	                }

	                if (event.loop && event.repeat)
	                {
	                    event.loop.call(target);
	                }

	                if (event.tween)
	                {
	                    event.tweenInstance = sys.tweens.add(event.tween);
	                }

	                if (event.sound)
	                {
	                    if (typeof event.sound === 'string')
	                    {
	                        sys.sound.play(event.sound);
	                    }
	                    else
	                    {
	                        sys.sound.play(event.sound.key, event.sound.config);
	                    }
	                }

	                if (event.event)
	                {
	                    this.emit(event.event, target);
	                }

	                if (event.run)
	                {
	                    event.run.call(target);
	                }

	                if (event.stop)
	                {
	                    this.stop();
	                }
	            }
	        }

	        if (removeSweep)
	        {
	            for (i = 0; i < events.length; i++)
	            {
	                if (events[i].complete && events[i].once)
	                {
	                    events.splice(i, 1);

	                    i--;
	                }
	            }
	        }

	        if (this.totalComplete >= events.length)
	        {
	            if (this.loop !== 0 && (this.loop === -1 || this.loop > this.iteration))
	            {
	                this.iteration++;

	                this.reset(true);
	            }
	            else
	            {
	                this.complete = true;
	            }
	        }

	        if (this.complete)
	        {
	            this.emit(Events.COMPLETE, this);
	        }
	    },

	    play: function (fromStart)
	    {
	        if (fromStart === undefined) { fromStart = true; }

	        this.paused = false;
	        this.complete = false;
	        this.totalComplete = 0;

	        if (fromStart)
	        {
	            this.reset();
	        }

	        return this;
	    },

	    pause: function ()
	    {
	        this.paused = true;

	        var events = this.events;

	        for (var i = 0; i < events.length; i++)
	        {
	            var event = events[i];

	            if (event.tweenInstance)
	            {
	                event.tweenInstance.paused = true;
	            }
	        }

	        return this;
	    },

	    repeat: function (amount)
	    {
	        if (amount === undefined || amount === true) { amount = -1; }
	        if (amount === false) { amount = 0; }

	        this.loop = amount;

	        return this;
	    },

	    resume: function ()
	    {
	        this.paused = false;

	        var events = this.events;

	        for (var i = 0; i < events.length; i++)
	        {
	            var event = events[i];

	            if (event.tweenInstance)
	            {
	                event.tweenInstance.paused = false;
	            }
	        }

	        return this;
	    },

	    stop: function ()
	    {
	        this.paused = true;
	        this.complete = true;

	        return this;
	    },

	    reset: function (loop)
	    {
	        if (loop === undefined) { loop = false; }

	        this.elapsed = 0;

	        if (!loop)
	        {
	            this.iteration = 0;
	        }

	        var events = this.events;

	        for (var i = 0; i < events.length; i++)
	        {
	            var event = events[i];

	            event.complete = false;

	            if (!loop)
	            {
	                event.repeat = 0;
	            }

	            if (event.tweenInstance)
	            {
	                event.tweenInstance.stop();
	            }
	        }

	        return this.play(false);
	    },

	    add: function (config)
	    {
	        if (!Array.isArray(config))
	        {
	            config = [ config ];
	        }

	        var events = this.events;
	        var prevTime = 0;

	        if (events.length > 0)
	        {
	            prevTime = events[events.length - 1].time;
	        }

	        for (var i = 0; i < config.length; i++)
	        {
	            var entry = config[i];

	            var startTime = GetFastValue(entry, 'at', 0);

	            var offsetTime = GetFastValue(entry, 'in', null);

	            if (offsetTime !== null)
	            {
	                startTime = this.elapsed + offsetTime;
	            }

	            var fromTime = GetFastValue(entry, 'from', null);

	            if (fromTime !== null)
	            {
	                startTime = prevTime + fromTime;
	            }

	            events.push({
	                complete: false,
	                time: startTime,
	                repeat: 0,
	                if: GetFastValue(entry, 'if', null),
	                run: GetFastValue(entry, 'run', null),
	                loop: GetFastValue(entry, 'loop', null),
	                event: GetFastValue(entry, 'event', null),
	                target: GetFastValue(entry, 'target', null),
	                set: GetFastValue(entry, 'set', null),
	                tween: GetFastValue(entry, 'tween', null),
	                sound: GetFastValue(entry, 'sound', null),
	                once: GetFastValue(entry, 'once', false),
	                stop: GetFastValue(entry, 'stop', false)
	            });

	            prevTime = startTime;
	        }

	        this.complete = false;

	        return this;
	    },

	    clear: function ()
	    {
	        var events = this.events;

	        for (var i = 0; i < events.length; i++)
	        {
	            var event = events[i];

	            if (event.tweenInstance)
	            {
	                event.tweenInstance.stop();
	            }
	        }

	        events = [];

	        this.elapsed = 0;
	        this.paused = true;

	        return this;
	    },

	    isPlaying: function ()
	    {
	        return (!this.paused && !this.complete);
	    },

	    getProgress: function ()
	    {
	        var total = Math.min(this.totalComplete, this.events.length);

	        return total / this.events.length;
	    },

	    destroy: function ()
	    {
	        var eventEmitter = this.systems.events;

	        eventEmitter.off(SceneEvents.PRE_UPDATE, this.preUpdate, this);
	        eventEmitter.off(SceneEvents.UPDATE, this.update, this);
	        eventEmitter.off(SceneEvents.SHUTDOWN, this.destroy, this);

	        this.clear();

	        this.scene = null;
	        this.systems = null;
	    }

	});

	GameObjectFactory.register('timeline', function (config)
	{
	    return new Timeline(this.scene, config);
	});

	Timeline_1 = Timeline;
	return Timeline_1;
}

var time;
var hasRequiredTime;

function requireTime () {
	if (hasRequiredTime) return time;
	hasRequiredTime = 1;
	time = {

	    Clock: requireClock(),
	    Events: requireEvents$1(),
	    Timeline: requireTimeline(),
	    TimerEvent: requireTimerEvent()

	};
	return time;
}

var GetNewValue_1;
var hasRequiredGetNewValue;

function requireGetNewValue () {
	if (hasRequiredGetNewValue) return GetNewValue_1;
	hasRequiredGetNewValue = 1;
	var GetNewValue = function (source, key, defaultValue)
	{
	    var valueCallback;

	    if (source.hasOwnProperty(key))
	    {
	        var t = typeof(source[key]);

	        if (t === 'function')
	        {
	            valueCallback = function (target, targetKey, value, targetIndex, totalTargets, tween)
	            {
	                return source[key](target, targetKey, value, targetIndex, totalTargets, tween);
	            };
	        }
	        else
	        {
	            valueCallback = function ()
	            {
	                return source[key];
	            };
	        }
	    }
	    else if (typeof defaultValue === 'function')
	    {
	        valueCallback = defaultValue;
	    }
	    else
	    {
	        valueCallback = function ()
	        {
	            return defaultValue;
	        };
	    }

	    return valueCallback;
	};

	GetNewValue_1 = GetNewValue;
	return GetNewValue_1;
}

var ReservedProps;
var hasRequiredReservedProps;

function requireReservedProps () {
	if (hasRequiredReservedProps) return ReservedProps;
	hasRequiredReservedProps = 1;
	ReservedProps = [
	    'callbackScope',
	    'completeDelay',
	    'delay',
	    'duration',
	    'ease',
	    'easeParams',
	    'flipX',
	    'flipY',
	    'hold',
	    'interpolation',
	    'loop',
	    'loopDelay',
	    'onActive',
	    'onActiveParams',
	    'onComplete',
	    'onCompleteParams',
	    'onLoop',
	    'onLoopParams',
	    'onPause',
	    'onPauseParams',
	    'onRepeat',
	    'onRepeatParams',
	    'onResume',
	    'onResumeParams',
	    'onStart',
	    'onStartParams',
	    'onStop',
	    'onStopParams',
	    'onUpdate',
	    'onUpdateParams',
	    'onYoyo',
	    'onYoyoParams',
	    'paused',
	    'persist',
	    'props',
	    'repeat',
	    'repeatDelay',
	    'targets',
	    'yoyo'
	];
	return ReservedProps;
}

var GetProps_1;
var hasRequiredGetProps;

function requireGetProps () {
	if (hasRequiredGetProps) return GetProps_1;
	hasRequiredGetProps = 1;
	var RESERVED = requireReservedProps();

	var GetProps = function (config)
	{
	    var key;
	    var keys = [];

	    if (config.hasOwnProperty('props'))
	    {
	        for (key in config.props)
	        {

	            if (key.substring(0, 1) !== '_')
	            {
	                keys.push({ key: key, value: config.props[key] });
	            }
	        }
	    }
	    else
	    {
	        for (key in config)
	        {

	            if (RESERVED.indexOf(key) === -1 && key.substring(0, 1) !== '_')
	            {
	                keys.push({ key: key, value: config[key] });
	            }
	        }
	    }

	    return keys;
	};

	GetProps_1 = GetProps;
	return GetProps_1;
}

var GetTargets_1;
var hasRequiredGetTargets;

function requireGetTargets () {
	if (hasRequiredGetTargets) return GetTargets_1;
	hasRequiredGetTargets = 1;
	var GetValue = requireGetValue();

	var GetTargets = function (config)
	{
	    var targets = GetValue(config, 'targets', null);

	    if (targets === null)
	    {
	        return targets;
	    }

	    if (typeof targets === 'function')
	    {
	        targets = targets.call();
	    }

	    if (!Array.isArray(targets))
	    {
	        targets = [ targets ];
	    }

	    return targets;
	};

	GetTargets_1 = GetTargets;
	return GetTargets_1;
}

var GetValueOp_1;
var hasRequiredGetValueOp;

function requireGetValueOp () {
	if (hasRequiredGetValueOp) return GetValueOp_1;
	hasRequiredGetValueOp = 1;
	var Between = requireBetween$1();
	var FloatBetween = requireFloatBetween();

	function hasGetActive (def)
	{
	    return (!!def.getActive && typeof def.getActive === 'function');
	}

	function hasGetStart (def)
	{
	    return (!!def.getStart && typeof def.getStart === 'function');
	}

	function hasGetEnd (def)
	{
	    return (!!def.getEnd && typeof def.getEnd === 'function');
	}

	function hasGetters (def)
	{
	    return hasGetStart(def) || hasGetEnd(def) || hasGetActive(def);
	}

	var GetValueOp = function (key, propertyValue)
	{
	    var callbacks;

	    var getEnd = function (target, key, value) { return value; };

	    var getStart = function (target, key, value) { return value; };

	    var getActive = null;

	    var t = typeof(propertyValue);

	    if (t === 'number')
	    {

	        getEnd = function ()
	        {
	            return propertyValue;
	        };
	    }
	    else if (Array.isArray(propertyValue))
	    {

	        getStart = function ()
	        {
	            return propertyValue[0];
	        };

	        getEnd = function ()
	        {
	            return propertyValue[propertyValue.length - 1];
	        };
	    }
	    else if (t === 'string')
	    {

	        var op = propertyValue.toLowerCase();
	        var isRandom = (op.substring(0, 6) === 'random');
	        var isInt = (op.substring(0, 3) === 'int');

	        if (isRandom || isInt)
	        {

	            var brace1 = op.indexOf('(');
	            var brace2 = op.indexOf(')');
	            var comma = op.indexOf(',');

	            if (brace1 && brace2 && comma)
	            {
	                var value1 = parseFloat(op.substring(brace1 + 1, comma));
	                var value2 = parseFloat(op.substring(comma + 1, brace2));

	                if (isRandom)
	                {
	                    getEnd = function ()
	                    {
	                        return FloatBetween(value1, value2);
	                    };
	                }
	                else
	                {
	                    getEnd = function ()
	                    {
	                        return Between(value1, value2);
	                    };
	                }
	            }
	            else
	            {
	                throw new Error('invalid random() format');
	            }
	        }
	        else
	        {
	            op = op[0];
	            var num = parseFloat(propertyValue.substr(2));

	            switch (op)
	            {
	                case '+':
	                    getEnd = function (target, key, value)
	                    {
	                        return value + num;
	                    };
	                    break;

	                case '-':
	                    getEnd = function (target, key, value)
	                    {
	                        return value - num;
	                    };
	                    break;

	                case '*':
	                    getEnd = function (target, key, value)
	                    {
	                        return value * num;
	                    };
	                    break;

	                case '/':
	                    getEnd = function (target, key, value)
	                    {
	                        return value / num;
	                    };
	                    break;

	                default:
	                    getEnd = function ()
	                    {
	                        return parseFloat(propertyValue);
	                    };
	            }
	        }
	    }
	    else if (t === 'function')
	    {

	        getEnd = propertyValue;
	    }
	    else if (t === 'object')
	    {
	        if (hasGetters(propertyValue))
	        {

	            if (hasGetActive(propertyValue))
	            {
	                getActive = propertyValue.getActive;
	            }

	            if (hasGetEnd(propertyValue))
	            {
	                getEnd = propertyValue.getEnd;
	            }

	            if (hasGetStart(propertyValue))
	            {
	                getStart = propertyValue.getStart;
	            }
	        }
	        else if (propertyValue.hasOwnProperty('value'))
	        {

	            callbacks = GetValueOp(key, propertyValue.value);
	        }
	        else
	        {

	            var hasTo = propertyValue.hasOwnProperty('to');
	            var hasFrom = propertyValue.hasOwnProperty('from');
	            var hasStart = propertyValue.hasOwnProperty('start');

	            if (hasTo && (hasFrom || hasStart))
	            {
	                callbacks = GetValueOp(key, propertyValue.to);

	                if (hasStart)
	                {
	                    var startCallbacks = GetValueOp(key, propertyValue.start);

	                    callbacks.getActive = startCallbacks.getEnd;
	                }

	                if (hasFrom)
	                {
	                    var fromCallbacks = GetValueOp(key, propertyValue.from);

	                    callbacks.getStart = fromCallbacks.getEnd;
	                }
	            }
	        }
	    }

	    if (!callbacks)
	    {
	        callbacks = {
	            getActive: getActive,
	            getEnd: getEnd,
	            getStart: getStart
	        };
	    }

	    return callbacks;
	};

	GetValueOp_1 = GetValueOp;
	return GetValueOp_1;
}

var TWEEN_ACTIVE_EVENT;
var hasRequiredTWEEN_ACTIVE_EVENT;

function requireTWEEN_ACTIVE_EVENT () {
	if (hasRequiredTWEEN_ACTIVE_EVENT) return TWEEN_ACTIVE_EVENT;
	hasRequiredTWEEN_ACTIVE_EVENT = 1;
	TWEEN_ACTIVE_EVENT = 'active';
	return TWEEN_ACTIVE_EVENT;
}

var TWEEN_COMPLETE_EVENT;
var hasRequiredTWEEN_COMPLETE_EVENT;

function requireTWEEN_COMPLETE_EVENT () {
	if (hasRequiredTWEEN_COMPLETE_EVENT) return TWEEN_COMPLETE_EVENT;
	hasRequiredTWEEN_COMPLETE_EVENT = 1;
	TWEEN_COMPLETE_EVENT = 'complete';
	return TWEEN_COMPLETE_EVENT;
}

var TWEEN_LOOP_EVENT;
var hasRequiredTWEEN_LOOP_EVENT;

function requireTWEEN_LOOP_EVENT () {
	if (hasRequiredTWEEN_LOOP_EVENT) return TWEEN_LOOP_EVENT;
	hasRequiredTWEEN_LOOP_EVENT = 1;
	TWEEN_LOOP_EVENT = 'loop';
	return TWEEN_LOOP_EVENT;
}

var TWEEN_PAUSE_EVENT;
var hasRequiredTWEEN_PAUSE_EVENT;

function requireTWEEN_PAUSE_EVENT () {
	if (hasRequiredTWEEN_PAUSE_EVENT) return TWEEN_PAUSE_EVENT;
	hasRequiredTWEEN_PAUSE_EVENT = 1;
	TWEEN_PAUSE_EVENT = 'pause';
	return TWEEN_PAUSE_EVENT;
}

var TWEEN_RESUME_EVENT;
var hasRequiredTWEEN_RESUME_EVENT;

function requireTWEEN_RESUME_EVENT () {
	if (hasRequiredTWEEN_RESUME_EVENT) return TWEEN_RESUME_EVENT;
	hasRequiredTWEEN_RESUME_EVENT = 1;
	TWEEN_RESUME_EVENT = 'resume';
	return TWEEN_RESUME_EVENT;
}

var TWEEN_REPEAT_EVENT;
var hasRequiredTWEEN_REPEAT_EVENT;

function requireTWEEN_REPEAT_EVENT () {
	if (hasRequiredTWEEN_REPEAT_EVENT) return TWEEN_REPEAT_EVENT;
	hasRequiredTWEEN_REPEAT_EVENT = 1;
	TWEEN_REPEAT_EVENT = 'repeat';
	return TWEEN_REPEAT_EVENT;
}

var TWEEN_START_EVENT;
var hasRequiredTWEEN_START_EVENT;

function requireTWEEN_START_EVENT () {
	if (hasRequiredTWEEN_START_EVENT) return TWEEN_START_EVENT;
	hasRequiredTWEEN_START_EVENT = 1;
	TWEEN_START_EVENT = 'start';
	return TWEEN_START_EVENT;
}

var TWEEN_STOP_EVENT;
var hasRequiredTWEEN_STOP_EVENT;

function requireTWEEN_STOP_EVENT () {
	if (hasRequiredTWEEN_STOP_EVENT) return TWEEN_STOP_EVENT;
	hasRequiredTWEEN_STOP_EVENT = 1;
	TWEEN_STOP_EVENT = 'stop';
	return TWEEN_STOP_EVENT;
}

var TWEEN_UPDATE_EVENT;
var hasRequiredTWEEN_UPDATE_EVENT;

function requireTWEEN_UPDATE_EVENT () {
	if (hasRequiredTWEEN_UPDATE_EVENT) return TWEEN_UPDATE_EVENT;
	hasRequiredTWEEN_UPDATE_EVENT = 1;
	TWEEN_UPDATE_EVENT = 'update';
	return TWEEN_UPDATE_EVENT;
}

var TWEEN_YOYO_EVENT;
var hasRequiredTWEEN_YOYO_EVENT;

function requireTWEEN_YOYO_EVENT () {
	if (hasRequiredTWEEN_YOYO_EVENT) return TWEEN_YOYO_EVENT;
	hasRequiredTWEEN_YOYO_EVENT = 1;
	TWEEN_YOYO_EVENT = 'yoyo';
	return TWEEN_YOYO_EVENT;
}

var events;
var hasRequiredEvents;

function requireEvents () {
	if (hasRequiredEvents) return events;
	hasRequiredEvents = 1;
	events = {

	    TWEEN_ACTIVE: requireTWEEN_ACTIVE_EVENT(),
	    TWEEN_COMPLETE: requireTWEEN_COMPLETE_EVENT(),
	    TWEEN_LOOP: requireTWEEN_LOOP_EVENT(),
	    TWEEN_PAUSE: requireTWEEN_PAUSE_EVENT(),
	    TWEEN_RESUME: requireTWEEN_RESUME_EVENT(),
	    TWEEN_REPEAT: requireTWEEN_REPEAT_EVENT(),
	    TWEEN_START: requireTWEEN_START_EVENT(),
	    TWEEN_STOP: requireTWEEN_STOP_EVENT(),
	    TWEEN_UPDATE: requireTWEEN_UPDATE_EVENT(),
	    TWEEN_YOYO: requireTWEEN_YOYO_EVENT()

	};
	return events;
}

var BaseTween_1;
var hasRequiredBaseTween;

function requireBaseTween () {
	if (hasRequiredBaseTween) return BaseTween_1;
	hasRequiredBaseTween = 1;
	var Class = requireClass();
	var EventEmitter = requireEventemitter3();
	var Events = requireEvents();
	var TWEEN_CONST = require_const$a();

	var BaseTween = new Class({

	    Extends: EventEmitter,

	    initialize:

	    function BaseTween (parent)
	    {
	        EventEmitter.call(this);

	        this.parent = parent;

	        this.data = [];

	        this.totalData = 0;

	        this.startDelay = 0;

	        this.hasStarted = false;

	        this.timeScale = 1;

	        this.loop = 0;

	        this.loopDelay = 0;

	        this.loopCounter = 0;

	        this.completeDelay = 0;

	        this.countdown = 0;

	        this.state = TWEEN_CONST.PENDING;

	        this.paused = false;

	        this.callbacks = {
	            onActive: null,
	            onComplete: null,
	            onLoop: null,
	            onPause: null,
	            onRepeat: null,
	            onResume: null,
	            onStart: null,
	            onStop: null,
	            onUpdate: null,
	            onYoyo: null
	        };

	        this.callbackScope;

	        this.persist = false;
	    },

	    setTimeScale: function (value)
	    {
	        this.timeScale = value;

	        return this;
	    },

	    getTimeScale: function ()
	    {
	        return this.timeScale;
	    },

	    isPlaying: function ()
	    {
	        return (!this.paused && this.isActive());
	    },

	    isPaused: function ()
	    {
	        return this.paused;
	    },

	    pause: function ()
	    {
	        if (!this.paused)
	        {
	            this.paused = true;

	            this.dispatchEvent(Events.TWEEN_PAUSE, 'onPause');
	        }

	        return this;
	    },

	    resume: function ()
	    {
	        if (this.paused)
	        {
	            this.paused = false;

	            this.dispatchEvent(Events.TWEEN_RESUME, 'onResume');
	        }

	        return this;
	    },

	    makeActive: function ()
	    {
	        this.parent.makeActive(this);

	        this.dispatchEvent(Events.TWEEN_ACTIVE, 'onActive');
	    },

	    onCompleteHandler: function ()
	    {
	        this.setPendingRemoveState();

	        this.dispatchEvent(Events.TWEEN_COMPLETE, 'onComplete');
	    },

	    complete: function (delay)
	    {
	        if (delay === undefined) { delay = 0; }

	        if (delay)
	        {
	            this.setCompleteDelayState();

	            this.countdown = delay;
	        }
	        else
	        {
	            this.onCompleteHandler();
	        }

	        return this;
	    },

	    completeAfterLoop: function (loops)
	    {
	        if (loops === undefined) { loops = 0; }

	        if (this.loopCounter > loops)
	        {
	            this.loopCounter = loops;
	        }

	        return this;
	    },

	    remove: function ()
	    {
	        if (this.parent)
	        {
	            this.parent.remove(this);
	        }

	        return this;
	    },

	    stop: function ()
	    {
	        if (this.parent && !this.isRemoved() && !this.isPendingRemove() && !this.isDestroyed())
	        {
	            this.dispatchEvent(Events.TWEEN_STOP, 'onStop');

	            this.setPendingRemoveState();
	        }

	        return this;
	    },

	    updateLoopCountdown: function (delta)
	    {
	        this.countdown -= delta;

	        if (this.countdown <= 0)
	        {
	            this.setActiveState();

	            this.dispatchEvent(Events.TWEEN_LOOP, 'onLoop');
	        }
	    },

	    updateStartCountdown: function (delta)
	    {
	        this.countdown -= delta;

	        if (this.countdown <= 0)
	        {
	            this.hasStarted = true;

	            this.setActiveState();

	            this.dispatchEvent(Events.TWEEN_START, 'onStart');

	            delta = 0;
	        }

	        return delta;
	    },

	    updateCompleteDelay: function (delta)
	    {
	        this.countdown -= delta;

	        if (this.countdown <= 0)
	        {
	            this.onCompleteHandler();
	        }
	    },

	    setCallback: function (type, callback, params)
	    {
	        if (params === undefined) { params = []; }

	        if (this.callbacks.hasOwnProperty(type))
	        {
	            this.callbacks[type] = { func: callback, params: params };
	        }

	        return this;
	    },

	    setPendingState: function ()
	    {
	        this.state = TWEEN_CONST.PENDING;
	    },

	    setActiveState: function ()
	    {
	        this.state = TWEEN_CONST.ACTIVE;

	        this.hasStarted = false;
	    },

	    setLoopDelayState: function ()
	    {
	        this.state = TWEEN_CONST.LOOP_DELAY;
	    },

	    setCompleteDelayState: function ()
	    {
	        this.state = TWEEN_CONST.COMPLETE_DELAY;
	    },

	    setStartDelayState: function ()
	    {
	        this.state = TWEEN_CONST.START_DELAY;

	        this.countdown = this.startDelay;

	        this.hasStarted = false;
	    },

	    setPendingRemoveState: function ()
	    {
	        this.state = TWEEN_CONST.PENDING_REMOVE;
	    },

	    setRemovedState: function ()
	    {
	        this.state = TWEEN_CONST.REMOVED;
	    },

	    setFinishedState: function ()
	    {
	        this.state = TWEEN_CONST.FINISHED;
	    },

	    setDestroyedState: function ()
	    {
	        this.state = TWEEN_CONST.DESTROYED;
	    },

	    isPending: function ()
	    {
	        return (this.state === TWEEN_CONST.PENDING);
	    },

	    isActive: function ()
	    {
	        return (this.state === TWEEN_CONST.ACTIVE);
	    },

	    isLoopDelayed: function ()
	    {
	        return (this.state === TWEEN_CONST.LOOP_DELAY);
	    },

	    isCompleteDelayed: function ()
	    {
	        return (this.state === TWEEN_CONST.COMPLETE_DELAY);
	    },

	    isStartDelayed: function ()
	    {
	        return (this.state === TWEEN_CONST.START_DELAY);
	    },

	    isPendingRemove: function ()
	    {
	        return (this.state === TWEEN_CONST.PENDING_REMOVE);
	    },

	    isRemoved: function ()
	    {
	        return (this.state === TWEEN_CONST.REMOVED);
	    },

	    isFinished: function ()
	    {
	        return (this.state === TWEEN_CONST.FINISHED);
	    },

	    isDestroyed: function ()
	    {
	        return (this.state === TWEEN_CONST.DESTROYED);
	    },

	    destroy: function ()
	    {
	        if (this.data)
	        {
	            this.data.forEach(function (tweenData)
	            {
	                tweenData.destroy();
	            });
	        }

	        this.removeAllListeners();

	        this.callbacks = null;
	        this.data = null;
	        this.parent = null;

	        this.setDestroyedState();
	    }

	});

	BaseTween.TYPES = [
	    'onActive',
	    'onComplete',
	    'onLoop',
	    'onPause',
	    'onRepeat',
	    'onResume',
	    'onStart',
	    'onStop',
	    'onUpdate',
	    'onYoyo'
	];

	BaseTween_1 = BaseTween;
	return BaseTween_1;
}

var Defaults;
var hasRequiredDefaults;

function requireDefaults () {
	if (hasRequiredDefaults) return Defaults;
	hasRequiredDefaults = 1;
	var TWEEN_DEFAULTS = {
	    targets: null,
	    delay: 0,
	    duration: 1000,
	    ease: 'Power0',
	    easeParams: null,
	    hold: 0,
	    repeat: 0,
	    repeatDelay: 0,
	    yoyo: false,
	    flipX: false,
	    flipY: false,
	    persist: false,
	    interpolation: null
	};

	Defaults = TWEEN_DEFAULTS;
	return Defaults;
}

var BaseTweenData_1;
var hasRequiredBaseTweenData;

function requireBaseTweenData () {
	if (hasRequiredBaseTweenData) return BaseTweenData_1;
	hasRequiredBaseTweenData = 1;
	var Class = requireClass();
	var Events = requireEvents();
	var TWEEN_CONST = require_const$a();

	var BaseTweenData = new Class({

	    initialize:

	    function BaseTweenData (tween, targetIndex, delay, duration, yoyo, hold, repeat, repeatDelay, flipX, flipY)
	    {

	        this.tween = tween;

	        this.targetIndex = targetIndex;

	        this.duration = (duration <= 0) ? 0.01 : duration;

	        this.totalDuration = 0;

	        this.delay = 0;

	        this.getDelay = delay;

	        this.yoyo = yoyo;

	        this.hold = hold;

	        this.repeat = repeat;

	        this.repeatDelay = repeatDelay;

	        this.repeatCounter = 0;

	        this.flipX = flipX;

	        this.flipY = flipY;

	        this.progress = 0;

	        this.elapsed = 0;

	        this.state = 0;

	        this.isCountdown = false;
	    },

	    getTarget: function ()
	    {
	        return this.tween.targets[this.targetIndex];
	    },

	    setTargetValue: function (value)
	    {
	        if (value === undefined) { value = this.current; }

	        this.tween.targets[this.targetIndex][this.key] = value;
	    },

	    setCreatedState: function ()
	    {
	        this.state = TWEEN_CONST.CREATED;
	        this.isCountdown = false;
	    },

	    setDelayState: function ()
	    {
	        this.state = TWEEN_CONST.DELAY;
	        this.isCountdown = true;
	    },

	    setPendingRenderState: function ()
	    {
	        this.state = TWEEN_CONST.PENDING_RENDER;
	        this.isCountdown = false;
	    },

	    setPlayingForwardState: function ()
	    {
	        this.state = TWEEN_CONST.PLAYING_FORWARD;
	        this.isCountdown = false;
	    },

	    setPlayingBackwardState: function ()
	    {
	        this.state = TWEEN_CONST.PLAYING_BACKWARD;
	        this.isCountdown = false;
	    },

	    setHoldState: function ()
	    {
	        this.state = TWEEN_CONST.HOLD_DELAY;
	        this.isCountdown = true;
	    },

	    setRepeatState: function ()
	    {
	        this.state = TWEEN_CONST.REPEAT_DELAY;
	        this.isCountdown = true;
	    },

	    setCompleteState: function ()
	    {
	        this.state = TWEEN_CONST.COMPLETE;
	        this.isCountdown = false;
	    },

	    isCreated: function ()
	    {
	        return (this.state === TWEEN_CONST.CREATED);
	    },

	    isDelayed: function ()
	    {
	        return (this.state === TWEEN_CONST.DELAY);
	    },

	    isPendingRender: function ()
	    {
	        return (this.state === TWEEN_CONST.PENDING_RENDER);
	    },

	    isPlayingForward: function ()
	    {
	        return (this.state === TWEEN_CONST.PLAYING_FORWARD);
	    },

	    isPlayingBackward: function ()
	    {
	        return (this.state === TWEEN_CONST.PLAYING_BACKWARD);
	    },

	    isHolding: function ()
	    {
	        return (this.state === TWEEN_CONST.HOLD_DELAY);
	    },

	    isRepeating: function ()
	    {
	        return (this.state === TWEEN_CONST.REPEAT_DELAY);
	    },

	    isComplete: function ()
	    {
	        return (this.state === TWEEN_CONST.COMPLETE);
	    },

	    setStateFromEnd: function (diff)
	    {
	        if (this.yoyo)
	        {
	            this.onRepeat(diff, true, true);
	        }
	        else if (this.repeatCounter > 0)
	        {
	            this.onRepeat(diff, true, false);
	        }
	        else
	        {
	            this.setCompleteState();
	        }
	    },

	    setStateFromStart: function (diff)
	    {
	        if (this.repeatCounter > 0)
	        {
	            this.onRepeat(diff, false);
	        }
	        else
	        {
	            this.setCompleteState();
	        }
	    },

	    reset: function ()
	    {
	        var tween = this.tween;
	        var totalTargets = tween.totalTargets;

	        var targetIndex = this.targetIndex;
	        var target = tween.targets[targetIndex];
	        var key = this.key;

	        this.progress = 0;
	        this.elapsed = 0;

	        this.delay = this.getDelay(target, key, 0, targetIndex, totalTargets, tween);

	        this.repeatCounter = (this.repeat === -1) ? TWEEN_CONST.MAX : this.repeat;

	        this.setPendingRenderState();

	        var t1 = this.duration + this.hold;

	        if (this.yoyo)
	        {
	            t1 += this.duration;
	        }

	        var t2 = t1 + this.repeatDelay;

	        this.totalDuration = this.delay + t1;

	        if (this.repeat === -1)
	        {
	            this.totalDuration += (t2 * TWEEN_CONST.MAX);
	            tween.isInfinite = true;
	        }
	        else if (this.repeat > 0)
	        {
	            this.totalDuration += (t2 * this.repeat);
	        }

	        if (this.totalDuration > tween.duration)
	        {

	            tween.duration = this.totalDuration;
	        }

	        if (this.delay < tween.startDelay)
	        {
	            tween.startDelay = this.delay;
	        }

	        if (this.delay > 0)
	        {
	            this.elapsed = this.delay;

	            this.setDelayState();
	        }
	    },

	    onRepeat: function (diff, setStart, isYoyo)
	    {
	        var tween = this.tween;
	        var totalTargets = tween.totalTargets;

	        var targetIndex = this.targetIndex;
	        var target = tween.targets[targetIndex];
	        var key = this.key;

	        var isTweenData = (key !== 'texture');

	        this.elapsed = diff;
	        this.progress = diff / this.duration;

	        if (this.flipX)
	        {
	            target.toggleFlipX();
	        }

	        if (this.flipY)
	        {
	            target.toggleFlipY();
	        }

	        if (isTweenData && (setStart || isYoyo))
	        {
	            this.start = this.getStartValue(target, key, this.start, targetIndex, totalTargets, tween);
	        }

	        if (isYoyo)
	        {
	            this.setPlayingBackwardState();

	            this.dispatchEvent(Events.TWEEN_YOYO, 'onYoyo');

	            return;
	        }

	        this.repeatCounter--;

	        if (isTweenData)
	        {
	            this.end = this.getEndValue(target, key, this.start, targetIndex, totalTargets, tween);
	        }

	        if (this.repeatDelay > 0)
	        {
	            this.elapsed = this.repeatDelay - diff;

	            if (isTweenData)
	            {
	                this.current = this.start;

	                target[key] = this.current;
	            }

	            this.setRepeatState();
	        }
	        else
	        {
	            this.setPlayingForwardState();

	            this.dispatchEvent(Events.TWEEN_REPEAT, 'onRepeat');
	        }
	    },

	    destroy: function ()
	    {
	        this.tween = null;
	        this.getDelay = null;
	        this.setCompleteState();
	    }

	});

	BaseTweenData_1 = BaseTweenData;
	return BaseTweenData_1;
}

var TweenData_1;
var hasRequiredTweenData;

function requireTweenData () {
	if (hasRequiredTweenData) return TweenData_1;
	hasRequiredTweenData = 1;
	var BaseTweenData = requireBaseTweenData();
	var Clamp = requireClamp();
	var Class = requireClass();
	var Events = requireEvents();

	var TweenData = new Class({

	    Extends: BaseTweenData,

	    initialize:

	    function TweenData (tween, targetIndex, key, getEnd, getStart, getActive, ease, delay, duration, yoyo, hold, repeat, repeatDelay, flipX, flipY, interpolation, interpolationData)
	    {
	        BaseTweenData.call(this, tween, targetIndex, delay, duration, yoyo, hold, repeat, repeatDelay, flipX, flipY);

	        this.key = key;

	        this.getActiveValue = getActive;

	        this.getEndValue = getEnd;

	        this.getStartValue = getStart;

	        this.ease = ease;

	        this.start = 0;

	        this.previous = 0;

	        this.current = 0;

	        this.end = 0;

	        this.interpolation = interpolation;

	        this.interpolationData = interpolationData;
	    },

	    reset: function (isSeeking)
	    {
	        BaseTweenData.prototype.reset.call(this);

	        var target = this.tween.targets[this.targetIndex];
	        var key = this.key;

	        if (isSeeking)
	        {
	            target[key] = this.start;
	        }

	        this.start = 0;
	        this.previous = 0;
	        this.current = 0;
	        this.end = 0;

	        if (this.getActiveValue)
	        {
	            target[key] = this.getActiveValue(target, key, 0);
	        }
	    },

	    update: function (delta)
	    {
	        var tween = this.tween;
	        var totalTargets = tween.totalTargets;

	        var targetIndex = this.targetIndex;
	        var target = tween.targets[targetIndex];
	        var key = this.key;

	        if (!target)
	        {
	            this.setCompleteState();

	            return false;
	        }

	        if (this.isCountdown)
	        {
	            this.elapsed -= delta;

	            if (this.elapsed <= 0)
	            {
	                this.elapsed = 0;

	                delta = 0;

	                if (this.isDelayed())
	                {
	                    this.setPendingRenderState();
	                }
	                else if (this.isRepeating())
	                {
	                    this.setPlayingForwardState();

	                    this.dispatchEvent(Events.TWEEN_REPEAT, 'onRepeat');
	                }
	                else if (this.isHolding())
	                {
	                    this.setStateFromEnd(0);
	                }
	            }
	        }

	        if (this.isPendingRender())
	        {
	            this.start = this.getStartValue(target, key, target[key], targetIndex, totalTargets, tween);

	            this.end = this.getEndValue(target, key, this.start, targetIndex, totalTargets, tween);

	            this.current = this.start;

	            target[key] = this.start;

	            this.setPlayingForwardState();

	            return true;
	        }

	        var forward = this.isPlayingForward();
	        var backward = this.isPlayingBackward();

	        if (forward || backward)
	        {
	            var elapsed = this.elapsed;
	            var duration = this.duration;
	            var diff = 0;
	            var complete = false;

	            elapsed += delta;

	            if (elapsed >= duration)
	            {
	                diff = elapsed - duration;
	                elapsed = duration;
	                complete = true;
	            }
	            else if (elapsed < 0)
	            {
	                elapsed = 0;
	            }

	            var progress = Clamp(elapsed / duration, 0, 1);

	            this.elapsed = elapsed;
	            this.progress = progress;
	            this.previous = this.current;

	            if (!forward)
	            {
	                progress = 1 - progress;
	            }

	            var v = this.ease(progress);

	            if (this.interpolation)
	            {
	                this.current = this.interpolation(this.interpolationData, v);
	            }
	            else
	            {
	                this.current = this.start + ((this.end - this.start) * v);
	            }

	            target[key] = this.current;

	            if (complete)
	            {
	                if (forward)
	                {
	                    if (tween.isNumberTween)
	                    {
	                        this.current = this.end;
	                        target[key] = this.current;
	                    }

	                    if (this.hold > 0)
	                    {
	                        this.elapsed = this.hold;

	                        this.setHoldState();
	                    }
	                    else
	                    {
	                        this.setStateFromEnd(diff);
	                    }
	                }
	                else
	                {
	                    if (tween.isNumberTween)
	                    {
	                        this.current = this.start;
	                        target[key] = this.current;
	                    }

	                    this.setStateFromStart(diff);
	                }
	            }

	            this.dispatchEvent(Events.TWEEN_UPDATE, 'onUpdate');
	        }

	        return !this.isComplete();
	    },

	    dispatchEvent: function (event, callback)
	    {
	        var tween = this.tween;

	        if (!tween.isSeeking)
	        {
	            var target = tween.targets[this.targetIndex];
	            var key = this.key;

	            var current = this.current;
	            var previous = this.previous;

	            tween.emit(event, tween, key, target, current, previous);

	            var handler = tween.callbacks[callback];

	            if (handler)
	            {
	                handler.func.apply(tween.callbackScope, [ tween, target, key, current, previous ].concat(handler.params));
	            }
	        }
	    },

	    destroy: function ()
	    {
	        BaseTweenData.prototype.destroy.call(this);

	        this.getActiveValue = null;
	        this.getEndValue = null;
	        this.getStartValue = null;
	        this.ease = null;
	    }

	});

	TweenData_1 = TweenData;
	return TweenData_1;
}

var TweenFrameData_1;
var hasRequiredTweenFrameData;

function requireTweenFrameData () {
	if (hasRequiredTweenFrameData) return TweenFrameData_1;
	hasRequiredTweenFrameData = 1;
	var BaseTweenData = requireBaseTweenData();
	var Clamp = requireClamp();
	var Class = requireClass();
	var Events = requireEvents();

	var TweenFrameData = new Class({

	    Extends: BaseTweenData,

	    initialize:

	    function TweenFrameData (tween, targetIndex, texture, frame, delay, duration, hold, repeat, repeatDelay, flipX, flipY)
	    {
	        BaseTweenData.call(this, tween, targetIndex, delay, duration, false, hold, repeat, repeatDelay, flipX, flipY);

	        this.key = 'texture';

	        this.startTexture = null;

	        this.endTexture = texture;

	        this.startFrame = null;

	        this.endFrame = frame;

	        this.yoyo = (repeat !== 0) ? true : false;
	    },

	    reset: function (isSeeking)
	    {
	        BaseTweenData.prototype.reset.call(this);

	        var target = this.tween.targets[this.targetIndex];

	        if (!this.startTexture)
	        {
	            this.startTexture = target.texture.key;
	            this.startFrame = target.frame.name;
	        }

	        if (isSeeking)
	        {
	            target.setTexture(this.startTexture, this.startFrame);
	        }
	    },

	    update: function (delta)
	    {
	        var tween = this.tween;
	        var targetIndex = this.targetIndex;
	        var target = tween.targets[targetIndex];

	        if (!target)
	        {
	            this.setCompleteState();

	            return false;
	        }

	        if (this.isCountdown)
	        {
	            this.elapsed -= delta;

	            if (this.elapsed <= 0)
	            {
	                this.elapsed = 0;

	                delta = 0;

	                if (this.isDelayed())
	                {
	                    this.setPendingRenderState();
	                }
	                else if (this.isRepeating())
	                {
	                    this.setPlayingForwardState();

	                    this.dispatchEvent(Events.TWEEN_REPEAT, 'onRepeat');
	                }
	                else if (this.isHolding())
	                {
	                    this.setStateFromEnd(0);
	                }
	            }
	        }

	        if (this.isPendingRender())
	        {
	            if (this.startTexture)
	            {
	                target.setTexture(this.startTexture, this.startFrame);
	            }

	            this.setPlayingForwardState();

	            return true;
	        }

	        var forward = this.isPlayingForward();
	        var backward = this.isPlayingBackward();

	        if (forward || backward)
	        {
	            var elapsed = this.elapsed;
	            var duration = this.duration;
	            var diff = 0;
	            var complete = false;

	            elapsed += delta;

	            if (elapsed >= duration)
	            {
	                diff = elapsed - duration;
	                elapsed = duration;
	                complete = true;
	            }
	            else if (elapsed < 0)
	            {
	                elapsed = 0;
	            }

	            var progress = Clamp(elapsed / duration, 0, 1);

	            this.elapsed = elapsed;
	            this.progress = progress;

	            if (complete)
	            {
	                if (forward)
	                {
	                    target.setTexture(this.endTexture, this.endFrame);

	                    if (this.hold > 0)
	                    {
	                        this.elapsed = this.hold;

	                        this.setHoldState();
	                    }
	                    else
	                    {
	                        this.setStateFromEnd(diff);
	                    }
	                }
	                else
	                {
	                    target.setTexture(this.startTexture, this.startFrame);

	                    this.setStateFromStart(diff);
	                }
	            }

	            this.dispatchEvent(Events.TWEEN_UPDATE, 'onUpdate');
	        }

	        return !this.isComplete();
	    },

	    dispatchEvent: function (event, callback)
	    {
	        var tween = this.tween;

	        if (!tween.isSeeking)
	        {
	            var target = tween.targets[this.targetIndex];
	            var key = this.key;

	            tween.emit(event, tween, key, target);

	            var handler = tween.callbacks[callback];

	            if (handler)
	            {
	                handler.func.apply(tween.callbackScope, [ tween, target, key ].concat(handler.params));
	            }
	        }
	    },

	    destroy: function ()
	    {
	        BaseTweenData.prototype.destroy.call(this);

	        this.startTexture = null;
	        this.endTexture = null;
	        this.startFrame = null;
	        this.endFrame = null;
	    }

	});

	TweenFrameData_1 = TweenFrameData;
	return TweenFrameData_1;
}

var Tween_1;
var hasRequiredTween;

function requireTween () {
	if (hasRequiredTween) return Tween_1;
	hasRequiredTween = 1;
	var BaseTween = requireBaseTween();
	var Class = requireClass();
	var Events = requireEvents();
	var GameObjectCreator = requireGameObjectCreator();
	var GameObjectFactory = requireGameObjectFactory();
	var MATH_CONST = require_const$c();
	var TWEEN_CONST = require_const$a();
	var TweenData = requireTweenData();
	var TweenFrameData = requireTweenFrameData();

	var Tween = new Class({

	    Extends: BaseTween,

	    initialize:

	    function Tween (parent, targets)
	    {
	        BaseTween.call(this, parent);

	        this.targets = targets;

	        this.totalTargets = targets.length;

	        this.isSeeking = false;

	        this.isInfinite = false;

	        this.elapsed = 0;

	        this.totalElapsed = 0;

	        this.duration = 0;

	        this.progress = 0;

	        this.totalDuration = 0;

	        this.totalProgress = 0;

	        this.isNumberTween = false;
	    },

	    add: function (targetIndex, key, getEnd, getStart, getActive, ease, delay, duration, yoyo, hold, repeat, repeatDelay, flipX, flipY, interpolation, interpolationData)
	    {
	        var tweenData = new TweenData(this, targetIndex, key, getEnd, getStart, getActive, ease, delay, duration, yoyo, hold, repeat, repeatDelay, flipX, flipY, interpolation, interpolationData);

	        this.totalData = this.data.push(tweenData);

	        return tweenData;
	    },

	    addFrame: function (targetIndex, texture, frame, delay, duration, hold, repeat, repeatDelay, flipX, flipY)
	    {
	        var tweenData = new TweenFrameData(this, targetIndex, texture, frame, delay, duration, hold, repeat, repeatDelay, flipX, flipY);

	        this.totalData = this.data.push(tweenData);

	        return tweenData;
	    },

	    getValue: function (index)
	    {
	        if (index === undefined) { index = 0; }

	        var value = null;

	        if (this.data)
	        {
	            value = this.data[index].current;
	        }

	        return value;
	    },

	    hasTarget: function (target)
	    {
	        return (this.targets && this.targets.indexOf(target) !== -1);
	    },

	    updateTo: function (key, value, startToCurrent)
	    {
	        if (startToCurrent === undefined) { startToCurrent = false; }

	        if (key !== 'texture')
	        {
	            for (var i = 0; i < this.totalData; i++)
	            {
	                var tweenData = this.data[i];

	                if (tweenData.key === key && (tweenData.isPlayingForward() || tweenData.isPlayingBackward()))
	                {
	                    tweenData.end = value;

	                    if (startToCurrent)
	                    {
	                        tweenData.start = tweenData.current;
	                    }
	                }
	            }
	        }

	        return this;
	    },

	    restart: function ()
	    {
	        switch (this.state)
	        {
	            case TWEEN_CONST.REMOVED:
	            case TWEEN_CONST.FINISHED:
	                this.seek();
	                this.parent.makeActive(this);
	                break;

	            case TWEEN_CONST.PENDING:
	            case TWEEN_CONST.PENDING_REMOVE:
	                this.parent.reset(this);
	                break;

	            case TWEEN_CONST.DESTROYED:
	                console.warn('Cannot restart destroyed Tween', this);
	                break;

	            default:
	                this.seek();
	                break;
	        }

	        this.paused = false;
	        this.hasStarted = false;

	        return this;
	    },

	    nextState: function ()
	    {
	        if (this.loopCounter > 0)
	        {
	            this.elapsed = 0;
	            this.progress = 0;
	            this.loopCounter--;

	            this.initTweenData(true);

	            if (this.loopDelay > 0)
	            {
	                this.countdown = this.loopDelay;

	                this.setLoopDelayState();
	            }
	            else
	            {
	                this.setActiveState();

	                this.dispatchEvent(Events.TWEEN_LOOP, 'onLoop');
	            }
	        }
	        else if (this.completeDelay > 0)
	        {
	            this.countdown = this.completeDelay;

	            this.setCompleteDelayState();
	        }
	        else
	        {
	            this.onCompleteHandler();

	            return true;
	        }

	        return false;
	    },

	    onCompleteHandler: function ()
	    {
	        this.progress = 1;
	        this.totalProgress = 1;

	        BaseTween.prototype.onCompleteHandler.call(this);
	    },

	    play: function ()
	    {
	        if (this.isDestroyed())
	        {
	            console.warn('Cannot play destroyed Tween', this);

	            return this;
	        }

	        if (this.isPendingRemove() || this.isFinished())
	        {
	            this.seek();
	        }

	        this.paused = false;

	        this.setActiveState();

	        return this;
	    },

	    seek: function (amount, delta, emit)
	    {
	        if (amount === undefined) { amount = 0; }
	        if (delta === undefined) { delta = 16.6; }
	        if (emit === undefined) { emit = false; }

	        if (this.isDestroyed())
	        {
	            console.warn('Cannot seek destroyed Tween', this);

	            return this;
	        }

	        if (!emit)
	        {
	            this.isSeeking = true;
	        }

	        this.reset(true);

	        this.initTweenData(true);

	        this.setActiveState();

	        this.dispatchEvent(Events.TWEEN_ACTIVE, 'onActive');

	        var isPaused = this.paused;

	        this.paused = false;

	        if (amount > 0)
	        {
	            var iterations = Math.floor(amount / delta);
	            var remainder = amount - (iterations * delta);

	            for (var i = 0; i < iterations; i++)
	            {
	                this.update(delta);
	            }

	            if (remainder > 0)
	            {
	                this.update(remainder);
	            }
	        }

	        this.paused = isPaused;

	        this.isSeeking = false;

	        return this;
	    },

	    initTweenData: function (isSeeking)
	    {
	        if (isSeeking === undefined) { isSeeking = false; }

	        this.duration = 0;
	        this.startDelay = MATH_CONST.MAX_SAFE_INTEGER;

	        var data = this.data;

	        for (var i = 0; i < this.totalData; i++)
	        {
	            data[i].reset(isSeeking);
	        }

	        this.duration = Math.max(this.duration, 0.01);

	        var duration = this.duration;
	        var completeDelay = this.completeDelay;
	        var loopCounter = this.loopCounter;
	        var loopDelay = this.loopDelay;

	        if (loopCounter > 0)
	        {
	            this.totalDuration = duration + completeDelay + ((duration + loopDelay) * loopCounter);
	        }
	        else
	        {
	            this.totalDuration = duration + completeDelay;
	        }
	    },

	    reset: function (skipInit)
	    {
	        if (skipInit === undefined) { skipInit = false; }

	        this.elapsed = 0;
	        this.totalElapsed = 0;
	        this.progress = 0;
	        this.totalProgress = 0;
	        this.loopCounter = this.loop;

	        if (this.loop === -1)
	        {
	            this.isInfinite = true;
	            this.loopCounter = TWEEN_CONST.MAX;
	        }

	        if (!skipInit)
	        {
	            this.initTweenData();

	            this.setActiveState();

	            this.dispatchEvent(Events.TWEEN_ACTIVE, 'onActive');
	        }

	        return this;
	    },

	    update: function (delta)
	    {
	        if (this.isPendingRemove() || this.isDestroyed())
	        {
	            if (this.persist)
	            {
	                this.setFinishedState();

	                return false;
	            }

	            return true;
	        }
	        else if (this.paused || this.isFinished())
	        {
	            return false;
	        }

	        delta *= this.timeScale * this.parent.timeScale;

	        if (this.isLoopDelayed())
	        {
	            this.updateLoopCountdown(delta);

	            return false;
	        }
	        else if (this.isCompleteDelayed())
	        {
	            this.updateCompleteDelay(delta);

	            return false;
	        }
	        else if (!this.hasStarted)
	        {
	            this.startDelay -= delta;

	            if (this.startDelay <= 0)
	            {
	                this.hasStarted = true;

	                this.dispatchEvent(Events.TWEEN_START, 'onStart');

	                delta = 0;
	            }
	        }

	        var stillRunning = false;

	        if (this.isActive())
	        {
	            var data = this.data;

	            for (var i = 0; i < this.totalData; i++)
	            {
	                if (data[i].update(delta))
	                {
	                    stillRunning = true;
	                }
	            }
	        }

	        this.elapsed += delta;
	        this.progress = Math.min(this.elapsed / this.duration, 1);

	        this.totalElapsed += delta;
	        this.totalProgress = Math.min(this.totalElapsed / this.totalDuration, 1);

	        if (!stillRunning)
	        {

	            this.nextState();
	        }

	        var remove = this.isPendingRemove();

	        if (remove && this.persist)
	        {
	            this.setFinishedState();

	            remove = false;
	        }

	        return remove;
	    },

	    forward: function (ms)
	    {
	        this.update(ms);

	        return this;
	    },

	    rewind: function (ms)
	    {
	        this.update(-ms);

	        return this;
	    },

	    dispatchEvent: function (event, callback)
	    {
	        if (!this.isSeeking)
	        {
	            this.emit(event, this, this.targets);

	            if (!this.callbacks)
	            {
	                return;
	            }

	            var handler = this.callbacks[callback];

	            if (handler)
	            {
	                handler.func.apply(this.callbackScope, [ this, this.targets ].concat(handler.params));
	            }
	        }
	    },

	    destroy: function ()
	    {
	        BaseTween.prototype.destroy.call(this);

	        this.targets = null;
	    }

	});

	GameObjectFactory.register('tween', function (config)
	{
	    return this.scene.sys.tweens.add(config);
	});

	GameObjectCreator.register('tween', function (config)
	{
	    return this.scene.sys.tweens.create(config);
	});

	Tween_1 = Tween;
	return Tween_1;
}

var NumberTweenBuilder_1;
var hasRequiredNumberTweenBuilder;

function requireNumberTweenBuilder () {
	if (hasRequiredNumberTweenBuilder) return NumberTweenBuilder_1;
	hasRequiredNumberTweenBuilder = 1;
	var BaseTween = requireBaseTween();
	var Defaults = requireDefaults();
	var GetAdvancedValue = requireGetAdvancedValue();
	var GetBoolean = requireGetBoolean();
	var GetEaseFunction = requireGetEaseFunction();
	var GetFastValue = requireGetFastValue();
	var GetNewValue = requireGetNewValue();
	var GetValue = requireGetValue();
	var GetValueOp = requireGetValueOp();
	var MergeRight = requireMergeRight();
	var Tween = requireTween();

	var NumberTweenBuilder = function (parent, config, defaults)
	{
	    if (config instanceof Tween)
	    {
	        config.parent = parent;

	        return config;
	    }

	    if (defaults === undefined)
	    {
	        defaults = Defaults;
	    }
	    else
	    {
	        defaults = MergeRight(Defaults, defaults);
	    }

	    var from = GetFastValue(config, 'from', 0);
	    var to = GetFastValue(config, 'to', 1);

	    var targets = [ { value: from } ];

	    var delay = GetFastValue(config, 'delay', defaults.delay);
	    var easeParams = GetFastValue(config, 'easeParams', defaults.easeParams);
	    var ease = GetFastValue(config, 'ease', defaults.ease);

	    var ops = GetValueOp('value', to);

	    var tween = new Tween(parent, targets);

	    var tweenData = tween.add(
	        0,
	        'value',
	        ops.getEnd,
	        ops.getStart,
	        ops.getActive,
	        GetEaseFunction(GetFastValue(config, 'ease', ease), GetFastValue(config, 'easeParams', easeParams)),
	        GetNewValue(config, 'delay', delay),
	        GetFastValue(config, 'duration', defaults.duration),
	        GetBoolean(config, 'yoyo', defaults.yoyo),
	        GetFastValue(config, 'hold', defaults.hold),
	        GetFastValue(config, 'repeat', defaults.repeat),
	        GetFastValue(config, 'repeatDelay', defaults.repeatDelay),
	        false,
	        false
	    );

	    tweenData.start = from;
	    tweenData.current = from;

	    tween.completeDelay = GetAdvancedValue(config, 'completeDelay', 0);
	    tween.loop = Math.round(GetAdvancedValue(config, 'loop', 0));
	    tween.loopDelay = Math.round(GetAdvancedValue(config, 'loopDelay', 0));
	    tween.paused = GetBoolean(config, 'paused', false);
	    tween.persist = GetBoolean(config, 'persist', false);
	    tween.isNumberTween = true;

	    tween.callbackScope = GetValue(config, 'callbackScope', tween);

	    var callbacks = BaseTween.TYPES;

	    for (var i = 0; i < callbacks.length; i++)
	    {
	        var type = callbacks[i];

	        var callback = GetValue(config, type, false);

	        if (callback)
	        {
	            var callbackParams = GetValue(config, type + 'Params', []);

	            tween.setCallback(type, callback, callbackParams);
	        }
	    }

	    return tween;
	};

	NumberTweenBuilder_1 = NumberTweenBuilder;
	return NumberTweenBuilder_1;
}

var StaggerBuilder_1;
var hasRequiredStaggerBuilder;

function requireStaggerBuilder () {
	if (hasRequiredStaggerBuilder) return StaggerBuilder_1;
	hasRequiredStaggerBuilder = 1;
	var GetEaseFunction = requireGetEaseFunction();
	var GetValue = requireGetValue();
	var MATH_CONST = require_const$c();

	var StaggerBuilder = function (value, options)
	{
	    if (options === undefined) { options = {}; }

	    var result;

	    var start = GetValue(options, 'start', 0);
	    var ease = GetValue(options, 'ease', null);
	    var grid = GetValue(options, 'grid', null);

	    var from = GetValue(options, 'from', 0);

	    var fromFirst = (from === 'first');
	    var fromCenter = (from === 'center');
	    var fromLast = (from === 'last');
	    var fromValue = (typeof(from) === 'number');

	    var isRange = (Array.isArray(value));
	    var value1 = (isRange) ? parseFloat(value[0]) : parseFloat(value);
	    var value2 = (isRange) ? parseFloat(value[1]) : 0;
	    var maxValue = Math.max(value1, value2);

	    if (isRange)
	    {
	        start += value1;
	    }

	    if (grid)
	    {

	        var gridWidth = grid[0];
	        var gridHeight = grid[1];

	        var fromX = 0;
	        var fromY = 0;

	        var distanceX = 0;
	        var distanceY = 0;

	        var gridValues = [];

	        if (fromLast)
	        {
	            fromX = gridWidth - 1;
	            fromY = gridHeight - 1;
	        }
	        else if (fromValue)
	        {
	            fromX = from % gridWidth;
	            fromY = Math.floor(from / gridWidth);
	        }
	        else if (fromCenter)
	        {
	            fromX = (gridWidth - 1) / 2;
	            fromY = (gridHeight - 1) / 2;
	        }

	        var gridMax = MATH_CONST.MIN_SAFE_INTEGER;

	        for (var toY = 0; toY < gridHeight; toY++)
	        {
	            gridValues[toY] = [];

	            for (var toX = 0; toX < gridWidth; toX++)
	            {
	                distanceX = fromX - toX;
	                distanceY = fromY - toY;

	                var dist = Math.sqrt(distanceX * distanceX + distanceY * distanceY);

	                if (dist > gridMax)
	                {
	                    gridMax = dist;
	                }

	                gridValues[toY][toX] = dist;
	            }
	        }
	    }

	    var easeFunction = (ease) ? GetEaseFunction(ease) : null;

	    if (grid)
	    {
	        result = function (target, key, value, index)
	        {
	            var gridSpace = 0;
	            var toX = index % gridWidth;
	            var toY = Math.floor(index / gridWidth);

	            if (toX >= 0 && toX < gridWidth && toY >= 0 && toY < gridHeight)
	            {
	                gridSpace = gridValues[toY][toX];
	            }

	            var output;

	            if (isRange)
	            {
	                var diff = (value2 - value1);

	                if (easeFunction)
	                {
	                    output = ((gridSpace / gridMax) * diff) * easeFunction(gridSpace / gridMax);
	                }
	                else
	                {
	                    output = (gridSpace / gridMax) * diff;
	                }
	            }
	            else if (easeFunction)
	            {
	                output = (gridSpace * value1) * easeFunction(gridSpace / gridMax);
	            }
	            else
	            {
	                output = gridSpace * value1;
	            }

	            return output + start;
	        };
	    }
	    else
	    {
	        result = function (target, key, value, index, total)
	        {

	            total--;

	            var fromIndex;

	            if (fromFirst)
	            {
	                fromIndex = index;
	            }
	            else if (fromCenter)
	            {
	                fromIndex = Math.abs((total / 2) - index);
	            }
	            else if (fromLast)
	            {
	                fromIndex = total - index;
	            }
	            else if (fromValue)
	            {
	                fromIndex = Math.abs(from - index);
	            }

	            var output;

	            if (isRange)
	            {
	                var spacing;

	                if (fromCenter)
	                {
	                    spacing = ((value2 - value1) / total) * (fromIndex * 2);
	                }
	                else
	                {
	                    spacing = ((value2 - value1) / total) * fromIndex;
	                }

	                if (easeFunction)
	                {
	                    output = spacing * easeFunction(fromIndex / total);
	                }
	                else
	                {
	                    output = spacing;
	                }
	            }
	            else if (easeFunction)
	            {
	                output = (total * maxValue) * easeFunction(fromIndex / total);
	            }
	            else
	            {
	                output = fromIndex * value1;
	            }

	            return output + start;
	        };
	    }

	    return result;
	};

	StaggerBuilder_1 = StaggerBuilder;
	return StaggerBuilder_1;
}

var TweenBuilder_1;
var hasRequiredTweenBuilder;

function requireTweenBuilder () {
	if (hasRequiredTweenBuilder) return TweenBuilder_1;
	hasRequiredTweenBuilder = 1;
	var BaseTween = requireBaseTween();
	var Defaults = requireDefaults();
	var GetAdvancedValue = requireGetAdvancedValue();
	var GetBoolean = requireGetBoolean();
	var GetEaseFunction = requireGetEaseFunction();
	var GetFastValue = requireGetFastValue();
	var GetInterpolationFunction = requireGetInterpolationFunction();
	var GetNewValue = requireGetNewValue();
	var GetProps = requireGetProps();
	var GetTargets = requireGetTargets();
	var GetValue = requireGetValue();
	var GetValueOp = requireGetValueOp();
	var MergeRight = requireMergeRight();
	var Tween = requireTween();

	var TweenBuilder = function (parent, config, defaults)
	{
	    if (config instanceof Tween)
	    {
	        config.parent = parent;

	        return config;
	    }

	    if (defaults === undefined)
	    {
	        defaults = Defaults;
	    }
	    else
	    {
	        defaults = MergeRight(Defaults, defaults);
	    }

	    var targets = GetTargets(config);

	    if (!targets && defaults.targets)
	    {
	        targets = defaults.targets;
	    }

	    var props = GetProps(config);

	    var delay = GetFastValue(config, 'delay', defaults.delay);
	    var duration = GetFastValue(config, 'duration', defaults.duration);
	    var easeParams = GetFastValue(config, 'easeParams', defaults.easeParams);
	    var ease = GetFastValue(config, 'ease', defaults.ease);
	    var hold = GetFastValue(config, 'hold', defaults.hold);
	    var repeat = GetFastValue(config, 'repeat', defaults.repeat);
	    var repeatDelay = GetFastValue(config, 'repeatDelay', defaults.repeatDelay);
	    var yoyo = GetBoolean(config, 'yoyo', defaults.yoyo);
	    var flipX = GetBoolean(config, 'flipX', defaults.flipX);
	    var flipY = GetBoolean(config, 'flipY', defaults.flipY);
	    var interpolation = GetFastValue(config, 'interpolation', defaults.interpolation);

	    var addTarget = function (tween, targetIndex, key, value)
	    {
	        if (key === 'texture')
	        {
	            var texture = value;
	            var frame = undefined;

	            if (Array.isArray(value))
	            {
	                texture = value[0];
	                frame = value[1];
	            }
	            else if (value.hasOwnProperty('value'))
	            {
	                texture = value.value;

	                if (Array.isArray(value.value))
	                {
	                    texture = value.value[0];
	                    frame = value.value[1];
	                }
	                else if (typeof value.value === 'string')
	                {
	                    texture = value.value;
	                }
	            }
	            else if (typeof value === 'string')
	            {
	                texture = value;
	            }

	            tween.addFrame(
	                targetIndex,
	                texture,
	                frame,
	                GetNewValue(value, 'delay', delay),
	                GetFastValue(value, 'duration', duration),
	                GetFastValue(value, 'hold', hold),
	                GetFastValue(value, 'repeat', repeat),
	                GetFastValue(value, 'repeatDelay', repeatDelay),
	                GetBoolean(value, 'flipX', flipX),
	                GetBoolean(value, 'flipY', flipY)
	            );
	        }
	        else
	        {
	            var ops = GetValueOp(key, value);

	            var interpolationFunc = GetInterpolationFunction(GetFastValue(value, 'interpolation', interpolation));

	            tween.add(
	                targetIndex,
	                key,
	                ops.getEnd,
	                ops.getStart,
	                ops.getActive,
	                GetEaseFunction(GetFastValue(value, 'ease', ease), GetFastValue(value, 'easeParams', easeParams)),
	                GetNewValue(value, 'delay', delay),
	                GetFastValue(value, 'duration', duration),
	                GetBoolean(value, 'yoyo', yoyo),
	                GetFastValue(value, 'hold', hold),
	                GetFastValue(value, 'repeat', repeat),
	                GetFastValue(value, 'repeatDelay', repeatDelay),
	                GetBoolean(value, 'flipX', flipX),
	                GetBoolean(value, 'flipY', flipY),
	                interpolationFunc,
	                (interpolationFunc) ? value : null
	            );
	        }
	    };

	    var tween = new Tween(parent, targets);

	    for (var p = 0; p < props.length; p++)
	    {
	        var key = props[p].key;
	        var value = props[p].value;

	        for (var targetIndex = 0; targetIndex < targets.length; targetIndex++)
	        {

	            if (key === 'scale' && !targets[targetIndex].hasOwnProperty('scale'))
	            {
	                addTarget(tween, targetIndex, 'scaleX', value);
	                addTarget(tween, targetIndex, 'scaleY', value);
	            }
	            else
	            {
	                addTarget(tween, targetIndex, key, value);
	            }
	        }
	    }

	    tween.completeDelay = GetAdvancedValue(config, 'completeDelay', 0);
	    tween.loop = Math.round(GetAdvancedValue(config, 'loop', 0));
	    tween.loopDelay = Math.round(GetAdvancedValue(config, 'loopDelay', 0));
	    tween.paused = GetBoolean(config, 'paused', false);
	    tween.persist = GetBoolean(config, 'persist', false);

	    tween.callbackScope = GetFastValue(config, 'callbackScope', tween);

	    var callbacks = BaseTween.TYPES;

	    for (var i = 0; i < callbacks.length; i++)
	    {
	        var type = callbacks[i];

	        var callback = GetValue(config, type, false);

	        if (callback)
	        {
	            var callbackParams = GetValue(config, type + 'Params', []);

	            tween.setCallback(type, callback, callbackParams);
	        }
	    }

	    return tween;
	};

	TweenBuilder_1 = TweenBuilder;
	return TweenBuilder_1;
}

var builders;
var hasRequiredBuilders;

function requireBuilders () {
	if (hasRequiredBuilders) return builders;
	hasRequiredBuilders = 1;
	builders = {

	    GetBoolean: requireGetBoolean(),
	    GetEaseFunction: requireGetEaseFunction(),
	    GetInterpolationFunction: requireGetInterpolationFunction(),
	    GetNewValue: requireGetNewValue(),
	    GetProps: requireGetProps(),
	    GetTargets: requireGetTargets(),
	    GetValueOp: requireGetValueOp(),
	    NumberTweenBuilder: requireNumberTweenBuilder(),
	    StaggerBuilder: requireStaggerBuilder(),
	    TweenBuilder: requireTweenBuilder()

	};
	return builders;
}

var TweenChain_1;
var hasRequiredTweenChain;

function requireTweenChain () {
	if (hasRequiredTweenChain) return TweenChain_1;
	hasRequiredTweenChain = 1;
	var ArrayRemove = requireRemove();
	var BaseTween = requireBaseTween();
	var Class = requireClass();
	var Events = requireEvents();
	var GameObjectCreator = requireGameObjectCreator();
	var GameObjectFactory = requireGameObjectFactory();
	var TWEEN_CONST = require_const$a();

	var TweenChain = new Class({

	    Extends: BaseTween,

	    initialize:

	    function TweenChain (parent)
	    {
	        BaseTween.call(this, parent);

	        this.currentTween = null;

	        this.currentIndex = 0;
	    },

	    init: function ()
	    {
	        this.loopCounter = (this.loop === -1) ? TWEEN_CONST.MAX : this.loop;

	        this.setCurrentTween(0);

	        if (this.startDelay > 0 && !this.isStartDelayed())
	        {
	            this.setStartDelayState();
	        }
	        else
	        {
	            this.setActiveState();
	        }

	        return this;
	    },

	    add: function (tweens)
	    {
	        var newTweens = this.parent.create(tweens);

	        if (!Array.isArray(newTweens))
	        {
	            newTweens = [ newTweens ];
	        }

	        var data = this.data;

	        for (var i = 0; i < newTweens.length; i++)
	        {
	            var tween = newTweens[i];

	            tween.parent = this;

	            data.push(tween.reset());
	        }

	        this.totalData = data.length;

	        return this;
	    },

	    remove: function (tween)
	    {

	        ArrayRemove(this.data, tween);

	        tween.setRemovedState();

	        if (tween === this.currentTween)
	        {
	            this.nextTween();
	        }

	        this.totalData = this.data.length;

	        return this;
	    },

	    hasTarget: function (target)
	    {
	        var data = this.data;

	        for (var i = 0; i < this.totalData; i++)
	        {
	            if (data[i].hasTarget(target))
	            {
	                return true;
	            }
	        }

	        return false;
	    },

	    restart: function ()
	    {
	        if (this.isDestroyed())
	        {
	            console.warn('Cannot restart destroyed TweenChain', this);

	            return this;
	        }

	        if (this.isRemoved())
	        {
	            this.parent.makeActive(this);
	        }

	        this.resetTweens();

	        this.paused = false;

	        return this.init();
	    },

	    reset: function (tween)
	    {
	        tween.seek();

	        tween.setActiveState();

	        return this;
	    },

	    makeActive: function (tween)
	    {
	        tween.reset();

	        tween.setActiveState();

	        return this;
	    },

	    nextState: function ()
	    {
	        if (this.loopCounter > 0)
	        {
	            this.loopCounter--;

	            this.resetTweens();

	            if (this.loopDelay > 0)
	            {
	                this.countdown = this.loopDelay;

	                this.setLoopDelayState();
	            }
	            else
	            {
	                this.setActiveState();

	                this.dispatchEvent(Events.TWEEN_LOOP, 'onLoop');
	            }
	        }
	        else if (this.completeDelay > 0)
	        {
	            this.countdown = this.completeDelay;

	            this.setCompleteDelayState();
	        }
	        else
	        {
	            this.onCompleteHandler();

	            return true;
	        }

	        return false;
	    },

	    play: function ()
	    {
	        if (this.isDestroyed())
	        {
	            console.warn('Cannot play destroyed TweenChain', this);

	            return this;
	        }

	        if (this.isPendingRemove() || this.isPending())
	        {
	            this.resetTweens();
	        }

	        this.paused = false;

	        if (this.startDelay > 0 && !this.isStartDelayed())
	        {
	            this.setStartDelayState();
	        }
	        else
	        {
	            this.setActiveState();
	        }

	        return this;
	    },

	    resetTweens: function ()
	    {
	        var data = this.data;
	        var total = this.totalData;

	        for (var i = 0; i < total; i++)
	        {
	            data[i].reset(false);
	        }

	        this.setCurrentTween(0);
	    },

	    update: function (delta)
	    {
	        if (this.isPendingRemove() || this.isDestroyed())
	        {
	            if (this.persist)
	            {
	                this.setFinishedState();

	                return false;
	            }

	            return true;
	        }
	        else if (this.isFinished() || this.paused)
	        {
	            return false;
	        }

	        delta *= this.parent.timeScale;

	        if (this.isLoopDelayed())
	        {
	            this.updateLoopCountdown(delta);

	            return false;
	        }
	        else if (this.isCompleteDelayed())
	        {
	            this.updateCompleteDelay(delta);

	            return false;
	        }
	        else if (!this.hasStarted)
	        {
	            this.startDelay -= delta;

	            if (this.startDelay <= 0)
	            {
	                this.hasStarted = true;

	                this.dispatchEvent(Events.TWEEN_START, 'onStart');

	                delta = 0;
	            }
	        }

	        var remove = false;

	        if (this.isActive() && this.currentTween)
	        {
	            if (this.currentTween.update(delta))
	            {

	                if (this.nextTween())
	                {
	                    this.nextState();
	                }
	            }

	            remove = this.isPendingRemove();

	            if (remove && this.persist)
	            {
	                this.setFinishedState();

	                remove = false;
	            }
	        }

	        return remove;
	    },

	    nextTween: function ()
	    {
	        this.currentIndex++;

	        if (this.currentIndex === this.totalData)
	        {
	            return true;
	        }
	        else
	        {
	            this.setCurrentTween(this.currentIndex);
	        }

	        return false;
	    },

	    setCurrentTween: function (index)
	    {
	        this.currentIndex = index;

	        this.currentTween = this.data[index];

	        this.currentTween.setActiveState();
	    },

	    dispatchEvent: function (event, callback)
	    {
	        this.emit(event, this);

	        var handler = this.callbacks[callback];

	        if (handler)
	        {
	            handler.func.apply(this.callbackScope, [ this ].concat(handler.params));
	        }
	    },

	    destroy: function ()
	    {
	        BaseTween.prototype.destroy.call(this);

	        this.currentTween = null;
	    }

	});

	GameObjectFactory.register('tweenchain', function (config)
	{
	    return this.scene.sys.tweens.chain(config);
	});

	GameObjectCreator.register('tweenchain', function (config)
	{
	    return this.scene.sys.tweens.create(config);
	});

	TweenChain_1 = TweenChain;
	return TweenChain_1;
}

var TweenChainBuilder_1;
var hasRequiredTweenChainBuilder;

function requireTweenChainBuilder () {
	if (hasRequiredTweenChainBuilder) return TweenChainBuilder_1;
	hasRequiredTweenChainBuilder = 1;
	var BaseTween = requireBaseTween();
	var GetAdvancedValue = requireGetAdvancedValue();
	var GetBoolean = requireGetBoolean();
	var GetTargets = requireGetTargets();
	var GetValue = requireGetValue();
	var TweenBuilder = requireTweenBuilder();
	var TweenChain = requireTweenChain();

	var TweenChainBuilder = function (parent, config)
	{
	    if (config instanceof TweenChain)
	    {
	        config.parent = parent;

	        return config;
	    }

	    var chain = new TweenChain(parent);

	    chain.startDelay = GetValue(config, 'delay', 0);
	    chain.completeDelay = GetAdvancedValue(config, 'completeDelay', 0);
	    chain.loop = Math.round(GetAdvancedValue(config, 'loop', GetValue(config, 'repeat', 0)));
	    chain.loopDelay = Math.round(GetAdvancedValue(config, 'loopDelay', GetValue(config, 'repeatDelay', 0)));
	    chain.paused = GetBoolean(config, 'paused', false);
	    chain.persist = GetBoolean(config, 'persist', false);

	    chain.callbackScope = GetValue(config, 'callbackScope', chain);

	    var i;
	    var callbacks = BaseTween.TYPES;

	    for (i = 0; i < callbacks.length; i++)
	    {
	        var type = callbacks[i];

	        var callback = GetValue(config, type, false);

	        if (callback)
	        {
	            var callbackParams = GetValue(config, type + 'Params', []);

	            chain.setCallback(type, callback, callbackParams);
	        }
	    }

	    var tweens = GetValue(config, 'tweens', null);

	    if (Array.isArray(tweens))
	    {
	        var chainedTweens = [];

	        var targets = GetTargets(config);
	        var defaults = undefined;

	        if (targets)
	        {
	            defaults = { targets: targets };
	        }

	        for (i = 0; i < tweens.length; i++)
	        {
	            chainedTweens.push(TweenBuilder(chain, tweens[i], defaults));
	        }

	        chain.add(chainedTweens);
	    }

	    return chain;
	};

	TweenChainBuilder_1 = TweenChainBuilder;
	return TweenChainBuilder_1;
}

var TweenManager_1;
var hasRequiredTweenManager;

function requireTweenManager () {
	if (hasRequiredTweenManager) return TweenManager_1;
	hasRequiredTweenManager = 1;
	var ArrayRemove = requireRemove();
	var Class = requireClass();
	var Flatten = requireFlatten();
	var NumberTweenBuilder = requireNumberTweenBuilder();
	var PluginCache = requirePluginCache();
	var SceneEvents = requireEvents$l();
	var StaggerBuilder = requireStaggerBuilder();
	var Tween = requireTween();
	var TweenBuilder = requireTweenBuilder();
	var TweenChain = requireTweenChain();
	var TweenChainBuilder = requireTweenChainBuilder();

	var TweenManager = new Class({

	    initialize:

	    function TweenManager (scene)
	    {

	        this.scene = scene;

	        this.events = scene.sys.events;

	        this.timeScale = 1;

	        this.paused = false;

	        this.processing = false;

	        this.tweens = [];

	        this.time = 0;

	        this.startTime = 0;

	        this.nextTime = 0;

	        this.prevTime = 0;

	        this.maxLag = 500;

	        this.lagSkip = 33;

	        this.gap = 1000 / 240;

	        this.events.once(SceneEvents.BOOT, this.boot, this);
	        this.events.on(SceneEvents.START, this.start, this);
	    },

	    boot: function ()
	    {
	        this.events.once(SceneEvents.DESTROY, this.destroy, this);
	    },

	    start: function ()
	    {
	        this.timeScale = 1;
	        this.paused = false;

	        this.startTime = Date.now();
	        this.prevTime = this.startTime;
	        this.nextTime = this.gap;

	        this.events.on(SceneEvents.UPDATE, this.update, this);
	        this.events.once(SceneEvents.SHUTDOWN, this.shutdown, this);
	    },

	    create: function (config)
	    {
	        if (!Array.isArray(config))
	        {
	            config = [ config ];
	        }

	        var result = [];

	        for (var i = 0; i < config.length; i++)
	        {
	            var tween = config[i];

	            if (tween instanceof Tween || tween instanceof TweenChain)
	            {

	                result.push(tween);
	            }
	            else if (Array.isArray(tween.tweens))
	            {
	                result.push(TweenChainBuilder(this, tween));
	            }
	            else
	            {
	                result.push(TweenBuilder(this, tween));
	            }
	        }

	        return (result.length === 1) ? result[0] : result;
	    },

	    add: function (config)
	    {
	        var tween = config;
	        var tweens = this.tweens;

	        if (tween instanceof Tween || tween instanceof TweenChain)
	        {
	            tweens.push(tween.reset());
	        }
	        else
	        {
	            if (Array.isArray(tween.tweens))
	            {
	                tween = TweenChainBuilder(this, tween);
	            }
	            else
	            {
	                tween = TweenBuilder(this, tween);
	            }

	            tweens.push(tween.reset());
	        }

	        return tween;
	    },

	    addMultiple: function (configs)
	    {
	        var tween;
	        var result = [];
	        var tweens = this.tweens;

	        for (var i = 0; i < configs.length; i++)
	        {
	            tween = configs[i];

	            if (tween instanceof Tween || tween instanceof TweenChain)
	            {
	                tweens.push(tween.reset());
	            }
	            else
	            {
	                if (Array.isArray(tween.tweens))
	                {
	                    tween = TweenChainBuilder(this, tween);
	                }
	                else
	                {
	                    tween = TweenBuilder(this, tween);
	                }

	                tweens.push(tween.reset());
	            }

	            result.push(tween);
	        }

	        return result;
	    },

	    chain: function (config)
	    {
	        var chain = TweenChainBuilder(this, config);

	        this.tweens.push(chain.init());

	        return chain;
	    },

	    getChainedTweens: function (tween)
	    {
	        return tween.getChainedTweens();
	    },

	    has: function (tween)
	    {
	        return (this.tweens.indexOf(tween) > -1);
	    },

	    existing: function (tween)
	    {
	        if (!this.has(tween))
	        {
	            this.tweens.push(tween.reset());
	        }

	        return this;
	    },

	    addCounter: function (config)
	    {
	        var tween = NumberTweenBuilder(this, config);

	        this.tweens.push(tween.reset());

	        return tween;
	    },

	    stagger: function (value, options)
	    {
	        return StaggerBuilder(value, options);
	    },

	    setLagSmooth: function (limit, skip)
	    {
	        if (limit === undefined) { limit = 1 / 1e-8; }
	        if (skip === undefined) { skip = 0; }

	        this.maxLag = limit;
	        this.lagSkip = Math.min(skip, this.maxLag);

	        return this;
	    },

	    setFps: function (fps)
	    {
	        if (fps === undefined) { fps = 240; }

	        this.gap = 1000 / fps;
	        this.nextTime = this.time * 1000 + this.gap;

	        return this;
	    },

	    getDelta: function (tick)
	    {
	        var elapsed = Date.now() - this.prevTime;

	        if (elapsed > this.maxLag)
	        {
	            this.startTime += elapsed - this.lagSkip;
	        }

	        this.prevTime += elapsed;

	        var time = this.prevTime - this.startTime;
	        var overlap = time - this.nextTime;
	        var delta = time - this.time * 1000;

	        if (overlap > 0 || tick)
	        {
	            time /= 1000;
	            this.time = time;
	            this.nextTime += overlap + (overlap >= this.gap ? 4 : this.gap - overlap);
	        }
	        else
	        {
	            delta = 0;
	        }

	        return delta;
	    },

	    tick: function ()
	    {
	        this.step(true);

	        return this;
	    },

	    update: function ()
	    {
	        if (!this.paused)
	        {
	            this.step(false);
	        }
	    },

	    step: function (tick)
	    {
	        if (tick === undefined) { tick = false; }

	        var delta = this.getDelta(tick);

	        if (delta <= 0)
	        {

	            return;
	        }

	        this.processing = true;

	        var i;
	        var tween;
	        var toDestroy = [];
	        var list = this.tweens;

	        for (i = 0; i < list.length; i++)
	        {
	            tween = list[i];

	            if (tween.update(delta))
	            {
	                toDestroy.push(tween);
	            }
	        }

	        var count = toDestroy.length;

	        if (count && list.length > 0)
	        {
	            for (i = 0; i < count; i++)
	            {
	                tween = toDestroy[i];

	                var idx = list.indexOf(tween);

	                if (idx > -1 && (tween.isPendingRemove() || tween.isDestroyed()))
	                {
	                    list.splice(idx, 1);

	                    tween.destroy();
	                }
	            }

	            toDestroy.length = 0;
	        }

	        this.processing = false;
	    },

	    remove: function (tween)
	    {
	        if (this.processing)
	        {

	            tween.setPendingRemoveState();
	        }
	        else
	        {

	            ArrayRemove(this.tweens, tween);

	            tween.setRemovedState();
	        }

	        return this;
	    },

	    reset: function (tween)
	    {
	        this.existing(tween);

	        tween.seek();

	        tween.setActiveState();

	        return this;
	    },

	    makeActive: function (tween)
	    {
	        this.existing(tween);

	        tween.setActiveState();

	        return this;
	    },

	    each: function (callback, scope)
	    {
	        var i;
	        var args = [ null ];

	        for (i = 1; i < arguments.length; i++)
	        {
	            args.push(arguments[i]);
	        }

	        this.tweens.forEach(function (tween)
	        {
	            args[0] = tween;

	            callback.apply(scope, args);
	        });

	        return this;
	    },

	    getTweens: function ()
	    {
	        return this.tweens.slice();
	    },

	    getTweensOf: function (target)
	    {
	        var output = [];
	        var list = this.tweens;

	        if (!Array.isArray(target))
	        {
	            target = [ target ];
	        }
	        else
	        {
	            target = Flatten(target);
	        }

	        var targetLen = target.length;

	        for (var i = 0; i < list.length; i++)
	        {
	            var tween = list[i];

	            for (var t = 0; t < targetLen; t++)
	            {
	                if (!tween.isDestroyed() && tween.hasTarget(target[t]))
	                {
	                    output.push(tween);
	                }
	            }
	        }

	        return output;
	    },

	    getGlobalTimeScale: function ()
	    {
	        return this.timeScale;
	    },

	    setGlobalTimeScale: function (value)
	    {
	        this.timeScale = value;

	        return this;
	    },

	    isTweening: function (target)
	    {
	        var list = this.tweens;
	        var tween;

	        for (var i = 0; i < list.length; i++)
	        {
	            tween = list[i];

	            if (tween.isPlaying() && tween.hasTarget(target))
	            {
	                return true;
	            }
	        }

	        return false;
	    },

	    killAll: function ()
	    {
	        var tweens = (this.processing) ? this.getTweens() : this.tweens;

	        for (var i = 0; i < tweens.length; i++)
	        {
	            tweens[i].destroy();
	        }

	        if (!this.processing)
	        {
	            tweens.length = 0;
	        }

	        return this;
	    },

	    killTweensOf: function (target)
	    {
	        var tweens = this.getTweensOf(target);

	        for (var i = 0; i < tweens.length; i++)
	        {
	            tweens[i].destroy();
	        }

	        return this;
	    },

	    pauseAll: function ()
	    {
	        this.paused = true;

	        return this;
	    },

	    resumeAll: function ()
	    {
	        this.paused = false;

	        return this;
	    },

	    shutdown: function ()
	    {
	        this.killAll();

	        this.tweens = [];

	        this.events.off(SceneEvents.UPDATE, this.update, this);
	        this.events.off(SceneEvents.SHUTDOWN, this.shutdown, this);
	    },

	    destroy: function ()
	    {
	        this.shutdown();

	        this.events.off(SceneEvents.START, this.start, this);

	        this.scene = null;
	        this.events = null;
	    }

	});

	PluginCache.register('TweenManager', TweenManager, 'tweens');

	TweenManager_1 = TweenManager;
	return TweenManager_1;
}

var tweens;
var hasRequiredTweens;

function requireTweens () {
	if (hasRequiredTweens) return tweens;
	hasRequiredTweens = 1;
	var Tweens = {

	    States: require_const$a(),

	    Builders: requireBuilders(),
	    Events: requireEvents(),

	    TweenManager: requireTweenManager(),
	    Tween: requireTween(),
	    TweenData: requireTweenData(),
	    TweenFrameData: requireTweenFrameData(),

	    BaseTween: requireBaseTween(),
	    TweenChain: requireTweenChain()
	};

	tweens = Tweens;
	return tweens;
}

var ArrayBufferToBase64_1;
var hasRequiredArrayBufferToBase64;

function requireArrayBufferToBase64 () {
	if (hasRequiredArrayBufferToBase64) return ArrayBufferToBase64_1;
	hasRequiredArrayBufferToBase64 = 1;
	var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	var ArrayBufferToBase64 = function (arrayBuffer, mediaType)
	{
	    var bytes = new Uint8Array(arrayBuffer);
	    var len = bytes.length;

	    var base64 = (mediaType) ? 'data:' + mediaType + ';base64,' : '';

	    for (var i = 0; i < len; i += 3)
	    {
	        base64 += chars[bytes[i] >> 2];
	        base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
	        base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
	        base64 += chars[bytes[i + 2] & 63];
	    }

	    if ((len % 3) === 2)
	    {
	        base64 = base64.substring(0, base64.length - 1) + '=';
	    }
	    else if (len % 3 === 1)
	    {
	        base64 = base64.substring(0, base64.length - 2) + '==';
	    }

	    return base64;
	};

	ArrayBufferToBase64_1 = ArrayBufferToBase64;
	return ArrayBufferToBase64_1;
}

var Base64ToArrayBuffer_1;
var hasRequiredBase64ToArrayBuffer;

function requireBase64ToArrayBuffer () {
	if (hasRequiredBase64ToArrayBuffer) return Base64ToArrayBuffer_1;
	hasRequiredBase64ToArrayBuffer = 1;
	var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	var lookup = new Uint8Array(256);

	for (var i = 0; i < chars.length; i++)
	{
	    lookup[chars.charCodeAt(i)] = i;
	}

	var Base64ToArrayBuffer = function (base64)
	{

	    base64 = base64.substr(base64.indexOf(',') + 1);

	    var len = base64.length;
	    var bufferLength = len * 0.75;
	    var p = 0;
	    var encoded1;
	    var encoded2;
	    var encoded3;
	    var encoded4;

	    if (base64[len - 1] === '=')
	    {
	        bufferLength--;

	        if (base64[len - 2] === '=')
	        {
	            bufferLength--;
	        }
	    }

	    var arrayBuffer = new ArrayBuffer(bufferLength);
	    var bytes = new Uint8Array(arrayBuffer);

	    for (var i = 0; i < len; i += 4)
	    {
	        encoded1 = lookup[base64.charCodeAt(i)];
	        encoded2 = lookup[base64.charCodeAt(i + 1)];
	        encoded3 = lookup[base64.charCodeAt(i + 2)];
	        encoded4 = lookup[base64.charCodeAt(i + 3)];

	        bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
	        bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
	        bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
	    }

	    return arrayBuffer;
	};

	Base64ToArrayBuffer_1 = Base64ToArrayBuffer;
	return Base64ToArrayBuffer_1;
}

var base64;
var hasRequiredBase64;

function requireBase64 () {
	if (hasRequiredBase64) return base64;
	hasRequiredBase64 = 1;
	base64 = {

	    ArrayBufferToBase64: requireArrayBufferToBase64(),
	    Base64ToArrayBuffer: requireBase64ToArrayBuffer()

	};
	return base64;
}

var GetMinMaxValue_1;
var hasRequiredGetMinMaxValue;

function requireGetMinMaxValue () {
	if (hasRequiredGetMinMaxValue) return GetMinMaxValue_1;
	hasRequiredGetMinMaxValue = 1;
	var GetValue = requireGetValue();
	var Clamp = requireClamp();

	var GetMinMaxValue = function (source, key, min, max, defaultValue)
	{
	    if (defaultValue === undefined) { defaultValue = min; }

	    var value = GetValue(source, key, defaultValue);

	    return Clamp(value, min, max);
	};

	GetMinMaxValue_1 = GetMinMaxValue;
	return GetMinMaxValue_1;
}

var object;
var hasRequiredObject;

function requireObject () {
	if (hasRequiredObject) return object;
	hasRequiredObject = 1;
	object = {

	    Clone: requireClone$7(),
	    DeepCopy: requireDeepCopy(),
	    Extend: requireExtend$1(),
	    GetAdvancedValue: requireGetAdvancedValue(),
	    GetFastValue: requireGetFastValue(),
	    GetMinMaxValue: requireGetMinMaxValue(),
	    GetValue: requireGetValue(),
	    HasAll: requireHasAll(),
	    HasAny: requireHasAny(),
	    HasValue: requireHasValue(),
	    IsPlainObject: requireIsPlainObject(),
	    Merge: requireMerge(),
	    MergeRight: requireMergeRight(),
	    Pick: requirePick(),
	    SetValue: requireSetValue()

	};
	return object;
}

var Format_1;
var hasRequiredFormat;

function requireFormat () {
	if (hasRequiredFormat) return Format_1;
	hasRequiredFormat = 1;
	var Format = function (string, values)
	{
	    return string.replace(/%([0-9]+)/g, function (s, n)
	    {
	        return values[Number(n) - 1];
	    });
	};

	Format_1 = Format;
	return Format_1;
}

var RemoveAt_1;
var hasRequiredRemoveAt;

function requireRemoveAt () {
	if (hasRequiredRemoveAt) return RemoveAt_1;
	hasRequiredRemoveAt = 1;
	var RemoveAt = function (string, index)
	{
	    if (index === 0)
	    {
	        return string.slice(1);
	    }
	    else
	    {
	        return string.slice(0, index) + string.slice(index + 1);
	    }
	};

	RemoveAt_1 = RemoveAt;
	return RemoveAt_1;
}

var Reverse_1;
var hasRequiredReverse;

function requireReverse () {
	if (hasRequiredReverse) return Reverse_1;
	hasRequiredReverse = 1;
	var Reverse = function (string)
	{
	    return string.split('').reverse().join('');
	};

	Reverse_1 = Reverse;
	return Reverse_1;
}

var string;
var hasRequiredString;

function requireString () {
	if (hasRequiredString) return string;
	hasRequiredString = 1;
	string = {

	    Format: requireFormat(),
	    Pad: requirePad(),
	    RemoveAt: requireRemoveAt(),
	    Reverse: requireReverse(),
	    UppercaseFirst: requireUppercaseFirst(),
	    UUID: requireUUID()

	};
	return string;
}

var utils;
var hasRequiredUtils;

function requireUtils () {
	if (hasRequiredUtils) return utils;
	hasRequiredUtils = 1;
	utils = {

	    Array: requireArray(),
	    Base64: requireBase64(),
	    Objects: requireObject(),
	    String: requireString(),
	    NOOP: requireNOOP(),
	    NULL: requireNULL()

	};
	return utils;
}

var main$1;
var hasRequiredMain;

function requireMain () {
	if (hasRequiredMain) return main$1;
	hasRequiredMain = 1;
	requireRequestVideoFrame();

	var CONST = require_const$f();
	var Extend = requireExtend$1();

	var HawkEngine = {

	    Actions: requireActions(),
	    Animations: requireAnimations(),
	    BlendModes: requireBlendModes(),
	    Cache: requireCache(),
	    Cameras: requireCameras(),
	    Core: requireCore(),
	    Class: requireClass(),
	    Create: requireCreate(),
	    Curves: requireCurves(),
	    Data: requireData(),
	    Display: requireDisplay(),
	    DOM: requireDom(),
	    Events: requireEvents$a(),
	    FX: requireFx$1(),
	    Game: requireGame(),
	    GameObjects: requireGameobjects(),
	    Geom: requireGeom(),
	    Input: requireInput(),
	    Loader: requireLoader(),
	    Math: requireMath(),
	    Physics: requirePhysics(),
	    Plugins: requirePlugins(),
	    Renderer: requireRenderer(),
	    Scale: requireScale(),
	    ScaleModes: requireScaleModes(),
	    Scene: requireScene$1(),
	    Scenes: requireScene(),
	    Structs: requireStructs(),
	    Textures: requireTextures(),
	    Tilemaps: requireTilemaps(),
	    Time: requireTime(),
	    Tweens: requireTweens(),
	    Utils: requireUtils()

	};

	HawkEngine = Extend(false, HawkEngine, CONST);
	main$1 = HawkEngine;
	commonjsGlobal.HawkEngine = HawkEngine;
	return main$1;
}

var mainExports = requireMain();
var main = /*@__PURE__*/getDefaultExportFromCjs(mainExports);

export { main as default };
