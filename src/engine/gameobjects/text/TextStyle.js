var Class = require('../../utils/Class');var GetAdvancedValue = require('../../utils/object/GetAdvancedValue');var GetValue = require('../../utils/object/GetValue');var MeasureText = require('./MeasureText');var propertyMap = {    fontFamily: [ 'fontFamily', 'Courier' ],    fontSize: [ 'fontSize', '16px' ],    fontStyle: [ 'fontStyle', '' ],    backgroundColor: [ 'backgroundColor', null ],    color: [ 'color', '#fff' ],    stroke: [ 'stroke', '#fff' ],    strokeThickness: [ 'strokeThickness', 0 ],    shadowOffsetX: [ 'shadow.offsetX', 0 ],    shadowOffsetY: [ 'shadow.offsetY', 0 ],    shadowColor: [ 'shadow.color', '#000' ],    shadowBlur: [ 'shadow.blur', 0 ],    shadowStroke: [ 'shadow.stroke', false ],    shadowFill: [ 'shadow.fill', false ],    align: [ 'align', 'left' ],    maxLines: [ 'maxLines', 0 ],    fixedWidth: [ 'fixedWidth', 0 ],    fixedHeight: [ 'fixedHeight', 0 ],    resolution: [ 'resolution', 0 ],    rtl: [ 'rtl', false ],    testString: [ 'testString', '|MÃ‰qgy' ],    baselineX: [ 'baselineX', 1.2 ],    baselineY: [ 'baselineY', 1.4 ],    wordWrapWidth: [ 'wordWrap.width', null ],    wordWrapCallback: [ 'wordWrap.callback', null ],    wordWrapCallbackScope: [ 'wordWrap.callbackScope', null ],    wordWrapUseAdvanced: [ 'wordWrap.useAdvancedWrap', false ]};var TextStyle = new Class({    initialize:    function TextStyle (text, style)    {        this.parent = text;        this.fontFamily;        this.fontSize;        this.fontStyle;        this.backgroundColor;        this.color;        this.stroke;        this.strokeThickness;        this.shadowOffsetX;        this.shadowOffsetY;        this.shadowColor;        this.shadowBlur;        this.shadowStroke;        this.shadowFill;        this.align;        this.maxLines;        this.fixedWidth;        this.fixedHeight;        this.resolution;        this.rtl;        this.testString;        this.baselineX;        this.baselineY;        this.wordWrapWidth;        this.wordWrapCallback;        this.wordWrapCallbackScope;        this.wordWrapUseAdvanced;        this._font;        this.setStyle(style, false, true);    },    setStyle: function (style, updateText, setDefaults)    {        if (updateText === undefined) { updateText = true; }        if (setDefaults === undefined) { setDefaults = false; }        for (var key in propertyMap)        {            var value = (setDefaults) ? propertyMap[key][1] : this[key];            if (key === 'wordWrapCallback' || key === 'wordWrapCallbackScope')            {                this[key] = GetValue(style, propertyMap[key][0], value);            }            else if (style && key === 'fontSize' && typeof style.fontSize === 'number')            {                this[key] = style.fontSize.toString() + 'px';            }            else            {                this[key] = GetAdvancedValue(style, propertyMap[key][0], value);            }        }        var font = GetValue(style, 'font', null);        if (font !== null)        {            this.setFont(font, false);        }        this._font = [ this.fontStyle, this.fontSize, this.fontFamily ].join(' ').trim();        var fill = GetValue(style, 'fill', null);        if (fill !== null)        {            this.color = fill;        }        var metrics = GetValue(style, 'metrics', false);        if (metrics)        {            this.metrics = {                ascent: GetValue(metrics, 'ascent', 0),                descent: GetValue(metrics, 'descent', 0),                fontSize: GetValue(metrics, 'fontSize', 0)            };        }        else if (updateText || !this.metrics)        {            this.metrics = MeasureText(this);        }        if (updateText)        {            return this.parent.updateText();        }        else        {            return this.parent;        }    },    syncFont: function (canvas, context)    {        context.font = this._font;    },    syncStyle: function (canvas, context)    {        context.textBaseline = 'alphabetic';        context.fillStyle = this.color;        context.strokeStyle = this.stroke;        context.lineWidth = this.strokeThickness;        context.lineCap = 'round';        context.lineJoin = 'round';    },    syncShadow: function (context, enabled)    {        if (enabled)        {            context.shadowOffsetX = this.shadowOffsetX;            context.shadowOffsetY = this.shadowOffsetY;            context.shadowColor = this.shadowColor;            context.shadowBlur = this.shadowBlur;        }        else        {            context.shadowOffsetX = 0;            context.shadowOffsetY = 0;            context.shadowColor = 0;            context.shadowBlur = 0;        }    },    update: function (recalculateMetrics)    {        if (recalculateMetrics)        {            this._font = [ this.fontStyle, this.fontSize, this.fontFamily ].join(' ').trim();            this.metrics = MeasureText(this);        }        return this.parent.updateText();    },    setFont: function (font, updateText)    {        if (updateText === undefined) { updateText = true; }        var fontFamily = font;        var fontSize = '';        var fontStyle = '';        if (typeof font !== 'string')        {            fontFamily = GetValue(font, 'fontFamily', 'Courier');            fontSize = GetValue(font, 'fontSize', '16px');            fontStyle = GetValue(font, 'fontStyle', '');        }        else        {            var fontSplit = font.split(' ');            var i = 0;            fontStyle = (fontSplit.length > 2) ? fontSplit[i++] : '';            fontSize = fontSplit[i++] || '16px';            fontFamily = fontSplit[i++] || 'Courier';        }        if (fontFamily !== this.fontFamily || fontSize !== this.fontSize || fontStyle !== this.fontStyle)        {            this.fontFamily = fontFamily;            this.fontSize = fontSize;            this.fontStyle = fontStyle;            if (updateText)            {                this.update(true);            }        }        return this.parent;    },    setFontFamily: function (family)    {        if (this.fontFamily !== family)        {            this.fontFamily = family;            this.update(true);        }        return this.parent;    },    setFontStyle: function (style)    {        if (this.fontStyle !== style)        {            this.fontStyle = style;            this.update(true);        }        return this.parent;    },    setFontSize: function (size)    {        if (typeof size === 'number')        {            size = size.toString() + 'px';        }        if (this.fontSize !== size)        {            this.fontSize = size;            this.update(true);        }        return this.parent;    },    setTestString: function (string)    {        this.testString = string;        return this.update(true);    },    setFixedSize: function (width, height)    {        this.fixedWidth = width;        this.fixedHeight = height;        if (width)        {            this.parent.width = width;        }        if (height)        {            this.parent.height = height;        }        return this.update(false);    },    setBackgroundColor: function (color)    {        this.backgroundColor = color;        return this.update(false);    },    setFill: function (color)    {        this.color = color;        return this.update(false);    },    setColor: function (color)    {        this.color = color;        return this.update(false);    },    setResolution: function (value)    {        this.resolution = value;        return this.update(false);    },    setStroke: function (color, thickness)    {        if (thickness === undefined) { thickness = this.strokeThickness; }        if (color === undefined && this.strokeThickness !== 0)        {            this.strokeThickness = 0;            this.update(true);        }        else if (this.stroke !== color || this.strokeThickness !== thickness)        {            this.stroke = color;            this.strokeThickness = thickness;            this.update(true);        }        return this.parent;    },    setShadow: function (x, y, color, blur, shadowStroke, shadowFill)    {        if (x === undefined) { x = 0; }        if (y === undefined) { y = 0; }        if (color === undefined) { color = '#000'; }        if (blur === undefined) { blur = 0; }        if (shadowStroke === undefined) { shadowStroke = false; }        if (shadowFill === undefined) { shadowFill = true; }        this.shadowOffsetX = x;        this.shadowOffsetY = y;        this.shadowColor = color;        this.shadowBlur = blur;        this.shadowStroke = shadowStroke;        this.shadowFill = shadowFill;        return this.update(false);    },    setShadowOffset: function (x, y)    {        if (x === undefined) { x = 0; }        if (y === undefined) { y = x; }        this.shadowOffsetX = x;        this.shadowOffsetY = y;        return this.update(false);    },    setShadowColor: function (color)    {        if (color === undefined) { color = '#000'; }        this.shadowColor = color;        return this.update(false);    },    setShadowBlur: function (blur)    {        if (blur === undefined) { blur = 0; }        this.shadowBlur = blur;        return this.update(false);    },    setShadowStroke: function (enabled)    {        this.shadowStroke = enabled;        return this.update(false);    },    setShadowFill: function (enabled)    {        this.shadowFill = enabled;        return this.update(false);    },    setWordWrapWidth: function (width, useAdvancedWrap)    {        if (useAdvancedWrap === undefined) { useAdvancedWrap = false; }        this.wordWrapWidth = width;        this.wordWrapUseAdvanced = useAdvancedWrap;        return this.update(false);    },    setWordWrapCallback: function (callback, scope)    {        if (scope === undefined) { scope = null; }        this.wordWrapCallback = callback;        this.wordWrapCallbackScope = scope;        return this.update(false);    },    setAlign: function (align)    {        if (align === undefined) { align = 'left'; }        this.align = align;        return this.update(false);    },    setMaxLines: function (max)    {        if (max === undefined) { max = 0; }        this.maxLines = max;        return this.update(false);    },    getTextMetrics: function ()    {        var metrics = this.metrics;        return {            ascent: metrics.ascent,            descent: metrics.descent,            fontSize: metrics.fontSize        };    },    toJSON: function ()    {        var output = {};        for (var key in propertyMap)        {            output[key] = this[key];        }        output.metrics = this.getTextMetrics();        return output;    },    destroy: function ()    {        this.parent = undefined;    }});module.exports = TextStyle;